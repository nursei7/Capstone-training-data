,text
0,"<|endoftext|>A student learning Python was trying to make a function that sorts all the letters of a word, but their code is broken, and they can't figure out why.
Spot and fix the error(s) in the code to make the function work. As an added challenge for those who are more advanced, see if you can shrink (the fixed version of) the student's code down to only a single line.
Examples
sort_word(""dcba"") ➞ ""abcd""

sort_word(""Unpredictable"") ➞ ""Uabcdeeilnprt""
# Capital letters should come first.

sort_word(""pneumonoultramicroscopicsilicovolcanoconiosis"") ➞ ""aacccccceiiiiiilllmmnnnnooooooooopprrsssstuuv""
Notes
If you're trying to get a function definition into a single line, try assigning a variable to a lambda function.:def sort_word(word):
  return ''.join(sorted(word))<|endoftext|>"
1,"<|endoftext|>On some rare machines where branching is expensive, the below obvious approach to find minimum can be slow as it uses branching.:# Python3 program to Compute the minimum
# or maximum of two integers without
# branching

# Function to find minimum of x and y

def min(x, y):

	return y ^ ((x ^ y) & -(x < y))


# Function to find maximum of x and y
def max(x, y):

	return x ^ ((x ^ y) & -(x < y))


# Driver program to test above functions
x = 15
y = 6
print(""Minimum of"", x, ""and"", y, ""is"", end="" "")
print(min(x, y))
print(""Maximum of"", x, ""and"", y, ""is"", end="" "")
print(max(x, y))

# This code is contributed
# by Smitha Dinesh Semwal
<|endoftext|>"
2,"<|endoftext|>Given a sentence, create a function that replaces every ""a"" as an article with ""an absolute"". It should return the same string without any change if it doesn't have any ""a"".
Examples
absolute(""I am a champion!!!"") ➞ ""I am an absolute champion!!!""

absolute(""Such an amazing bowler."") ➞ ""Such an amazing bowler.""

absolute(""A man with no haters."") ➞ ""An absolute man with no haters.""
Notes
Watch for uppercase letters as shown in example #3.:def absolute(txt):
    return txt.replace('a ','an absolute ').replace('A ','an absolute ').capitalize()<|endoftext|>"
3,"<|endoftext|>AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot be more than one for all nodes. 

Insertion 
To make sure that the given tree remains AVL after every insertion, we must augment the standard BST insert operation to perform some re-balancing. Following are two basic operations that can be performed to re-balance a BST without violating the BST property (keys(left) < key(root) < keys(right)). :# Python code to insert a node in AVL tree
 
# Generic tree node class
class TreeNode(object):
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1
 
# AVL tree class which supports the
# Insert operation
class AVL_Tree(object):
 
    # Recursive function to insert key in
    # subtree rooted with node and returns
    # new root of subtree.
    def insert(self, root, key):
     
        # Step 1 - Perform normal BST
        if not root:
            return TreeNode(key)
        elif key < root.val:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)
 
        # Step 2 - Update the height of the
        # ancestor node
        root.height = 1 + max(self.getHeight(root.left),
                           self.getHeight(root.right))
 
        # Step 3 - Get the balance factor
        balance = self.getBalance(root)
 
        # Step 4 - If the node is unbalanced,
        # then try out the 4 cases
        # Case 1 - Left Left
        if balance > 1 and key < root.left.val:
            return self.rightRotate(root)
 
        # Case 2 - Right Right
        if balance < -1 and key > root.right.val:
            return self.leftRotate(root)
 
        # Case 3 - Left Right
        if balance > 1 and key > root.left.val:
            root.left = self.leftRotate(root.left)
            return self.rightRotate(root)
 
        # Case 4 - Right Left
        if balance < -1 and key < root.right.val:
            root.right = self.rightRotate(root.right)
            return self.leftRotate(root)
 
        return root
 
    def leftRotate(self, z):
 
        y = z.right
        T2 = y.left
 
        # Perform rotation
        y.left = z
        z.right = T2
 
        # Update heights
        z.height = 1 + max(self.getHeight(z.left),
                         self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left),
                         self.getHeight(y.right))
 
        # Return the new root
        return y
 
    def rightRotate(self, z):
 
        y = z.left
        T3 = y.right
 
        # Perform rotation
        y.right = z
        z.left = T3
 
        # Update heights
        z.height = 1 + max(self.getHeight(z.left),
                        self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left),
                        self.getHeight(y.right))
 
        # Return the new root
        return y
 
    def getHeight(self, root):
        if not root:
            return 0
 
        return root.height
 
    def getBalance(self, root):
        if not root:
            return 0
 
        return self.getHeight(root.left) - self.getHeight(root.right)
 
    def preOrder(self, root):
 
        if not root:
            return
 
        print(""{0} "".format(root.val), end="""")
        self.preOrder(root.left)
        self.preOrder(root.right)
 
 
# Driver program to test above function
myTree = AVL_Tree()
root = None
 
root = myTree.insert(root, 10)
root = myTree.insert(root, 20)
root = myTree.insert(root, 30)
root = myTree.insert(root, 40)
root = myTree.insert(root, 50)
root = myTree.insert(root, 25)
 
""""""The constructed AVL Tree would be
            30
           /  \
         20   40
        /  \     \
       10  25    50""""""
 
# Preorder Traversal
print(""Preorder traversal of the"",
      ""constructed AVL tree is"")
myTree.preOrder(root)
print()
 
# This code is contributed by Ajitesh Pathak<|endoftext|>"
4,"<|endoftext|>You are given an array of strings words and a string pref.

Return the number of strings in words that contain pref as a prefix.

A prefix of a string s is any leading contiguous substring of s.

 :class Solution(object):
    def prefixCount(self, words, pref):
        """"""
        :type words: List[str]
        :type pref: str
        :rtype: int
        """"""
        
        return sum([1 for word in words if pref == word[0:len(pref)]])<|endoftext|>"
5,"<|endoftext|>In the previous article, we have discussed Python Program for Snake Case of a Given Sentence
The task is counting the words that appear exactly twice in an array/list of words in a given list in Python

Examples:

Example1:

Input:

Given List of words = ['hi', 'all', 'this', 'is', 'btechgeeks', 'hi', 'this', 'btechgeeks']
Output:

The Count of words in a given list ['hi', 'all', 'this', 'is', 'btechgeeks', 'hi', 'this', 'btechgeeks']  which are exactly repeated two times = 3:# Import the Counter() function from collections using the import keyword.
from collections import Counter
# Give the list of words as static input and store it in a variable.
gvn_lst = [""hi"", ""all"", ""this"", ""is"", ""btechgeeks"", ""hi"", ""this"", ""btechgeeks""]
# Calculate the frequency of all the given list of words using the Counter() function
# which returns the element and its frequency as key-value pair and store this
# dictionary in a variable(say dictnry)
dictnry = Counter(gvn_lst)
# Take a variable say countt and initialize its value with 0.
countt = 0
# Iterate in the above-obtained dictionary values using the for loop.
for itr in dictnry.values():
  # Check if the iterator value is equal to 2 or not using the if conditional statement.
    if itr == 2:
       # If the statement is true, increase the value of ""countt"" by 1.
        countt += 1
# Print the count of words that appear exactly twice in an array/list of words in a
# given list.
print(""The Count of words in a given list"", gvn_lst,
      "" which are exactly repeated two times ="", countt)<|endoftext|>"
6,"<|endoftext|>In previous post, BFS only with a particular vertex is performed i.e. it is assumed that all vertices are reachable from the starting vertex. But in the case of disconnected graph or any vertex that is unreachable from all vertex, the previous implementation will not give the desired output, so in this post, a modification is done in BFS.:# Python3 implementation of modified BFS 
import queue
  
# A utility function to add an edge 
# in an undirected graph. 
def addEdge(adj, u, v):
    adj[u].append(v)
  
# A utility function to do BFS of 
# graph from a given vertex u. 
def BFSUtil(u, adj, visited):
  
    # Create a queue for BFS 
    q = queue.Queue()
      
    # Mark the current node as visited
    # and enqueue it 
    visited[u] = True
    q.put(u) 
      
    # 'i' will be used to get all adjacent 
    # vertices 4 of a vertex list<int>::iterator i 
      
    while(not q.empty()):
          
        # Dequeue a vertex from queue 
        # and print it 
        u = q.queue[0] 
        print(u, end = "" "") 
        q.get() 
      
        # Get all adjacent vertices of the 
        # dequeued vertex s. If an adjacent 
        # has not been visited, then mark 
        # it visited and enqueue it 
        i = 0
        while i != len(adj[u]):
            if (not visited[adj[u][i]]):
                    visited[adj[u][i]] = True
                    q.put(adj[u][i])
            i += 1
  
# This function does BFSUtil() for all 
# unvisited vertices. 
def BFS(adj, V):
    visited = [False] * V 
    for u in range(V):
        if (visited[u] == False): 
            BFSUtil(u, adj, visited)
  
# Driver code 
if __name__ == '__main__':
  
    V = 5
    adj = [[] for i in range(V)] 
  
    addEdge(adj, 0, 4) 
    addEdge(adj, 1, 2) 
    addEdge(adj, 1, 3) 
    addEdge(adj, 1, 4) 
    addEdge(adj, 2, 3) 
    addEdge(adj, 3, 4) 
    BFS(adj, V)
  
# This code is contributed by PranchalK
<|endoftext|>"
7,"<|endoftext|>In the previous article, we have discussed Program to Find Lexicographic Rank of a Given String
 Given a string and the task is to find all the Non repeated characters in a given String.
 Counter function in Python:
 The counter is a set and dict subset. Counter() takes an iterable entity as an argument and stores the elements as keys and the frequency of the elements as a value. So, in collections, if we transfer a string. When you call Counter(), you’ll get a Counter class object with characters as keys and their frequency in a string as values.
 Counter() returns a Counter type object (a subclass of dict) with all characters in the string as keys and their occurrence count as values. We’ll use the [] operator to get the occurrence count of the characters from it.
 Examples:
 Example1:
 Input:
 Given String = ""hello this is btechgeeks""
 Output:
 In a Given String,{ hello this is btechgeeks } all Non-repeating Characters are:
 
 o b c g k
 Example2:
 Input:
 Given String = ""good morning btechgeeks""
 Output:
 In a Given String,{ good morning btechgeeks } all Non-repeating Characters are:
 
 d m r i b t c h k s:# Import the Counter() function from collections using the import keyword.
 
 from collections import Counter
 
 # Give the string as static input and store it in a variable.
 
 gven_str = ""hello this is btechgeeks""
 
 # Calculate the frequency of all the given string elements using the Counter() function
 
 # which returns the element and its frequency as a key-value pair and stores this
 
 # dictionary in another variable (say strngfreqelements).
 
 strngfreqelements = Counter(gven_str)
 
 print(""In a Given String,{"", gven_str, ""} all Non-repeating Characters are:"")
 
 # Traverse in this frequency dictionary using the for loop.
 
 for key in strngfreqelements:
 
  # Inside the loop, check if the Key has the frequency 1 and key not equal to space
 
  # using the if conditional statement
 
  if(strngfreqelements[key] == 1 and key != "" ""):
 
  # If the statement is true, then print the value of the key.
 
  print(key, end="" "")<|endoftext|>"
8,"<|endoftext|>Create a function that takes a word and returns True if the word has two consecutive identical letters.
Examples
double_letters(""loop"") ➞ True

double_letters(""yummy"") ➞ True

double_letters(""orange"") ➞ False

double_letters(""munchkin"") ➞ False
Notes
N/A:def double_letters(word):
  return any(i*2 in word for i in word)<|endoftext|>"
9,"<|endoftext|>Given a doubly linked list and a key x. The problem is to delete all occurrences of the given key x from the doubly linked list.:# Python3 implementation to delete all occurrences
# of a given key in a doubly linked list
import math

# a node of the doubly linked list
class Node:
	def __init__(self,data):
		self.data = data
		self.next = None
		self.prev = None

# Function to delete a node in a Doubly Linked List.
# head_ref --> pointer to head node pointer.
# del --> pointer to node to be deleted.
def deleteNode(head, delete):
	# base case
	if (head == None or delete == None):
		return None

	# If node to be deleted is head node
	if (head == delete):
		head = delete.next

	# Change next only if node to be deleted
	# is NOT the last node
	if (delete.next != None):
		delete.next.prev = delete.prev

	# Change prev only if node to be deleted
	# is NOT the first node
	if (delete.prev != None):
		delete.prev.next = delete.next

	# Finally, free the memory occupied by del
	# free(del)
	delete = None
	return head

# function to delete all occurrences of the given
# key 'x'
def deleteAllOccurOfX(head, x):
	# if list is empty
	if (head == None):
		return

	current = head

	# traverse the list up to the end
	while (current != None):

		# if node found with the value 'x'
		if (current.data == x):

			# save current's next node in the
			#pointer 'next'
			next = current.next

			# delete the node pointed to by
			# 'current'
			head = deleteNode(head, current)

			# update current
			current = next
		
		# else simply move to the next node
		else:
			current = current.next
	
	return head

# Function to insert a node at the beginning
# of the Doubly Linked List
def push(head,new_data):
	# allocate node
	new_node = Node(new_data)

	# put in the data
	new_node.data = new_data

	# since we are adding at the beginning,
	#prev is always None
	new_node.prev = None

	# link the old list off the new node
	new_node.next = head

	# change prev of head node to new node
	if (head != None):
		head.prev = new_node

	# move the head to point to the new node
	head = new_node
	return head

# Function to print nodes in a given doubly
# linked list
def printList(head):
	# if list is empty
	if (head == None):
		print(""Doubly Linked list empty"")

	while (head != None) :
		print(head.data,end="" "")
		head = head.next
	
# Driver functions
if __name__=='__main__':
	# Start with the empty list
	head = None

	# Create the doubly linked list:
	#	 2<->2<->10<->8<->4<->2<->5<->2
	head = push(head, 2)
	head = push(head, 5)
	head = push(head, 2)
	head = push(head, 4)
	head = push(head, 8)
	head = push(head, 10)
	head = push(head, 2)
	head = push(head, 2)

	print(""Original Doubly linked list:"")
	printList(head)

	x = 2

	# delete all occurrences of 'x'
	head = deleteAllOccurOfX(head, x)

	print(""\nDoubly linked list after deletion of "",x,"":"")
	printList(head)

# This article contributed by Srathore<|endoftext|>"
10,"<|endoftext|>Given a number N and the task is to find the sum of series (5^2+10^2+15^2+…..N^2) till the given number N in Python.:# Import math module using the import keyword.
import math
# Give the number N(limit) as static input and store it in a variable.
gvn_numb = 25
# Take a variable to say itr and initialize its value to 5.
itr = 5
# Take a variable to say rsltseries_summ and initialize its value to 0.
rsltseries_summ = 0
# Loop until the above-declared variable itr value is less than or equal to the
# given number using the while loop.
while(itr <= gvn_numb):
    # Calculate the value of itr raised to the power 2 (square) using the pow() function
    # and store it in another variable.
    k = pow(itr, 2)
    # Add the above result to the rsltseries_summ and store it in the
    # same variable.
    rsltseries_summ += k
    # Increment the above itr value by 5.
    itr += 5
print(""The above given series sum = "", rsltseries_summ)<|endoftext|>"
11,"<|endoftext|>You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr).
Return the maximum absolute sum of any (possibly empty) subarray of nums.
Note that abs(x) is defined as follows:

If x is a negative integer, then abs(x) = -x.
If x is a non-negative integer, then abs(x) = x.

 
Example 1:

Input: nums = [1,-3,2,3,-4]
Output: 5
Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.

Example 2:

Input: nums = [2,-5,1,-4,3,-2]
Output: 8
Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.

 
Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104:def maxAbsoluteSum(self, A):
  return max(accumulate(A, initial=0)) - min(accumulate(A, initial=0))<|endoftext|>"
12,"<|endoftext|>In this program, we will create a circular linked list and delete a node from the beginning of the list. If the list is empty, print the message ""List is empty"". If the list is not empty, we will make the head to point to the next node in the list, i.e., we will delete the first node.
:#Represents the node of list.    
class Node:    
    def __init__(self,data):    
        self.data = data;    
        self.next = None;    
     
class CreateList:    
    #Declaring head and tail pointer as null.    
    def __init__(self):    
        self.head = Node(None);    
        self.tail = Node(None);    
        self.head.next = self.tail;    
        self.tail.next = self.head;    
        
    #This function will add the new node at the end of the list.    
    def add(self,data):    
        newNode = Node(data);    
        #Checks if the list is empty.    
        if self.head.data is None:    
            #If list is empty, both head and tail would point to new node.    
            self.head = newNode;    
            self.tail = newNode;    
            newNode.next = self.head;    
        else:    
            #tail will point to new node.    
            self.tail.next = newNode;    
            #New node will become new tail.    
            self.tail = newNode;    
            #Since, it is circular linked list tail will point to head.    
            self.tail.next = self.head;    
        
    #Deletes node from the beginning of the list    
    def deleteStart(self):    
        #Checks whether list is empty    
        if(self.head == None):    
            return;    
        else:    
            #Checks whether contain only one element    
            #If not, head will point to next element in the list and tail will point to new head.    
            if(self.head != self.tail ):    
                self.head = self.head.next;    
                self.tail.next = self.head;    
            #If the list contains only one element     
            #then it will remove it and both head and tail will point to null    
            else:    
                self.head = self.tail = None;    
                
    #Displays all the nodes in the list    
    def display(self):    
        current = self.head;    
        if self.head is None:    
            print(""List is empty"");    
            return;    
        else:    
            #Prints each node by incrementing pointer.    
            print(current.data, end= ' ');    
            while(current.next != self.head):    
                current = current.next;    
                print(current.data,end=' ');    
            print(""\n"");    
     
class CircularLinkedList:    
    cl = CreateList();    
    #Adds data to the list    
    cl.add(1);    
    cl.add(2);    
    cl.add(3);    
    cl.add(4);    
    #Printing original list    
    print(""Original List:"");    
    cl.display();    
    while(cl.head != None):    
        cl.deleteStart();    
        #Printing updated list    
        print(""Updated List:"");    
        cl.display();    <|endoftext|>"
13,"<|endoftext|>You have n packages that you are trying to place in boxes, one package in each box. There are m suppliers that each produce boxes of different sizes (with infinite supply). A package can be placed in a box if the size of the package is less than or equal to the size of the box.

The package sizes are given as an integer array packages, where packages[i] is the size of the ith package. The suppliers are given as a 2D integer array boxes, where boxes[j] is an array of box sizes that the jth supplier produces.

You want to choose a single supplier and use boxes from them such that the total wasted space is minimized. For each package in a box, we define the space wasted to be size of the box - size of the package. The total wasted space is the sum of the space wasted in all the boxes.

For example, if you have to fit packages with sizes [2,3,5] and the supplier offers boxes of sizes [4,8], you can fit the packages of size-2 and size-3 into two boxes of size-4 and the package with size-5 into a box of size-8. This would result in a waste of (4-2) + (4-3) + (8-5) = 6.
Return the minimum total wasted space by choosing the box supplier optimally, or -1 if it is impossible to fit all the packages inside boxes. Since the answer may be large, return it modulo 109 + 7.:class Solution:
    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:
        packages.sort()
        largest_package = packages[-1]
        all_boxes = []

        for i, box in enumerate(boxes):
            # Optional: ignore box lists that don't work at the start. 
            # Spends time finding max to save time sorting/iterating later.
            if max(box) >= largest_package:
                all_boxes.extend(((x, i) for x in box))

        if not all_boxes:
            return -1

        all_boxes.sort(key=lambda j: j[0])

        space_wasted_by_box = [0] * len(boxes)
        last_package_handled = [-1] * len(boxes)
        package_ptr, num_packages = 0, len(packages)

        # Find smallest box that fits the smallest package
        start_index = bisect.bisect_right(all_boxes, (packages[0], -1))

        for box_size, orig_ind in all_boxes[start_index:]:
            # Package_ptr always points to the largest package with size <= box_size
            while package_ptr + 1 < num_packages and packages[package_ptr + 1] <= box_size:
                package_ptr += 1

            if last_package_handled[orig_ind] < package_ptr:
                space_wasted_by_box[orig_ind] += (package_ptr - last_package_handled[orig_ind]) * box_size
                last_package_handled[orig_ind] = package_ptr

        smallest_waste = min(space_wasted_by_box[i] for i in range(len(boxes)) if last_package_handled[i] == num_packages - 1)
        return (smallest_waste - sum(packages)) % 1000000007<|endoftext|>"
14,"<|endoftext|>An ice cream sandwich is a string that is formed by two identical ends and a different middle.
Some examples of ice cream sandwiches:
""AABBBAA""

""3&&3""

""yyyyymmmmmmmmyyyyy""

""hhhhhhhhmhhhhhhhh""
Notice how left and right ends of the sandwich are identical in both length and in repeating character). The middle section is distinctly different.
Not ice cream sandwiches:
""BBBBB""
// You can't have just plain icecream.

""AAACCCAA""
// You can't have unequal sandwich ends.

""AACDCAA""
// You can't have more than one filling.

""A""
// You can't have fewer than 3 characters.
Write a function that returns True if a string is an ice cream sandwich and False otherwise.
Examples
is_icecream_sandwich(""CDC"") ➞ True

is_icecream_sandwich(""AAABB"") ➞ False

is_icecream_sandwich(""AA"") ➞ False
Notes
An ice cream sandwich must have a minimum length of 3 characters, and at least two of these characters must be distinct (you can't only have the filling!).:def is_icecream_sandwich(txt):
  return txt == txt[::-1] and len(set(txt)) == 2<|endoftext|>"
15,"<|endoftext|>You are given an array nums​​​ and an integer k​​​​​. The XOR of a segment [left, right] where left <= right is the XOR of all the elements with indices between left and right, inclusive: nums[left] XOR nums[left+1] XOR ... XOR nums[right].
Return the minimum number of elements to change in the array such that the XOR of all segments of size k​​​​​​ is equal to zero.
 
Example 1:

Input: nums = [1,2,0,3,0], k = 1
Output: 3
Explanation: Modify the array from [1,2,0,3,0] to from [0,0,0,0,0].

Example 2:

Input: nums = [3,4,5,2,1,7,3,4,7], k = 3
Output: 3
Explanation: Modify the array from [3,4,5,2,1,7,3,4,7] to [3,4,7,3,4,7,3,4,7].

Example 3:

Input: nums = [1,2,4,1,2,5,1,2,6], k = 3
Output: 3
Explanation: Modify the array from [1,2,4,1,2,5,1,2,6] to [1,2,3,1,2,3,1,2,3].
 
Constraints:

1 <= k <= nums.length <= 2000
​​​​​​0 <= nums[i] < 210:def minChanges(self, nums: List[int], k: int) -> int:

  LIMIT = 2**10
  mrr = [[0 for _ in range(LIMIT)] 
  for _ in range(k)]
  for i,x in enumerate(nums):
  mrr[i%k][x] += 1

  dp = [-2000 for _ in range(LIMIT)]
  dp[0] = 0
  for row in mrr:
  maxprev = max(dp)
  new_dp = [maxprev for _ in range(LIMIT)]
  for i,cnt in enumerate(row):
  if cnt > 0:
  for j,prev in enumerate(dp):
  new_dp[i^j] = max(new_dp[i^j], prev+cnt)
  dp = new_dp

  return len(nums) - new_dp[0]<|endoftext|>"
16,"<|endoftext|>Create a function that flips a horizontal list into a vertical list, and a vertical list into a horizontal list.
In other words, take an 1 x n list (1 row + n columns) and flip it into a n x 1 list (n rows and 1 column), and vice versa.
Examples
flip_list([1, 2, 3, 4]) ➞ [[1], [2], [3], [4]]
# Take a horizontal list and flip it vertical.

flip_list([[5], [6], [9]]) ➞ [5, 6, 9]
# Take a vertical list and flip it horizontal.

flip_list([]) ➞ []
Notes
If given an empty list [], return an empty list [].:def flip_list(lst):
  return [x[0] if isinstance(x, list) else [x] for x in lst]<|endoftext|>"
17,"<|endoftext|>Create a function that converts color in RGB format to Hex format.
Examples
rgb_to_hex(""rgb(0, 128, 192)"") ➞ ""#0080c0""

rgb_to_hex(""rgb(45, 255, 192)"") ➞ ""#2dffc0""

rgb_to_hex(""rgb(0, 0, 0)"") ➞ ""#000000""
Notes
The Hex format should be displayed in lowercase.:def rgb_to_hex(col):
  return '#{:02x}{:02x}{:02x}'.format(*eval(col[3:]))<|endoftext|>"
18,"<|endoftext|>In the previous article, we have discussed Python Program to Find Sum of Series 1-2+3-4+5…+N
 Given a number N and the task is to find the triangular number series (1 3 6 10 15 …N) until the given number.
 int() function in Python:
 The int() function is used to transform a value into an integer number.
 Examples:
 Example1:
 Input:
 Given Number = 8
 Output:
 The Triangular series until the given number{ 8 } is :
 
 1 3 6 10 15 21 28 36
 Example2:
 Input:
 Given Number = 15
 Output:
 The Triangular series until the given number{ 15 } is :
 
 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120:# Give the number N as static input and store it in a variable.
 
 gvn_numb = 8
 
 # Take a variable say k and initialize its value with 1.
 
 k = 1
 
 print(""The Triangular series until the given number{"", gvn_numb, ""} is :"")
 
 # Loop until the value of k is less than or equal to the given number using the while loop.
 
 while(k &lt;= gvn_numb):
 
  # Inside the loop, multiply the value of k with k+1 and divide the result by 2 and
 
  # convert it into an integer using the int() function.
 
  # Store it in a variable say p.
 
  p = int((k*(k+1))/2)
 
  # Print the above result (p) separated by spaces to get the triangular series until
 
  # the given number.
 
  print(p, end="" "")
 
  # Increment the value of k by 1 and store it in the same variable k.
 
  k += 1
 
 </pre><|endoftext|>"
19,"<|endoftext|>Reservoir sampling is a family of randomized algorithms for randomly choosing k samples from a list of n items, where n is either a very large or unknown number. Typically n is large enough that the list doesn’t fit into main memory. For example, a list of search queries in Google and Facebook.
So we are given a big array (or stream) of numbers (to simplify), and we need to write an efficient function to randomly select k numbers where 1 <= k <= n. Let the input array be stream[]. 

A simple solution is to create an array reservoir[] of maximum size k. One by one randomly select an item from stream[0..n-1]. If the selected item is not previously selected, then put it in reservoir[]. To check if an item is previously selected or not, we need to search the item in reservoir[]. The time complexity of this algorithm will be O(k^2). This can be costly if k is big. Also, this is not efficient if the input is in the form of a stream. 

It can be solved in O(n) time. The solution also suits well for input in the form of stream. The idea is similar to this post. Following are the steps.
1) Create an array reservoir[0..k-1] and copy first k items of stream[] to it. 
2) Now one by one consider all items from (k+1)th item to nth item. 
…a) Generate a random number from 0 to i where i is the index of the current item in stream[]. Let the generated random number is j. 
…b) If j is in range 0 to k-1, replace reservoir[j] with stream[i]
Time Complexity: O(n)

Auxiliary Space: O(k)

How does this work? 
To prove that this solution works perfectly, we must prove that the probability that any item stream[i] where 0 <= i < n will be in final reservoir[] is k/n. Let us divide the proof in two cases as first k items are treated differently.

Case 1: For last n-k stream items, i.e., for stream[i] where k <= i < n 
For every such stream item stream[i], we pick a random index from 0 to i and if the picked index is one of the first k indexes, we replace the element at picked index with stream[i]
To simplify the proof, let us first consider the last item. The probability that the last item is in final reservoir = The probability that one of the first k indexes is picked for last item = k/n (the probability of picking one of the k items from a list of size n)
Let us now consider the second last item. The probability that the second last item is in final reservoir[] = [Probability that one of the first k indexes is picked in iteration for stream[n-2]] X [Probability that the index picked in iteration for stream[n-1] is not same as index picked for stream[n-2] ] = [k/(n-1)]*[(n-1)/n] = k/n.
Similarly, we can consider other items for all stream items from stream[n-1] to stream[k] and generalize the proof.

Case 2: For first k stream items, i.e., for stream[i] where 0 <= i < k 
The first k items are initially copied to reservoir[] and may be removed later in iterations for stream[k] to stream[n]. 
The probability that an item from stream[0..k-1] is in final array = Probability that the item is not picked when items stream[k], stream[k+1], …. stream[n-1] are considered = [k/(k+1)] x [(k+1)/(k+2)] x [(k+2)/(k+3)] x … x [(n-1)/n] = k/n:# An efficient Python3 program
# to randomly select k items
# from a stream of items
import random
# A utility function
# to print an array
def printArray(stream,n):
	for i in range(n):
		print(stream[i],end="" "");
	print();

# A function to randomly select
# k items from stream[0..n-1].
def selectKItems(stream, n, k):
		i=0;
		# index for elements
		# in stream[]
		
		# reservoir[] is the output
		# array. Initialize it with
		# first k elements from stream[]
		reservoir = [0]*k;
		for i in range(k):
			reservoir[i] = stream[i];
		
		# Iterate from the (k+1)th
		# element to nth element
		while(i < n):
			# Pick a random index
			# from 0 to i.
			j = random.randrange(i+1);
			
			# If the randomly picked
			# index is smaller than k,
			# then replace the element
			# present at the index
			# with new element from stream
			if(j < k):
				reservoir[j] = stream[i];
			i+=1;
		
		print(""Following are k randomly selected items"");
		printArray(reservoir, k);
	
# Driver Code

if __name__ == ""__main__"":
	stream = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
	n = len(stream);
	k = 5;
	selectKItems(stream, n, k);

# This code is contributed by mits<|endoftext|>"
20,"<|endoftext|>Create a function that takes a value as an argument and returns the type of this value.
Examples
get_type(1) ➞ ""int""

get_type(""a"") ➞ ""str""

get_type(True) ➞ ""bool""

get_type([]) ➞ ""list""

get_type(None) ➞ ""NoneType""
Notes
N/A:def get_type(value):
  return type(value).__name__<|endoftext|>"
21,"<|endoftext|>The break Statement
With the break statement we can stop the loop before it has looped through all the items::fruits = [""apple"", ""banana"", ""cherry""]
for x in fruits:
  print(x)
  if x == ""banana"":
    break
<|endoftext|>"
22,"<|endoftext|>In the previous article, we have discussed Python Program to Check Trimorphic Number or Not
 The task is to remove spaces from a sentence and rewrite it in the Snake case. It is a writing style in which spaces are replaced with underscores and all words begin with small letters.
 The lower() method in Python:
 lower() returns a string with all characters in lower case.
 Examples:
 Example1:
 Input:
 Given string/sentence = Hello this is Btechgeeks
 Output:
 The given sentence { Hello this is Btechgeeks } after Converting into Snake case :
 
 hello_this_is_btechgeeks
 Example2:
 Input:
 Given string/sentence = Good morning This is Btechgeeks
 Output:
 The given sentence { Good morning This is Btechgeeks } after Converting into Snake case :
 
 good_morning_this_is_btechgeeks:# Give the string/sentence as static input and store it in a variable.
 
 gvn_strng = ""Hello this is Btechgeeks""
 
 # Calculate the length of the given string using the len() function and
 
 # store it in another variable.
 
 str_lengt = len(gvn_strng)
 
 # Convert the given string into a list of characters using the list() function and
 
 # store it in another variable say lst_strng.
 
 lst_strng = list(gvn_strng)
 
 # Iterate up to the length of the given string using the for loop.
 
 print(""The given sentence {"", gvn_strng,
 
  ""} after Converting into Snake case :"")
 
 for itr in range(str_lengt):
 
  # Check if the element of the list of characters ( lst_strng ) is equal to space ( ' ' )
 
  # using the if conditional statement.
 
  if (lst_strng[itr] == ' '):
 
  # If the statement is true, then replace the space with the underscore( _ ).
 
  lst_strng[itr] = '_'
 
  else:
 
  # If the statement is false, then convert the elements of the list of characters ( lst_strng )
 
  # into lower case using the lower() function.
 
  lst_strng[itr] = lst_strng[itr].lower()
 
 # Convert the above list lst_strng into the string using the join function.
 
 # Store it in the same variable lst_strng.
 
 lst_strng = """".join(lst_strng)
 
 # Print the lst_strng to remove spaces from a given sentence and rewrite it in the
 
 # Snake case.
 
 print(lst_strng)
 
 </pre><|endoftext|>"
23,"<|endoftext|>Given a String and the task is to change the ‘+’ sign into ‘-‘ and vice versa for a given string.

Examples:

Example1:

Input:

Given String = ""  --btech++geeks-- ""
Output:

The given string { --btech++geeks-- } after changing the '+' sign into '-' and vice versa = ++btech--geeks++
Example2:

Input:

Given String = ""--1++2--3+""
Output:

The given string { --1++2--3+ } after changing the '+' sign into '-' and vice versa = ++1--2++3-:# Give the string as static input and store it in a variable.
 gvn_str = ""32--1++4""
 # Take an empty string say ""new_str"" and store it in another variable.
 new_str = """"
 # Loop in the given string using the for loop.
 for itr in gvn_str:
  # Inside the loop, check if the iterator value is equal to '+' sign using the if
  # conditional statement.
  if(itr == ""+""):
  # If it is true, then concatenate the '-' sign with the new_str and store it in the
  # same variable new_str.
  new_str += ""-""
 # Check if the iterator value is equal to the '-' sign using the elif conditional statement.
  elif(itr == ""-""):
  # If it is true, then concatenate the '+' sign with the new_str and store it in the
  # same variable new_str.
  new_str += ""+""
  else:
  # Else concatenate the iterator value to the new_str and store it in the same variable new_str.
  new_str += itr
 # Print the given string after changing the '+' sign into '-' and vice versa.
 print(""The given string {"", gvn_str,
  ""} after changing the '+' sign into '-' and vice versa ="", new_str)<|endoftext|>"
24,"<|endoftext|>Create a function which takes in a sentence txt and a string of characters chars and return the sentence but with all the specified characters removed.
Examples
strip_sentence(""the quick brown fox jumps over the lazy dog"", ""aeiou"") ➞ ""th qck brwn fx jmps vr th lzy dg""

strip_sentence(""the hissing snakes sinisterly slither across the rustling leaves"", ""s"") ➞ ""the hiing nake initerly lither acro the rutling leave""

strip_sentence(""gone, reduced to atoms"", ""go, muscat nerd"") ➞ """"
Notes
You may be asked to remove punctuation and spaces.
Return an empty string if every character is specified (see example #3).
All tests will be in lowercase.:def strip_sentence(txt, chars):
  return ''.join(i for i in txt if i not in chars)<|endoftext|>"
25,"<|endoftext|>Find the length of maximum number of consecutive numbers jumbled up in an array.:
# Python3 program to find largest consecutive
# numbers present in arr.
 
 
def findLongestConseqSubseq(arr, n):
    #The longest sequence in an empty array is, of course, 0, so we can simply return that.
    if n==0:
       return 0
       
    #We will arrange array elements in ascending order using sort function.
    arr.sort()
 
    # check each possible sequence from the start
    # then update optimal length
    ans = 1
    count = 1
    for i in range(1, n):
      #For handling duplicate elements
      if arr[i]!=arr[i-1]:
 
        # if difference between current element and previous element is 1
        # then we want to update our current sequence count
 
        if arr[i]-arr[i-1] == 1:
            count += 1
 
        # otherwise, we will update our count to zero to check for other sequences.
        # before updating count value we have to check if current sequence length is more than our ans.
        # if count > ans then we want to update our ans.
 
        else:
            ans = max(ans, count)
            count = 1
 
    return max(ans,count) #To handle the case in which last element is present in longest sequence.
 
 
# Driver code
if __name__ == '__main__':
    arr = [1, 94, 93, 1000, 5, 92, 78]
    n = len(arr)
    print(findLongestConseqSubseq(arr, n))
 
  
# This code is contributed by sanjanasikarwar24<|endoftext|>"
26,"<|endoftext|>Write a function that retrieves all words that begin with a vowel.
Examples
retrieve(""A simple life is a happy life for me."") ➞ [""a"", ""is"", ""a""]

retrieve(""Exercising is a healthy way to burn off energy."")
➞ [""exercising"", ""is"", ""a"", ""off"", ""energy""]

retrieve(""The poor ostrich was ostracized."")
➞ [""ostrich"", ""ostracized""]

retrieve("""")
➞ []
Notes
Make all words lower case in the output.
Retrieve the words in the order they appear in the sentence.:def retrieve(txt):
  return [i for i in txt[:-1].lower().split() if i[0] in 'aeiou']<|endoftext|>"
27,"<|endoftext|>Given a string s of lowercase letters, you need to find the maximum number of non-empty substrings of s that meet the following conditions:

The substrings do not overlap, that is for any two substrings s[i..j] and s[k..l], either j < k or i > l is true.
A substring that contains a certain character c must also contain all occurrences of c.

Find the maximum number of substrings that meet the above conditions. If there are multiple solutions with the same number of substrings, return the one with minimum total length. It can be shown that there exists a unique solution of minimum total length.
Notice that you can return the substrings in any order.
 
Example 1:

Input: s = ""adefaddaccc""
Output: [""e"",""f"",""ccc""]
Explanation: The following are all the possible substrings that meet the conditions:
[
 ""adefaddaccc""
 ""adefadda"",
 ""ef"",
 ""e"",
  ""f"",
 ""ccc"",
]
If we choose the first string, we cannot choose anything else and we'd get only 1. If we choose ""adefadda"", we are left with ""ccc"" which is the only one that doesn't overlap, thus obtaining 2 substrings. Notice also, that it's not optimal to choose ""ef"" since it can be split into two. Therefore, the optimal way is to choose [""e"",""f"",""ccc""] which gives us 3 substrings. No other solution of the same number of substrings exist.

Example 2:

Input: s = ""abbaccd""
Output: [""d"",""bb"",""cc""]
Explanation: Notice that while the set of substrings [""d"",""abba"",""cc""] also has length 3, it's considered incorrect since it has larger total length.

 
Constraints:

1 <= s.length <= 10^5
s contains only lowercase English letters.:class Solution:
  def maxNumOfSubstrings(self, s):
  fst = { c : i for i, c in reversed(list(enumerate(s))) }
  lst = { c : i for i, c in enumerate(s) }
  
  ans, prev = [], -1
  for i in sorted(lst.values()):
  b, e = fst[s[i]], lst[s[i]]
  j = e
  while j >= b and b > prev and e == i:
  b = min(b, fst[s[j]])
  e = max(e, lst[s[j]])
  j -= 1
  if b > prev and e == i:
  ans.append(s[b:e + 1])
  prev = e
  
  return ans<|endoftext|>"
28,"<|endoftext|>Given the size, return a square matrix of numbers in spiral order.

The matrix should be filled with natural numbers, starting from 1 in the top-left corner, increasing in an inward, clockwise spiral order, like these examples:

Examples
Spiral matrix of size 3
1 2 3
8 9 4
7 6 5
Spiral matrix of size 4
 1  2  3 4
12 13 14 5
11 16 15 6
10  9  8 7:from itertools import cycle
def spiral_matrix(size):
    matrix = [[None] * size for _ in range(size)]
    r, c = 0, 0
    # this cycle determines the movement of the ""current cell""
    # (0,1) represents moving along a row to the right
    # (1,0) represents moving down a column
    deltas = cycle(((0,1), (1,0), (0,-1), (-1,0)))
    dr, dc = next(deltas)
    for i in range(size**2):
        matrix[r][c] = i+1
        if (
            not 0 <= r+dr < size or
            not 0 <= c+dc < size or
            matrix[r+dr][c+dc] is not None
        ):
            dr, dc = next(deltas)
        r += dr
        c += dc
    return matrix<|endoftext|>"
29,"<|endoftext|>Given two unsorted arrays that represent two sets (elements in every array are distinct), find the union and intersection of two arrays.:# Python3 program to find union and intersection
# using similar Hashing Technique
# without using any predefined Java Collections
# Time Complexity best case & avg case = O(m+n)
# Worst case = O(nlogn)


# Prints intersection of arr1[0..n1-1] and
# arr2[0..n2-1]
def findPosition(a, b):
	v = len(a) + len(b);
	ans = [0]*v;
	zero1 = zero2 = 0;
	print(""Intersection :"",end="" "");
	
	# Iterate first array
	for i in range(len(a)):
		zero1 = iterateArray(a, v, ans, i);
	
	# Iterate second array
	for j in range(len(b)):
		zero2 = iterateArray(b, v, ans, j);
	
	zero = zero1 + zero2;
	placeZeros(v, ans, zero);
	printUnion(v, ans, zero);
	
# Prints union of arr1[0..n1-1] and arr2[0..n2-1]
def printUnion(v, ans,zero):
	zero1 = 0;
	print(""\nUnion :"",end="" "");
	for i in range(v):
		if ((zero == 0 and ans[i] == 0) or
			(ans[i] == 0 and zero1 > 0)):
			continue;
		if (ans[i] == 0):
			zero1+=1;
		print(ans[i],end="","");

def placeZeros(v, ans, zero):
	if (zero == 2):
		print(""0"");
		d = [0];
		placeValue(d, ans, 0, 0, v);
	if (zero == 1):
		d=[0];
		placeValue(d, ans, 0, 0, v);

# Function to iterate array
def iterateArray(a,v,ans,i):
	if (a[i] != 0):
		p = a[i] % v;
		placeValue(a, ans, i, p, v);
	else:
		return 1;
	
	return 0;

def placeValue(a,ans,i,p,v):
	p = p % v;
	if (ans[p] == 0):
		ans[p] = a[i];
	else:
		if (ans[p] == a[i]):
			print(a[i],end="","");
		else:
			# Hashing collision happened increment
			# position and do recursive call
			p = p + 1;
			placeValue(a, ans, i, p, v);

# Driver code
a = [ 7, 1, 5, 2, 3, 6 ];
b = [ 3, 8, 6, 20, 7 ];
findPosition(a, b);

# This code is contributed by mits<|endoftext|>"
30,"<|endoftext|>Count Numbers that don’t Contain 3 (User Input):# Give the list as user input using list(),map(),input(),and split() functions.
# Store it in a variable.
lstnmbs = list(map(int, input(
    'Enter some random List Elements separated by spaces = ').split()))
# Take a variable that stores the count of numbers
# that doesn't contain digit 3 in them(say cunt)
cunt = 0
# Traverse the given list using For loop.
for numbr in lstnmbs:
    # Convert the list element to a string and store it in a variable.
    strnumbr = str(numbr)
    # Check if this string contains digit 3 in it using not in operator and If statement.
    if '3' not in strnumbr:
        # If it is true then increment the cunt by 1.
        cunt = cunt+1
# Print the cunt value.
print('The Count of numbers that doesnt contain three in the given list',
      lstnmbs, 'is [', cunt, ']')<|endoftext|>"
31,"<|endoftext|>There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.

Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.

Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.
Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.
Alice and Bob cannot remove pieces from the edge of the line.
If a player cannot make a move on their turn, that player loses and the other player wins.
Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.

 :class Solution:
    def winnerOfGame(self, colors: str) -> bool:
        # idea is to count presence of 'A' and 'B' in groups
        #every time you get a continuoius group of As or Bs and it counts is > 3
        # then it would mean there can be count-2 turns for that player
        # the player with maximum possible moves wins. in case of tie, bob wins always.
        
        n = len(colors)
        if n <=2 :
            return False
        grouped_count_map = {'A':0 , 'B':0}
        start, end = 0,0
        while end < n:
            if colors[start] != colors[end]:
                grouped_len = end-start
                if grouped_len >=3:
                    grouped_count_map[colors[start]] += grouped_len -2
                start = end
                
            else:
                end +=1
        
        if end-start >=3:
            grouped_count_map[colors[start]] += end-start -2
            
        if grouped_count_map['A'] > grouped_count_map['B']:
            return True
        else:
            return False
                        ```<|endoftext|>"
32,"<|endoftext|>This python program generates flag of Nepal made up of stars up to n lines.
Note: Here row number indicates number of row in each section in pattern. If we give input row number 7 then total row will be 21 :):# Python Program to Generate Flag of Nepal

# Generating Triangle Shape
def triangleShape(n):
    for i in range(n):
        for k in range(i+1):
            print('*',end=' ')
        print()

# Generating Pole Shape
def poleShape(n):
    for i in range(n):
        print('*')

# Input and Function Call
row = int(input('Enter number of rows: '))
triangleShape(row)
triangleShape(row)
poleShape(row)<|endoftext|>"
33,"<|endoftext|>In the world of birding there are four-letter codes for the common names of birds. These codes are created by some simple rules:
If the bird's name has only one word, the code takes the first four letters of that word.
If the name is made up of two words, the code takes the first two letters of each word.
If the name is made up of three words, the code is created by taking the first letter from the first two words and the first two letters from the third word.
If the name is four words long, the code uses the first letter from all the words.
There are other ways codes are created, but this challenge will only use the four rules listed above.
In this challenge you will write a function that takes a list of strings of common bird names and create the codes for those names based on the rules above. The function will return a list of codes in the same order in which the input names were presented.
Examples
bird_code([""Black-Capped Chickadee"", ""Common Tern""]) ➞ [""BCCH"", ""COTE""]

bird_code([""American Redstart"", ""Northern Cardinal""]) ➞ [""AMRE"",""NOCA""]

bird_code([""Bobolink"", ""American White Pelican""]) ➞ [""BOBO"",""AWPE""]
Notes
The four-letter codes in the returned list should be in UPPER CASE.
If a common name has a hyphen/dash, it should be considered a space.:def bird_code(lst):
  def f(name):
    w=name.replace('-',' ').upper().split()
    s={1:[4],2:[2,2],3:[1,1,2],4:[1,1,1,1]}[len(w)]
    return ''.join(x[:l] for x, l in zip(w, s))
  return list(map(f,lst))<|endoftext|>"
34,"<|endoftext|>We have an array of integers, nums, and an array of requests where requests[i] = [starti, endi]. The ith request asks for the sum of nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. Both starti and endi are 0-indexed.
Return the maximum total sum of all requests among all permutations of nums.
Since the answer may be too large, return it modulo 109 + 7.
 
Example 1:

Input: nums = [1,2,3,4,5], requests = [[1,3],[0,1]]
Output: 19
Explanation: One permutation of nums is [2,1,3,4,5] with the following result: 
requests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8
requests[1] -> nums[0] + nums[1] = 2 + 1 = 3
Total sum: 8 + 3 = 11.
A permutation with a higher total sum is [3,5,4,2,1] with the following result:
requests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11
requests[1] -> nums[0] + nums[1] = 3 + 5  = 8
Total sum: 11 + 8 = 19, which is the best that you can do.

Example 2:

Input: nums = [1,2,3,4,5,6], requests = [[0,1]]
Output: 11
Explanation: A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].
Example 3:

Input: nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]
Output: 47
Explanation: A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].
 
Constraints:

n == nums.length
1 <= n <= 105
0 <= nums[i] <= 105
1 <= requests.length <= 105
requests[i].length == 2
0 <= starti <= endi < n:def maxSumRangeQuery(self, A, req):
  n = len(A)
  count = [0] * (n + 1)
  for i, j in req:
  count[i] += 1
  count[j + 1] -= 1
  for i in xrange(1, n + 1):
  count[i] += count[i - 1]
  res = 0
  for v, c in zip(sorted(count[:-1]), sorted(A)):
  res += v * c
  return res % (10**9 + 7)<|endoftext|>"
35,"<|endoftext|>Given the number of rows of the diamond pattern, the task is to print the diamond star pattern in C, C++, and Python

Examples:

Example1:

Input:

given number of rows of diamond =5
Output:

  *
  ***
  *****
  *******
 *********
  *******
  *****
  ***
  *
Example2:

Input:

given number of rows of diamond =7
given character to print ='$'
Output:

  $
  $$$
  $$$$$
  $$$$$$$
  $$$$$$$$$
  $$$$$$$$$$$
$$$$$$$$$$$$$
  $$$$$$$$$$$
  $$$$$$$$$
  $$$$$$$
  $$$$$
  $$$
  $:# Give the number of rows of the diamond pattern as static input and store it in a variable.
diamondrows = 5
# Loop from 1 to the number of rows using For Loop.
for m in range(1, diamondrows+1):
  # Loop from 1 to the number of rows -iterator value of the parent
  # For loop using another For loop(Nested For loop).
  for n in range(1, diamondrows - m + 1):
  # Print the space character in the inner For loop.
  print(end=' ')
  # Loop from 0 to the 2* iterator value - 1 of the parent For loop
  # using another For loop(Nested For loop).
  for l in range(0, (2 * m) - 1):
  # Print the star character
  print('*', end='')
  # After the end of the inner for Loops print the Newline Character.
  print()
# Loop from 1 to the number of rows using For loop.
for m in range(1, diamondrows):
  # Loop from 1 to iterator value of the parent For loop
  # using another For loop(Nested For loop).
  for n in range(1, m+1):
  # Print the space character in the inner For loop.
  print(end=' ')
  # Loop from 1 to 2*(number of rows - iterator value of the parent for loop)
  # using another For loop(Nested For loop).
  for l in range(1, (2 * (diamondrows - m))):
  # Print the star character
  print('*', end='')
  # After the end of the inner for Loops print the Newline Character.
  print()<|endoftext|>"
36,"<|endoftext|>We are given a directed graph. We need to compute whether the graph has a negative cycle or not. A negative cycle is one in which the overall sum of the cycle becomes negative.:# A Python3 program to check if a graph contains negative
# weight cycle using Bellman-Ford algorithm. This program
# works only if all vertices are reachable from a source
# vertex 0.
  
# a structure to represent a weighted edge in graph
class Edge:
      
    def __init__(self):
        self.src = 0
        self.dest = 0
        self.weight = 0
  
# a structure to represent a connected, directed and
# weighted graph
class Graph:
      
    def __init__(self):
          
        # V. Number of vertices, E. Number of edges
        self.V = 0
        self.E = 0
  
        # graph is represented as an array of edges.
        self.edge = None
  
# Creates a graph with V vertices and E edges
def createGraph(V, E):
  
    graph = Graph()
    graph.V = V;
    graph.E = E;
    graph.edge =[Edge() for i in range(graph.E)]
    return graph;
  
# The main function that finds shortest distances
# from src to all other vertices using Bellman-
# Ford algorithm.  The function also detects
# negative weight cycle
def isNegCycleBellmanFord(graph, src):
  
    V = graph.V;
    E = graph.E;
    dist = [1000000 for i in range(V)];
    dist[src] = 0;
  
    # Step 2: Relax all edges |V| - 1 times.
    # A simple shortest path from src to any
    # other vertex can have at-most |V| - 1
    # edges
    for i in range(1, V):
        for j in range(E):
          
            u = graph.edge[j].src;
            v = graph.edge[j].dest;
            weight = graph.edge[j].weight;
            if (dist[u] != 1000000 and dist[u] + weight < dist[v]):
                dist[v] = dist[u] + weight;
  
    # Step 3: check for negative-weight cycles.
    # The above step guarantees shortest distances
    # if graph doesn't contain negative weight cycle.
    # If we get a shorter path, then there
    # is a cycle.
    for i in range(E):
      
        u = graph.edge[i].src;
        v = graph.edge[i].dest;
        weight = graph.edge[i].weight;
        if (dist[u] != 1000000 and dist[u] + weight < dist[v]):
            return True;
  
    return False;
  
# Driver program to test above functions
if __name__=='__main__':
      
    # Let us create the graph given in above example 
    V = 5; # Number of vertices in graph
    E = 8; # Number of edges in graph
    graph = createGraph(V, E);
  
    # add edge 0-1 (or A-B in above figure)
    graph.edge[0].src = 0;
    graph.edge[0].dest = 1;
    graph.edge[0].weight = -1;
  
    # add edge 0-2 (or A-C in above figure)
    graph.edge[1].src = 0;
    graph.edge[1].dest = 2;
    graph.edge[1].weight = 4;
  
    # add edge 1-2 (or B-C in above figure)
    graph.edge[2].src = 1;
    graph.edge[2].dest = 2;
    graph.edge[2].weight = 3;
  
    # add edge 1-3 (or B-D in above figure)
    graph.edge[3].src = 1;
    graph.edge[3].dest = 3;
    graph.edge[3].weight = 2;
  
    # add edge 1-4 (or A-E in above figure)
    graph.edge[4].src = 1;
    graph.edge[4].dest = 4;
    graph.edge[4].weight = 2;
  
    # add edge 3-2 (or D-C in above figure)
    graph.edge[5].src = 3;
    graph.edge[5].dest = 2;
    graph.edge[5].weight = 5;
  
    # add edge 3-1 (or D-B in above figure)
    graph.edge[6].src = 3;
    graph.edge[6].dest = 1;
    graph.edge[6].weight = 1;
  
    # add edge 4-3 (or E-D in above figure)
    graph.edge[7].src = 4;
    graph.edge[7].dest = 3;
    graph.edge[7].weight = -3;
  
    if (isNegCycleBellmanFord(graph, 0)):
        print(""Yes"")
    else:
        print(""No"")
  
        # This code is contributed by pratham76
<|endoftext|>"
37,"<|endoftext|>The is keyword is used to test if two variables refer to the same object.

The test returns True if the two objects are the same object.

The test returns False if they are not the same object, even if the two objects are 100% equal.

Use the == operator to test if two variables are equal.:x = [""apple"", ""banana"", ""cherry""]

y = x

print(x is y)<|endoftext|>"
38,"<|endoftext|>Are you wondering how to seek help from subject matter experts and learn the Java language? Go with these Basic Java Programming Examples and try to code all of them on your own then check with the exact code provided by expert programmers.
 
 Given a number, the task is to check whether the given number is a Peterson number or not.
 
 Peterson Number:
 
 The Peterson number is the number whose sum of factorials of each digit equals the number itself. Let me give you an example to help you understand:
 
 Examples:
 
 Example1:
 
 Input:
 
 Given number =1
 Output:
 
 The given number [ 1 ] is a Peterson number
 Example2:
 
 Input:
 
 Given number =145
 Output:
 
 The given number [ 145 ] is a Peterson number:# Import the math module using the import keyword.
 import math
 # Give the number as static input and store it in a variable.4
 gvnnumb = 145
 # Take a variable psum and initialize its value to 0.
 psum = 0
 # Convert the given number to a string using the str() function.
 strnumbe = str(gvnnumb)
 # Convert the given number into a list of
 # digits using list(),map(),int,split() functions.
 lstdigts = list(map(int, strnumbe))
 # Traverse in this list of digits using For loop.
 for dgtnumbr in lstdigts:
  # Calculate the factorial of the list value using math.factorial() function.
  numbfact = math.factorial(dgtnumbr)
  # Add this factorial value to psum.
  psum = psum+numbfact
 # Check if psum is equal to the given number using the If statement.
 if(psum == gvnnumb):
  # If it is true then it is a Peterson number.
  print('The given number [', gvnnumb, '] is a Peterson number')
 # Else it is not Peterson's number.
 else:
  print('The given number [', gvnnumb, '] is not a Peterson number')<|endoftext|>"
39,"<|endoftext|>Create a function that takes an integer n and reverses it.
Examples
rev(5121) ➞ ""1215""

rev(69) ➞ ""96""

rev(-122157) ➞ ""751221""
Notes
This challenge is about using two operators that are related to division.
If the number is negative, treat it like it's positive.:def rev(n):
  return str(abs(n))[::-1]<|endoftext|>"
40,"<|endoftext|>
Definition and Usage
The extend() method adds the specified list elements (or any iterable) to the end of the current list.:fruits = ['apple', 'banana', 'cherry']

cars = ['Ford', 'BMW', 'Volvo']

fruits.extend(cars)<|endoftext|>"
41,"<|endoftext|>Looping Through an Iterator
We can also use a for loop to iterate through an iterable object::mytuple = (""apple"", ""banana"", ""cherry"")

for x in mytuple:
  print(x)<|endoftext|>"
42,"<|endoftext|>Create a function that takes number of units consumed by the customer and returns calculated Electricity Bill as per following conditions:
First 100 Units will be charged at $1/unit.
Next 100 Units will be charged at $2/unit.
Next 100 Units will be charged at $3/unit.
Next 200 Units will be charged at $4/unit.
Next Units will be charged at $5/unit.
10% tax to be added in final amount.
Extra $15 to be added for Meter Charge.
Examples
electricity_bill(100) ➞ 125
# 100 units at $1/unit = 100,
# 10% Tax = 10,
# $15 for Meter Charge = 15,
# Electricity Bill = 100 + 10 + 15

electricity_bill(225) ➞ 427.5
# 100 units at $1/unit = 100, 100 units at $2/unit = 200, 25 units at $3/unit = 75
# 10% Tax = 37.5,
# 15$ for Meter Charge = 15,
# Electricity Bill = 100 + 200 + 75 + 22.5 + 15 = 427.50

electricity_bill(300) ➞ 675
# 100 units at $1/unit = 100, 100 units at $2/unit = 200, 100 units at $3/unit = 300
# 10% Tax = 60,
# 15$ for Meter Charge = 15,
# Electricity Bill = 100 + 200 + 300 + 60 + 15 = 675
Notes
Return final calculated Electricity Bill rounded up to two decimal places.:def electricity_bill(units):
    rates = [1, 2, 3, 4]
    amounts = [100, 100, 100, 200]
    bill = 0
    for i in range(4):
        if units >= amounts[i]:
            bill += amounts[i] * rates[i]
            units -= amounts[i]
        else:
            bill += units * rates[i]
            units = 0
    bill += units * 5
    bill *= 1.1
    return round(bill + 15.004, 2)<|endoftext|>"
43,"<|endoftext|>Recursion:

Recursion is a functional technique to problem-solving that involves breaking an issue down into a series of small subproblems with an identical pattern and solving them sequentially by calling one subproblem within another. Recursion is carried out by defining a function capable of solving one subproblem at a time. It calls itself but solves another subproblem somewhere inside that method. As a result, the call to itself continues until some limiting requirements are met.

The main program’s first call to a recursive function will be returned only after all sub calls have completed. As a result, Python keeps the results of all subproblems in temporary memory, does some arithmetic operations (if necessary), and releases the memory at the end of the recursion.

Lists in Python:

A list is a built-in Python data structure that stores a collection of things. Lists have a number of key features:

Items in a list are enclosed in square brackets, as in [item1, item2, item3].
Lists are ordered, which means that the items in the list appear in a particular order. This allows us to use an index to find any object.
Lists are mutable, which means they can be added or removed once they are created.
List elements do not have to be distinct. Item duplication is possible since each element has its own individual address and may be accessed independently via the index.
Elements can be of many data types: strings, numbers, and objects can all be combined in the same list.
Given a list, the task is to calculate the length of the given list recursively in Python

Examples:

Example1:

Input:

given list = [929, 138, 3, 193, 11, 1, 2, 3, 41, 132, 56, 11, 917, 212, 455, 2235, 1, 1, 2, 3]
Output:

The given list is :
[929, 138, 3, 193, 11, 1, 2, 3, 41, 132, 56, 11, 917, 212, 455, 2235, 1, 1, 2, 3]
The length of the given list =  20:# function which accepts the list as argument and
# calculates the length of the given list and return it


def listlengthRecursion(given_list):
  # Put a condition in the method that says if it
  # isn't the original list, it should return 0.
    if not given_list:
        return 0
    # Otherwise, execute the function recursively to determine the length of the list.
    return 1 + listlengthRecursion(given_list[1::2]) + listlengthRecursion(given_list[2::2])


# Give the list input as static input and store it in a variable.
given_list = [929, 138, 3, 193, 11, 1, 2, 3, 41,
              132, 56, 11, 917, 212, 455, 2235, 1, 1, 2, 3]
# printing the given list
print('The given list is :')
print(given_list)
# Pass the given list as an argument to the recursive function which
# calculates the length of the given list and returns it.
print(""The length of the given list = "", listlengthRecursion(given_list))<|endoftext|>"
44,"<|endoftext|>The following are the common definitions of Binomial Coefficients. 

A binomial coefficient C(n, k) can be defined as the coefficient of x^k in the expansion of (1 + x)^n.



A binomial coefficient C(n, k) also gives the number of ways, disregarding order, that k objects can be chosen from among n objects more formally, the number of k-element subsets (or k-combinations) of a n-element set.:# A Dynamic Programming based Python
# Program that uses table C[][]
# to calculate the Binomial Coefficient

# Returns value of Binomial Coefficient C(n, k)


def binomialCoef(n, k):
	C = [[0 for x in range(k+1)] for x in range(n+1)]

	# Calculate value of Binomial
	# Coefficient in bottom up manner
	for i in range(n+1):
		for j in range(min(i, k)+1):
			# Base Cases
			if j == 0 or j == i:
				C[i][j] = 1

			# Calculate value using
			# previously stored values
			else:
				C[i][j] = C[i-1][j-1] + C[i-1][j]

	return C[n][k]


# Driver program to test above function
n = 5
k = 2
print(""Value of C["" + str(n) + ""]["" + str(k) + ""] is ""
	+ str(binomialCoef(n, k)))

# This code is contributed by Bhavya Jain<|endoftext|>"
45,"<|endoftext|>Left-Right representation of a binary tree is standard representation where every node has a pointer to left child and another pointer to right child.
Down-Right representation is an alternate representation where every node has a pointer to left (or first) child and another pointer to next sibling. So siblings at every level are connected from left to right.
Given a binary tree in left-right representation as below 

                               1
                    /    \
                   2      3
                   /    \
                   4      5
                     /     /   \
                    6    7      8 
Convert the structure of the tree to down-right representation like the below tree. 

            1
            |
            2 – 3
                |
                4 — 5
                |   |
                6   7 – 8 :# Python3 program to convert left-right to
# down-right representation of binary tree

# Helper function that allocates a new
# node with the given data and None
# left and right pointers.									
class newNode:

	# Construct to create a new node
	def __init__(self, key):
		self.key = key
		self.left = None
		self.right = None

# An Iterative level order traversal based
# function to convert left-right to down-right
# representation.
def convert(root):

	# Base Case
	if (root == None):
		return

	# Recursively convert left an
	# right subtrees
	convert(root.left)
	convert(root.right)

	# If left child is None, make right
	# child as left as it is the first child.
	if (root.left == None):
		root.left = root.right

	# If left child is NOT None, then make
	# right child as right of left child
	else:
		root.left.right = root.right

	# Set root's right as None
	root.right = None

# A utility function to traverse a
# tree stored in down-right form.
def downRightTraversal(root):

	if (root != None):
	
		print( root.key, end = "" "")
		downRightTraversal(root.right)
		downRightTraversal(root.left)

# Driver Code
if __name__ == '__main__':
	
	# Let us create binary tree shown
	# in above diagram
	""""""
		1
		/ \
		2	 3
			/ \
			4 5
		/ / \
		6 7 8
	""""""
	root = newNode(1)
	root.left = newNode(2)
	root.right = newNode(3)
	root.right.left = newNode(4)
	root.right.right = newNode(5)
	root.right.left.left = newNode(6)
	root.right.right.left = newNode(7)
	root.right.right.right = newNode(8)

	convert(root)
	
	print(""Traversal of the tree converted"",
					""to down-right form"")
	downRightTraversal(root)

# This code is contributed by
# Shubham Singh(SHUBHAMSINGH10)
<|endoftext|>"
46,"<|endoftext|>Given two four digit prime numbers, suppose 1033 and 8179, we need to find the shortest path from 1033 to 8179 by altering only single digit at a time such that every number that we get after changing a digit is prime. For example a solution is 1033, 1733, 3733, 3739, 3779, 8779, 8179:# Python3 program to reach a prime number 
# from another by changing single digits  
# and using only prime numbers.
import queue 
  
class Graph: 
      
    def __init__(self, V):
        self.V = V; 
        self.l = [[] for i in range(V)]
          
    def addedge(self, V1, V2):
        self.l[V1].append(V2); 
        self.l[V2].append(V1);
  
    # in1 and in2 are two vertices of graph  
    # which are actually indexes in pset[] 
    def bfs(self, in1, in2):
        visited = [0] * self.V
        que = queue.Queue()
        visited[in1] = 1
        que.put(in1)
        while (not que.empty()): 
            p = que.queue[0] 
            que.get()
            i = 0
            while i < len(self.l[p]):
                if (not visited[self.l[p][i]]):
                    visited[self.l[p][i]] = visited[p] + 1
                    que.put(self.l[p][i])
                if (self.l[p][i] == in2):
                    return visited[self.l[p][i]] - 1
                i += 1
      
    # Returns true if num1 and num2 
    # differ by single digit.
      
# Finding all 4 digit prime numbers 
def SieveOfEratosthenes(v):
      
    # Create a boolean array ""prime[0..n]"" and  
    # initialize all entries it as true. A value 
    # in prime[i] will finally be false if i is 
    # Not a prime, else true. 
    n = 9999
    prime = [True] * (n + 1)
  
    p = 2
    while p * p <= n:
  
        # If prime[p] is not changed, 
        # then it is a prime 
        if (prime[p] == True):
  
            # Update all multiples of p
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
  
    # Forming a vector of prime numbers
    for p in range(1000, n + 1):
        if (prime[p]): 
            v.append(p)
      
def compare(num1, num2):
      
    # To compare the digits 
    s1 = str(num1) 
    s2 = str(num2)
    c = 0
    if (s1[0] != s2[0]):
        c += 1
    if (s1[1] != s2[1]):
        c += 1
    if (s1[2] != s2[2]):
        c += 1
    if (s1[3] != s2[3]): 
        c += 1
  
    # If the numbers differ only by a single 
    # digit return true else false 
    return (c == 1)
      
def shortestPath(num1, num2):
      
    # Generate all 4 digit 
    pset = [] 
    SieveOfEratosthenes(pset) 
  
    # Create a graph where node numbers 
    # are indexes in pset[] and there is 
    # an edge between two nodes only if 
    # they differ by single digit. 
    g = Graph(len(pset))
    for i in range(len(pset)):
        for j in range(i + 1, len(pset)):
            if (compare(pset[i], pset[j])): 
                g.addedge(i, j)     
  
    # Since graph nodes represent indexes 
    # of numbers in pset[], we find indexes
    # of num1 and num2. 
    in1, in2 = None, None
    for j in range(len(pset)):
        if (pset[j] == num1):
            in1 = j
    for j in range(len(pset)):
        if (pset[j] == num2): 
            in2 = j
  
    return g.bfs(in1, in2)
  
# Driver code 
if __name__ == '__main__':
  
    num1 = 1033
    num2 = 8179
    print(shortestPath(num1, num2))
  
# This code is contributed by PranchalK
<|endoftext|>"
47,"<|endoftext|>Files in Python:

Python file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python’s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.

Given a file, the task is to count the number of uppercase, lowercase, spaces in a given file in Python.:# Initialize all the uppercase, lowercase, digits, spaces, special characters count to zero.
uppr_cnt = lwr_cnt = dig_cnt = space_cnt = spclchrs_cnt = 0
# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Pass the given filename, r (represents read-only mode) as arguments to the open() function
# to open the given file
file = open(givenFilename, ""r"")
# Iterate in the above text of the file using the for loop
for line in file:
  # Iterate in the characters of the line using nested for loop
  for charactrs in line:
  # Check if the ASCII value of character is greater than or equal to 'A' and less than or equal to 'Z'
  # using the if conditional statement.
  if charactrs >= 'A' and charactrs <= 'Z':
  # If it is true then increment the uppercase count value by 1
  uppr_cnt = uppr_cnt+1
  # Check if the ASCII value of character is greater than or equal to 'a' and less than or equal to 'z'
  # using the elif conditional statement.
  elif charactrs >= 'a' and charactrs <= 'z':
  # If it is true then increment the lowercase count value by 1
  lwr_cnt = lwr_cnt+1
  # Check if the character is greater than 0 and less than or equal to '9'
  # using the elif conditional statement.
  elif charactrs > '0' and charactrs <= '9':
  # If it is true then increment the digit count value by 1
  dig_cnt = dig_cnt+1
  # Check if the character is equal to space(' ')
  # using the elif conditional statement.
  elif charactrs == ' ':
  # If it is true then increment the spaces count value by 1
  space_cnt = space_cnt+1
  else:
  # Else increment the special characters count value by 1
  spclchrs_cnt = spclchrs_cnt+1
# Print the number of uppercase characters in a given file  
print(""The number of uppercase characters ="", uppr_cnt)
# Print the number of lowercase characters in a given file  
print(""The number of lowercase characters ="", lwr_cnt)
# Print the number of digits in a given file 
print(""The number of digits in a given file ="", dig_cnt)
# Print the number of spaces in a given file 
print(""The number of spaces in a given file ="", space_cnt)
# Print the number of special characters in a given file
print(""The number of special characters in a given file="", spclchrs_cnt)<|endoftext|>"
48,"<|endoftext|>A vertex cover of an undirected graph is a subset of its vertices such that for every edge (u, v) of the graph, either ‘u’ or ‘v’ is in vertex cover.
Although the name is Vertex Cover, the set covers all edges of the given graph. :# A naive recursive Python3 implementation
# for vertex cover problem for a tree
 
# A utility function to find min of two integers
 
# A binary tree node has data, pointer to
# left child and a pointer to right child
class Node:
     
    def __init__(self, x):
         
        self.data = x
        self.left = None
        self.right = None
 
# The function returns size of
# the minimum vertex cover
def vCover(root):
     
    # The size of minimum vertex cover
    # is zero if tree is empty or there
    # is only one node
    if (root == None):
        return 0
         
    if (root.left == None and
       root.right == None):
        return 0
 
    # Calculate size of vertex cover when
    # root is part of it
    size_incl = (1 + vCover(root.left) +
                     vCover(root.right))
 
    # Calculate size of vertex cover
    # when root is not part of it
    size_excl = 0
    if (root.left):
      size_excl += (1 + vCover(root.left.left) +
                        vCover(root.left.right))
    if (root.right):
      size_excl += (1 + vCover(root.right.left) +
                        vCover(root.right.right))
 
    # Return the minimum of two sizes
    return min(size_incl, size_excl)
 
# Driver Code
if __name__ == '__main__':
     
    # Let us construct the tree
    # given in the above diagram
    root  = Node(20)
    root.left = Node(8)
    root.left.left = Node(4)
    root.left.right = Node(12)
    root.left.right.left = Node(10)
    root.left.right.right = Node(14)
    root.right  = Node(22)
    root.right.right = Node(25)
 
    print(""Size of the smallest vertex cover is"", vCover(root))
 
# This code is contributed by mohit kumar 29<|endoftext|>"
49,"<|endoftext|>Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant.

One room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.

Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.

Return the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.:class Solution:
    def numberOfWays(self, corridor: str) -> int:
        count=0
        a=0
        ans=1
        countseat=0
        for item in corridor:
            if item==""S"":
                countseat+=1
        if countseat==0 or countseat%2!=0:
            return 0
        for item in corridor:
            if item==""S"":
                countseat-=1
                count+=1
            if countseat==0:
                return ans
            if count>2:
                count=1
                ans*=a
                ans%=(10**9+7)
                a=0
            if count==2:
                a+=1
        return ans<|endoftext|>"
50,"<|endoftext|>For each challenge of this series you do not need to submit a function. Instead, you need to submit a formatted template string to get a certain outcome.
Write a template string according to the following example:
Example
template = ""yourtemplatestringhere""
template.format(""name"", me = ""John"", him = ""Joe"") ➞ ""My name is John. His name is Joe.""
Tips
You can pass keyword arguments to .format() that can then be accessed by placing the key inside a place holder.
For example:
""I'm {age} years old."".format(age = 30) ➞ ""I'm 30 years old.""
Notes
Submit a string, not a function.
Do not change the name of the variable template.
You can find all the exercises in this series over here.:template = ""My {0} is {me}. His {0} is {him}.""<|endoftext|>"
51,"<|endoftext|>In the previous article, we have discussed Python Program to Find the First Small Letter in a Given String
 Given two numbers and the task is to find the sum of the given two numbers using recursion.
 Recursion:
 Recursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.
 Examples:
 Example1:
 Input:
 Given First Number = 3
 
 Given Second Number = 0
 Output:
 The sum of { 3 } and { 0 } using recursion = 3
 Example2:
 Input:
 Given First Number = 20
 
 Given Second Number = 30
 Output:
 The sum of { 20 } and { 30 } using recursion = 50:# Create a recursive function to say recur_sum which takes the two numbers as arguments
 
 # and returns the sum of the given two numbers using recursion.
 
 
 
 
 
 def recur_sum(fst_numb, secnd_numb):
 
  # Check if the second number is equal to 0 using the if conditional statement.
 
  if secnd_numb == 0:
 
  # If the statement is true, return the first number.
 
  return fst_numb
 
  # Else return (fst_numb, secnd_numb-1)+1 {Recursive logic}
 
  return recur_sum(fst_numb, secnd_numb-1)+1
 
 
 
 
 
 # Give the first number as static input and store it in a variable.
 
 fst_numb = 3
 
 # Give the second number as static input and store it in another variable.
 
 secnd_numb = 0
 
 #Pass the given two numbers as the arguments to recur_sum function
 
 print(""The sum of {"", fst_numb, ""} and {"", secnd_numb,
 
  ""} using recursion ="", recur_sum(fst_numb, secnd_numb))<|endoftext|>"
52,"<|endoftext|>You are given a function foo() that represents a biased coin. When foo() is called, it returns 0 with 60% probability, and 1 with 40% probability. Write a new function that returns 0 and 1 with a 50% probability each. Your function should use only foo(), no other library method.

Solution: 
We know foo() returns 0 with 60% probability. How can we ensure that 0 and 1 are returned with a 50% probability? 
The solution is similar to this post. If we can somehow get two cases with equal probability, then we are done. We call foo() two times. Both calls will return 0 with a 60% probability. So the two pairs (0, 1) and (1, 0) will be generated with equal probability from two calls of foo(). Let us see how.
(0, 1): The probability to get 0 followed by 1 from two calls of foo() = 0.6 * 0.4 = 0.24 
(1, 0): The probability to get 1 followed by 0 from two calls of foo() = 0.4 * 0.6 = 0.24
So the two cases appear with equal probability. The idea is to return consider only the above two cases, return 0 in one case, return 1 in other case. For other cases [(0, 0) and (1, 1)], recur until you end up in any of the above two cases. :# Python3 program for the
# above approach
def foo():

	# Some code here
	pass

# Returns both 0 and 1
# with 50% probability
def my_fun():

	val1, val2 = foo(), foo()
	
	if val1 ^ val2:
	
		# Will reach here with
		# (0.24 + 0.24) probability
		return val1
	
	# Will reach here with
	# (1 - 0.24 - 0.24) probability
	return my_fun()

# Driver Code
if __name__ == '__main__':
	print(my_fun())

# This code is contributed by sgshah2<|endoftext|>"
53,"<|endoftext|>In the previous article, we have discussed Python Program to Print Series 1, 3, 7, 15, 31 … N
 Given a number N and the task is to print the series (1, -2, 6, -15, 31 … N) till the given number N in Python.
 Examples:
 Example1:
 Input:
 Given Number (Limit) = 8
 Output:
 The above series till the given number{ 8 } is :
 
 1 -2 6 -15 31 -56 92 -141
 Example2:
 Input:
 Given Number (Limit) = 11
 Output:
 The above series till the given number{ 11 } is :
 
 1 -2 6 -15 31 -56 92 -141 205 -286 386:# Give the number N (Limit) as static input and store it in a variable.
 
 gvn_numb = 8
 
 # Take a variable to say itr and initialize its value to 1.
 
 itr = 1
 
 # Take another variable say previous_val and initialize its value to 1.
 
 previous_val = 1
 
 print(""The above series till the given number{"", gvn_numb, ""} is :"")
 
 # Loop until the above-declared variable itr value is less than or equal to the
 
 # given number using the while loop.
 
 while itr &lt;= gvn_numb:
 
  # Inside the loop, check if the above itr value is even or not using the if
 
  # conditional statement.
 
  if(itr % 2 == 0):
 
  # If it is true, then print the value of above previous_val multiplied with -1
 
  # separated by spaces.
 
  print(-1*previous_val, end="" "")
 
  else:
 
  # Else, Print the value of the above previous_val separated by spaces.
 
  print(previous_val, end="" "")
 
  # Calculate the value of itr raised to power 2 using the pow() function and
 
  # add it to the previous_val.
 
  # Store it in the same variable previous_val.
 
  previous_val += pow(itr, 2)
 
  # Increment the above itr value by 1.
 
  itr += 1
 
 </pre><|endoftext|>"
54,"<|endoftext|>You are given a square matrix (matrix[][]) of order n, where matrix[i][j] = i*j. Find the number of cells which have entry equal to a given number x. 
NOte : Indexing of matrix starts from 1, i.e. 1<= i,j <= n. 
Examples : 
 

Input : matrix[][] = {1, 2, 3, 4,
                      2, 4, 6, 8,
                      3, 6, 9, 12,
                      4, 8, 12, 16}  
                x = 4
Output : 3

Input : matrix[][] = {1, 2, 3, 4,
                      2, 4, 6, 8,
                      3, 6, 9, 12,
                      4, 8, 12, 16}   
                 x = 12
Output : 2

 :# Python 3 program for counting
# number of cell equals to given x
 
# function to count factors
# as number of cell
def count(n, x):
    cnt = 0
 
    # traverse and find the factors
    for i in range(1, n + 1):
 
        # // x%i == 0 means i is factor of x
        # x/i <= n means i and j are <= n (for i*j=x)
        if i <= x:
            if x // i <= n and x % i == 0:
                cnt += 1
    return cnt
 
# Driver code
n = 8
x = 24
print(count(n, x))
 
# This code is contributed by Shrikant13
<|endoftext|>"
55,"<|endoftext|>Given a graph and a source vertex in the graph, find the shortest paths from the source to all vertices in the given graph.
Dijkstra’s algorithm is very similar to Prim’s algorithm for minimum spanning tree. Like Prim’s MST, we generate a SPT (shortest path tree) with a given source as a root. We maintain two sets, one set contains vertices included in the shortest-path tree, other set includes vertices not yet included in the shortest-path tree. At every step of the algorithm, we find a vertex that is in the other set (set of not yet included) and has a minimum distance from the source.
Below are the detailed steps used in Dijkstra’s algorithm to find the shortest path from a single source vertex to all other vertices in the given graph. 

Algorithm 
1) Create a set sptSet (shortest path tree set) that keeps track of vertices included in the shortest-path tree, i.e., whose minimum distance from the source is calculated and finalized. Initially, this set is empty. 
2) Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE. Assign distance value as 0 for the source vertex so that it is picked first. 
3) While sptSet doesn’t include all vertices 
….a) Pick a vertex u which is not there in sptSet and has a minimum distance value. 
….b) Include u to sptSet. 
….c) Update distance value of all adjacent vertices of u. To update the distance values, iterate through all adjacent vertices. For every adjacent vertex v, if the sum of distance value of u (from source) and weight of edge u-v, is less than the distance value of v, then update the distance value of v. :# Python program for Dijkstra's single
# source shortest path algorithm. The program is
# for adjacency matrix representation of the graph

# Library for INT_MAX
import sys

class Graph():

	def __init__(self, vertices):
		self.V = vertices
		self.graph = [[0 for column in range(vertices)]
					for row in range(vertices)]

	def printSolution(self, dist):
		print(""Vertex \tDistance from Source"")
		for node in range(self.V):
			print(node, ""\t"", dist[node])

	# A utility function to find the vertex with
	# minimum distance value, from the set of vertices
	# not yet included in shortest path tree
	def minDistance(self, dist, sptSet):

		# Initialize minimum distance for next node
		min = sys.maxsize

		# Search not nearest vertex not in the
		# shortest path tree
		for u in range(self.V):
			if dist[u] < min and sptSet[u] == False:
				min = dist[u]
				min_index = u

		return min_index

	# Function that implements Dijkstra's single source
	# shortest path algorithm for a graph represented
	# using adjacency matrix representation
	def dijkstra(self, src):

		dist = [sys.maxsize] * self.V
		dist[src] = 0
		sptSet = [False] * self.V

		for cout in range(self.V):

			# Pick the minimum distance vertex from
			# the set of vertices not yet processed.
			# x is always equal to src in first iteration
			x = self.minDistance(dist, sptSet)

			# Put the minimum distance vertex in the
			# shortest path tree
			sptSet[x] = True

			# Update dist value of the adjacent vertices
			# of the picked vertex only if the current
			# distance is greater than new distance and
			# the vertex in not in the shortest path tree
			for y in range(self.V):
				if self.graph[x][y] > 0 and sptSet[y] == False and \
				dist[y] > dist[x] + self.graph[x][y]:
						dist[y] = dist[x] + self.graph[x][y]

		self.printSolution(dist)

# Driver program
g = Graph(9)
g.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0],
		[4, 0, 8, 0, 0, 0, 0, 11, 0],
		[0, 8, 0, 7, 0, 4, 0, 0, 2],
		[0, 0, 7, 0, 9, 14, 0, 0, 0],
		[0, 0, 0, 9, 0, 10, 0, 0, 0],
		[0, 0, 4, 14, 10, 0, 2, 0, 0],
		[0, 0, 0, 0, 0, 2, 0, 1, 6],
		[8, 11, 0, 0, 0, 0, 1, 0, 7],
		[0, 0, 2, 0, 0, 0, 6, 7, 0]
		];

g.dijkstra(0);

# This code is contributed by Divyanshu Mehta and Updated by Pranav Singh Sambyal<|endoftext|>"
56,"<|endoftext|>You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers:

You should build the array arr which has the following properties:

arr has exactly n integers.
1 <= arr[i] <= m where (0 <= i < n).
After applying the mentioned algorithm to arr, the value search_cost is equal to k.

Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7.
 
Example 1:

Input: n = 2, m = 3, k = 1
Output: 6
Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]

Example 2:

Input: n = 5, m = 2, k = 3
Output: 0
Explanation: There are no possible arrays that satisify the mentioned conditions.

Example 3:

Input: n = 9, m = 1, k = 1
Output: 1
Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]

 
Constraints:

1 <= n <= 50
1 <= m <= 100
0 <= k <= n:class Solution:
  def numOfArrays(self, N: int, M: int, K: int) -> int:
  dp = [[[0 for _ in range(M + 1)] for _ in range(K + 1)] for _ in range(N + 1)]
  # the array has length of 1, and 1 jump, only 1 way to do that, for any k
  for k in range(1, M + 1):
  dp[1][1][k] = 1
  
  for i, j, k in itertools.product(range(1, N + 1), range(1, K + 1), range(M + 1)):
  dp[i][j][k] += dp[i - 1][j][k] * k
  dp[i][j][k] += sum(dp[i - 1][j - 1][1:k])
  
  return sum(dp[N][K][1:]) % (10 ** 9 + 7)<|endoftext|>"
57,"<|endoftext|>Create a function that returns the majority vote in a list. A majority vote is an element that occurs > N/2 times in a list (where N is the length of the list).
Examples
majority_vote([""A"", ""A"", ""B""]) ➞ ""A""

majority_vote([""A"", ""A"", ""A"", ""B"", ""C"", ""A""]) ➞ ""A""

majority_vote([""A"", ""B"", ""B"", ""A"", ""C"", ""C""]) ➞ None
Notes
The frequency of the majority element must be strictly greater than 1/2.
If there is no majority element, return None.
If the list is empty, return None.:def majority_vote(lst): 
  for i in set(lst):
    if lst.count(i)>len(lst)//2:
      return i
  return None<|endoftext|>"
58,"<|endoftext|>Your task is to create a Circle constructor that creates a circle with a radius provided by an argument. The circles constructed must have two getters getArea() (PI*r^2) and getPerimeter() (2*PI*r) which give both respective areas and perimeter (circumference).
For help with this class, I have provided you with a Rectangle constructor which you can use as a base example.
Examples
circy = Circle(11)
circy.getArea()

# Should return 380.132711084365

circy = Circle(4.44)
circy.getPerimeter()

# Should return 27.897342763877365
Notes
Round results up to the nearest integer.:from math import pi
class Circle(object):
  def __init__(self, radius):
    self.radius = radius
  def getArea(self):
    return round(pi * self.radius**2) # round because of error in test
  def getPerimeter(self):
    return round(2 * pi * self.radius)<|endoftext|>"
59,"<|endoftext|>Write a Python Program to Print 1 and 0 in alternative Columns using While Loop and For Loop with an example:# Python Program to Print 1 and 0 in alternative Columns
 
rows = int(input(""Please Enter the total Number of Rows  : ""))
columns = int(input(""Please Enter the total Number of Columns  : ""))

print(""Print Number Pattern - 1 and 0 in alternative Columns"") 
 
for i in range(1, rows + 1):
    for j in range(1, columns + 1):
        if(j % 2 == 0):          
            print('0', end = '  ')
        else:
            print('1', end = '  ')
    print()<|endoftext|>"
60,"<|endoftext|>Boston Housing Data: This dataset was taken from the StatLib library and is maintained by Carnegie Mellon University. This dataset concerns the housing prices in the housing city of Boston. The dataset provided has 506 instances with 13 features.:# Importing Libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Importing Data
from sklearn.datasets import load_boston
boston = load_boston()
data = pd.DataFrame(boston.data)
data.columns = boston.feature_names

data.head(10)
data['Price'] = boston.target
data.head()
# Input Data
x = boston.data

# Output Data
y = boston.target


# splitting data to training and testing dataset.

#from sklearn.cross_validation import train_test_split
#the submodule cross_validation is renamed and reprecated to model_selection
from sklearn.model_selection import train_test_split

xtrain, xtest, ytrain, ytest = train_test_split(x, y, test_size =0.2,
													random_state = 0)

print(""xtrain shape : "", xtrain.shape)
print(""xtest shape : "", xtest.shape)
print(""ytrain shape : "", ytrain.shape)
print(""ytest shape : "", ytest.shape)
# Fitting Multi Linear regression model to training model
from sklearn.linear_model import LinearRegression
regressor = LinearRegression()
regressor.fit(xtrain, ytrain)

# predicting the test set results
y_pred = regressor.predict(xtest)
# Plotting Scatter graph to show the prediction
# results - 'ytrue' value vs 'y_pred' value
plt.scatter(ytest, y_pred, c = 'green')
plt.xlabel(""Price: in $1000's"")
plt.ylabel(""Predicted value"")
plt.title(""True value vs predicted value : Linear Regression"")
plt.show()
# Results of Linear Regression.
from sklearn.metrics import mean_squared_error
mse = mean_squared_error(ytest, y_pred)
print(""Mean Square Error : "", mse)
<|endoftext|>"
61,"<|endoftext|>Given two sentences, return whether they are shadows of each other. This means that all of the word lengths are the same, but the corresponding words don't share any common letters.
Examples
shadow_sentence(""they are round"", ""fold two times"") ➞ True

shadow_sentence(""own a boat"", ""buy my wine"") ➞ False
# No words share common letters, but ""a"" and ""my"" have different lengths.

shadow_sentence(""his friends"", ""our company"") ➞ False
# Word lengths are the same but ""friends"" and ""company"" share the letter ""n"".

shadow_sentence(""salmonella supper"", ""birthright"") ➞ False
# Setences with different numbers of words.
Notes
All sentences will be given in lowercase, and will have no punctuation.
Return False if the sentences have different numbers of words.:def shadow_sentence(a, b):
  A=a.split()
  B=b.split()
  return  len(A)==len(B) and all(len(A[i])==len(B[i]) and set(A[i])&set(B[i])==set() for i in range(len(A)))<|endoftext|>"
62,"<|endoftext|>Files in Python:

Files are identified locations on the disc where associated data is stored. They’re used to keep data in non-volatile memory for a long time (e.g. hard disk).

We use files for future usage of the data by permanently saving it because Random Access Memory (RAM) is volatile (it loses its contents when the machine is turned off).



We must first open a file before we can read from or write to it. When we’re finished, it needs to be closed so that the file’s resources may be released.

As a result, a file operation in Python is performed in the following order:

Create a new file
You can either read or write (perform the operations)
Close the file.

Given a file, the task is to merge given two files into a third file in Python:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
gvn_fstfile = ""samplefile_1.txt""
# Open the first file in read-only mode. In this case, we're simply reading the contents of the file.
with open(gvn_fstfile, 'r') as givenfilecontent:
  # Read the above file using the read() function(get the content) and store it in a variable
  fst_file = givenfilecontent.read() 
# Make another variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
gvn_scndfile = ""samplefile_2.txt""
# Open the second file in read-only mode. In this case, we're simply reading the contents of the file.
with open(gvn_scndfile, 'r') as givenfilecontent:
  # Read the above file using the read() function(get the content) and store it in a variable
  scnd_file = givenfilecontent.read() 
# Add nextline to the above first file.
fst_file += ""\n""
# Add or concatenate both the first and the second files data and store it into a first file
fst_file += scnd_file 
# Make another variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
mergedFile = 'mergedfile.txt'
# Open the merged file in write mode. In this case, we're writing the contents into the file.
with open(mergedFile, 'w') as merged_File:
  # Write the data of the firstfile(concatenation of both first and second files)
  # into the merged file using the write() function.
  merged_File.write(fst_file)
# Close the merged file using the close() function
merged_File.close()<|endoftext|>"
63,"<|endoftext|>Given the radius and height of the cylinder, and the task is to calculate the surface area and volume of the given cylinder. A cylinder is a closed geometrical solid shape with two parallel bases joined by a curved surface.
The bases are circular in shape.
The following is the formula for calculating:
The area of a cylinder = 2πr(r+h)
The volume of a cylinder = πr²h, where  r = radius of the base circle, h = height of the curved surface
:# Import math module using the import keyword.
import math
# Give the radius as user input using the float(input())function and store it in a variable.
gvn_radius = float(input(""Enter some random number = ""))
# Give the height as user input using the float(input())function store it in another variable.
gvn_heigt = float(input(""Enter some random number = ""))
# Calculate the surface area of the given cylinder using the above given mathematical
# formula, math.pi () method and store it in another variable.
surfc_area = 2*math.pi*pow(gvn_radius, 2)*gvn_heigt
# Calculate the volume of the given cylinder using the above given mathematical formula,
# math.pi () method and store it in another variable.
vol = math.pi*pow(gvn_radius, 2)*gvn_heigt
# Print the surface area of the given cylinder.
print(""The surface area of a given cylinder ="", surfc_area)
# Print the volume of the given cylinder.
print(""The volume of a given cylinder ="", vol)<|endoftext|>"
64,"<|endoftext|>You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.

 

Example 1:


Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
Example 2:

Input: height = [1,1]
Output: 1
 

Constraints:

n == height.length
2 <= n <= 105
0 <= height[i] <= 104:class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r, area = 0, len(height) - 1, 0
        while l < r:
            area = max(area, (r - l) * min(height[l], height[r]))
            if height[l] < height[r]:
                                l += 1
            else:
                                r -= 1
                                
        return area<|endoftext|>"
65,"<|endoftext|>Create a function that checks if the given arguments are of the same type. Return True if they are and False if they're not.
Examples
compare_data(1, 6, 5, 3, 7, 9) ➞ True

compare_data(1, 6, 5, 3, ""7"", 9) ➞ False

compare_data([]) ➞ True

compare_data([1], (1)) ➞ False
Notes
If no input is given or only one input, return True.
Use the (*args) construct to enter an undefined number of function arguments.:def compare_data(*args):
    return len(set(type(i) for i in args)) == 1 if args else True<|endoftext|>"
66,"<|endoftext|>User Input: Print first letter of each word in Capital, separated by Full Stops:# Give the sentence/string as user input using the input() function
# and store it in a variable.
gvnstrng = input('Enter some random string/sentence = ')
# Split the sentence into a list of words using the built-in spit() function.
gvnstrngwords = gvnstrng.split()
# Take an empty string to say resultstrng and initialize with the null value using """".
resultstrng = """"
# Traverse in this list of words using the For loop.
for strngword in gvnstrngwords:
        # Check if the word is alphabet or not using the If statement and isalpha() function
    if(strngword.isalpha()):
                # If it is true then, Convert the first letter of the word of
        # the string to the upper using the upper function and store it in a variable.
        firstchar = strngword[0].upper()
        # Concatenate dot character to the above variable using string concatenation.
        firstchar = firstchar+"".""
        # Add this result to resultstrng using string concatenation.
        resultstrng = resultstrng+firstchar

# Print resultstrng.
print(resultstrng)<|endoftext|>"
67,"<|endoftext|>In the previous article, we have discussed Python Program to Find Leaders in an Array/List
 Given a string and the task is to count all the Non-palindromic words in a given sentence.
 Palindrome:
 If the reverse of a string is the same as the string, it is said to be a palindrome.
 Example :
 Given string = “sos asked to bring the madam “.
 Output :
 Explanation: In this “madam”, “sos” are the palindromic words. By sorting them we get {“madam”,”sos”}
 Examples:
 Example1:
 Input:
 Given String = ""dad and mom both ordered to bring sos in malayalam""
 Output:
 The count of all the Non-palindromic words in a given sentence = 6
 Example2:
 Input:
 Given String = ""My mom and dad treats me in equal level""
 Output:
 The count of all the Non-palindromic words in a given sentence = 6:# Give the string as static input and store it in a variable.
 
 gvn_str = ""dad and mom both ordered to bring sos in malayalam""
 
 # Take an empty list and store it in another variable.
 
 lst = []
 
 # Split the given string using the split() function and store it in another variable.
 
 splt_str = gvn_str.split()
 
 # Loop in the above-obtained split list of words using the for loop.
 
 for wrd in splt_str:
 
  # Check if the iterator value is not equal to the reverse of the iterator value using
 
  # the if conditional statement.
 
  if wrd != wrd[::-1]:
 
  # If the statement is true, then append the respective iterator value to the
 
  # above initialized empty list using the append() method.
 
  lst.append(wrd)
 
 # Calculate the length above initialized list ""lst"" using the len() function
 
 # and store it in a variable.
 
 # Print the count of all the Non-palindromic words in a given sentence.
 
 count = len(lst)
 
 # Print the count of all the Non-palindromic words in a given sentence.
 
 print(""The count of all the Non-palindromic words in a given sentence ="", count)
 
 </pre><|endoftext|>"
68,"<|endoftext|>A stack permutation is a permutation of objects in the given input queue which is done by transferring elements from input queue to the output queue with the help of a stack and the built-in push and pop functions.
The well defined rules are: 
 

Only dequeue from the input queue.
Use inbuilt push, pop functions in the single stack.
Stack and input queue must be empty at the end.
Only enqueue to the output queue.
There are a huge number of permutations possible using a stack for a single input queue. 
Given two arrays, both of unique elements. One represents the input queue and the other represents the output queue. Our task is to check if the given output is possible through stack permutation.:# Given two arrays, check if one array is
# stack permutation of other.
from queue import Queue

# function to check if Input queue
# is permutable to output queue
def checkStackPermutation(ip, op, n):
	
	# Input queue
	Input = Queue()
	for i in range(n):
		Input.put(ip[i])

	# output queue
	output = Queue()
	for i in range(n):
		output.put(op[i])

	# stack to be used for permutation
	tempStack = []
	while (not Input.empty()):
		ele = Input.queue[0]
		Input.get()
		if (ele == output.queue[0]):
			output.get()
			while (len(tempStack) != 0):
				if (tempStack[-1] == output.queue[0]):
					tempStack.pop()
					output.get()
				else:
					break
		else:
			tempStack.append(ele)

	# If after processing, both Input
	# queue and stack are empty then
	# the Input queue is permutable
	# otherwise not.
	return (Input.empty() and
		len(tempStack) == 0)

# Driver Code
if __name__ == '__main__':

	# Input Queue
	Input = [1, 2, 3]

	# Output Queue
	output = [2, 1, 3]

	n = 3

	if (checkStackPermutation(Input,
							output, n)):
		print(""Yes"")
	else:
		print(""Not Possible"")

# This code is contributed by PranchalK<|endoftext|>"
69,"<|endoftext|>Files in Python:

Python, like many other programming languages, offers file handling and allows users to read and write files, as well as perform a variety of other file-related tasks. The concept of file handling has been extended to a variety of other languages, but the implementation is either complicated or lengthy. However, like most Python principles, this concept is simple and straightforward. Python processes file differently depending on whether they are text or binary, which is crucial. Each line of code consists of a series of characters that together constitute a text file. A specific character called the EOL or End of Line character, such as the comma, or a newline character is used to end each line in a file.

Given two files, the task is to copy the contents of one file to the other file.:# In read mode, open the first file say  samplefile1.txt.
with open(""samplefile1.txt"") as file1:
  # In write mode, open the second file say  samplefile2.txt.
    with open(""samplefile2.txt"", ""w"") as file2:
      # Using for loop, go over the lines in the first file.
        for iline in file1:
          # Copy the ith line of the first file to the second file using the write function.
            file2.write(iline)<|endoftext|>"
70,"<|endoftext|>Create a function that takes two strings and determines if an anagram of the first string is in the second string. Anagrams of ""bag"" are ""bag"", ""bga"", ""abg"", ""agb"", ""gab"", ""gba"". Since none of those anagrams are in ""grab"", the answer is false. A ""g"", ""a"", and ""b"" are in the string ""grab"", but they're split up by the ""r"".

Examples
ana_str_str(""car"", ""race"") ➞ True

ana_str_str(""nod"", ""done"") ➞ True

ana_str_str(""bag"", ""grab"") ➞ False
Notes
Inputs will be valid strings in all lowercase letters.
There exists a linear time algorithm for this.:from itertools import *
def ana_str_str(needle, haystack):
  return any(''.join(p) in haystack for p in permutations(needle))<|endoftext|>"
71,"<|endoftext|>Given two binary arrays, arr1[] and arr2[] of the same size n. Find the length of the longest common span (i, j) where j >= i such that arr1[i] + arr1[i+1] + …. + arr1[j] = arr2[i] + arr2[i+1] + …. + arr2[j].:# Python program to find largest subarray
# with equal number of 0's and 1's.

# Returns largest common subarray with equal
# number of 0s and 1s
def longestCommonSum(arr1, arr2, n):
	
	# Find difference between the two
	arr = [0 for i in range(n)]
	
	for i in range(n):
		arr[i] = arr1[i] - arr2[i];
	
	# Creates an empty hashMap hM
	hm = {}
	sum = 0	 # Initialize sum of elements
	max_len = 0	 #Initialize result
	
	# Traverse through the given array
	for i in range(n):
		
		# Add current element to sum
		sum += arr[i]
		
		# To handle sum=0 at last index
		if (sum == 0):
			max_len = i + 1
		
		# If this sum is seen before,
		# then update max_len if required
		if sum in hm:
			max_len = max(max_len, i - hm[sum])
		else: # Else put this sum in hash table
			hm[sum] = i
	return max_len

# Driver code
arr1 = [0, 1, 0, 1, 1, 1, 1]
arr2 = [1, 1, 1, 1, 1, 0, 1]
n = len(arr1)
print(longestCommonSum(arr1, arr2, n))

# This code is contributed by rag2127<|endoftext|>"
72,"<|endoftext|>Operations on Circular Queue:

Front:Get the front item from queue.
Rear: Get the last item from queue.
enQueue(value) This function is used to insert an element into the circular queue. In a circular queue, the new element is always inserted at Rear position.
Steps:
Create a new node dynamically and insert value into it.
Check if front==NULL, if it is true then front = rear = (newly created node)
If it is false then rear=(newly created node) and rear node always contains the address of the front node.
deQueue() This function is used to delete an element from the circular queue. In a queue, the element is always deleted from front position.
Steps:
Check whether queue is empty or not means front == NULL.
If it is empty then display Queue is empty. If queue is not empty then step 3
Check if (front==rear) if it is true then set front = rear = NULL else move the front forward in queue, update address of front in rear node and return the element.:# Python3 program for insertion and
# deletion in Circular Queue

# Structure of a Node
class Node:
	def __init__(self):
		self.data = None
		self.link = None

class Queue:
	def __init__(self):
		front = None
		rear = None

# Function to create Circular queue
def enQueue(q, value):
	temp = Node()
	temp.data = value
	if (q.front == None):
		q.front = temp
	else:
		q.rear.link = temp

	q.rear = temp
	q.rear.link = q.front

# Function to delete element from
# Circular Queue
def deQueue(q):
	if (q.front == None):
		print(""Queue is empty"")
		return -999999999999

	# If this is the last node to be deleted
	value = None # Value to be dequeued
	if (q.front == q.rear):
		value = q.front.data
		q.front = None
		q.rear = None
	else: # There are more than one nodes
		temp = q.front
		value = temp.data
		q.front = q.front.link
		q.rear.link = q.front

	return value

# Function displaying the elements
# of Circular Queue
def displayQueue(q):
	temp = q.front
	print(""Elements in Circular Queue are: "",
								end = "" "")
	while (temp.link != q.front):
		print(temp.data, end = "" "")
		temp = temp.link
	print(temp.data)

# Driver Code
if __name__ == '__main__':

	# Create a queue and initialize
	# front and rear
	q = Queue()
	q.front = q.rear = None

	# Inserting elements in Circular Queue
	enQueue(q, 14)
	enQueue(q, 22)
	enQueue(q, 6)

	# Display elements present in
	# Circular Queue
	displayQueue(q)

	# Deleting elements from Circular Queue
	print(""Deleted value = "", deQueue(q))
	print(""Deleted value = "", deQueue(q))

	# Remaining elements in Circular Queue
	displayQueue(q)

	enQueue(q, 9)
	enQueue(q, 20)
	displayQueue(q)

# This code is contributed by PranchalK<|endoftext|>"
73,"<|endoftext|>Give an algorithm for reversing a queue Q. Only following standard operations are allowed on queue. 
enqueue(x) : Add an item x to rear of queue.
dequeue() : Remove an item from front of queue.
empty() : Checks if a queue is empty or not.


 :# Python3 program to reverse a queue
from queue import Queue
 
# Utility function to print the queue
def Print(queue):
    while (not queue.empty()):
        print(queue.queue[0], end = "", "")
        queue.get()
 
# Function to reverse the queue
def reversequeue(queue):
    Stack = []
    while (not queue.empty()):
        Stack.append(queue.queue[0])
        queue.get()
    while (len(Stack) != 0):
        queue.put(Stack[-1])
        Stack.pop()
 
# Driver code
if __name__ == '__main__':
    queue = Queue()
    queue.put(10)
    queue.put(20)
    queue.put(30)
    queue.put(40)
    queue.put(50)
    queue.put(60)
    queue.put(70)
    queue.put(80)
    queue.put(90)
    queue.put(100)
 
    reversequeue(queue)
    Print(queue)
 
# This code is contributed by PranchalK
<|endoftext|>"
74,"<|endoftext|>Given an array that represents Inorder Traversal, find all possible Binary Trees with the given Inorder traversal and print their preorder traversals.:# Python program to find binary tree with given
# inorder traversal

# Node Structure
class Node:

	# Utility to create a new node
	def __init__(self , item):
		self.key = item
		self.left = None
		self.right = None

# A utility function to do preorder traversal of BST
def preorder(root):
	if root is not None:
		print (root.key,end="" "")
		preorder(root.left)
		preorder(root.right)


# Function for constructing all possible trees with
# given inorder traversal stored in an array from
# arr[start] to arr[end]. This function returns a
# vector of trees.
def getTrees(arr , start , end):

	# List to store all possible trees
	trees = []
	
	"""""" if start > end then subtree will be empty so
	returning NULL in the list """"""
	if start > end :
		trees.append(None)
		return trees
	

	"""""" Iterating through all values from start to end
		for constructing left and right subtree
		recursively """"""
	for i in range(start , end+1):

		# Constructing left subtree
		ltrees = getTrees(arr , start , i-1)
		
		# Constructing right subtree
		rtrees = getTrees(arr , i+1 , end)
		
		"""""" Looping through all left and right subtrees
		and connecting to ith root below""""""
		for j in ltrees :
			for k in rtrees :

				# Making arr[i] as root
				node = Node(arr[i])
	
				# Connecting left subtree
				node.left = j

				# Connecting right subtree
				node.right = k

				# Adding this tree to list
				trees.append(node)
	return trees

# Driver program to test above function
inp = [4 , 5, 7]
n = len(inp)

trees = getTrees(inp , 0 , n-1)

print (""Preorder traversals of different possible\
Binary Trees are "")
for i in trees :
	preorder(i);
	print ("""")

# This program is contributed by Nikhil Kumar Singh(nickzuck_007)<|endoftext|>"
75,"<|endoftext|>Eulerian Path is a path in graph that visits every edge exactly once. Eulerian Circuit is an Eulerian Path which starts and ends on the same vertex.

We strongly recommend to first read the following post on Euler Path and Circuit. 

In the above mentioned post, we discussed the problem of finding out whether a given graph is Eulerian or not. In this post, an algorithm to print Eulerian trail or circuit is discussed.
Following is Fleury’s Algorithm for printing Eulerian trail or cycle (Source Ref1).
1. Make sure the graph has either 0 or 2 odd vertices.
2. If there are 0 odd vertices, start anywhere. If there are 2 odd vertices, start at one of them.
3. Follow edges one at a time. If you have a choice between a bridge and a non-bridge, always choose the non-bridge.
4. Stop when you run out of edges.
The idea is, “don’t burn bridges“ so that we can come back to a vertex and traverse remaining edges. For example let us consider the following graph. 

:# Python program print Eulerian Trail in a given Eulerian or Semi-Eulerian Graph
  
from collections import defaultdict
  
#This class represents an undirected graph using adjacency list representation
class Graph:
  
    def __init__(self,vertices):
        self.V= vertices #No. of vertices
        self.graph = defaultdict(list) # default dictionary to store graph
        self.Time = 0
  
    # function to add an edge to graph
    def addEdge(self,u,v):
        self.graph[u].append(v)
        self.graph[v].append(u)
 
    # This function removes edge u-v from graph   
    def rmvEdge(self, u, v):
        for index, key in enumerate(self.graph[u]):
            if key == v:
                self.graph[u].pop(index)
        for index, key in enumerate(self.graph[v]):
            if key == u:
                self.graph[v].pop(index)
 
    # A DFS based function to count reachable vertices from v
    def DFSCount(self, v, visited):
        count = 1
        visited[v] = True
        for i in self.graph[v]:
            if visited[i] == False:
                count = count + self.DFSCount(i, visited)        
        return count
 
    # The function to check if edge u-v can be considered as next edge in
    # Euler Tour
    def isValidNextEdge(self, u, v):
        # The edge u-v is valid in one of the following two cases:
  
          #  1) If v is the only adjacent vertex of u
        if len(self.graph[u]) == 1:
            return True
        else:
            '''
             2) If there are multiple adjacents, then u-v is not a bridge
                 Do following steps to check if u-v is a bridge
  
            2.a) count of vertices reachable from u'''   
            visited =[False]*(self.V)
            count1 = self.DFSCount(u, visited)
 
            '''2.b) Remove edge (u, v) and after removing the edge, count
                vertices reachable from u'''
            self.rmvEdge(u, v)
            visited =[False]*(self.V)
            count2 = self.DFSCount(u, visited)
 
            #2.c) Add the edge back to the graph
            self.addEdge(u,v)
 
            # 2.d) If count1 is greater, then edge (u, v) is a bridge
            return False if count1 > count2 else True
 
 
    # Print Euler tour starting from vertex u
    def printEulerUtil(self, u):
        #Recur for all the vertices adjacent to this vertex
        for v in self.graph[u]:
            #If edge u-v is not removed and it's a a valid next edge
            if self.isValidNextEdge(u, v):
                print(""%d-%d "" %(u,v)),
                self.rmvEdge(u, v)
                self.printEulerUtil(v)
 
 
     
    '''The main function that print Eulerian Trail. It first finds an odd
   degree vertex (if there is any) and then calls printEulerUtil()
   to print the path '''
    def printEulerTour(self):
        #Find a vertex with odd degree
        u = 0
        for i in range(self.V):
            if len(self.graph[i]) %2 != 0 :
                u = i
                break
        # Print tour starting from odd vertex
        print (""\n"")
        self.printEulerUtil(u)
 
# Create a graph given in the above diagram
 
g1 = Graph(4)
g1.addEdge(0, 1)
g1.addEdge(0, 2)
g1.addEdge(1, 2)
g1.addEdge(2, 3)
g1.printEulerTour()
 
 
g2 = Graph(3)
g2.addEdge(0, 1)
g2.addEdge(1, 2)
g2.addEdge(2, 0)
g2.printEulerTour()
 
g3 = Graph (5)
g3.addEdge(1, 0)
g3.addEdge(0, 2)
g3.addEdge(2, 1)
g3.addEdge(0, 3)
g3.addEdge(3, 4)
g3.addEdge(3, 2)
g3.addEdge(3, 1)
g3.addEdge(2, 4)
g3.printEulerTour()
 
 
#This code is contributed by Neelam Yadav
<|endoftext|>"
76,"<|endoftext|>Files in Python:

Files are identified locations on the disc where associated data is stored. They’re used to keep data in non-volatile memory for a long time (e.g. hard disk).

We use files for future usage of the data by permanently saving it because Random Access Memory (RAM) is volatile (it loses its contents when the machine is turned off).



We must first open a file before we can read from or write to it. When we’re finished, it needs to be closed so that the file’s resources may be released.

As a result, a file operation in Python is performed in the following order:

Create a new file
You can either read or write (perform the operations)
Close the file.

Given a file, the task is to reverse each word in the given file in python:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in read-only mode. In this case, we're simply reading the contents of the file.
with open(givenFilename, 'r') as givenfilecontent:
  # Read the above file using the read() function(get the content) and store it in a variable
  gvn_data = givenfilecontent.read()
# Take a variable and initialize it with a new empty string
rslt_str = """"
# Split the given data into list of words using the split() function and
# iterate in that list using the for loop
for wrd in gvn_data.split():
  # Reverse each word and store it in a variable
  revrse_wrd = wrd[::-1]
  # Add the above reversed word to the above empty result string and 
  # store it in the same variable.
  rslt_str += revrse_wrd
  # Give spaces in the  result string
  rslt_str += "" ""
# Open the file in write mode. In this case, we're writing the contents into the file.
with open(""samplefile.txt"",""w"") as givenfilecontent:
  # write the data stored in the result string into the file using the write() function
  givenfilecontent.write(rslt_str)<|endoftext|>"
77,"<|endoftext|>Object-Oriented Programming(OOPS):

Object-oriented programming (OOP) is a form of program structure that involves grouping related characteristics and activities into separate objects.

Objects are conceptually similar to system components. Consider a program to be a sort of factory assembly line. A system component processes some material at each step of the assembly line, eventually changing raw material into a finished product.



An object comprises data, such as the raw or preprocessed materials at each step of an assembly line, as well as behavior, such as the action performed by each assembly line component.

Given length and breadth, the task is to calculate the area of the rectangle with the given length and breadth using classes.

Examples:

Example1:

Input:

given length of rectangle = 15
given breadth of rectangle = 11
Output:

The area of the rectangle with the given sides 15 , 11 = 165
Example2:

Input:

given length of rectangle = 31
given breadth of rectangle = 19
Output:

The area of the rectangle with the given sides 31 , 19 = 589:# creating a class
 class rectangle():
  # parameterized constructor with breadth and length as arguments
  # parameterized constructor is used to initialize its values (length and breadth of the rectangle).
  def __init__(self, rectbreadth, rectlength):
  self.rectbreadth = rectbreadth
  self.rectlength = rectlength
  # Creating a method called areaofRect that returns the area with the given length and breadth of the rectangle
  def areaofRect(self):
  return self.rectbreadth*self.rectlength
 # Give the length and breadth as static input and store it in two variables.
 rectlength = 31
 rectbreadth = 19
 # Creating an object to represent the class.
 # Call the method areaofRect() on the object with the length and breadth as the parameters taken from the user as static input.
 rectObj = rectangle(rectlength, rectbreadth)
 print(""The area of the rectangle with the given sides"",
  rectlength, ',', rectbreadth, '=', rectObj.areaofRect())<|endoftext|>"
78,"<|endoftext|>Given a number, the task is to check whether the given number is a Neon Number or not in Python.

Neon Number:

A Neon Number is a number whose square sum of digits equals the original number.

Ex: 9

Square of 9 =81

Sum of digits of square = 8 +1 =9 ,So it is Neon Number

Examples:

Example1:

Input:

Given Number = 9
Output:

The Given Number [ 9 ] is a neon Number:#Give the number as static input and store it in a variable.
givnumb=9
#Calculate the square of the given number using the ** operator 
#or multiply the given number by itself and store it in a variable.
squarnumb=givnumb**2
#Convert this squared number into a list of digits
#using list(),int(),map(),str() functions.
#Store this list in a variable.
numbedigit=list(map(int,str(givnumb)))
#Calculate the sum of digits of this list using the sum() function.
sumdigi=sum(numbedigit)
#Check if this sum is equal to the given number 
#or not using the If conditional statement.
#If it is true then the given number is a Neon Number.
if(sumdigi==givnumb):
  print('The Given Number [',givnumb,'] is a neon Number')
#Else the given number is not a Neon Number.
else:
    print('The Given Number [',givnumb,'] is not a neon Number')<|endoftext|>"
79,"<|endoftext|>Given an array of items, an i-th index element denotes the item id’s, and given a number m, the task is to remove m elements such that there should be minimum distinct id’s left. Print the number of distinct id’s.:
# Python program for above implementation
 
# Function to find distinct id's
def distinctIds(arr, n, mi):
  m = {}
  v = []
  count = 0
 
  # Store the occurrence of ids
  for i in range(n):
    if arr[i] in m:
      m[arr[i]] += 1
    else:
      m[arr[i]] = 1
 
  # Store into the list value as key and vice-versa
  for i in m:
    v.append([m[i],i])
 
  v.sort()
  size = len(v)
 
  # Start removing elements from the beginning
  for i in range(size):
     
    # Remove if current value is less than
    # or equal to mi
    if (v[i][0] <= mi):
      mi -= v[i][0]
      count += 1
         
    else:   # Return the remaining size
      return size - count
  return size - count
 
# Driver code
arr = [ 2, 3, 1, 2, 3, 3 ]
n = len(arr)
 
m = 3
 
# To display the result
print(distinctIds(arr, n, m))
 
# This code is contributed by rohitsingh07052<|endoftext|>"
80,"<|endoftext|>Given an array, the task is to find the maximum triplet sum in the array.:# Python 3 code to find
# maximum triplet sum

# This function assumes
# that there are at least
# three elements in arr[].
def maxTripletSum(arr, n) :

	# Initialize Maximum, second
	# maximum and third maximum
	# element
	maxA = -100000000
	maxB = -100000000
	maxC = -100000000

	for i in range(0, n) :
	
		# Update Maximum, second maximum
		# and third maximum element
		if (arr[i] > maxA) :
			maxC = maxB
			maxB = maxA
			maxA = arr[i]

		# Update second maximum and
		# third maximum element
		elif (arr[i] > maxB) :
			maxC = maxB
			maxB = arr[i]
		
		# Update third maximum element
		elif (arr[i] > maxC) :
			maxC = arr[i]
			
	return (maxA + maxB + maxC)
	
# Driven code
arr = [ 1, 0, 8, 6, 4, 2 ]
n = len(arr)

print(maxTripletSum(arr, n))

# This code is contributed by Nikita Tiwari.<|endoftext|>"
81,"<|endoftext|>Swapping refers to the exchange of two elements, this is usually done with a list. In this section, we see various methods to python swap list elements. The list is a container that stores elements of similar data types.:# python program to swap two elements in a list # user-defined function def swap(l, p1, p2): l[p1], l[p2] = l[p2], l[p1] return l # take inputs l = [10, 34, 17, 18] # print new list p1, p2 = 1, 2 print(swap(l, p1-1, p2-1))<|endoftext|>"
82,"<|endoftext|>What is the procedure for performing a Python increment operation? You might want to try extending a comparable increment functionality to Python if you’re coming from a language like C++ or Java.

However, as we will see later in this essay, this is not the case. Let’s have a look at how we may use Python’s Increment (++) operation to achieve comparable results.:# given number
number = 19
# increment it by 1
number += 1
print(number)<|endoftext|>"
83,"<|endoftext|>Create a function that takes a string and returns the letters that occur only once.
Examples
find_letters(""monopoly"") ➞ [""m"", ""n"", ""p"", ""l"", ""y""]

find_letters(""balloon"") ➞ [""b"", ""a"", ""n""]

find_letters(""analysis"") ➞ [""n"", ""l"", ""y"", ""i""]
Notes
The final list should not include letters that appear more than once in the string.
Return the letters in the sequence they were originally in, do not sort them.
All letters will be in lowercase.:def find_letters(word):
  return [i for i in word if word.count(i) == 1]<|endoftext|>"
84,"<|endoftext|>There are three types of triangle based on the length of the sides: equilateral, isosceles, and scalene.

This python program checks whether a triangle is equilateral or isosceles or scalene based on given length of sides.:# Validity of Triangle given sides

# Function definition to check validity
def is_valid_triangle(a,b,c):
    if a+b>=c and b+c>=a and c+a>=b:
        return True
    else:
        return False

# Function definition for type
def type_of_triangle(a,b,c):
    if a==b and b==c:
        print('Triangle is Equilateral.')
    elif a==b or b==c or a==c:
        print('Triangle is Isosceles.')
    else:
        print('Triangle is Scalane')

# Reading Three Sides
side_a = float(input('Enter length of side a: '))
side_b = float(input('Enter length of side b: '))
side_c = float(input('Enter length of side c: '))

# Function call & making decision
if is_valid_triangle(side_a, side_b, side_c):
    type_of_triangle(side_a, side_b, side_c)
else:
    print('Tringle is not possible from given sides.')<|endoftext|>"
85,"<|endoftext|>Create a function that takes a number n (integer greater than zero) as an argument, and returns 2 if n is odd and 8 if n is even.
You can only use the following arithmetic operators: addition of numbers +, subtraction of numbers -, multiplication of number *, division of number /, and exponentiation **.
You are not allowed to use any other methods in this challenge (i.e. no if statements, comparison operators, etc).
Examples
f(1) ➞ 2

f(2) ➞ 8

f(3) ➞ 2
Notes
N/A:def f(n):
    return 3*(-1)**n + 5<|endoftext|>"
86,"<|endoftext|>Given a square matrix, the task is to swap the upper diagonal elements and lower diagonal elements of a given matrix.:# Give the matrix as static input and store it in a variable.
mtrx = [[10, 20, 30], [45, 60, 70], [11, 12, 13]]
# Calculate the number of rows of the given matrix by
# calculating the length of the nested list using the len() function
# and store it in a variable mtrxrows.
mtrxrows = len(mtrx)
# Calculate the number of columns of the given matrix by
# calculating the length of the first list in the nested list
# using the len() function and store it in a variable mtrxcols.
mtrxcols = len(mtrx[0])
# Loop till the given number of rows using the For loop.
for itor in range(0, mtrxrows):
   # Inside the For loop, iterate from the iterator value +1 of the parent for loop to the
   # given number of rows using another Nested For loop(Inner For loop).

    for k in range(itor + 1, mtrxrows):
      # Swap mtrx[itor][k], mtrx[k][itor] using the comma(,) operator ( where itor is the
      # iterator value of the parent for loop and k is the iterator value
      # of the inner for loop).

        mtrx[itor][k], mtrx[k][itor] = mtrx[k][itor], mtrx[itor][k]

print(""The Matrix after swapping the upper diagonal and lower diagonal elements is:"")
# Loop till the given number of rows using the For loop.
for n in range(mtrxrows):
    # Inside the For loop, Iterate till the given number of rows using another
    # Nested For loop(Inner For loop).
    for m in range(mtrxcols):
        # Print the element of the matrix by printing gvnmatrix[n][m] value
        # where n is the iterator value of the parent For loop and m is the iterator
        # value of the inner For loop.
        print(mtrx[n][m], end=' ')
    print()<|endoftext|>"
87,"<|endoftext|>You will be given a list of dancing couples, with the woman first and man second, as well as a parameter ""men"" or ""women"".
If the parameter is ""men"", the men reverse their positions (first moves to last, last moves to first, etc), while women keep their positions.
If the parameter is ""women"", the women reverse their positions, while men keep their positions.
Examples
dance([
  [Ana, Bob],
  [Amy, Josh],
  [Lisa, Tim]
], men) ➞ [
  [Ana, Tim],
  [Amy, Josh],
  [Lisa, Bob]
]

dance([
  [Ana, Bob],
  [Amy, Josh],
  [Lisa, Tim]
], women) ➞ [
  [Lisa, Bob],
  [Amy, Josh],
  [Ana, Tim]
]
Notes
Input lists will always be the same length.:def dance(lst,par):
  (i,j) = (1,-1) if par == ""men"" else (-1,1) 
  return [[a[0],b[1]] for a,b in zip(lst[::i],lst[::j])]<|endoftext|>"
88,"<|endoftext|>Given an array of numbers, arrange them in a way that yields the largest value. For example, if the given numbers are {54, 546, 548, 60}, the arrangement 6054854654 gives the largest value. And if the given numbers are {1, 34, 3, 98, 9, 76, 45, 4}, then the arrangement 998764543431 gives the largest value.:# Python3 implementation this is to use itertools.
# permutations as coded below:

from itertools import permutations
def largest(l):
	lst = []
	for i in permutations(l, len(l)):
		# provides all permutations of the list values,
		# store them in list to find max
		lst.append("""".join(map(str,i)))
	return max(lst)

print(largest([54, 546, 548, 60])) #Output 6054854654

# This code is contributed by Raman Monga
<|endoftext|>"
89,"<|endoftext|>The del keyword is used to delete objects. In Python everything is an object, so the del keyword can also be used to delete variables, lists, or parts of a list etc.

:class MyClass:
  name = ""John""

del MyClass

print(MyClass)<|endoftext|>"
90,"<|endoftext|>In the previous article, we have discussed Python Program to Swap Upper Diagonal Elements with Lower Diagonal Elements of Matrix.
 Given a number N and the task is to find the sum of the given series (1+(1+2)+(1+2+3)+…till N) for the given number in Python.
 Examples:
 Example1:
 Input:
 Given Number = 25
 Output:
 The total sum of the series till the given number { 25 } = 2925
 Example2:
 Input:
 Given Number = 18
 Output:
 The total sum of the series till the given number { 18 } = 1140:# Give the number N as static input and store it in a variable.
 
 gvn_numb = 25
 
 # Take a variable say resltsum which gives the sum of the given series till N and
 
 # initialize its value to 0.
 
 resltsum = 0
 
 # Take another variable say k and initialize its value with 1.
 
 k = 1
 
 # Loop until the value of k is less than or equal to the given number using the while loop.
 
 while(k &lt;= gvn_numb):
 
  # Inside the loop, iterate from 1 to the value of k using the for loop.
 
  for itr in range(1, k+1):
 
  # Add the iterator value to the above-initialized resltsum and store it in the same
 
  # variable resltsum.
 
  resltsum += itr
 
  # Increment the value of k by 1 outside the for loop.
 
  k += 1
 
 # Print the resltsum value which is the result of the series till the given Number N.
 
 print(
 
  ""The total sum of the series till the given number {"", gvn_numb, ""} = "", resltsum)
 
 </pre><|endoftext|>"
91,"<|endoftext|>Degree
In graph theory, the degree (or valency) of a vertex of a graph is the number of edges incident to the vertex, with loops counted twice.[1] The degree of a vertex  v is denoted  \deg(v) or  \deg v. The maximum degree of a graph G, denoted by \Delta (G), and the minimum degree of a graph, denoted by \delta (G), are the maximum and minimum degree of its vertices. In the graph on the right, the maximum degree is 5 and the minimum degree is 0. In a regular graph, all degrees are the same, and so we can speak of the degree of the graph.

Degree Centrality
Historically first and conceptually simplest is degree centrality, which is defined as the number of links incident upon a node (i.e., the number of ties that a node has). The degree can be interpreted in terms of the immediate risk of a node for catching whatever is flowing through the network (such as a virus, or some information). In the case of a directed network (where ties have direction), we usually define two separate measures of degree centrality, namely indegree and outdegree. Accordingly, indegree is a count of the number of ties directed to the node and outdegree is the number of ties that the node directs to others. When ties are associated to some positive aspects such as friendship or collaboration, indegree is often interpreted as a form of popularity, and outdegree as gregariousness.

The degree centrality of a vertex v , for a given graph G:=(V,E) with |V| vertices and |E| edges, is defined as

C_{D}(v)=\deg(v)
Calculating degree centrality for all the nodes in a graph takes \Theta(V^2) in a dense adjacency matrix representation of the graph, and for edges takes \Theta(E) in a sparse matrix representation.

The definition of centrality on the node level can be extended to the whole graph, in which case we are speaking of graph centralization. Let v* be the node with highest degree centrality in G. Let X:=(Y,Z) be the |Y| node connected graph that maximizes the following quantity (with y* being the node with highest degree centrality in X):

H=\sum _{{j=1}}^{{|Y|}}[C_{D}(y*)-C_{D}(y_{j})]
Correspondingly, the degree centralization of the graph G is as follows:

C_D(G)= \frac{\displaystyle{\sum^{|V|}_{i=1}{[C_D(v*)-C_D(v_i)]}}}{H}
The value of H is maximized when the graph X contains one central node to which all other nodes are connected (a star graph):
import networkx as nx
  
def degree_centrality(G, nodes):
    r""""""Compute the degree centrality for nodes in a bipartite network.
  
    The degree centrality for a node `v` is the fraction of nodes 
    connected to it.
  
    Parameters
    ----------
    G : graph
       A bipartite network
  
    nodes : list or container
      Container with all nodes in one bipartite node set.
  
    Returns
    -------
    centrality : dictionary
       Dictionary keyed by node with bipartite degree centrality as the value.
  
    Notes
    -----
    The nodes input parameter must contain all nodes in one bipartite node set,
    but the dictionary returned contains all nodes from both bipartite node
    sets.
  
    For unipartite networks, the degree centrality values are 
    normalized by dividing by the maximum possible degree (which is 
    `n-1` where `n` is the number of nodes in G). 
  
    In the bipartite case, the maximum possible degree of a node in a
    bipartite node set is the number of nodes in the opposite node set
    [1]_.  The degree centrality for a node `v` in the bipartite
    sets `U` with `n` nodes and `V` with `m` nodes is
  
    .. math::
  
        d_{v} = \frac{deg(v)}{m}, \mbox{for} v \in U ,
  
        d_{v} = \frac{deg(v)}{n}, \mbox{for} v \in V ,
  
  
    where `deg(v)` is the degree of node `v`.        
  
      
    """"""
    top = set(nodes)
    bottom = set(G) - top
    s = 1.0/len(bottom)
    centrality = dict((n,d*s) for n,d in G.degree_iter(top))
    s = 1.0/len(top)
    centrality.update(dict((n,d*s) for n,d in G.degree_iter(bottom)))
    return centrality<|endoftext|>"
92,"<|endoftext|>In a singly linked list, for accessing any node of the linked list, we start traversing from the first node. If we are at any node in the middle of the list, then it is not possible to access nodes that precede the given node. This problem can be solved by slightly altering the structure of a singly linked list. In a singly linked list, the next part (pointer to next node) is NULL. If we utilize this link to point to the first node, then we can reach the preceding nodes. Refer to this for more advantages of circular linked lists.:class Node:
	def __init__(self, data):
		self.data = data
		self.next = None

class CircularLinkedList:
	def __init__(self):
		self.last = None

	# This function is only for empty list
	def addToEmpty(self, data):

		if (self.last != None):
			return self.last

		# Creating the newnode temp
		temp = Node(data)
		self.last = temp

		# Creating the link
		self.last.next = self.last
		return self.last

	def addBegin(self, data):

		if (self.last == None):
			return self.addToEmpty(data)

		temp = Node(data)
		temp.next = self.last.next
		self.last.next = temp

		return self.last

	def addEnd(self, data):

		if (self.last == None):
			return self.addToEmpty(data)

		temp = Node(data)
		temp.next = self.last.next
		self.last.next = temp
		self.last = temp

		return self.last

	def addAfter(self, data, item):

		if (self.last == None):
			return None

		temp = Node(data)
		p = self.last.next
		while p:
			if (p.data == item):
				temp.next = p.next
				p.next = temp

				if (p == self.last):
					self.last = temp
					return self.last
				else:
					return self.last
			p = p.next
			if (p == self.last.next):
				print(item, ""not present in the list"")
				break

	def traverse(self):
		if (self.last == None):
			print(""List is empty"")
			return

		temp = self.last.next
		while temp:
			print(temp.data, end = "" "")
			temp = temp.next
			if temp == self.last.next:
				break

# Driver Code
if __name__ == '__main__':

	llist = CircularLinkedList()

	last = llist.addToEmpty(6)
	last = llist.addBegin(4)
	last = llist.addBegin(2)
	last = llist.addEnd(8)
	last = llist.addEnd(12)
	last = llist.addAfter(10,8)

	llist.traverse()

# This code is contributed by
# Aditya Singh
<|endoftext|>"
93,"<|endoftext|>Given number of rows and columns. And given number of 1’s, 2’s, 3’s ……k’s which needs to be printed. Print them in a zig-zag way. 
It is guaranteed that n*m = number of 1’s + 2’s + 3’s + …… + k’s 

Examples: 
Input :  2 3
         2 1 2 1
Output : 1 1 2
         4 3 3
Explanation :
Here number of rows are 2 and number of columns are 3
and number of 1's are 2
    number of 2's are 1
    number of 3's are 2
    number of 4's are 1
    -----------
   | 1 | 1 | 2 |
   | 3 | 3 | 4 |
    -----------

Input :  4 3
         2 4 3 1 2
Output : 1 1 2
         2 2 2
         3 3 3
         5 5 4
Explanation :
Here number of rows are 4 and number of columns are 3
and number of 1's are 2
    number of 2's are 4 [Note that 2s are printed in]
    number of 3's are 3 [zig zag manner]
    number of 4's are 1
    number of 5's are 2:# Python3 program to print given number of 1's,
# 2's, 3's ....k's in zig-zag way.
 
# function that prints given number of 1's,
# 2's, 3's ....k's in zig-zag way.
def ZigZag(rows, columns, numbers):
    k = 0
     
    # two-dimensional array to store numbers.
    arr = [[0 for i in range(columns)] for j in range(rows)]
    for i in range(rows):
         
        # for even row.
        if (i % 2 == 0):
             
            # for each column.
            j = 0
            while j < columns and numbers[k] > 0:
                 
                # storing element.
                arr[i][j] = k + 1
                 
                # decrement element at
                # kth index.
                numbers[k] -= 1   
                 
                # if array contains zero
                # then increment index to
                # make this next index
                if numbers[k] == 0:
                    k += 1
                j += 1
        # for odd row.
        else:
             
            # for each column.
            j = columns-1
            while j>=0 and numbers[k]>0:
                 
                # storing element.
                arr[i][j] = k+1
                 
                # decrement element
                # at kth index.
                numbers[k] -= 1
                 
                # if array contains zero then
                # increment index to make this
                # next index.
                if numbers[k] == 0:
                    k += 1
                j -= 1
     
    # printing the stored elements.
    for i in arr:
        for j in i:
            print(j, end ="" "")
        print()
 
# Driver code
rows = 4;
columns = 5;
Numbers = [3, 4, 2, 2, 3, 1, 5]
ZigZag(rows, columns, Numbers)
 
# This code is contributed by
# Rajnis09
<|endoftext|>"
94,"<|endoftext|>Write a function that returns the minimum number of swaps to convert the first binary string into the second.
Examples
min_swaps(""1100"", ""1001"") ➞ 1

min_swaps(""110011"", ""010111"") ➞ 1

min_swaps(""10011001"", ""01100110"") ➞ 4
Notes
Both binary strings will be of equal length.
Both binary strings will have an equal number of zeroes and ones.
A swap is switching two elements in a string (swaps do not have to be adjacent).:def min_swaps(s1, s2):
  return sum(a != b for a, b in zip(s1, s2)) // 2<|endoftext|>"
95,"<|endoftext|>Write a function to connect all the adjacent nodes at the same level in a binary tree.

Example: 

Input Tree
       A
      / \
     B   C
    / \   \
   D   E   F


Output Tree
       A--->NULL
      / \
     B-->C-->NULL
    / \   \
   D-->E-->F-->NULL:#! /usr/bin/env python3

# connect nodes at same level using level order traversal
import sys


class Node:
        def __init__(self, data):
                self.data = data
                self.left = None
                self.right = None
                self.nextRight = None

        def __str__(self):
                return '{}'.format(self.data)


def printLevelByLevel(root):
        # print level by level
        if root:
                node = root
                while node:
                        print('{}'.format(node.data), end=' ')
                        node = node.nextRight
                print()
                if root.left:
                        printLevelByLevel(root.left)
                else:
                        printLevelByLevel(root.right)


def inorder(root):
        if root:
                inorder(root.left)
                print(root.data, end=' ')
                inorder(root.right)


def connect(root):
        # set nextRight of all nodes of a tree
        queue = []
        queue.append(root)
        # null marker to represent end of current level
        queue.append(None)
        # do level order of tree using None markers
        while queue:
                p = queue.pop(0)
                if p:
                        # next element in queue represents
                        # next node at current level
                        p.nextRight = queue[0]
                        # pus left and right children of current node
                        if p.left:
                                queue.append(p.left)
                        if p.right:
                                queue.append(p.right)
                else if queue:
                        queue.append(None)


def main():
        """"""Driver program to test above functions.
                Constructed binary tree is
                                10
                        / \
                        8         2
                        /         \
                3                 90
        """"""

        root = Node(10)
        root.left = Node(8)
        root.right = Node(2)
        root.left.left = Node(3)
        root.right.right = Node(90)

        # Populates nextRight pointer in all nodes
        connect(root)

        # Let us check the values of nextRight pointers
        print(""Following are populated nextRight pointers in \n""
        ""the tree (-1 is printed if there is no nextRight) \n"")
        if(root.nextRight != None):
                print(""nextRight of %d is %d \n"" %(root.data,root.nextRight.data))
        else:
                print(""nextRight of %d is %d \n"" %(root.data,-1))
        if(root.left.nextRight != None):
                print(""nextRight of %d is %d \n"" %(root.left.data,root.left.nextRight.data))
        else:
                print(""nextRight of %d is %d \n"" %(root.left.data,-1))
        if(root.right.nextRight != None):
                print(""nextRight of %d is %d \n"" %(root.right.data,root.right.nextRight.data))
        else:
                print(""nextRight of %d is %d \n"" %(root.right.data,-1))
        if(root.left.left.nextRight != None):
                print(""nextRight of %d is %d \n"" %(root.left.left.data,root.left.left.nextRight.data))
        else:
                print(""nextRight of %d is %d \n"" %(root.left.left.data,-1))
        if(root.right.right.nextRight != None):
                print(""nextRight of %d is %d \n"" %(root.right.right.data,root.right.right.nextRight.data))
        else:
                print(""nextRight of %d is %d \n"" %(root.right.right.data,-1))
                
        print()


if __name__ == ""__main__"":
        main()

# This code is contributed by Ram Basnet
<|endoftext|>"
96,"<|endoftext|>Create a function to multiply all of the values in a list by the amount of values in the given list.
Examples
multiply_by_length([2, 3, 1, 0]) ➞ [8, 12, 4, 0]

multiply_by_length([4, 1, 1]) ➞ ([12, 3, 3])

multiply_by_length([1, 0, 3, 3, 7, 2, 1]) ➞  [7, 0, 21, 21, 49, 14, 7]

multiply_by_length([0]) ➞ ([0])
Notes
All of the values given are numbers.
All lists will have at least one element.
Don't forget to return the result.:def multiply_by_length(arr):
  return[n*len(arr) for n in arr]<|endoftext|>"
97,"<|endoftext|>Given an array and an integer K, find the maximum for each and every contiguous subarray of size k.:
# Python program to find the maximum for
# each and every contiguous subarray of
# size k
 
# Method to find the maximum for each
# and every contiguous subarray
# of size k
def printMax(arr, n, k):
    max = 0
   
    for i in range(n - k + 1):
        max = arr[i]
        for j in range(1, k):
            if arr[i + j] > max:
                max = arr[i + j]
        print(str(max) + "" "", end = """")
 
# Driver method
if __name__==""__main__"":
    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    n = len(arr)
    k = 3
    printMax(arr, n, k)
 
# This code is contributed by Shiv Shankar
<|endoftext|>"
98,"<|endoftext|>Write a function that takes a string, breaks it up and returns it with vowels first, consonants second. For any character that's not a vowel (like special characters or spaces), treat them like consonants.
Examples
split(""abcde"") ➞ ""aebcd""

split(""Hello!"") ➞ ""eoHll!""

split(""What's the time?"") ➞ ""aeieWht's th tm?""
Notes
Vowels are a, e, i, o, u.
Define a separate is_vowel() function for easier to read code (recommendation).:def split(txt):
  return ''.join(sorted(txt, key=lambda x: x.lower() not in 'aeiou'))<|endoftext|>"
99,"<|endoftext|>Given a binary tree, you need to check whether sum of all covered elements is equal to sum of all uncovered elements or not. 
In a binary tree, a node is called Uncovered if it appears either on left boundary or right boundary. Rest of the nodes are called covered. 

For example, consider below binary tree

In above binary tree,
Covered node:     6, 5, 7
Uncovered node:   9, 4, 3, 17, 22, 20

The output for this tree should be false as 
sum of covered and uncovered node is not same:# Python3 program to find sum of Covered and
# Uncovered node of binary tree

# To create a newNode of tree and return pointer
class newNode:
	def __init__(self, key):
		self.key = key
		self.left = self.right = None

# Utility function to calculate sum
# of all node of tree
def Sum(t):
	if (t == None):
		return 0
	return t.key + Sum(t.left) + Sum(t.right)

# Recursive function to calculate sum
# of left boundary elements
def uncoveredSumLeft(t):
	
	# If leaf node, then just return
	# its key value
	if (t.left == None and t.right == None):
		return t.key

	# If left is available then go
	# left otherwise go right
	if (t.left != None):
		return t.key + uncoveredSumLeft(t.left)
	else:
		return t.key + uncoveredSumLeft(t.right)

# Recursive function to calculate sum of
# right boundary elements
def uncoveredSumRight(t):
	
	# If leaf node, then just return
	# its key value
	if (t.left == None and t.right == None):
		return t.key

	# If right is available then go right
	# otherwise go left
	if (t.right != None):
		return t.key + uncoveredSumRight(t.right)
	else:
		return t.key + uncoveredSumRight(t.left)

# Returns sum of uncovered elements
def uncoverSum(t):
	
	# Initializing with 0 in case we
	# don't have left or right boundary
	lb = 0
	rb = 0

	if (t.left != None):
		lb = uncoveredSumLeft(t.left)
	if (t.right != None):
		rb = uncoveredSumRight(t.right)

	# returning sum of root node,
	# left boundary and right boundary
	return t.key + lb + rb

# Returns true if sum of covered and
# uncovered elements is same.
def isSumSame(root):
	
	# Sum of uncovered elements
	sumUC = uncoverSum(root)

	# Sum of all elements
	sumT = Sum(root)

	# Check if sum of covered and
	# uncovered is same
	return (sumUC == (sumT - sumUC))

# Helper function to print Inorder
# traversal of binary tree
def inorder(root):
	if (root):
		inorder(root.left)
		print(root.key, end = "" "")
		inorder(root.right)

# Driver Code
if __name__ == '__main__':
	
	# Making above given diagram's
	# binary tree
	root = newNode(8)
	root.left = newNode(3)

	root.left.left = newNode(1)
	root.left.right = newNode(6)
	root.left.right.left = newNode(4)
	root.left.right.right = newNode(7)

	root.right = newNode(10)
	root.right.right = newNode(14)
	root.right.right.left = newNode(13)

	if (isSumSame(root)):
		print(""Sum of covered and uncovered is same"")
	else:
		print(""Sum of covered and uncovered is not same"")
		
# This code is contributed by PranchalK
<|endoftext|>"
100,"<|endoftext|>Files in Python:

One of the most important subjects for programmers and automation testers is Python file handling (also known as File I/O). It is necessary to work with files in order to write to or read data from them.

Also, if you didn’t know, I/O operations are the most expensive processes where a programme can go wrong. As a result, you must use extreme caution while implementing file processing for reporting or any other reason. Optimizing a single file action can help in the creation of a high-performing application or a reliable automated software testing solution.



Consider the following scenario: you’re planning to construct a large Python project with a large number of workflows. Then it’s unavoidable that you don’t make a log file. You’ll also be handling the log file’s read and write activities. Debugging huge applications with log files is a terrific way to go. It’s usually better to consider a scalable design from the start, as you won’t be sorry later if you didn’t.

File seekable() Method in Python:

If the file is seekable, the seekable() method returns True; otherwise, it returns False. That means it checks whether the file is seekable or not

A file is seekable if it, like the seek() method, allows access to the file stream.

Syntax:

file.seekable()
Parameters: This method doesn’t accept any arguments.

Return Value:

This method’s return type is <class ‘bool’>; it returns True if the file stream is seekable and False otherwise.:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in write mode. In this case, we're writing the contents into the file.
gvn_file = open(givenFilename, 'w') 
# Apply seekable() function to the given file to check if the file is seekable or not
# and print the result.
print(""In write-mode:"", gvn_file.seekable())
# Close the given file using the close() function
gvn_file.close()
# Open the file in read-only mode. In this case, we're simply reading the contents of the file.
gvn_file = open(givenFilename, 'r') 
# Apply seekable() function to the given file to check if the file is seekable or not
# and print the result.
print(""In read-mode:"", gvn_file.seekable())
# Close the given file using the close() function
gvn_file.close()<|endoftext|>"
101,"<|endoftext|>Given a list of numbers and a value n, write a function that returns the probability of choosing a number greater than or equal to n from the list. The probability should be expressed as a percentage, rounded to one decimal place.
Examples
probability([5, 1, 8, 9], 6) ➞ 50.0

probability([7, 4, 17, 14, 12, 3], 16) ➞ 16.7

probability([4, 6, 2, 9, 15, 18, 8, 2, 10, 8], 6) ➞ 70.0
Notes
Precent probability of event = 100 * (num of favourable outcomes) / (total num of possible outcomes)
The numbers in the list are uniformly distributed, and have an equal chance of being chosen.:def probability(lst, n):
  return round(sum(1 for x in lst if x >= n) / len(lst) * 100, 1)<|endoftext|>"
102,"<|endoftext|>Briscola is an Italian card game, played with a deck of 40 cards that has four suits (hearts, diamonds, clubs, and spades), so that there are ten cards per suit: the Ace, the numbered cards from 2 up to 7, and the three face-cards (Jack, Queen, and King). In this challenge, the notation used for the cards is a string containing the card value (with the upper-case initial for face-cards) and the lower-case initial for suits, as in the examples below:
Ah = Ace of Hearts
2s = Two of Spades
Jc = Jack of Clubs
Kd = King of Diamonds
The total number of points available is 120. When counting the points scored at the end of a game, the cards have the following values:
Ace: 11 points
Three: 10 points
King: 4 points
Queen: 3 points
Jack: 2 points
Any other card has no value (0 points).
Each game of Briscola is made of two rounds. After the first round, the points are counted for both you and your opponent, and these scores (plus 1) will set the target for winning the game, after that the second round is played.
- First Round -
Player score: 80
Opponent score: 40
- Second Round -
Player wins scoring 41 points or more.
Opponent wins scoring 81 points or more.
If after the second round the total points are equal for both you and your opponent, it's a tie.
- First Round -
Player score: 80
Opponent score: 40
- Second Round -
Player score: 40
Opponent score: 80

It's a tie! 120 points for both players.
You are given two lists as parameters:
my_deck1 contains your collected cards during the first round.
my_deck2 contains your collected cards during the second round.
You have to implement a function that returns:
""You Win!"" if in the second round you totalized a higher score than your opponent's score in the first round.
""You Lose!"" if in the second round you totalized a lower score than your opponent's score in the first round.
""Draw!"" if after the second round the total points are the same for both you and your opponent.
Examples
briscola_score(
  [""3c"", ""3s"", ""Qd"", ""Jh"", ""5d"", ""Jc"", ""6d"", ""Ad"", ""Js"", ""Qc""],
  [""Jd"", ""Kd"", ""4c"", ""6s"", ""Ks"", ""5c"", ""3d"", ""As"", ""Jh"", ""6h""]
) ➞ ""You Lose!""

# You score 43 points in the first round.
# You need to score at least 78 points in the second round.
# You score 33 points in the second round.

briscola_score(
  [""Ac"", ""As"", ""3d"", ""3h"", ""3s"", ""Ah"", ""Kd""],
  [""3d"", ""Ad"", ""Ac"", ""As"", ""Ah""]
) ➞ ""You Win!""

# You score 67 points in the first round.
# You need to score at least 54 points in the second round.
# You score 54 points in the second round.

briscola_score(
  [""Ac"", ""As"", ""3d"", ""3h"", ""3s"", ""Ah"", ""Kd""],
  [""3d"", ""Ad"", ""Ac"", ""As"", ""3h""]
) ➞ ""Draw!""

# You score 67 points in the first round.
# You need to score at least 54 points in the second round.
# You score 53 points in the second round.
# Your total score is 120, and so is for your opponent.
Notes
You don't need to count the points scored by your opponent, because you know the maximum points available in a round (120).
Despite suits are important during the game, they do not influence the score when counting points.
The original standard suits and face-cards of an Italian deck are different from the international ones used for Poker. If you want to know more, take a look at the Resources tab.:def briscola_score(my_deck1, my_deck2):
  value = {'A':11,'3':10,'K':4,'Q':3,'J':2}
  score = sum(value.get(card[0], 0) for card in my_deck1 + my_deck2)
  if score > 120: return 'You Win!'
  if score < 120: return 'You Lose!'
  return 'Draw!'<|endoftext|>"
103,"<|endoftext|>Write all content of a given file into a new file by skipping line number 5:# read test.txt
with open(""test.txt"", ""r"") as fp:
    # read all lines from a file
    lines = fp.readlines()

# open new file in write mode
with open(""new_file.txt"", ""w"") as fp:
    count = 0
    # iterate each lines from a test.txt
    for line in lines:
        # skip 5th lines
        if count == 4:
            count += 1
            continue
        else:
            # write current line
            fp.write(line)
        # in each iteration reduce the count
        count += 1<|endoftext|>"
104,"<|endoftext|>Given a directed graph, find out if a vertex j is reachable from another vertex i for all vertex pairs (i, j) in the given graph. Here reachable mean that there is a path from vertex i to j. The reach-ability matrix is called the transitive closure of a graph.:# Python program for transitive closure using Floyd Warshall Algorithm
#Complexity : O(V^3)
 
from collections import defaultdict
 
#Class to represent a graph
class Graph:
 
    def __init__(self, vertices):
        self.V = vertices
 
    # A utility function to print the solution
    def printSolution(self, reach):
        print (""Following matrix transitive closure of the given graph "")   
        for i in range(self.V):
            for j in range(self.V):
                if (i == j):
                  print (""%7d\t"" % (1),end="" "")
                else:
                  print (""%7d\t"" %(reach[i][j]),end="" "")
            print()
     
     
    # Prints transitive closure of graph[][] using Floyd Warshall algorithm
    def transitiveClosure(self,graph):
        '''reach[][] will be the output matrix that will finally
        have reachability values.
        Initialize the solution matrix same as input graph matrix'''
        reach =[i[:] for i in graph]
        '''Add all vertices one by one to the set of intermediate
        vertices.
         ---> Before start of a iteration, we have reachability value
         for all pairs of vertices such that the reachability values
          consider only the vertices in set
        {0, 1, 2, .. k-1} as intermediate vertices.
          ----> After the end of an iteration, vertex no. k is
         added to the set of intermediate vertices and the
        set becomes {0, 1, 2, .. k}'''
        for k in range(self.V):
             
            # Pick all vertices as source one by one
            for i in range(self.V):
                 
                # Pick all vertices as destination for the
                # above picked source
                for j in range(self.V):
                     
                    # If vertex k is on a path from i to j,
                       # then make sure that the value of reach[i][j] is 1
                    reach[i][j] = reach[i][j] or (reach[i][k] and reach[k][j])
 
        self.printSolution(reach)
         
g= Graph(4)
 
graph = [[1, 1, 0, 1],
         [0, 1, 1, 0],
         [0, 0, 1, 1],
         [0, 0, 0, 1]]
 
#Print the solution
g.transitiveClosure(graph)
 
#This code is contributed by Neelam Yadav
<|endoftext|>"
105,"<|endoftext|>Given a matrix, check whether it’s Magic Square or not. A Magic Square is a n x n matrix of the distinct elements from 1 to n2 where the sum of any row, column, or diagonal is always equal to the same number.
Examples: 
 

Input : n = 3
  2   7   6
  9   5   1
  4   3   8
Output : Magic matrix
Explanation:In matrix sum of each
row and each column and diagonals sum is 
same = 15.

Input : n = 3
  1   2   2 
  2   2   1
  2   1   2
Output : Not a Magic Matrix
Explanation:In matrix sum of each
row and each column and diagonals sum is
not same.


 :# Python3 program to check whether a given
# matrix is magic matrix or not
# Returns true if mat[][] is magic
# square, else returns false.
def isMagicSquare( mat) :
  n = len(mat)
  # sumd1 and sumd2 are the sum of the two diagonals
  sumd1=0
  sumd2=0
  for i in range(n):
    # (i, i) is the diagonal from top-left -> bottom-right
    # (i, n - i - 1) is the diagonal from top-right -> bottom-left
    sumd1+=mat[i][i]
    sumd2+=mat[i][n-i-1]
    # if the two diagonal sums are unequal then it is not a magic square
  if not(sumd1==sumd2):
    return False
  for i in range(n):
    #sumr is rowsum and sumc is colsum
    sumr=0
    sumc=0
    for j in range(n):
      sumr+=mat[i][j]
      sumc+=mat[j][i]
    if not(sumr==sumc==sumd1):
      return False
    #if all the conditions are satisfied then it is a magic square
  return True
     
       
           
     
     
# Driver Code
mat = [ [ 2, 7, 6 ],
        [ 9, 5, 1 ],
        [ 4, 3, 8 ] ]
     
if (isMagicSquare(mat)) :
    print( ""Magic Square"")
else :
    print( ""Not a magic Square"")
    
<|endoftext|>"
106,"<|endoftext|>Given a binary tree

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

 

Example 1:


Input: root = [1,2,3,4,5,null,7]
Output: [1,#,2,3,#,4,5,7,#]
Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
Example 2:

Input: root = []
Output: []:class Solution:
    def connect(self, root: Optional['Node']) -> Optional['Node']:
        
        if not root:
            return root
        
        # Initialize a queue data structure which contains
        # just the root of the tree
        Q = collections.deque([root])
        
        # Outer while loop which iterates over 
        # each level
        while Q:
            
            # Note the size of the queue
            size = len(Q)
            
            # Iterate over all the nodes on the current level
            for i in range(size):
                
                # Pop a node from the front of the queue
                node = Q.popleft()
                
                # This check is important. We don't want to
                # establish any wrong connections. The queue will
                # contain nodes from 2 levels at most at any
                # point in time. This check ensures we only 
                # don't establish next pointers beyond the end
                # of a level
                if i < size - 1:
                    node.next = Q[0]
                
                # Add the children, if any, to the back of
                # the queue
                if node.left:
                    Q.append(node.left)
                if node.right:
                    Q.append(node.right)
        
        # Since the tree has now been modified, return the root node
        return root<|endoftext|>"
107,"<|endoftext|>In this example, you will learn to concatenate two lists in Python.:list_1 = [1, 'a']
list_2 = [3, 4, 5]

list_joined = list_1 + list_2
print(list_joined)
list_1 = [1, 'a']
list_2 = range(2, 4)

list_joined = [*list_1, *list_2]
print(list_joined)
list_1 = [1, 'a']
list_2 = [1, 2, 3]

list_joined = list(set(list_1 + list_2))
print(list_joined)
list_1 = [1, 'a']
list_2 = [1, 2, 3]

list_2.extend(list_1)
print(list_2)<|endoftext|>"
108,"<|endoftext|>Goods and Services Tax (GST):

GST is an abbreviation for Goods and Services Tax. It is a value-added tax levied on goods and services sold for domestic use or consumption. Customers pay GST to the government when they buy goods and services.



To calculate the GST percentage, first, compute the net GST amount by subtracting the original price from the net price that includes the GST. We will use the GST percent formula after calculating the net GST amount.

Formula:

GST% formula = ((GST Amount * 100)/Original price)

Net price  = Original price + GST amount

GST amount  = Net price – Original price

GST%  = ((GST amount * 100)/Original price)

round() function: round function rounds off to the nearest integer value.



Given the Net price, the original price, and the task is to calculate the GST percentage.

Examples:

Example1:

Input:

Given original price = 520
Given Net price  = 650
Output:

The GST percent for the above given input net and original prices =  25.0%
Example 2:

Input:

Given original price = 354.80
Given Net price  = 582.5
Output:

The GST percent for the above given input net and original prices =  64.17700112739571%:# Give the original price as static input and store it in a variable.
 gvn_Orignl_amt = 520
 # Give the net price as static input and store it in another variable.
 gvn_Net_amt = 650
 # Calculate the GST amount by using the above given formula and store it in
 # another variable.
 GST_amnt = gvn_Net_amt - gvn_Orignl_amt
 # Calculate the given GST percentage by using the above given formula and
 # store it in another variable.
 gvn_GST_percnt = ((GST_amnt * 100) / gvn_Orignl_amt)
 # Print the given GST value for the above given original and net prices.
 print(""The GST percent for the above given input net and original prices = "",
  gvn_GST_percnt, end='')
 print(""%"")<|endoftext|>"
109,"<|endoftext|>The program creates a circular doubly linked list and presents the user with a menu to perform various operations on the list.:class Node:
    def __init__(self, data):
       self.data = data
       self.next = None
       self.prev = None
 
 
class CircularDoublyLinkedList:
    def __init__(self):
        self.first = None
 
    def get_node(self, index):
        current = self.first
        for i in range(index):
            current = current.next
            if current == self.first:
                return None
        return current
 
    def insert_after(self, ref_node, new_node):
        new_node.prev = ref_node
        new_node.next = ref_node.next
        new_node.next.prev = new_node
        ref_node.next = new_node
 
    def insert_before(self, ref_node, new_node):
        self.insert_after(ref_node.prev, new_node)
 
    def insert_at_end(self, new_node):
        if self.first is None:
            self.first = new_node
            new_node.next = new_node
            new_node.prev = new_node
        else:
            self.insert_after(self.first.prev, new_node)
 
    def insert_at_beg(self, new_node):
        self.insert_at_end(new_node)
        self.first = new_node
 
    def remove(self, node):
        if self.first.next == self.first:
            self.first = None
        else:
            node.prev.next = node.next
            node.next.prev = node.prev
            if self.first == node:
                self.first = node.next
 
    def display(self):
        if self.first is None:
            return
        current = self.first
        while True:
            print(current.data, end = ' ')
            current = current.next
            if current == self.first:
                break
 
 
a_cdllist = CircularDoublyLinkedList()
 
print('Menu')
print('insert <data> after <index>')
print('insert <data> before <index>')
print('insert <data> at beg')
print('insert <data> at end')
print('remove <index>') 
print('quit')
 
while True:
    print('The list: ', end = '')
    a_cdllist.display()
    print()
    do = input('What would you like to do? ').split()
 
    operation = do[0].strip().lower()
 
    if operation == 'insert':
        data = int(do[1])
        position = do[3].strip().lower()
        new_node = Node(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            if position == 'beg':
                a_cdllist.insert_at_beg(new_node)
            elif position == 'end':
                a_cdllist.insert_at_end(new_node)
        else:
            index = int(position)
            ref_node = a_cdllist.get_node(index)
            if ref_node is None:
                print('No such index.')
                continue
            if suboperation == 'after':
                a_cdllist.insert_after(ref_node, new_node)
            elif suboperation == 'before':
                a_cdllist.insert_before(ref_node, new_node)
 
    elif operation == 'remove':
        index = int(do[1])
        node = a_cdllist.get_node(index)
        if node is None:
            print('No such index.')
            continue
        a_cdllist.remove(node)
 
    elif operation == 'quit':
        break<|endoftext|>"
110,"<|endoftext|>Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

Custom Judge:

The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.

 

Example 1:

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
Example 2:

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
 

Constraints:

1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
nums is sorted in non-decreasing order.:class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow = 0
        fast = 1
        l = len(nums)
        while fast<l:
            if nums[slow] == nums[fast]:fast += 1
            else:
                slow += 1
                nums[slow] ,nums[fast] = nums[fast] ,nums[slow]
                fast += 1
        return slow+1<|endoftext|>"
111,"<|endoftext|>Definition and Usage
The copy() method copies the set.:fruits = {""apple"", ""banana"", ""cherry""}

x = fruits.copy()

print(x)
<|endoftext|>"
112,"<|endoftext|>Files in Python:

Python file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python’s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.

File readline() Method in Python:

The readline() method reads one line from a file and returns it.

The size option can also be used to specify how many bytes from the line to return.

Syntax:

file.readline(size)
Parameters

size: This is Optional. The number of bytes to return from the line. The default value is -1, which implies the entire line.

Return Value:

This method’s return type is <class’str’>, which means it returns a string.:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in read mode. In this case, we're simply reading the contents of the file.
gvn_file = open(givenFilename, 'r') 
# Print only one line(first) of the file using the readline() function.
print(gvn_file.readline())<|endoftext|>"
113,"<|endoftext|>Write a program that, given an array A[] of n numbers and another number x, determines whether or not there exist two elements in A[] whose sum is exactly x. 

Examples: 

Input: arr[] = {0, -1, 2, -3, 1}
        sum = -2
Output: -3, 1
         Valid pair exists.
         
If we calculate the sum of the output,
1 + (-3) = -2

Input: arr[] = {1, -2, 1, 0, 5}
       sum = 0
Output:
        No valid pair exists.:# Python program to check if there exists a pair
# in array whose sum results in x.

# Function to find and print pair
def chkPair(A, size, x) :
	for i in range (0, size - 1) :
		for j in range (i + 1, size):
			if (A[i] + A[j] == x) :
				print(""Pair with a given sum "" , x , "" is ("" , A[i] , "", "" , A[j] , "")"")

				return True
	return False

# Driver code
A = [0, -1, 2, -3, 1]
x = -2
size = len(A)

if (chkPair(A, size, x)) :
	print(""Valid pair exists"")

else :
	print(""No valid pair exists for "" , x )

# This code is contributed by AR_Gaurav<|endoftext|>"
114,"<|endoftext|>Given an array, count those pair whose product value is present in array. 
Examples: 
 

Input : arr[] = {6, 2, 4, 12, 5, 3}
Output : 3
       All pairs whose product exist in array 
       (6 , 2) (2, 3) (4, 3)   

Input :  arr[] = {3, 5, 2, 4, 15, 8}
Output : 2 :# A hashing based C++ program to count
# pairs whose product exists in arr[]

# Returns count of pairs whose product
# exists in arr[]
def countPairs(arr, n):
	result = 0

	# Create an empty hash-set that
	# store all array element
	Hash = set()

	# Insert all array element into set
	for i in range(n):
		Hash.add(arr[i])

	# Generate all pairs and check is
	# exist in 'Hash' or not
	for i in range(n):
		for j in range(i + 1, n):
			product = arr[i] * arr[j]

			# if product exists in set then
			# we increment count by 1
			if product in(Hash):
				result += 1
	
	# return count of pairs whose
	# product exist in array
	return result

# Driver Code
if __name__ == '__main__':
	arr = [6, 2, 4, 12, 5, 3]
	n = len(arr)
	print(countPairs(arr, n))
	
# This code is contributed by
# Sanjit_Prasad<|endoftext|>"
115,"<|endoftext|>Given a Binary Tree, write a function that returns the size of the largest subtree which is also a Binary Search Tree (BST). If the complete Binary Tree is BST, then return the size of the whole tree.


 :# Python program to find largest
# BST in a Binary Tree.
 
INT_MIN = -2147483648
INT_MAX = 2147483647
 
# Helper function that allocates a new
# node with the given data and None left
# and right pointers.
class newNode:
 
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
 
# Returns Information about subtree. The
# Information also includes size of largest
# subtree which is a BST
def largestBSTBT(root):
     
# Base cases : When tree is empty or it has
    # one child.
    if (root == None):
        return 0, INT_MIN, INT_MAX, 0, True
    if (root.left == None and root.right == None) :
        return 1, root.data, root.data, 1, True
 
    # Recur for left subtree and right subtrees
    l = largestBSTBT(root.left)
    r = largestBSTBT(root.right)
 
    # Create a return variable and initialize its
    # size.
    ret = [0, 0, 0, 0, 0]
    ret[0] = (1 + l[0] + r[0])
 
    # If whole tree rooted under current root is
    # BST.
    if (l[4] and r[4] and l[1] <
        root.data and r[2] > root.data) :
     
        ret[2] = min(l[2], min(r[2], root.data))
        ret[1] = max(r[1], max(l[1], root.data))
 
        # Update answer for tree rooted under
        # current 'root'
        ret[3] = ret[0]
        ret[4] = True
 
        return ret
     
 
    # If whole tree is not BST, return maximum
    # of left and right subtrees
    ret[3] = max(l[3], r[3])
    ret[4] = False
 
    return ret
 
# Driver Code
if __name__ == '__main__':
     
    """"""Let us construct the following Tree
        60
        / \
        65 70
    /
    50 """"""
    root = newNode(60)
    root.left = newNode(65)
    root.right = newNode(70)
    root.left.left = newNode(50)
    print(""Size of the largest BST is"",
                    largestBSTBT(root)[3])
                             
# This code is contributed
# Shubham Singh(SHUBHAMSINGH10)
<|endoftext|>"
116,"<|endoftext|>In daily share trading, a buyer buys shares in the morning and sells them on the same day. If the trader is allowed to make at most 2 transactions in a day, whereas the second transaction can only start after the first one is complete (Buy->sell->Buy->sell). Given stock prices throughout the day, find out the maximum profit that a share trader could have made.:import sys

def maxtwobuysell(arr, size):
	first_buy = -sys.maxsize;
	first_sell = 0;
	second_buy = -sys.maxsize;
	second_sell = 0;

	for i in range(size):

		first_buy = max(first_buy, -arr[i]);
		first_sell = max(first_sell, first_buy + arr[i]);
		second_buy = max(second_buy, first_sell - arr[i]);
		second_sell = max(second_sell, second_buy + arr[i]);

	
	return second_sell;

if __name__ == '__main__':
	arr = [ 2, 30, 15, 10, 8, 25, 80 ];
	size = len(arr);
	print(maxtwobuysell(arr, size));

# This code is contributed by gauravrajput1<|endoftext|>"
117,"<|endoftext|>Given a binary tree in which each node element contains a number. Find the maximum possible sum from one leaf node to another. 
The maximum sum path may or may not go through root. For example, in the following binary tree, the maximum sum is 27(3 + 6 + 9 + 0 – 1 + 10). Expected time complexity is O(n).:# Python program to find maximumpath sum between two leaves
# of a binary tree

INT_MIN = -2**32

# A binary tree node


class Node:
	# Constructor to create a new node
	def __init__(self, data):
		self.data = data
		self.left = None
		self.right = None

# Utility function to find maximum sum between any
# two leaves. This function calculates two values:
# 1) Maximum path sum between two leaves which are stored
# in res
# 2) The maximum root to leaf path sum which is returned
# If one side of root is empty, then it returns INT_MIN


def maxPathSumUtil(root, res):

	# Base Case
	if root is None:
		return 0

	# Find maximumsum in left and right subtree. Also
	# find maximum root to leaf sums in left and right
	# subtrees ans store them in ls and rs
	ls = maxPathSumUtil(root.left, res)
	rs = maxPathSumUtil(root.right, res)

	# If both left and right children exist
	if root.left is not None and root.right is not None:

		# update result if needed
		res[0] = max(res[0], ls + rs + root.data)

		# Return maximum possible value for root being
		# on one side
		return max(ls, rs) + root.data

	# If any of the two children is empty, return
	# root sum for root being on one side
	if root.left is None:
		return rs + root.data
	else:
		return ls + root.data

# The main function which returns sum of the maximum
# sum path betwee ntwo leaves. THis function mainly
# uses maxPathSumUtil()


def maxPathSum(root):
	res = [INT_MIN]
	maxPathSumUtil(root, res)
	return res[0]


# Driver program to test above function
root = Node(-15)
root.left = Node(5)
root.right = Node(6)
root.left.left = Node(-8)
root.left.right = Node(1)
root.left.left.left = Node(2)
root.left.left.right = Node(6)
root.right.left = Node(3)
root.right.right = Node(9)
root.right.right.right = Node(0)
root.right.right.right.left = Node(4)
root.right.right.right.right = Node(-1)
root.right.right.right.right.left = Node(10)

print (""Max pathSum of the given binary tree is"", maxPathSum(root))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)<|endoftext|>"
118,"<|endoftext|>There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.
In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.
Your score is the sum of the points of the cards you have taken.
Given the integer array cardPoints and the integer k, return the maximum score you can obtain.
 
Example 1:

Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.

Example 2:

Input: cardPoints = [2,2,2], k = 2
Output: 4
Explanation: Regardless of which two cards you take, your score will always be 4.

Example 3:

Input: cardPoints = [9,7,7,9,7,7,9], k = 7
Output: 55
Explanation: You have to take all the cards. Your score is the sum of points of all cards.

 
Constraints:

1 <= cardPoints.length <= 105
1 <= cardPoints[i] <= 104
1 <= k <= cardPoints.length:class Solution:
  def maxScore(self, cardPoints: List[int], k: int) -> int:
  size = len(cardPoints) - k
  minSubArraySum = curr = sum(cardPoints[:size])
  
  for i in range(len(cardPoints) - size):
  curr += cardPoints[size + i] - cardPoints[i]
  minSubArraySum = min(minSubArraySum, curr)
  
  return sum(cardPoints) - minSubArraySum<|endoftext|>"
119,"<|endoftext|>The math.asin() method returns the arc sine of a number.

Note: The parameter passed in math.asin() must lie between -1 to 1.

Tip: math.asin(1) will return the value of PI/2, and math.asin(-1) will return the value of -PI/2.:# Import math Library
import math

# Return the arc sine of numbers
print(math.asin(0.55))
print(math.asin(-0.55))
print(math.asin(0))
print(math.asin(1))
print(math.asin(-1))<|endoftext|>"
120,"<|endoftext|>Given an array of n non-negative integers. The task is to find frequency of a particular element in the arbitrary range of array[]. The range is given as positions (not 0 based indexes) in array. There can be multiple queries of given type. :
# Python program to find total 
# count of an element in a range
 
# Returns count of element
# in arr[left-1..right-1]
def findFrequency(arr, n, left, right, element):
 
    count = 0
    for i in range(left - 1, right):
        if (arr[i] == element):
            count += 1
    return count
 
 
# Driver Code
arr = [2, 8, 6, 9, 8, 6, 8, 2, 11]
n = len(arr)
 
# Print frequency of 2 from position 1 to 6
print(""Frequency of 2 from 1 to 6 = "",
        findFrequency(arr, n, 1, 6, 2))
 
# Print frequency of 8 from position 4 to 9
print(""Frequency of 8 from 4 to 9 = "",
        findFrequency(arr, n, 4, 9, 8))
         
     
# This code is contributed by Anant Agarwal.<|endoftext|>"
121,"<|endoftext|>A number n is called uban if its name (in English) does not contain the letter ""u"". In particular, it cannot contain the terms ""four"", ""hundred"", and ""thousand"", so the uban number following 99 is 1,000,000.
Write a function to determine if the given integer is uban.
Examples
is_uban(456) ➞ False

is_uban(25) ➞ True

is_uban(1098) ➞ False
Notes
N/A:is_uban = lambda n:str(n)[-1]!=""4"" and len(str(n))<3 or len(str(n))>6<|endoftext|>"
122,"<|endoftext|>The program creates a Graph data structure and allows the user to add vertices and edges to it.:class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}
 
    def add_vertex(self, key):
        """"""Add a vertex with the given key to the graph.""""""
        vertex = Vertex(key)
        self.vertices[key] = vertex
 
    def get_vertex(self, key):
        """"""Return vertex object with the corresponding key.""""""
        return self.vertices[key]
 
    def __contains__(self, key):
        return key in self.vertices
 
    def add_edge(self, src_key, dest_key, weight=1):
        """"""Add edge from src_key to dest_key with given weight.""""""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)
 
    def does_edge_exist(self, src_key, dest_key):
        """"""Return True if there is an edge from src_key to dest_key.""""""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])
 
    def __iter__(self):
        return iter(self.vertices.values())
 
 
class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}
 
    def get_key(self):
        """"""Return key corresponding to this vertex object.""""""
        return self.key
 
    def add_neighbour(self, dest, weight):
        """"""Make this vertex point to dest with given edge weight.""""""
        self.points_to[dest] = weight
 
    def get_neighbours(self):
        """"""Return all vertices pointed to by this vertex.""""""
        return self.points_to.keys()
 
    def get_weight(self, dest):
        """"""Get weight of edge from this vertex to dest.""""""
        return self.points_to[dest]
 
    def does_it_point_to(self, dest):
        """"""Return True if this vertex points to dest.""""""
        return dest in self.points_to
 
 
g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest> [weight]')
print('display')
print('quit')
 
while True:
    do = input('What would you like to do? ').split()
 
    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    if len(do) == 5:
                        weight = int(do[4])
                        g.add_edge(src, dest, weight)
                    else:
                        g.add_edge(src, dest)
                else:
                    print('Edge already exists.')
 
    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()
 
        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()
 
    elif operation == 'quit':
        break<|endoftext|>"
123,"<|endoftext|>A number is non-decreasing if every digit (except the first one) is greater than or equal to previous digit. For example, 223, 4455567, 899, are non-decreasing numbers.
So, given the number of digits n, you are required to find the count of total non-decreasing numbers with n digits.:# Python3 program to count
# non-decreasing number with n digits
def countNonDecreasing(n):
     
    # dp[i][j] contains total count
    # of non decreasing numbers ending
    # with digit i and of length j
    dp = [[0 for i in range(n + 1)]
             for i in range(10)]
              
    # Fill table for non decreasing
    # numbers of length 1.
    # Base cases 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
 
    for i in range(10):
        dp[i][1] = 1
 
    # Fill the table in bottom-up manner
    for digit in range(10):
         
        # Compute total numbers of non
        # decreasing numbers of length 'len'
        for len in range(2, n + 1):
             
            # sum of all numbers of length
            # of len-1 in which last
            # digit x is <= 'digit'
            for x in range(digit + 1):
                dp[digit][len] += dp[x][len - 1]
    count = 0
     
    # There total nondecreasing numbers
    # of length n won't be dp[0][n] +
    # dp[1][n] ..+ dp[9][n]
    for i in range(10):
        count += dp[i][n]
    return count
     
# Driver Code
n = 3
print(countNonDecreasing(n))
 
# This code is contributed
# by sahilshelangia<|endoftext|>"
124,"<|endoftext|>You are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi.

Return true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise.

An integer x is covered by an interval ranges[i] = [starti, endi] if starti <= x <= endi.

 :class Solution:

def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
    # loop throught the range from left and right, inclusively
    for i in range(left, right + 1):
        # check if the number is between any interval
        # put this variable to see if the number is found in any range
        in_range = False
        for interval in ranges:
            # if the number is found, we set the boolean true
            if i >= interval[0] and i <= interval[1]:
                in_range = True
                break
        if not in_range:
            return False
    
    return True<|endoftext|>"
125,"<|endoftext|>Given a singly linked list, select a random node from linked list (the probability of picking a node should be 1/N if there are N nodes in list). You are given a random number generator.
Below is a Simple Solution 
1) Count number of nodes by traversing the list. 
2) Traverse the list again and select every node with probability 1/N. The selection can be done by generating a random number from 0 to N-i for i’th node, and selecting the i’th node only if generated number is equal to 0 (or any other fixed number from 0 to N-i). 
We get uniform probabilities with above schemes. 

i = 1, probability of selecting first node = 1/N
i = 2, probability of selecting second node =
                   [probability that first node is not selected] * 
                   [probability that second node is selected]
                  = ((N-1)/N)* 1/(N-1)
                  = 1/N  
Similarly, probabilities of other selecting other nodes is 1/N
The above solution requires two traversals of linked list. 
How to select a random node with only one traversal allowed? 
The idea is to use Reservoir Sampling. Following are the steps. This is a simpler version of Reservoir Sampling as we need to select only one key instead of k keys. 
(1) Initialize result as first node
   result = head->key 
(2) Initialize n = 2
(3) Now one by one consider all nodes from 2nd node onward.
    (3.a) Generate a random number from 0 to n-1. 
         Let the generated random number is j.
    (3.b) If j is equal to 0 (we could choose other fixed number 
          between 0 to n-1), then replace result with current node.
    (3.c) n = n+1
    (3.d) current = current->next:# Python program to randomly select a node from singly
# linked list

import random

# Node class
class Node:

	# Constructor to initialize the node object
	def __init__(self, data):
		self.data= data
		self.next = None

class LinkedList:

	# Function to initialize head
	def __init__(self):
		self.head = None

	# A reservoir sampling based function to print a
	# random node from a linked list
	def printRandom(self):

		# If list is empty
		if self.head is None:
			return
		if self.head and not self.head.next:
		print (""Randomly selected key is %d"" %(self.head.data))

		# Use a different seed value so that we don't get
		# same result each time we run this program
		random.seed()

		# Initialize result as first node
		result = self.head.data

		# Iterate from the (k+1)th element nth element
		# because we iterate from (k+1)th element, or
		# the first node will be picked more easily
		current = self.head.next
		n = 2
		while(current is not None):
			
			# change result with probability 1/n
			if (random.randrange(n) == 0 ):
				result = current.data

			# Move to next node
			current = current.next
			n += 1

		print (""Randomly selected key is %d"" %(result))
		
	# Function to insert a new node at the beginning
	def push(self, new_data):
		new_node = Node(new_data)
		new_node.next = self.head
		self.head = new_node

	# Utility function to print the LinkedList
	def printList(self):
		temp = self.head
		while(temp):
			print (temp.data,end="" "")
			temp = temp.next


# Driver program to test above function
llist = LinkedList()
llist.push(5)
llist.push(20)
llist.push(4)
llist.push(3)
llist.push(30)
llist.printRandom()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)<|endoftext|>"
126,"<|endoftext|>Given an integer array of size n, find the maximum of the minimum’s of every window size in the array. Note that window size varies from 1 to n.:# A naive method to find maximum of
# minimum of all windows of different sizes
INT_MIN = -1000000
def printMaxOfMin(arr, n):
     
    # Consider all windows of different
    # sizes starting from size 1
    for k in range(1, n + 1):
         
        # Initialize max of min for
        # current window size k
        maxOfMin = INT_MIN;
 
        # Traverse through all windows
        # of current size k
        for i in range(n - k + 1):
             
            # Find minimum of current window
            min = arr[i]
            for j in range(k):
                if (arr[i + j] < min):
                    min = arr[i + j]
 
            # Update maxOfMin if required
            if (min > maxOfMin):
                maxOfMin = min
                 
        # Print max of min for current window size
        print(maxOfMin, end = "" "")
 
# Driver Code
arr = [10, 20, 30, 50, 10, 70, 30]
n = len(arr)
printMaxOfMin(arr, n)
 
# This code is contributed by sahilshelangia
<|endoftext|>"
127,"<|endoftext|>Implementing artificial neural network:
from joblib.numpy_pickle_utils import xrange
from numpy import *
 
 
class NeuralNet(object):
    def __init__(self):
        # Generate random numbers
        random.seed(1)
 
        # Assign random weights to a 3 x 1 matrix,
        self.synaptic_weights = 2 * random.random((3, 1)) - 1
 
    # The Sigmoid function
    def __sigmoid(self, x):
        return 1 / (1 + exp(-x))
 
    # The derivative of the Sigmoid function.
    # This is the gradient of the Sigmoid curve.
    def __sigmoid_derivative(self, x):
        return x * (1 - x)
 
    # Train the neural network and adjust the weights each time.
    def train(self, inputs, outputs, training_iterations):
        for iteration in xrange(training_iterations):
            # Pass the training set through the network.
            output = self.learn(inputs)
 
            # Calculate the error
            error = outputs - output
 
            # Adjust the weights by a factor
            factor = dot(inputs.T, error * self.__sigmoid_derivative(output))
            self.synaptic_weights += factor
 
        # The neural network thinks.
 
    def learn(self, inputs):
        return self.__sigmoid(dot(inputs, self.synaptic_weights))
 
 
if __name__ == ""__main__"":
    # Initialize
    neural_network = NeuralNet()
 
    # The training set.
    inputs = array([[0, 1, 1], [1, 0, 0], [1, 0, 1]])
    outputs = array([[1, 0, 1]]).T
 
    # Train the neural network
    neural_network.train(inputs, outputs, 10000)
 
    # Test the neural network with a test example.
    print(neural_network.learn(array([1, 0, 1])))<|endoftext|>"
128,"<|endoftext|>Given an array of size n where all elements are distinct and in range from 0 to n-1, change contents of arr[] so that arr[i] = j is changed to arr[j] = i. 
Examples: 
 

Example 1:
Input: arr[]  = {1, 3, 0, 2};
Output: arr[] = {2, 0, 3, 1};
Explanation for the above output.
Since arr[0] is 1, arr[1] is changed to 0
Since arr[1] is 3, arr[3] is changed to 1
Since arr[2] is 0, arr[0] is changed to 2
Since arr[3] is 2, arr[2] is changed to 3

Example 2:
Input: arr[]  = {2, 0, 1, 4, 5, 3};
Output: arr[] = {1, 2, 0, 5, 3, 4};

Example 3:
Input: arr[]  = {0, 1, 2, 3};
Output: arr[] = {0, 1, 2, 3};

Example 4:
Input: arr[]  = {3, 2, 1, 0};
Output: arr[] = {3, 2, 1, 0};:# A simple Python3 program to rearrange
# contents of arr[] such that arr[j]
# becomes j if arr[i] is j

# A simple method to rearrange
# 'arr[0..n-1]' so that 'arr[j]'
# becomes 'i' if 'arr[i]' is 'j'
def rearrangeNaive(arr, n):

	# Create an auxiliary array
	# of same size
	temp = [0] * n
	
	# Store result in temp[]
	for i in range(0, n):
		temp[arr[i]] = i

	# Copy temp back to arr[]
	for i in range(0, n):
		arr[i] = temp[i]


	# A utility function to print
	# contents of arr[0..n-1]
def printArray(arr, n):
	for i in range(0, n):
		print(arr[i], end = "" "")

# Driver program
arr = [1, 3, 0, 2]
n = len(arr)
print(""Given array is"", end = "" "")
printArray(arr, n)

rearrangeNaive(arr, n)
print(""\nModified array is"", end = "" "")
printArray(arr, n)

# This code is contributed by Smitha Dinesh Semwal<|endoftext|>"
129,"<|endoftext|>This python program calculates simple and compound interest where principal amount, rate and time are given by user.
Following formula are used in this program to calculate simple and compound interest:

Simple Interest = (P*T*R)/100

Compound Interest = P * ( (1+r/100 )t - 1):# Simple and Compound Interest

# Reading principal amount, rate and time
principal = float(input('Enter amount: '))
time = float(input('Enter time: '))
rate = float(input('Enter rate: '))

# Calcualtion
simple_interest = (principal*time*rate)/100
compound_interest = principal * ( (1+rate/100)**time - 1)

# Displaying result
print('Simple interest is: %f' % (simple_interest))
print('Compound interest is: %f' %(compound_interest))<|endoftext|>"
130,"<|endoftext|>Create a function that calculates the missing value of 3 inputs using Ohm's law. The inputs are v, r or i (aka: voltage, resistance and current).
Ohm's law:
V = R * I
Return the missing value rounded to two decimal places.
Examples
ohms_law(12, 220, None) ➞ 0.05

ohms_law(230, None, 2) ➞ 115

ohms_law(None, 220, 0.02) ➞ 4.4

ohms_law(None, None, 10) ➞ ""Invalid""

ohms_law(500, 50, 10) ➞ ""Invalid""
Notes
Missing values will be None
If there is more than one missing value, or no missing value, return ""Invalid""
Only numbers will be given.:def ohms_law(u, r, i):
    if (u, r, i).count(None) != 1:
        return ""Invalid""
    elif u is None:
        return r * i
    elif r is None:
        return u / i
    elif i is None:
        return round(u / r, 2)<|endoftext|>"
131,"<|endoftext|>A sentence is a list of words that are separated by a single space with no leading or trailing spaces.

You are given an array of strings sentences, where each sentences[i] represents a single sentence.

Return the maximum number of words that appear in a single sentence.:class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int:
        max=0
        for i in sentences:
            temp=i.split("" "")
            res=len(temp)
            if res>max:
                max=res
        return max<|endoftext|>"
132,"<|endoftext|>Write a function to delete a given node in a doubly-linked list. :# Program to delete a node in a doubly-linked list

# for Garbage collection
import gc

# A node of the doubly linked list
class Node:
	
	# Constructor to create a new node
	def __init__(self, data):
		self.data = data
		self.next = None
		self.prev = None

class DoublyLinkedList:
	# Constructor for empty Doubly Linked List
	def __init__(self):
		self.head = None

# Function to delete a node in a Doubly Linked List.
# head_ref --> pointer to head node pointer.
# dele --> pointer to node to be deleted

	def deleteNode(self, dele):
		
		# Base Case
		if self.head is None or dele is None:
			return
		
		# If node to be deleted is head node
		if self.head == dele:
			self.head = dele.next

		# Change next only if node to be deleted is NOT
		# the last node
		if dele.next is not None:
			dele.next.prev = dele.prev
	
		# Change prev only if node to be deleted is NOT
		# the first node
		if dele.prev is not None:
			dele.prev.next = dele.next
		# Finally, free the memory occupied by dele
		# Call python garbage collector
		gc.collect()


	# Given a reference to the head of a list and an
	# integer, inserts a new node on the front of list
	def push(self, new_data):

		# 1. Allocates node
		# 2. Put the data in it
		new_node = Node(new_data)

		# 3. Make next of new node as head and
		# previous as None (already None)
		new_node.next = self.head

		# 4. change prev of head node to new_node
		if self.head is not None:
			self.head.prev = new_node

		# 5. move the head to point to the new node
		self.head = new_node


	def printList(self, node):
		while(node is not None):
			print(node.data,end=' ')
			node = node.next


# Driver program to test the above functions

# Start with empty list
dll = DoublyLinkedList()

# Let us create the doubly linked list 10<->8<->4<->2
dll.push(2);
dll.push(4);
dll.push(8);
dll.push(10);

print (""\n Original Linked List"",end=' ')
dll.printList(dll.head)

# delete nodes from doubly linked list
dll.deleteNode(dll.head)
dll.deleteNode(dll.head.next)
dll.deleteNode(dll.head.next)
# Modified linked list will be NULL<-8->NULL
print(""\n Modified Linked List"",end=' ')
dll.printList(dll.head)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)<|endoftext|>"
133,"<|endoftext|>In the previous post, we discussed range update and point query solutions using BIT. 
rangeUpdate(l, r, val) : We add ‘val’ to element at index ‘l’. We subtract ‘val’ from element at index ‘r+1’. 
getElement(index) [or getSum()]: We return sum of elements from 0 to index which can be quickly obtained using BIT.
We can compute rangeSum() using getSum() queries. 
rangeSum(l, r) = getSum(r) – getSum(l-1):# Python program to demonstrate Range Update
# and Range Queries using BIT
 
# Returns sum of arr[0..index]. This function assumes
# that the array is preprocessed and partial sums of
# array elements are stored in BITree[]
def getSum(BITree: list, index: int) -> int:
    summ = 0 # Initialize result
 
    # index in BITree[] is 1 more than the index in arr[]
    index = index + 1
 
    # Traverse ancestors of BITree[index]
    while index > 0:
 
        # Add current element of BITree to sum
        summ += BITree[index]
 
        # Move index to parent node in getSum View
        index -= index & (-index)
    return summ
 
# Updates a node in Binary Index Tree (BITree) at given
# index in BITree. The given value 'val' is added to
# BITree[i] and all of its ancestors in tree.
def updateBit(BITTree: list, n: int, index: int, val: int) -> None:
 
    # index in BITree[] is 1 more than the index in arr[]
    index = index + 1
 
    # Traverse all ancestors and add 'val'
    while index <= n:
 
        # Add 'val' to current node of BI Tree
        BITTree[index] += val
 
        # Update index to that of parent in update View
        index += index & (-index)
 
 
# Returns the sum of array from [0, x]
def summation(x: int, BITTree1: list, BITTree2: list) -> int:
    return (getSum(BITTree1, x) * x) - getSum(BITTree2, x)
 
 
def updateRange(BITTree1: list, BITTree2: list, n: int, val: int, l: int,
                r: int) -> None:
 
    # Update Both the Binary Index Trees
    # As discussed in the article
 
    # Update BIT1
    updateBit(BITTree1, n, l, val)
    updateBit(BITTree1, n, r + 1, -val)
 
    # Update BIT2
    updateBit(BITTree2, n, l, val * (l - 1))
    updateBit(BITTree2, n, r + 1, -val * r)
 
def rangeSum(l: int, r: int, BITTree1: list, BITTree2: list) -> int:
 
    # Find sum from [0,r] then subtract sum
    # from [0,l-1] in order to find sum from
    # [l,r]
    return summation(r, BITTree1, BITTree2) - summation(
        l - 1, BITTree1, BITTree2)
 
# Driver Code
if __name__ == ""__main__"":
    n = 5
 
    # BIT1 to get element at any index
    # in the array
    BITTree1 = [0] * (n + 1)
 
    # BIT 2 maintains the extra term
    # which needs to be subtracted
    BITTree2 = [0] * (n + 1)
 
    # Add 5 to all the elements from [0,4]
    l = 0
    r = 4
    val = 5
    updateRange(BITTree1, BITTree2, n, val, l, r)
 
    # Add 2 to all the elements from [2,4]
    l = 2
    r = 4
    val = 10
    updateRange(BITTree1, BITTree2, n, val, l, r)
 
    # Find sum of all the elements from
    # [1,4]
    l = 1
    r = 4
    print(""Sum of elements from [%d,%d] is %d"" %
        (l, r, rangeSum(l, r, BITTree1, BITTree2)))
 
# This code is contributed by
# sanjeev2552<|endoftext|>"
134,"<|endoftext|>Given a two dimensional array, Write a program to print lower triangular matrix and upper triangular matrix. 

Lower triangular matrix is a matrix which contains elements below principle diagonal including principle diagonal elements and rest of the elements are 0.
Upper triangular matrix is a matrix which contains elements above principle diagonal including principle diagonal elements and rest of the elements are 0.:# Python3 program to print Lower
# triangular and Upper triangular
# matrix of an array
 
# Function to form lower triangular
# matrix
def lower(matrix, row, col):
 
     
    for i in range(0, row):
     
        for j in range(0, col):
         
            if (i < j):
             
                print(""0"", end = "" "");
             
            else:
                print(matrix[i][j],
                       end = "" "" );
         
        print("" "");
     
# Function to form upper triangular matrix
def upper(matrix, row, col):
 
    for i in range(0, row):
     
        for j in range(0, col):
         
            if (i > j):
                print(""0"", end = "" "");
             
            else:
                print(matrix[i][j],
                       end = "" "" );
         
        print("" "");
 
# Driver Code
matrix = [[1, 2, 3],
          [4, 5, 6],
          [7, 8, 9]];
row = 3;
col = 3;
     
print(""Lower triangular matrix: "");
lower(matrix, row, col);
     
print(""Upper triangular matrix: "");
upper(matrix, row, col);
         
# This code is contributed by
# Shivi_Aggarwal
<|endoftext|>"
135,"<|endoftext|>Given a Binary Tree (BT), convert it to a Doubly Linked List(DLL) In-Place. The left and right pointers in nodes are to be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be same as Inorder of the given Binary Tree. The first node of Inorder traversal (left most node in BT) must be head node of the DLL.:# Python3 program to convert a given Binary Tree to Doubly Linked List
class Node:
	def __init__(self, data):
		self.data = data
		self.left = self.right = None

class BinaryTree:
	# A simple recursive function to convert a given
	# Binary tree to Doubly Linked List
	# root --> Root of Binary Tree
	# head --> Pointer to head node of created doubly linked list
	root, head = None, None
	
	def BToDll(self, root: Node):
		if root is None:
			return

		# Recursively convert right subtree
		self.BToDll(root.right)

		# Insert root into doubly linked list
		root.right = self.head

		# Change left pointer of previous head
		if self.head is not None:
			self.head.left = root

		# Change head of doubly linked list
		self.head = root

		# Recursively convert left subtree
		self.BToDll(root.left)

	@staticmethod
	def print_list(head: Node):
		print('Extracted Double Linked list is:')
		while head is not None:
			print(head.data, end = ' ')
			head = head.right

# Driver program to test above function
if __name__ == '__main__':
	
	""""""
	Constructing below tree
			5
		// \\
		3 6
		// \\ \\
		1 4 8
	// \\ // \\
	0 2 7 9
	""""""
	tree = BinaryTree()
	tree.root = Node(5)
	tree.root.left = Node(3)
	tree.root.right = Node(6)
	tree.root.left.left = Node(1)
	tree.root.left.right = Node(4)
	tree.root.right.right = Node(8)
	tree.root.left.left.left = Node(0)
	tree.root.left.left.right = Node(2)
	tree.root.right.right.left = Node(7)
	tree.root.right.right.right = Node(9)

	tree.BToDll(tree.root)
	tree.print_list(tree.head)

# This code is contributed by Rajat Srivastava
<|endoftext|>"
136,"<|endoftext|>A succinct encoding of Binary Tree takes close to minimum possible space. The number of structurally different binary trees on n nodes is n’th Catalan number. For large n, this is about 4n; thus we need at least about log2 4 n = 2n bits to encode it. A succinct binary tree therefore would occupy 2n+o(n) bits.:# Python program to demonstrate Succinct Tree Encoding and Decoding
 
# Node structure
class Node:
    # Utility function to create new Node
    def __init__(self , key):
        self.key = key
        self.left = None
        self.right = None
 
def EncodeSuccinct(root , struc , data):
     
    # If root is None , put 0 in structure array and return
    if root is None :
        struc.append(0)
        return
 
    # Else place 1 in structure array, key in 'data' array
    # and recur for left and right children
    struc.append(1)
    data.append(root.key)
    EncodeSuccinct(root.left , struc , data)
    EncodeSuccinct(root.right , struc ,data)
     
 
# Constructs tree from 'struc' and 'data'
def DecodeSuccinct(struc , data):
    if(len(struc) <= 0):
        return None
     
    # Remove one item from structure list
    b = struc[0]
    struc.pop(0)
     
    # If removed bit is 1
    if b == 1:
        key = data[0]
        data.pop(0)
     
        #Create a tree node with removed data
        root = Node(key)
 
        #And recur to create left and right subtrees
        root.left = DecodeSuccinct(struc , data);
        root.right = DecodeSuccinct(struc , data);
        return root
 
    return None
 
 
def preorder(root):
    if root is not None:
        print (""key: %d"" %(root.key),end="" "")
             
        if root.left is not None:
            print (""| left child: %d"" %(root.left.key),end="" "")
        if root.right is not None:
            print (""| right child %d"" %(root.right.key),end="" "")
        print ()
        preorder(root.left)
        preorder(root.right)
 
# Driver Program
root = Node(10)
root.left = Node(20)
root.right = Node(30)
root.left.left = Node(40)
root.left.right = Node(50)
root.right.right = Node(70)        
 
print (""Given Tree"")
preorder(root)
struc = []
data = []
EncodeSuccinct(root , struc , data)
 
print (""\nEncoded Tree"")
print (""Structure List"")
 
for i in struc:
    print (i ,end="" "")
 
print (""\nDataList"")
for value in data:
    print (value,end="" "")
 
newroot = DecodeSuccinct(struc , data)
 
print (""\n\nPreorder Traversal of decoded tree"")
preorder(newroot)
 
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
<|endoftext|>"
137,"<|endoftext|>Given a matrix of N * M. Find the maximum path sum in matrix. The maximum path is sum of all elements from first row to last row where you are allowed to move only down or diagonally to left or right. You can start from any element in first row.:# Python 3 program for finding max path in matrix
# To calculate max path in matrix

def findMaxPath(mat):

        for i in range(1, N):

                res = -1
                for j in range(M):

                        # When all paths are possible
                        if (j > 0 and j < M - 1):
                                mat[i][j] += max(mat[i - 1][j],
                                                                max(mat[i - 1][j - 1],
                                                                        mat[i - 1][j + 1]))

                        # When diagonal right is not possible
                        else if (j > 0):
                                mat[i][j] += max(mat[i - 1][j],
                                                                mat[i - 1][j - 1])

                        # When diagonal left is not possible
                        else if (j < M - 1):
                                mat[i][j] += max(mat[i - 1][j],
                                                                mat[i - 1][j + 1])

                        # Store max path sum
                        res = max(mat[i][j], res)
        return res

# Driver program to check findMaxPath
N=4
M=6
mat = ([[ 10, 10, 2, 0, 20, 4 ],
                [ 1, 0, 0, 30, 2, 5 ],
                [ 0, 10, 4, 0, 2, 0 ],
                [ 1, 0, 2, 20, 0, 4 ]])
                        
print(findMaxPath(mat))

# This code is contributed by Azkia Anam.
<|endoftext|>"
138,"<|endoftext|>Create the function that takes a list of dictionaries and returns the sum of people's budgets.
Examples
get_budgets([
  { ""name"": ""John"", ""age"": 21, ""budget"": 23000 },
  { ""name"": ""Steve"",  ""age"": 32, ""budget"": 40000 },
  { ""name"": ""Martin"",  ""age"": 16, ""budget"": 2700 }
]) ➞ 65700

get_budgets([
  { ""name"": ""John"",  ""age"": 21, ""budget"": 29000 },
  { ""name"": ""Steve"",  ""age"": 32, ""budget"": 32000 },
  { ""name"": ""Martin"",  ""age"": 16, ""budget"": 1600 }
]) ➞ 62600
Notes
N/A:def get_budgets(lst):
  return sum(i['budget'] for i in lst)<|endoftext|>"
139,"<|endoftext|>In this program, you'll learn to find the factors of a number using the for loop.:# Python Program to find the factors of a number

# This function computes the factor of the argument passed
def print_factors(x):
   print(""The factors of"",x,""are:"")
   for i in range(1, x + 1):
       if x % i == 0:
           print(i)

num = 320

print_factors(num)<|endoftext|>"
140,"<|endoftext|>You are given an array of n-elements, you have to find the number of operations needed to make all elements of array equal. Where a single operation can increment an element by k. If it is not possible to make all elements equal print -1.:# Python3 Program to make all array equal
 
# function for calculating min operations
def minOps(arr, n, k):
 
    # max elements of array
    max1 = max(arr)
    res = 0
 
    # iterate for all elements
    for i in range(0, n):
 
        # check if element can make equal to
        # max or not if not then return -1
        if ((max1 - arr[i]) % k != 0):
            return -1
 
        # else update res fo
        # required operations
        else:
            res += (max1 - arr[i]) / k
     
    # return result
    return int(res)
 
# driver program
arr = [21, 33, 9, 45, 63]
n = len(arr)
k = 6
print(minOps(arr, n, k))
 
# This code is contributed by
# Smitha Dinesh Semwal<|endoftext|>"
141,"<|endoftext|>Given a BST (Binary Search Tree) that may be unbalanced, convert it into a balanced BST that has minimum possible height.:# Python3 program to convert a left
# unbalanced BST to a balanced BST
import sys
import math
 
# A binary tree node has data, pointer to left child
# and a pointer to right child
class Node:
    def __init__(self,data):
        self.data=data
        self.left=None
        self.right=None
 
# This function traverse the skewed binary tree and
# stores its nodes pointers in vector nodes[]
def storeBSTNodes(root,nodes):
     
    # Base case
    if not root:
        return
     
    # Store nodes in Inorder (which is sorted
    # order for BST)
    storeBSTNodes(root.left,nodes)
    nodes.append(root)
    storeBSTNodes(root.right,nodes)
 
# Recursive function to construct binary tree
def buildTreeUtil(nodes,start,end):
     
    # base case
    if start>end:
        return None
 
    # Get the middle element and make it root
    mid=(start+end)//2
    node=nodes[mid]
 
    # Using index in Inorder traversal, construct
    # left and right subtress
    node.left=buildTreeUtil(nodes,start,mid-1)
    node.right=buildTreeUtil(nodes,mid+1,end)
    return node
 
# This functions converts an unbalanced BST to
# a balanced BST
def buildTree(root):
     
    # Store nodes of given BST in sorted order
    nodes=[]
    storeBSTNodes(root,nodes)
 
    # Constructs BST from nodes[]
    n=len(nodes)
    return buildTreeUtil(nodes,0,n-1)
 
# Function to do preorder traversal of tree
def preOrder(root):
    if not root:
        return
    print(""{} "".format(root.data),end="""")
    preOrder(root.left)
    preOrder(root.right)
 
# Driver code
if __name__=='__main__':
    # Constructed skewed binary tree is
    #         10
    #         /
    #         8
    #         /
    #     7
    #     /
    #     6
    #     /
    # 5
    root = Node(10)
    root.left = Node(8)
    root.left.left = Node(7)
    root.left.left.left = Node(6)
    root.left.left.left.left = Node(5)
    root = buildTree(root)
    print(""Preorder traversal of balanced BST is :"")
    preOrder(root)
     
# This code has been contributed by Vikash Kumar 37
<|endoftext|>"
142,"<|endoftext|>Given a Directed Graph and two vertices in it, check whether there is a path from the first given vertex to second. 
:# Python3 program to find shortest path
# with exactly k edges

# Define number of vertices in the graph
# and infinite value

# A naive recursive function to count
# walks from u to v with k edges
def shortestPath(graph, u, v, k):
        V = 4
        INF = 999999999999
        
        # Base cases
        if k == 0 and u == v:
                return 0
        if k == 1 and graph[u][v] != INF:
                return graph[u][v]
        if k <= 0:
                return INF

# Initialize result
        res = INF

# Go to all adjacents of u and recur
        for i in range(V):
                if graph[u][i] != INF and u != i and v != i:
                        rec_res = shortestPath(graph, i, v, k - 1)
                        if rec_res != INF:
                                res = min(res, graph[u][i] + rec_res)
        return res

# Driver Code
if __name__ == '__main__':
        INF = 999999999999
        
        # Let us create the graph shown
        # in above diagram
        graph = [[0, 10, 3, 2],
                        [INF, 0, INF, 7],
                        [INF, INF, 0, 6],
                        [INF, INF, INF, 0]]
        u = 0
        v = 3
        k = 2
        print(""Weight of the shortest path is"",
                        shortestPath(graph, u, v, k))

# This code is contributed by PranchalK
<|endoftext|>"
143,"<|endoftext|>Create a function that takes an initial word and extracts any words that start with the same letters as the initial word.
Examples
dictionary(""bu"", [""button"", ""breakfast"", ""border""]) ➞ [""button""]

dictionary(""tri"", [""triplet"", ""tries"", ""trip"", ""piano"", ""tree""]) ➞ [""triplet"", ""tries"", trip""]

dictionary(""beau"", [""pastry"", ""delicious"", ""name"", ""boring""]) ➞ []
Notes
If none of the words match, return an empty list.
Keep the filtered list in the same relative order as the original list of words.:def dictionary(initial, words):
  return [i for i in words if i.startswith(initial)]<|endoftext|>"
144,"<|endoftext|>Given the number of rows and columns, the task is to print 1 and 0 in alternative rows in C, C++, and Python.:# Give the number of rows and number of columns as static input.
# Store them in two separate variables row numbers and column numbers.
rownumbs = 15
colnumbs = 11
# Run an outer loop from 1 to rows to iterate through the rows using For loop.
for m in range(1, rownumbs+1):
  # Iterate through the columns from 1 to cols using another For inner loop.
    for n in range(1, colnumbs+1):
      # Before printing any number, we must first check the condition inside the inner loop.
      # This means that for every odd row, 1 is displayed, and for every even row, 0 is displayed.
          # We check whether the row is odd or not using the if statement.
      # If it is true then print 1 else print 0.
        if(m % 2 == 1):
            print('1', end=' ')
        # If it is true then print 1 else print 0.
        else:
            print('0', end=' ')
    print()<|endoftext|>"
145,"<|endoftext|>This algorithm finds all occurrences of a pattern in a text in linear time. Let length of text be n and of pattern be m, then total time taken is O(m + n) with linear space complexity. Now we can see that both time and space complexity is same as KMP algorithm but this algorithm is Simpler to understand.
In this algorithm, we construct a Z array.:# Python3 program that implements Z algorithm
# for pattern searching
 
# Fills Z array for given string str[]
def getZarr(string, z):
    n = len(string)
 
    # [L,R] make a window which matches
    # with prefix of s
    l, r, k = 0, 0, 0
    for i in range(1, n):
 
        # if i>R nothing matches so we will calculate.
        # Z[i] using naive way.
        if i > r:
            l, r = i, i
 
            # R-L = 0 in starting, so it will start
            # checking from 0'th index. For example,
            # for ""ababab"" and i = 1, the value of R
            # remains 0 and Z[i] becomes 0. For string
            # ""aaaaaa"" and i = 1, Z[i] and R become 5
            while r < n and string[r - l] == string[r]:
                r += 1
            z[i] = r - l
            r -= 1
        else:
 
            # k = i-L so k corresponds to number which
            # matches in [L,R] interval.
            k = i - l
 
            # if Z[k] is less than remaining interval
            # then Z[i] will be equal to Z[k].
            # For example, str = ""ababab"", i = 3, R = 5
            # and L = 2
            if z[k] < r - i + 1:
                z[i] = z[k]
 
            # For example str = ""aaaaaa"" and i = 2,
            # R is 5, L is 0
            else:
 
                # else start from R and check manually
                l = i
                while r < n and string[r - l] == string[r]:
                    r += 1
                z[i] = r - l
                r -= 1
 
# prints all occurrences of pattern
# in text using Z algo
def search(text, pattern):
 
    # Create concatenated string ""P$T""
    concat = pattern + ""$"" + text
    l = len(concat)
 
    # Construct Z array
    z = [0] * l
    getZarr(concat, z)
 
    # now looping through Z array for matching condition
    for i in range(l):
 
        # if Z[i] (matched region) is equal to pattern
        # length we got the pattern
        if z[i] == len(pattern):
            print(""Pattern found at index"",
                      i - len(pattern) - 1)
 
# Driver Code
if __name__ == ""__main__"":
    text = ""GEEKS FOR GEEKS""
    pattern = ""GEEK""
    search(text, pattern)
 
# This code is contributed by
# sanjeev2552<|endoftext|>"
146,"<|endoftext|>In Python, there are many methods available on the list data type that help you remove an element from a given list. In this post, we will discuss how to remove items or elements from the list using remove(), pop(), clear(), and del operator. We will take a list while declaring the variables then the Python program removes the element from the list. Finally, the new list will be displayed on the screen.:# Python program to remove item from list # take list my_list = ['C', 'Java', 'Python', 'HTML', 'Javascript'] # printing original list print('List:', my_list) # removed HTML from the list my_list.remove('HTML') # print list after item deletion print('New list:', my_list)<|endoftext|>"
147,"<|endoftext|>You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e., 0 <= i < n).
In one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.
Given an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.
 
Example 1:

Input: n = 3
Output: 2
Explanation: arr = [1, 3, 5]
First operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]
In the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].

Example 2:

Input: n = 6
Output: 9

 
Constraints:

1 <= n <= 104:class Solution:
  def minOperations(self, n: int) -> int:
  return n * n // 4<|endoftext|>"
148,"<|endoftext|>Create a function that converts Celsius to Fahrenheit and vice versa.
Examples
convert(""35*C"") ➞ ""95*F""

convert(""19*F"") ➞ ""-7*C""

convert(""33"") ➞ ""Error""
Notes
Round to the nearest integer.
If the input is incorrect, return ""Error"".
For the formulae to convert back and forth, check the Resources tab.:def convert(deg):
    try:
      temp, unit = deg.split('*')
    except:
      return 'Error'
        if unit == 'F':
      return str(round((int(temp) - 32) / 1.8)) + '*' + 'C'
          if unit == 'C':
      return str(round((int(temp) * 1.8) + 32)) + '*' + 'F'<|endoftext|>"
149,"<|endoftext|>Write a function that takes a string of one or more words as an argument and returns the same string, but with all five or more letter words reversed. Strings passed in will consist of only letters and spaces. Spaces will be included only when more than one word is present.
Examples
reverse(""Reverse"") ➞ ""esreveR""

reverse(""This is a typical sentence."") ➞ ""This is a lacipyt .ecnetnes""

reverse(""The dog is big."") ➞ ""The dog is big.""
Notes
You can expect a valid string to be provided for each test case.:def reverse(txt):
    return "" "".join([x if len(x) < 5 else x[::-1] for x in txt.split()])<|endoftext|>"
150,"<|endoftext|>Instructions
Take a nested list and return a single flattened list with all values except nil/null.

The challenge is to write a function that accepts an arbitrarily-deep nested list-like structure and returns a flattened structure without any nil/null values.

For Example

input: [1,[2,3,null,4],[null],5]

output: [1,2,3,4,5]:"""""" Exercism flatten array exercise """"""
def flatten(iterable):
    array = []
    for item in iterable:
        if isinstance(item, int):
            array.append(item)
        elif isinstance(item, list):
            array += flatten(item)
    return array<|endoftext|>"
151,"<|endoftext|>Add Methods
:class Student(Person):
  def __init__(self, fname, lname, year):
    super().__init__(fname, lname)
    self.graduationyear = year

  def welcome(self):
    print(""Welcome"", self.firstname, self.lastname, ""to the class of"", self.graduationyear)<|endoftext|>"
152,"<|endoftext|>Given an array and a number k where k is smaller than the size of the array, we need to find the k’th smallest element in the given array. It is given that all array elements are distinct.

Examples: 

Input: arr[] = {7, 10, 4, 3, 20, 15}
       k = 3
Output: 7

Input: arr[] = {7, 10, 4, 3, 20, 15}
       k = 4
Output: 10
We have discussed three different solutions here.

Recommended: Please solve it on “PRACTICE ” first, before moving on to the solution. 
 
In this post method 5 is discussed which is mainly an extension of method 4 (QuickSelect) discussed in the previous post. The idea is to randomly pick a pivot element. To implement randomized partition, we use a random function, rand() to generate index between l and r, swap the element at randomly generated index with the last element, and finally call the standard partition process which uses last element as pivot.:# Python3 implementation of randomized
# quickSelect
import random

# This function returns k'th smallest
# element in arr[l..r] using QuickSort
# based method. ASSUMPTION: ELEMENTS
# IN ARR[] ARE DISTINCT
def kthSmallest(arr, l, r, k):
	
	# If k is smaller than number of
	# elements in array
	if (k > 0 and k <= r - l + 1):
		
		# Partition the array around a random
		# element and get position of pivot
		# element in sorted array
		pos = randomPartition(arr, l, r)

		# If position is same as k
		if (pos - l == k - 1):
			return arr[pos]
		if (pos - l > k - 1): # If position is more,
							# recur for left subarray
			return kthSmallest(arr, l, pos - 1, k)

		# Else recur for right subarray
		return kthSmallest(arr, pos + 1, r,
						k - pos + l - 1)

	# If k is more than the number of
	# elements in the array
	return 999999999999

def swap(arr, a, b):
	temp = arr[a]
	arr[a] = arr[b]
	arr[b] = temp

# Standard partition process of QuickSort().
# It considers the last element as pivot and
# moves all smaller element to left of it and
# greater elements to right. This function
# is used by randomPartition()
def partition(arr, l, r):
	x = arr[r]
	i = l
	for j in range(l, r):
		if (arr[j] <= x):
			swap(arr, i, j)
			i += 1
	swap(arr, i, r)
	return i

# Picks a random pivot element between l and r
# and partitions arr[l..r] around the randomly
# picked element using partition()
def randomPartition(arr, l, r):
	n = r - l + 1
	pivot = int(random.random() * n)
	swap(arr, l + pivot, r)
	return partition(arr, l, r)

# Driver Code
if __name__ == '__main__':

	arr = [12, 3, 5, 7, 4, 19, 26]
	n = len(arr)
	k = 3
	print(""K'th smallest element is"",
		kthSmallest(arr, 0, n - 1, k))

# This code is contributed by PranchalK<|endoftext|>"
153,"<|endoftext|>The program creates a ternary max-heap and presents a menu to the user to perform various operations on it.:class TernaryHeap:
    def __init__(self):
        self.items = []
 
    def size(self):
        return len(self.items)
 
    def parent(self, i):
        return (i - 1)//3
 
    def left(self, i):
        return 3*i + 1
 
    def mid(self, i):
        return 3*i + 2
 
    def right(self, i):
        return 3*i + 3
 
    def get(self, i):
        return self.items[i]
 
    def get_max(self):
        if self.size() == 0:
            return None
        return self.items[0]
 
    def extract_max(self):
        if self.size() == 0:
            return None
        largest = self.get_max()
        self.items[0] = self.items[-1]
        del self.items[-1]
        self.max_heapify(0)
        return largest
 
    def max_heapify(self, i):
        l = self.left(i)
        r = self.right(i)
        m = self.mid(i)
        if (l <= self.size() - 1 and self.get(l) > self.get(i)):
            largest = l
        else:
            largest = i
        if (m <= self.size() - 1 and self.get(m) > self.get(largest)):
            largest = m
        if (r <= self.size() - 1 and self.get(r) > self.get(largest)):
            largest = r
        if (largest != i):
            self.swap(largest, i)
            self.max_heapify(largest)
 
    def swap(self, i, j):
        self.items[i], self.items[j] = self.items[j], self.items[i]
 
    def insert(self, key):
        index = self.size()
        self.items.append(key)
 
        while (index != 0):
            p = self.parent(index)
            if self.get(p) < self.get(index):
                self.swap(p, index)
            index = p
 
 
theap = TernaryHeap()
 
print('Menu (this assumes no duplicate keys)')
print('insert <data>')
print('max get')
print('max extract')
print('quit')
 
while True:
    do = input('What would you like to do? ').split()
 
    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        theap.insert(data)
    elif operation == 'max':
        suboperation = do[1].strip().lower()
        if suboperation == 'get':
            print('Maximum value: {}'.format(theap.get_max()))
        elif suboperation == 'extract':
            print('Maximum value removed: {}'.format(theap.extract_max()))
 
    elif operation == 'quit':
        break<|endoftext|>"
154,"<|endoftext|>In chess, queens can move any number of squares horizontally, vertically or diagonally.
Given the location of your queen and your opponents' queen, determine whether or not you're able to capture your opponent's queen. Your location and your opponents' location are the first and second elements of the list, respectively.
Examples
can_capture([""A1"", ""H8""]) ➞ True
# Your queen can move diagonally to capture opponents' piece.

can_capture([""A1"", ""C2""]) ➞ False
# Your queen cannot reach C2 from A1 (although a knight could).

can_capture([""G3"", ""E5""]) ➞ True
Notes
Assume there are no blocking pieces.:def can_capture(queens):
  samefile = queens[0][0] == queens[1][0]
  samerank = queens[0][1] == queens[1][1]
  samediagonal = abs(ord(queens[0][0]) - ord(queens[1][0])) == abs(int(queens[0][]) - int(queens[1][1]))
  return samefile or samerank or samediagonal<|endoftext|>"
155,"<|endoftext|>You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.
Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.

A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1.
A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as -1.

We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a ""V"" shaped pattern between two boards or if a board redirects the ball into either wall of the box.
Return an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 if the ball gets stuck in the box.
 
Example 1:


Input: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
Output: [1,-1,-1,-1,-1]
Explanation: This example is shown in the photo.
Ball b0 is dropped at column 0 and falls out of the box at column 1.
Ball b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.
Ball b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.
Ball b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.
Ball b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.

Example 2:

Input: grid = [[-1]]
Output: [-1]
Explanation: The ball gets stuck against the left wall.

Example 3:

Input: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
Output: [0,1,2,3,4,-1]

 
Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 100
grid[i][j] is 1 or -1.:def findBall(self, grid):
  m, n = len(grid), len(grid[0])

  def test(i):
  for j in xrange(m):
  i2 = i + grid[j][i]
  if i2 < 0 or i2 >= n or grid[j][i2] != grid[j][i]:
  return -1
  i = i2
  return i
  return map(test, range(n))<|endoftext|>"
156,"<|endoftext|>Count the number of numbers in a number using Python. We learn how to count the total number of digits in a number using python in this tutorial. The program receives the number and prints the total number of digits in the given number. We’ll show you three ways to calculate total numbers in a number.
 Examples:
 Example1:
 Input:
 number = 27482
 Output:
 The total digits present in the given number= 5
 Example2:
 Input:
 number = 327
 Output:
 The total digits present in the given number= 3:# given number
 
 given_number = 27482
 
 # initializing a variable that counts the digit of the given number.
 
 # initlaize it with 0
 
 digits_count = 0
 
 # using while loop to traverse digit by digit of the given number
 
 while (given_number > 0):
 
  # divide the number by 10
 
  given_number = given_number//10
 
  # increment the count
 
  digits_count = digits_count + 1
 
 # printing the digits count of the given number
 
 print(""The total digits present in the given number="", digits_count)<|endoftext|>"
157,"<|endoftext|>In this program, you will learn to convert decimal number to binary using recursive function. :# Function to print binary number using recursion
def convertToBinary(n):
   if n > 1:
       convertToBinary(n//2)
   print(n % 2,end = '')

# decimal number
dec = 34

convertToBinary(dec)
print()<|endoftext|>"
158,"<|endoftext|>Given the upper limit and lower limit, the task is to generate n natural numbers which are not repeating in Python.:# Import the random module using the import keyword.
import random
# Give the number n as static input and store it in a variable.
numbe = 13
# Give the lower limit range and upper limit range as static input
# and store them in two separate variables.
lowerlimitrange = 19
upperlimitrange = 45
# Take an empty list (say rndmnumbs) and initialize it with an empty list
# using [] or list().
rndmnumbs = []
# Loop till n times using For loop.
for m in range(numbe):
        # Generate a random number using randint(lowerlimitrange,upperlimitrange)
    # and store it in a variable.
    randomnumbe = random.randint(lowerlimitrange, upperlimitrange)
    # Check whether the above random number is present in the list or not
    # using not in operator.
    if randomnumbe not in rndmnumbs:
        # If it is not in the list then append the element
        # to the rndmnumbs list using the append() function.
        rndmnumbs.append(randomnumbe)

# Print the rndmnumbs
print('The random numbers present in the range from',
      lowerlimitrange, 'to', upperlimitrange, 'are :')
for q in rndmnumbs:
    print(q, end=' ')<|endoftext|>"
159,"<|endoftext|>Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

Custom Judge:

The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.

 

Example 1:

Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
Example 2:

Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
 

Constraints:

1 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums is sorted in non-decreasing order.:class Solution(object):
    def removeDuplicates(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        
        # Initialize the counter and the second pointer.
        j, count = 1, 1
        
        # Start from the second element of the array and process
        # elements one by one.
        for i in range(1, len(nums)):
            
            # If the current element is a duplicate, 
            # increment the count.
            if nums[i] == nums[i - 1]:
                count += 1
            else:
                # Reset the count since we encountered a different element
                # than the previous one
                count = 1
            
            # For a count <= 2, we copy the element over thus
            # overwriting the element at index ""j"" in the array
            if count <= 2:
                nums[j] = nums[i]
                j += 1
                
        return j<|endoftext|>"
160,"<|endoftext|>You are given a binary string s. You are allowed to perform two types of operations on the string in any sequence:

Type-1: Remove the character at the start of the string s and append it to the end of the string.
Type-2: Pick any character in s and flip its value, i.e., if its value is '0' it becomes '1' and vice-versa.
Return the minimum number of type-2 operations you need to perform such that s becomes alternating.

The string is called alternating if no two adjacent characters are equal.

For example, the strings ""010"" and ""1010"" are alternating, while the string ""0100"" is not.:class Solution:
    def minFlips(self, s: str) -> int:
        n = len(s)
        diff1,diff2 = 0,0
        alt1,alt2 = """",""""
        s=s+s
        alt1, alt2 = ""01"" * n, ""10"" * n
        l=0
        res = len(s)
        for r in range(len(s)):
            if s[r]!=alt1[r]:
                diff1+=1
            if s[r]!=alt2[r]:
                diff2+=1
            if r>=n:
                if n%2!=0: # if 0th(Lth) bit are different with alt1,alt2 then n+1 bit will be same and vice versa
                    if s[l]!=alt1[l]:
                        diff1-=1
                    if s[l]!=alt2[l]:
                        diff2-=1
                l+=1
            if r >= n-1:
                res = min(res,diff1,diff2)
        return res<|endoftext|>"
161,"<|endoftext|>Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.

You must do it in place.

 

Example 1:


Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]
Example 2:


Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
 

Constraints:

m == matrix.length
n == matrix[0].length
1 <= m, n <= 200
-231 <= matrix[i][j] <= 231 - 1
 

Follow up:

A straightforward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution?:class Solution(object):
    def setZeroes(self, matrix):
        """"""
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """"""
        is_col = False
        R = len(matrix)
        C = len(matrix[0])
        for i in range(R):
            # Since first cell for both first row and first column is the same i.e. matrix[0][0]
            # We can use an additional variable for either the first row/column.
            # For this solution we are using an additional variable for the first column
            # and using matrix[0][0] for the first row.
            if matrix[i][0] == 0:
                is_col = True
            for j in range(1, C):
                # If an element is zero, we set the first element of the corresponding row and column to 0
                if matrix[i][j]  == 0:
                    matrix[0][j] = 0
                    matrix[i][0] = 0

        # Iterate over the array once again and using the first row and first column, update the elements.
        for i in range(1, R):
            for j in range(1, C):
                if not matrix[i][0] or not matrix[0][j]:
                    matrix[i][j] = 0

        # See if the first row needs to be set to zero as well
        if matrix[0][0] == 0:
            for j in range(C):
                matrix[0][j] = 0

        # See if the first column needs to be set to zero as well        
        if is_col:
            for i in range(R):
                matrix[i][0] = 0<|endoftext|>"
162,"<|endoftext|>Given two square matrices A and B of size n x n each, find their multiplication matrix. :# Version 3.6
 
import numpy as np
 
def split(matrix):
    """"""
    Splits a given matrix into quarters.
    Input: nxn matrix
    Output: tuple containing 4 n/2 x n/2 matrices corresponding to a, b, c, d
    """"""
    row, col = matrix.shape
    row2, col2 = row//2, col//2
    return matrix[:row2, :col2], matrix[:row2, col2:], matrix[row2:, :col2], matrix[row2:, col2:]
 
def strassen(x, y):
    """"""
    Computes matrix product by divide and conquer approach, recursively.
    Input: nxn matrices x and y
    Output: nxn matrix, product of x and y
    """"""
 
    # Base case when size of matrices is 1x1
    if len(x) == 1:
        return x * y
 
    # Splitting the matrices into quadrants. This will be done recursively
    # until the base case is reached.
    a, b, c, d = split(x)
    e, f, g, h = split(y)
 
    # Computing the 7 products, recursively (p1, p2...p7)
    p1 = strassen(a, f - h) 
    p2 = strassen(a + b, h)       
    p3 = strassen(c + d, e)       
    p4 = strassen(d, g - e)       
    p5 = strassen(a + d, e + h)       
    p6 = strassen(b - d, g + h) 
    p7 = strassen(a - c, e + f) 
 
    # Computing the values of the 4 quadrants of the final matrix c
    c11 = p5 + p4 - p2 + p6 
    c12 = p1 + p2          
    c21 = p3 + p4           
    c22 = p1 + p5 - p3 - p7 
 
    # Combining the 4 quadrants into a single matrix by stacking horizontally and vertically.
    c = np.vstack((np.hstack((c11, c12)), np.hstack((c21, c22))))
 
    return c<|endoftext|>"
163,"<|endoftext|>LeetCode company workers use key-cards to unlock office doors. Each time a worker uses their key-card, the security system saves the worker's name and the time when it was used. The system emits an alert if any worker uses the key-card three or more times in a one-hour period.
You are given a list of strings keyName and keyTime where [keyName[i], keyTime[i]] corresponds to a person's name and the time when their key-card was used in a single day.
Access times are given in the 24-hour time format ""HH:MM"", such as ""23:51"" and ""09:49"".
Return a list of unique worker names who received an alert for frequent keycard use. Sort the names in ascending order alphabetically.
Notice that ""10:00"" - ""11:00"" is considered to be within a one-hour period, while ""22:51"" - ""23:52"" is not considered to be within a one-hour period.
 
Example 1:

Input: keyName = [""daniel"",""daniel"",""daniel"",""luis"",""luis"",""luis"",""luis""], keyTime = [""10:00"",""10:40"",""11:00"",""09:00"",""11:00"",""13:00"",""15:00""]
Output: [""daniel""]
Explanation: ""daniel"" used the keycard 3 times in a one-hour period (""10:00"",""10:40"", ""11:00"").

Example 2:

Input: keyName = [""alice"",""alice"",""alice"",""bob"",""bob"",""bob"",""bob""], keyTime = [""12:01"",""12:00"",""18:00"",""21:00"",""21:20"",""21:30"",""23:00""]
Output: [""bob""]
Explanation: ""bob"" used the keycard 3 times in a one-hour period (""21:00"",""21:20"", ""21:30"").

 
Constraints:

1 <= keyName.length, keyTime.length <= 105
keyName.length == keyTime.length
keyTime[i] is in the format ""HH:MM"".
[keyName[i], keyTime[i]] is unique.
1 <= keyName[i].length <= 10
keyName[i] contains only lowercase English letters.:def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
  name_to_time = collections.defaultdict(list)
  for name, hour_minute in zip(keyName, keyTime):
  hour, minute = map(int, hour_minute.split(':'))
  time = hour * 60 + minute
 name_to_time[name].append(time)
  names = []  
  for name, time_list in name_to_time.items():
  time_list.sort()
  dq = collections.deque()
  for time in time_list:
  dq.append(time)
  if dq[-1] - dq[0] > 60:
  dq.popleft()
  if len(dq) >= 3:
  names.append(name)
  break
  return sorted(names)<|endoftext|>"
164,"<|endoftext|>Create a function that takes a number as an argument and returns n instances of the Fibonacci sequence as a list.
Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1. So the easy explanation is: The next element is the sum of the two previous elements.
If you want to read more about this sequence, take a look at the On-Line Encyclopedia of Integer Sequences. Fibonacci numbers are strongly related to the golden ratio. See the OEIS and Wikipedia links in the resources tab.
Examples
fib_seq(4) ➞ [0, 1, 1, 2]

fib_seq(7) ➞ [0, 1, 1, 2, 3, 5, 8]

fib_seq(0) ➞ []
Notes
If 0 is given, return an empty list.
If no argument is given, return None.
The input will never be a negative integer.:def fib_seq(*end):
  try:
    if end[0] == 0:
      return []
    elif end[0] == 1:
      return [0]
    else:
      lst = [0,1]
      while True:
        if len(lst) == end[0]:
          return lst
        lst.append(lst[-1] + lst[-2])
        except IndexError:
    return None<|endoftext|>"
165,"<|endoftext|>The diameter of a tree is the number of nodes on the longest path between two leaves in the tree. The diagram below shows two trees each with diameter nine, the leaves that form the ends of the longest path are colored (note that there may be more than one path in the tree of the same diameter).:# Simple Python3 program to find diameter
# of a binary tree.

class newNode:
	def __init__(self, data):
		self.data = data
		self.left = self.right = None

# Function to find height of a tree
def height(root, ans):
	if (root == None):
		return 0

	left_height = height(root.left, ans)

	right_height = height(root.right, ans)

	# update the answer, because diameter
	# of a tree is nothing but maximum
	# value of (left_height + right_height + 1)
	# for each node
	ans[0] = max(ans[0], 1 + left_height +
							right_height)

	return 1 + max(left_height,
				right_height)

# Computes the diameter of binary
# tree with given root.
def diameter(root):
	if (root == None):
		return 0
	ans = [-999999999999] # This will store
						# the final answer
	height_of_tree = height(root, ans)
	return ans[0]

# Driver code
if __name__ == '__main__':
	root = newNode(1)
	root.left = newNode(2)
	root.right = newNode(3)
	root.left.left = newNode(4)
	root.left.right = newNode(5)

	print(""Diameter is"", diameter(root))

# This code is contributed by PranchalK
<|endoftext|>"
166,"<|endoftext|>Create a function, that will for a given a, b, c, do the following:
Add a to itself b times.
Check if the result is divisible by c.
Examples
abcmath(42, 5, 10) ➞ False
# 42+42 = 84,84+84 = 168,168+168 = 336,336+336 = 672, 672+672 = 1344
# 1344 is not divisible by 10

abcmath(5, 2, 1) ➞ True

abcmath(1, 2, 3) ➞ False
Notes
""if the result is divisible by c"", means that if you divide the result and c, you will get an integer (5, and not 4.5314).
The second test is correct.:def abcmath(a, b, c):
  return not a*2**b%c<|endoftext|>"
167,"<|endoftext|>We will discuss how to remove last element from list in python. We are using list.pop() function, del function, and slice operator to remove last element from list. If the original list is [‘C’, ‘C++’, ‘Java’, ‘Python’, ‘Javascript’]. The list after removing last element [‘C’, ‘C++’, ‘Java’, ‘Python’].:# Python program to remove last element from list # take list mylist = ['C', 'C++', 'Java', 'Python', 'Javascript'] # printing original list print('The original list:', mylist) # remove last element using list.pop() mylist.pop() # printing list without last element print('The list after removing last elements:', mylist)<|endoftext|>"
168,"<|endoftext|>You are given an array of integers nums and an integer target.
Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. Since the answer may be too large, return it modulo 109 + 7.
 
Example 1:

Input: nums = [3,5,6,7], target = 9
Output: 4
Explanation: There are 4 subsequences that satisfy the condition.
[3] -> Min value + max value <= target (3 + 3 <= 9)
[3,5] -> (3 + 5 <= 9)
[3,5,6] -> (3 + 6 <= 9)
[3,6] -> (3 + 6 <= 9)

Example 2:

Input: nums = [3,3,6,8], target = 10
Output: 6
Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]

Example 3:

Input: nums = [2,3,3,4,6,7], target = 12
Output: 61
Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]).
Number of valid subsequences (63 - 2 = 61).

 
Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 106
1 <= target <= 106:def numSubseq(self, A, target):
  A.sort()
  l, r = 0, len(A) - 1
  res = 0
  mod = 10**9 + 7
  while l <= r:
  if A[l] + A[r] > target:
  r -= 1
  else:
  res += pow(2, r - l, mod)
  l += 1
  return res % mod<|endoftext|>"
169,"<|endoftext|>Palindrome String in Python | If the reverse of the string is the same string then the string is called palindrome string. Some examples of palindromic words are redivider, noon, civic, radar, level, rotor, kayak, reviver, racecar, redder, madam, and refer. The palindrome number is also based on the palindrome string. The reverse of a number that is equal to the same number is called a palindrome number.:# Python program to check if string is Palindrome # take inputs string = input('Enter the string: ') # find reverse of string i = string reverse = '' while(len(i) > 0): if(len(i) > 0): a = i[-1] i = i[:-1] reverse += a # compare reverse to original string if(reverse == string): print(string,'is a Palindrome') else: print(string,'is not a Palindrome')<|endoftext|>"
170,"<|endoftext|>Instructions
Create an implementation of the rotational cipher, also sometimes called the Caesar cipher.

The Caesar cipher is a simple shift cipher that relies on transposing all the letters in the alphabet using an integer key between 0 and 26. Using a key of 0 or 26 will always yield the same output due to modular arithmetic. The letter is shifted for as many values as the value of the key.

The general notation for rotational ciphers is ROT + <key>. The most commonly used rotational cipher is ROT13.

A ROT13 on the Latin alphabet would be as follows:

Plain:  abcdefghijklmnopqrstuvwxyz
Cipher: nopqrstuvwxyzabcdefghijklm
It is stronger than the Atbash cipher because it has 27 possible keys, and 25 usable keys.

Ciphertext is written out in the same formatting as the input including spaces and punctuation.

Examples
ROT5 omg gives trl
ROT0 c gives c
ROT26 Cool gives Cool
ROT13 The quick brown fox jumps over the lazy dog. gives Gur dhvpx oebja sbk whzcf bire gur ynml qbt.
ROT13 Gur dhvpx oebja sbk whzcf bire gur ynml qbt. gives The quick brown fox jumps over the lazy dog.:chars = ""abcdefghijklmnopqrstuvwxyz""
def rotate(text, key):
    newchars = chars[key:] + chars[:key]
    trans = str.maketrans(chars + chars.upper(), newchars + newchars.upper())
    return text.translate(trans)<|endoftext|>"
171,"<|endoftext|>You are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid.

A uni-value grid is a grid where all the elements of it are equal.

Return the minimum number of operations to make the grid uni-value. If it is not possible, return -1.:class Solution:
    def minOperations(self, grid: List[List[int]], x: int) -> int:
        
        m=len(grid)
        n=len(grid[0])
        def check(no):
            ans=0
            for i in range(m):
                for j in range(n):
                    if abs(grid[i][j]-no)%x!=0:
                        
                        return float('inf')
                    else:
                        ans+=(abs(grid[i][j]-no)//x)
            return ans
        if m==1 and n==1:
            return 0
        arr=[]
        for i in range(m):
            for j in range(n):
                arr.append(grid[i][j])
        arr.sort()
        
        c1=arr[(m*n)//2]
        c2=arr[(m*n)//2-1]
        
        k1=check(c1)
        k2=check(c2)
        
        mn=min(k1,k2)
        if mn==float('inf'):
            return -1
        return mn<|endoftext|>"
172,"<|endoftext|>Given two Binary Search Trees(BST), print the elements of both BSTs in sorted form. The expected time complexity is O(m+n) where m is the number of nodes in the first tree and n is the number of nodes in the second tree. The maximum allowed auxiliary space is O(height of the first tree + height of the second tree). :# Class to create a new Tree Node
class newNode:
    def __init__(self, data: int):
        self.data = data
        self.left = None
        self.right = None
 
def inorder(root: newNode):
 
    if root:
        inorder(root.left)
        print(root.data, end="" "")
        inorder(root.right)
 
def merge(root1: newNode, root2: newNode):
 
    # s1 is stack to hold nodes of first BST
    s1 = []
     
    # Current node of first BST
    current1 = root1
     
    # s2 is stack to hold nodes of first BST
    s2 = []
     
    # Current node of second BST
    current2 = root2
 
    # If first BST is empty then the output is the
    # inorder traversal of the second BST
    if not root1:
        return inorder(root2)
 
    # If the second BST is empty then the output is the
    # inorder traversal of the first BST
    if not root2:
        return inorder(root1)
 
    # Run the loop while there are nodes not yet printed.
    # The nodes may be in stack(explored, but not printed)
    # or may be not yet explored
    while current1 or s1 or current2 or s2:
 
        # Following steps follow iterative Inorder Traversal
        if current1 or current2:
         
            # Reach the leftmost node of both BSTs and push ancestors of
            # leftmost nodes to stack s1 and s2 respectively
            if current1:
                s1.append(current1)
                current1 = current1.left
 
            if current2:
                s2.append(current2)
                current2 = current2.left
 
        else:
 
            # If we reach a NULL node and either of the stacks is empty,
            # then one tree is exhausted, print the other tree
 
            if not s1:
                while s2:
                    current2 = s2.pop()
                    current2.left = None
                    inorder(current2)
                    return
            if not s2:
                while s1:
                    current1 = s1.pop()
                    current1.left = None
                    inorder(current1)
                    return
 
            # Pop an element from both stacks and compare the
            # popped elements
            current1 = s1.pop()
            current2 = s2.pop()
 
            # If element of first tree is smaller, then print it
            # and push the right subtree. If the element is larger,
            # then we push it back to the corresponding stack.
            if current1.data < current2.data:
                print(current1.data, end="" "")
                current1 = current1.right
                s2.append(current2)
                current2 = None
 
            else:
                print(current2.data, end="" "")
                current2 = current2.right
                s1.append(current1)
                current1 = None
 
# Driver code
 
def main():
 
    # Let us create the following tree as first tree
    #     3
    #     / \
    # 1 5
 
    root1 = newNode(3)
    root1.left = newNode(1)
    root1.right = newNode(5)
 
    # Let us create the following tree as second tree
    #     4
    #     / \
    # 2 6
    #
 
    root2 = newNode(4)
    root2.left = newNode(2)
    root2.right = newNode(6)
 
    merge(root1, root2)
 
 
if __name__ == ""__main__"":
    main()
 
# This code is contributed by Koushik Reddy Bukkasamudram
<|endoftext|>"
173,"<|endoftext|>Instructions
An Armstrong number is a number that is the sum of its own digits each raised to the power of the number of digits.

For example:

9 is an Armstrong number, because 9 = 9^1 = 9
10 is not an Armstrong number, because 10 != 1^2 + 0^2 = 1
153 is an Armstrong number, because: 153 = 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153
154 is not an Armstrong number, because: 154 != 1^3 + 5^3 + 4^3 = 1 + 125 + 64 = 190
Write some code to determine whether a number is an Armstrong number.:# Armstrong numbers are equal to the sum of the powers of their digits
# Exponent is the length of the number, base 10
def is_armstrong_number(number: int) -> bool:
    """"""Is number the equal to sum of powers of digits?""""""
    s = str(number)
    exp = len(s)
    return number == sum([int(ch)**exp for ch in s])<|endoftext|>"
174,"<|endoftext|>Write a function that retrieves the last n elements from a list.
Examples
last([1, 2, 3, 4, 5], 1) ➞ [5]

last([4, 3, 9, 9, 7, 6], 3) ➞ [9, 7, 6]

last([1, 2, 3, 4, 5], 7) ➞ ""invalid""

last([1, 2, 3, 4, 5], 0) ➞ []
Notes
Return ""invalid"" if n exceeds the length of the list.
Return an empty list if n == 0.:def last(a, n):
  return 'invalid' if n>len(a) else a[len(a)-n:]<|endoftext|>"
175,"<|endoftext|>Given two strings str1 and str2, find if str1 is a subsequence of str2. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements:# memoization Python program to check
# if a string is subsequence
# of another string
dp = [[-1]*1001]*1001
 
# returns the length of longest common subsequence
def isSubSequence(s1,s2,i,j):
 
   if (i == 0 or j == 0):
      return 0
 
   if (dp[i][j] != -1):
      return dp[i][j]
 
   if (s1[i - 1] == s2[j - 1]):
      dp[i][j] = 1 + isSubSequence(s1, s2, i - 1, j - 1)
      return dp[i][j]
 
   else:
      dp[i][j] = isSubSequence(s1, s2, i, j - 1)
      return dp[i][j]
 
# Driver program to test above function
str1 = ""gksrek""
str2 = ""geeksforgeeks""
m = len(str1)
n = len(str2)
 
if (m > n):
   print(""NO"")
 
if (isSubSequence(str1, str2, m, n) == m):
    print(""YES"")
 
else:
    print(""NO"")
 
# this code is contributed by shinjanpatra<|endoftext|>"
176,"<|endoftext|>The Fibonacci sequence, as you know, is generated by iterative addition of the sum of the last two elements of the sequence to the end of the sequence, starting with [0, 1].

Fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …]
The iccanobiF sequence (see Resources tab for more info) is generated in a similar way — except that the digits of the last two elements should first be reversed, then added together, then added to the sequence. Single-digit numbers are unaffected, so the first 8 elements are identical to the Fibonacci sequence:

iccanobiF = [0, 1, 1, 2, 3, 5, 8, 13]
The next element is the sum of the reverse of 8 (still 8), and the reverse of 13 — 31 (8 + 31 = 39).

iccanobiF = [0, 1, 1, 2, 3, 5, 8, 13, 39]
The next element is 31 + 93 = 124

iccanobiF = [0, 1, 1, 2, 3, 5, 8, 13, 39, 124]
And so on.

Create a function that takes a number n and returns the difference between the nth iccanobiF number and the nth Fibonacci number.

Examples
icc_minus_fib(4) ➞ 0
# For all n < 9, the difference is zero.

icc_minus_fib(9) ➞ 18

icc_minus_fib(18) ➞ 790920:def icc_minus_fib(n):
    a, b, c, d, idx = 0, 1, 0, 1, 2
    while idx < n:
        a, b = b, a + b
        c, d = d, int(str(c)[::-1]) + int(str(d)[::-1])
        idx += 1
    return d - b<|endoftext|>"
177,"<|endoftext|>Here, we will discuss how to print sum of two numbers in python. We will see many methods to add two numbers in python. We will give two numbers num1 and num2. Python program will add these numbers using various methods.:# python program to add two numbers # take inputs num1 = 5 num2 = 10 # add two numbers sum = num1 + num2 # displaying the addition result print('{0} + {1} = {2}'.format(num1, num2, sum))<|endoftext|>"
178,"<|endoftext|>Definition and Usage
The clear() method removes all the elements from a list.:fruits = ['apple', 'banana', 'cherry', 'orange']

fruits.clear()<|endoftext|>"
179,"<|endoftext|>Given a singly linked list, swap kth node from beginning with kth node from end. Swapping of data is not allowed, only pointers should be changed. This requirement may be logical in many situations where the linked list data part is huge (For example student details line Name, RollNo, Address, ..etc). The pointers are always fixed (4 bytes for most of the compilers).
Example: 
 

Input: 1 -> 2 -> 3 -> 4 -> 5, K = 2
Output: 1 -> 4 -> 3 -> 2 -> 5 
Explanation: The 2nd node from 1st is 2 and 
2nd node from last is 4, so swap them.


Input: 1 -> 2 -> 3 -> 4 -> 5, K = 5
Output: 5 -> 2 -> 3 -> 4 -> 1 
Explanation: The 5th node from 1st is 5 and 
5th node from last is 1, so swap them.:""""""
A Python3 program to swap kth node from
the beginning with kth node from the end
""""""
class Node:
	def __init__(self, data, next = None):
		self.data = data
		self.next = next
	
class LinkedList:

	def __init__(self, *args, **kwargs):
		self.head = Node(None)
	""""""
	Utility function to insert a node at the beginning
	@args:
		data: value of node
	""""""
	def push(self, data):
		node = Node(data)
		node.next = self.head
		self.head = node
	
	# Print linked list
	def printList(self):
		node = self.head
		while node.next is not None:
			print(node.data, end = "" "")
			node = node.next
	
	# count number of node in linked list
	def countNodes(self):
		count = 0
		node = self.head
		while node.next is not None:
			count += 1
			node = node.next
		return count
	
	""""""
	Function for swapping kth nodes from
	both ends of linked list
	""""""
	def swapKth(self, k):

		# Count nodes in linked list
		n = self.countNodes()

		# check if k is valid
		if n<k:
			return

		""""""
		If x (kth node from start) and
		y(kth node from end) are same
		""""""
		if (2 * k - 1) == n:
			return

		""""""
		Find the kth node from beginning of linked list.
		We also find previous of kth node because we need
		to update next pointer of the previous.
		""""""
		x = self.head
		x_prev = Node(None)
		for i in range(k - 1):
			x_prev = x
			x = x.next

		""""""
		Similarly, find the kth node from end and its
		previous. kth node from end is (n-k + 1)th node
		from beginning
		""""""
		y = self.head
		y_prev = Node(None)
		for i in range(n - k):
			y_prev = y
			y = y.next

		""""""
		If x_prev exists, then new next of it will be y.
		Consider the case when y->next is x, in this case,
		x_prev and y are same. So the statement
		""x_prev->next = y"" creates a self loop. This self
		loop will be broken when we change y->next.
		""""""
		if x_prev is not None:
			x_prev.next = y

		# Same thing applies to y_prev
		if y_prev is not None:
			y_prev.next = x
		
		""""""
		Swap next pointers of x and y. These statements
		also break self loop if x->next is y or y->next
		is x
		""""""
		temp = x.next
		x.next = y.next
		y.next = temp

		# Change head pointers when k is 1 or n
		if k == 1:
			self.head = y
		
		if k == n:
			self.head = x

# Driver Code
llist = LinkedList()
for i in range(8, 0, -1):
	llist.push(i)
llist.printList()


for i in range(1, 9):
	llist.swapKth(i)
	print(""Modified List for k = "", i)
	llist.printList()
	print(""\n"")

# This code is contributed by Pulkit<|endoftext|>"
180,"<|endoftext|>Find the Total Number of Bits Needed to be Flipped to Convert One Number into Another Using XOR Operator and Count Variable(User Input separated by spaces):# function which accepts the two numbers as arguments
# and return the number of bits to be flipped


def countFlipbits(firstnumber, secondnumber):
    # Calculate the xor value of the two numbers and store it in a result say resultnum.
    resultnum = firstnumber ^ secondnumber
    # Use the while loop to calculate the total number of set bits in the resultnum.
    setbitCounter = 0
    while resultnum:
        resultnum = resultnum & (resultnum - 1)
        setbitCounter = setbitCounter + 1
    # Return the number of set bits which is the result (number of bits to be flipped).
    return setbitCounter


# Driver Code
# Give the two numbers as user input using int, map(), and split() functions.
# Store them in two separate variables.
firstnumber, secondnumber = map(int, input(
    'Enter some random two numbers separated by spaces = ').split())
# Pass the given two numbers as arguments to the ( function which calculates the total number
# of bits to be flipped to convert one number into another.
print('Binary representations of the given two numbers are :')
print(firstnumber, '=', bin(firstnumber)[2:])
print(secondnumber, '=', bin(secondnumber)[2:])
print('The total number of bits to be flipped =',
      countFlipbits(firstnumber, secondnumber))<|endoftext|>"
181,"<|endoftext|>Given height in centimeters , the task is to convert the given height to feet and inches in Python.:# Enter the height in centimeters as user input using int(input()) function.
heightcm = int(input('Enter some random height in centimeters = '))
# Convert the given height in centimeters to feet by multiplying it with 0.0328
# and store it in a variable.
heightfeet = 0.0328*heightcm
# Convert the given height in centimeters to inches by multiplying it with 0.0.394
# and store it in a variable.
heightinches = 0.394*heightcma
# Print the height in feet and inches.
print(""The given height"", heightcm, 'cm',
      'in inches = ', round(heightinches, 2), 'inches')
print(""The given height"", heightcm, 'cm',
      'in feet = ', round(heightfeet, 2), 'feet')<|endoftext|>"
182,"<|endoftext|>Strings in Python:

A string is a series of one or more characters (letters, integers, symbols) that might be constant or variable. Strings, which are made up of Unicode, are immutable sequences, which means they do not change.

Because the text is such a frequent type of data in our daily lives, the string data type is a critical building block of programming.



Given a string, the task is to remove all the characters present at odd indices in the given string in Python

Examples:

Example1:

Input:

given string = HelloThisisBTechgeeks
Output:

The given string before modification =  HelloThisisBTechgeeks
The given string after modification =  HlohssTcges
Example2:

Input:

given string = btechgeeks online coding platform for coding studeents
Output:

Enter the given random string = btechgeeks online coding platform for coding studeents
The given string before modification = btechgeeks online coding platform for coding studeents
The given string after modification = behek niecdn ltomfrcdn tdet:# function  that accepts the string as an argument
# and removes all the characters present at odd indices in the given string.
def removeOddString(givenstrng):
  # In the function take an empty string say tempstng using '' .
  tempstng = """"
  # Traverse the given string using For loop.
  for charindex in range(len(givenstrng)):
  # Use an if statement and modulus operator to
  # determine whether the string's index is odd or even.
  if charindex % 2 == 0:
  # If the index is an even number, append the
  # character to the tempstng using String Concatenation.
  tempstng = tempstng + givenstrng[charindex]
  # Return the tempstng.
  return tempstng
# Give the string as static input and store it in a variable.
givenstrng = 'HelloThisisBTechgeeks'
# print the given string without modification'
print('The given string before modification = ', givenstrng)
# Pass the given string as an argument to the removeOddString function.
resstrng = removeOddString(givenstrng)
# print the given string after modification
print('The given string after modification = ', resstrng)<|endoftext|>"
183,"<|endoftext|>Simple calculator in Python | In this post, We will create a calculator, It will be a basic calculator in python with CUI (character user interface) which can perform the different arithmetical operations, such as add(+), subtract(-), multiply(*), and divide(/) of two numbers.:# Python program to make a simple calculator # take inputs num1 = float(input(""Enter first number: "")) num2 = float(input(""Enter second number: "")) # choise operation print(""Operation: +, -, *, /"") select = input(""Select operations: "") # check operations and display result # add(+) two numbers if select == ""+"": print(num1, ""+"", num2, ""="", num1+num2) # subtract(-) two numbers elif select == ""-"": print(num1, ""-"", num2, ""="", num1-num2) # multiplies(*) two numbers elif select == ""*"": print(num1, ""*"", num2, ""="", num1*num2) # divides(/) two numbers elif select == ""/"": print(num1, ""/"", num2, ""="", num1/num2) else: print(""Invalid input"")<|endoftext|>"
184,"<|endoftext|>Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.
A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true:

0 <= i < j < k < arr.length
|arr[i] - arr[j]| <= a
|arr[j] - arr[k]| <= b
|arr[i] - arr[k]| <= c

Where |x| denotes the absolute value of x.
Return the number of good triplets.
 
Example 1:

Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
Output: 4
Explanation: There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].

Example 2:

Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1
Output: 0
Explanation: No triplet satisfies all conditions.

 
Constraints:

3 <= arr.length <= 100
0 <= arr[i] <= 1000
0 <= a, b, c <= 1000:class Solution:
  def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
  
  size = len(arr)
  
  good_count = 0
  
  for i in range(size-2):
  for j in range(i+1, size-1):
  for k in range(j+1, size):
  
  ok_a = abs(arr[i] - arr[j]) <= a
  ok_b = abs(arr[j] - arr[k]) <= b
  ok_c = abs(arr[i] - arr[k]) <= c
  
  if all((ok_a, ok_b, ok_c)):
  good_count += 1
  
  
  return good_count<|endoftext|>"
185,"<|endoftext|>Create a function that determines if the temp of the water is considered boiling or not. temp will be measured in fahrenheit and celsius.
Examples
is_boiling(""212F"") ➞ True

is_boiling(""100C"") ➞ True

is_boiling(""0F"") ➞ False
Notes
The boiling point of water is 212F in fahrenheit and 100C in celsius.:def is_boiling(temp):
  t = int(temp[:-1])
  return t>=212 if 'F' in temp else t>=100<|endoftext|>"
186,"<|endoftext|>You will be implementing a basic case of the map-reduce pattern in programming. Given a vector stored as a list of integers, find the magnitude of the vector. Use the standard distance formula for n-dimensional Cartesian coordinates.
Examples
magnitude([3, 4]) ➞ 5

magnitude([0, 0, -10]) ➞ 10

magnitude([]) ➞ 0

magnitude([2, 3, 6, 1, 8] ) ➞ 10.677078252031311
Notes
The list can have any length.
The input list will contain integers (except for empty list [] ➞ 0).:def magnitude(list):
  return sum([x**2 for x in list]) ** (0.5)<|endoftext|>"
187,"<|endoftext|>Given a letter and a list of words, return whether the letter does not appear in any of the words.

Examples
forbidden_letter(""r"", [""rock"", ""paper"", ""scissors""]) ➞ False

forbidden_letter(""a"", [""spoon"", ""fork"", ""knife""]) ➞ True

forbidden_letter(""m"", []) ➞ True
Notes
All inputs given will be in lowercase.
You will always be given a forbidden letter, but there may be empty lists.:def forbidden_letter(char, lst):
	return not any(char in x for x in lst)<|endoftext|>"
188,"<|endoftext|>Here is a trainwreck of a photo:
The challenge is to fix all of the bugs in this incredibly messy code, which the code in the image might've actually looked like (probably not)! The code given will output the same middle two lines as in the image shown above.
First parameter is the user's score.
Second parameter is the required score.
Examples
grade_percentage(""85%"", ""85%"") ➞ ""You PASSED the Exam""

grade_percentage(""99%"", ""85%"") ➞ ""You PASSED the Exam""

grade_percentage(""65%"", ""90%"") ➞ ""You FAILED the Exam""
Notes
Note that inputs will be given as a string percentage number.
Maintain all capitalization.
Feel free to declutter and refactor code if it helps!:def grade_percentage(user_score, pass_score):
  return 'You {} the Exam'.format('PASSED' if user_score >= pass_score else 'FAILED')<|endoftext|>"
189,"<|endoftext|>A number is called Automorphic number if its square ends in the original number. Create a function that takes a number n and returns True if it is an Automorphic number, otherwise False.
Examples
automorphic(1) ➞ True

automorphic(3) ➞ False
# 3^2 = 9

automorphic(6) ➞ True
# 6^2 = 36 (ends with 6)

automorphic(95) ➞ False
# 95^2 = 9025 (does not end with 95)
Notes
N/A:def automorphic(n):
  return str(n**2).endswith(str(n))<|endoftext|>"
190,"<|endoftext|>Create a function that takes two parameters (start, stop), and returns the sum of all even numbers in the range.
Examples
sum_even_nums_in_range(10, 20) ➞ 90
# 10, 12, 14, 16, 18, 20

sum_even_nums_in_range(51, 150) ➞ 5050

sum_even_nums_in_range(63, 97) ➞ 1360
Notes
Remember that the start and stop values are inclusive.:def sum_even_nums_in_range(start, stop):
    return sum(i for i in range(start, stop+1) if not i%2)<|endoftext|>"
191,"<|endoftext|>You are given the head of a linked list, and an integer k.
Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).
 
Example 1:


Input: head = [1,2,3,4,5], k = 2
Output: [1,4,3,2,5]

Example 2:

Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5
Output: [7,9,6,6,8,7,3,0,9,5]

 
Constraints:

The number of nodes in the list is n.
1 <= k <= n <= 105
0 <= Node.val <= 100:class Solution:
  def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
  # Find kth node from left
  l = r = head
  for _ in range(k-1):
  l = l.next
  # Find kth node from right
  # by finding tail node
  tail = l
  while tail.next:
  r, tail = r.next, tail.next
  # Swap values and return
  l.val, r.val = r.val, l.val
  return head<|endoftext|>"
192,"<|endoftext|>Iterative Method:
To delete a node from the linked list, we need to do the following steps. 
1) Find the previous node of the node to be deleted. 
2) Change the next of the previous node. 
3) Free memory for the node to be deleted.:# Python program to delete a node in a linked list
# at a given position

# Node class


class Node:

        # Constructor to initialize the node object
        def __init__(self, data):
                self.data = data
                self.next = None


class LinkedList:

        # Constructor to initialize head
        def __init__(self):
                self.head = None

        # Function to insert a new node at the beginning
        def push(self, new_data):
                new_node = Node(new_data)
                new_node.next = self.head
                self.head = new_node

        # Given a reference to the head of a list
        # and a position, delete the node at a given position
        #This delete function code is contributed by Arabin Islam
        def deleteNode(self, position):
                if self.head is None:
                        return
                if position == 0:
                        self.head = self.head.next
                        return self.head
                index = 0
                current = self.head
                prev = self.head
                temp = self.head
                while current is not None:
                        if index == position:
                                temp = current.next
                                break
                        prev = current
                        current = current.next
                        index += 1
                prev.next = temp
                return prev

        # Utility function to print the LinkedList

        def printList(self):
                temp = self.head
                while(temp):
                        print ("" %d "" % (temp.data),end="" "")
                        temp = temp.next


# Driver program to test above function
llist = LinkedList()
llist.push(7)
llist.push(1)
llist.push(3)
llist.push(2)
llist.push(8)

print (""Created Linked List: "")
llist.printList()
llist.deleteNode(4)
print (""\nLinked List after Deletion at position 4: "")
llist.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
<|endoftext|>"
193,"<|endoftext|>A prime number is a natural number which is greater than 1 and has no positive divisor other than 1 and itself, such as 2, 3, 5, 7, 11, 13, and so on.

The user is given two integer numbers, lower value, and upper value. The task is to write the Python program for printing all the prime numbers between the given interval (or range).:# First, we will take the input:  
lower_value = int(input (""Please, Enter the Lowest Range Value: ""))  
upper_value = int(input (""Please, Enter the Upper Range Value: ""))  
  
print (""The Prime Numbers in the range are: "")  
for number in range (lower_value, upper_value + 1):  
    if number > 1:  
        for i in range (2, number):  
            if (number % i) == 0:  
                break  
        else:  
            print (number)  <|endoftext|>"
194,"<|endoftext|>Given a list of directions to spin, ""left"" or ""right"", return an integer of how many full 360° rotations were made. Note that each word in the list counts as a 90° rotation in that direction.
Worked Example
spin_around([""right"", ""right"", ""right"", ""right"", ""left"", ""right""]) ➞ 1
# You spun right 4 times (90 * 4 = 360)
# You spun left once (360 - 90 = 270)
# But you spun right once more to make a full rotation (270 + 90 = 360)
Examples
spin_around([""left"", ""right"", ""left"", ""right""]) ➞ 0

spin_around([""right"", ""right"", ""right"", ""right"", ""right"", ""right"", ""right"", ""right""]) ➞ 2

spin_around([""left"", ""left"", ""left"", ""left""]) ➞ 1
Notes
Return a positive number.
All tests will only include the words ""right"" and ""left"".:def spin_around(lst):
  return abs(lst.count('left') - lst.count('right')) // 4<|endoftext|>"
195,"<|endoftext|>Write a function that will return the longest word in a sentence. In cases where more than one word is found, return the first one.
Examples
find_longest(""A thing of beauty is a joy forever."") ➞ ""forever""

find_longest(""Forgetfulness is by all means powerless!"") ➞ ""forgetfulness""

find_longest(""\""Strengths\"" is the longest and most commonly used word that contains only a single vowel."") ➞ ""strengths""
Notes
Special characters and symbols don't count as part of the word.
Return the longest word found in lowercase letters.
A recursive version of this challenge can be found via this link.:import re
def find_longest(s):
    return max(re.split('\W', s.lower()), key=len)<|endoftext|>"
196,"<|endoftext|>Reverse Delete algorithm is closely related to Kruskal’s algorithm. In Kruskal’s algorithm what we do is : Sort edges by increasing order of their weights. After sorting, we one by one pick edges in increasing order. We include current picked edge if by including this in spanning tree not form any cycle until there are V-1 edges in spanning tree, where V = number of vertices.
In Reverse Delete algorithm, we sort all edges in decreasing order of their weights. After sorting, we one by one pick edges in decreasing order. We include current picked edge if excluding current edge causes disconnection in current graph. The main idea is delete edge if its deletion does not lead to disconnection of graph.
The Algorithm 
1) Sort all edges of graph in non-increasing order of
   edge weights.

2) Initialize MST as original graph and remove extra
   edges using step 3.

3) Pick highest weight edge from remaining edges and 
   check if deleting the edge disconnects the graph  
   or not.
       If disconnects, then we don't delete the edge.
       Else we delete the edge and continue. :# Python3 program to find Minimum Spanning Tree
# of a graph using Reverse Delete Algorithm
 
# Graph class represents a directed graph
# using adjacency list representation
class Graph:
    def __init__(self, v):
 
        # No. of vertices
        self.v = v
        self.adj = [0] * v
        self.edges = []
        for i in range(v):
            self.adj[i] = []
 
    # function to add an edge to graph
    def addEdge(self, u: int, v: int, w: int):
        self.adj[u].append(v) # Add w to v’s list.
        self.adj[v].append(u) # Add w to v’s list.
        self.edges.append((w, (u, v)))
 
    def dfs(self, v: int, visited: list):
 
        # Mark the current node as visited and print it
        visited[v] = True
 
        # Recur for all the vertices adjacent to
        # this vertex
        for i in self.adj[v]:
            if not visited[i]:
                self.dfs(i, visited)
 
    # Returns true if graph is connected
    # Returns true if given graph is connected, else false
    def connected(self):
        visited = [False] * self.v
 
        # Find all reachable vertices from first vertex
        self.dfs(0, visited)
 
        # If set of reachable vertices includes all,
        # return true.
        for i in range(1, self.v):
            if not visited[i]:
                return False
 
        return True
 
    # This function assumes that edge (u, v)
    # exists in graph or not,
    def reverseDeleteMST(self):
 
        # Sort edges in increasing order on basis of cost
        self.edges.sort(key = lambda a: a[0])
 
        mst_wt = 0 # Initialize weight of MST
 
        print(""Edges in MST"")
 
        # Iterate through all sorted edges in
        # decreasing order of weights
        for i in range(len(self.edges) - 1, -1, -1):
            u = self.edges[i][1][0]
            v = self.edges[i][1][1]
 
            # Remove edge from undirected graph
            self.adj[u].remove(v)
            self.adj[v].remove(u)
 
            # Adding the edge back if removing it
            # causes disconnection. In this case this
            # edge becomes part of MST.
            if self.connected() == False:
                self.adj[u].append(v)
                self.adj[v].append(u)
 
                # This edge is part of MST
                print(""( %d, %d )"" % (u, v))
                mst_wt += self.edges[i][0]
        print(""Total weight of MST is"", mst_wt)
 
# Driver Code
if __name__ == ""__main__"":
 
    # create the graph given in above figure
    V = 9
    g = Graph(V)
 
    # making above shown graph
    g.addEdge(0, 1, 4)
    g.addEdge(0, 7, 8)
    g.addEdge(1, 2, 8)
    g.addEdge(1, 7, 11)
    g.addEdge(2, 3, 7)
    g.addEdge(2, 8, 2)
    g.addEdge(2, 5, 4)
    g.addEdge(3, 4, 9)
    g.addEdge(3, 5, 14)
    g.addEdge(4, 5, 10)
    g.addEdge(5, 6, 2)
    g.addEdge(6, 7, 1)
    g.addEdge(6, 8, 6)
    g.addEdge(7, 8, 7)
 
    g.reverseDeleteMST()
 
# This code is contributed by
# sanjeev2552
<|endoftext|>"
197,"<|endoftext|>We are given queue data structure, the task is to implement stack using only given queue data structure.

We have discussed a solution that uses two queues. In this article, a new solution is discussed that uses only one queue. This solution assumes that we can find size of queue at any point. The idea is to keep newly inserted element always at front of queue, keeping order of previous elements same. Below are complete steps.


 :# Python3 program to implement stack using a
# single queue
  
q = []
 
# append operation
def append(val):
 
    # get previous size of queue
    size = len(q)
 
    # Add current element
    q.append(val);
 
    # Pop (or Dequeue) all previous
    # elements and put them after current
    # element
    for i in range(size):
 
        # this will add front element into
        # rear of queue
        x = q.pop(0);
        q.append(x);
            
# Removes the top element
def pop():
 
    if (len(q) == 0):
 
        print(""No elements"");
        return -1;
     
    x = q.pop(0);
    return x;
 
# Returns top of stack
def top():
 
    if(len(q) == 0):
        return -1;
    return q[-1]
 
# Returns true if Stack is empty else false
def isEmpty():
 
    return len(q)==0;
 
# Driver program to test above methods
if __name__=='__main__':
 
    s = []
 
    s.append(10);
    s.append(20);
    print(""Top element :"" + str(s[-1]));
    s.pop();
    s.append(30);
    s.pop();
    print(""Top element :"" + str(s[-1]));
     
    # This code is contributed by rutvik_56.
<|endoftext|>"
198,"<|endoftext|>Given a string and the task is to find all the Non repeated characters in a given String.

Counter function in Python:

The counter is a set and dict subset. Counter() takes an iterable entity as an argument and stores the elements as keys and the frequency of the elements as a value. So, in collections, if we transfer a string. When you call Counter(), you’ll get a Counter class object with characters as keys and their frequency in a string as values.

Counter() returns a Counter type object (a subclass of dict) with all characters in the string as keys and their occurrence count as values. We’ll use the [] operator to get the occurrence count of the characters from it.

Examples:

Example1:

Input:

Given String = ""hello this is btechgeeks""
Output:

In a Given String,{ hello this is btechgeeks } all Non-repeating Characters are:
o b c g k
:# Import the Counter() function from collections using the import keyword.
from collections import Counter
# Give the string as static input and store it in a variable.
gven_str = ""hello this is btechgeeks""
# Calculate the frequency of all the given string elements using the Counter() function
# which returns the element and its frequency as a key-value pair and stores this
# dictionary in another variable (say strngfreqelements).
strngfreqelements = Counter(gven_str)
print(""In a Given String,{"", gven_str, ""} all Non-repeating Characters are:"")
# Traverse in this frequency dictionary using the for loop.
for key in strngfreqelements:
    # Inside the loop, check if the Key has the frequency 1 and key not equal to space
    # using the if conditional statement
    if(strngfreqelements[key] == 1 and key != "" ""):
     # If the statement is true, then print the value of the key.
        print(key, end="" "")<|endoftext|>"
199,"<|endoftext|>Given the array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop, if you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i], otherwise, you will not receive any discount at all.
Return an array where the ith element is the final price you will pay for the ith item of the shop considering the special discount.
 
Example 1:

Input: prices = [8,4,6,2,3]
Output: [4,2,4,2,3]
Explanation: 
For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4. 
For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2. 
For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4. 
For items 3 and 4 you will not receive any discount at all.

Example 2:

Input: prices = [1,2,3,4,5]
Output: [1,2,3,4,5]
Explanation: In this case, for all items, you will not receive any discount at all.

Example 3:

Input: prices = [10,1,1,6]
Output: [9,0,1,6]

 
Constraints:

1 <= prices.length <= 500
1 <= prices[i] <= 10^3:def finalPrices(self, A):
  stack = []
  for i, a in enumerate(A):
  while stack and A[stack[-1]] >= a:
  A[stack.pop()] -= a
  stack.append(i)
  return A<|endoftext|>"
200,"<|endoftext|>You are given a string s, an integer k, a letter letter, and an integer repetition.

Return the lexicographically smallest subsequence of s of length k that has the letter letter appear at least repetition times. The test cases are generated so that the letter appears in s at least repetition times.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

A string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.

 :class Solution:
    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:
        counts,total = 0, 0
        n = len(s)
        for ch in s:
            if ch==letter:
                total +=1
        stack = []
        occ = 0
        for idx,ch in enumerate(s):
            if ch==letter:
                counts +=1
            while stack and stack[-1]>ch and  len(stack)+ (n-1-idx)>=k and (occ+total-counts-(stack[-1]==letter)+(ch==letter)>=repetition ): 
                occ -= stack.pop()==letter
            if ch!=letter  and len(stack)< k-max(0,(repetition-occ)):
                stack.append(ch)
            elif ch==letter and len(stack)+(total-counts)<k:
                stack.append(ch)
                occ +=1
        return ''.join(stack)<|endoftext|>"
201,"<|endoftext|>Inversion Count for an array indicates – how far (or close) the array is from being sorted. If the array is already sorted, then the inversion count is 0, but if the array is sorted in the reverse order, the inversion count is the maximum. 
Formally speaking, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j :from heapq import heappush, heappop
from bisect import bisect, insort


def getNumOfInversions(A):
	N = len(A)
	if N <= 1:
		return 0

	sortList = []
	result = 0

	# heapsort, O(N*log(N))
	for i, v in enumerate(A):
		heappush(sortList, (v, i))

	x = [] # create a sorted list of indexes
	while sortList: # O(N)
		v, i = heappop(sortList) # O(log(N))
		# find the current minimum's index
		# the index y can represent how many minimums on the left
		y = bisect(x, i) # O(log(N))
		# i can represent how many elements on the left
		# i - y can find how many bigger nums on the left
		result += i - y

		insort(x, i) # O(log(N))

	return result

# Driver Code
# Given array is
A = [-1, 6, 3, 4, 7, 4]
result = getNumOfInversions(A)
print(f'Number of inversions are {result}')<|endoftext|>"
202,"<|endoftext|>Files in Python:

One of the most important subjects for programmers and automation testers is Python file handling (also known as File I/O). It is necessary to work with files in order to write to or read data from them.

Also, if you didn’t know, I/O operations are the most expensive processes where a programme can go wrong. As a result, you must use extreme caution while implementing file processing for reporting or any other reason. Optimizing a single file action can help in the creation of a high-performing application or a reliable automated software testing solution.



Consider the following scenario: you’re planning to construct a large Python project with a large number of workflows. Then it’s unavoidable that you don’t make a log file. You’ll also be handling the log file’s read and write activities. Debugging huge applications with log files is a terrific way to go. It’s usually better to consider a scalable design from the start, as you won’t be sorry later if you didn’t.

Given a file, the task is to count the number of digits in a given file in Python.:# Make a single variable to store the path of the file. This is a constant value. 
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Pass the given filename, r (represents read only) as arguments to the open() function
# to open the given file
file = open(givenFilename,""r"")
# Read the above file using the read() function(get the content) and store it in a variable
filetext = file.read()
# Take a variable(which gives the count of digits in a file) and initialize its value with zero.
digit_cnt = 0
# Iterate in the above text of the file using the for loop
for chr in filetext:
  # Check if each character of the file text is digit or not using the isdigit() function
  # and if conditional statement
  if chr.isdigit():
  # If it is true, then increment the value of the above initialized 
  # variable(digit_cnt) by 1
  digit_cnt += 1
# Print the count of number of digits in a given file
print(""The count of number of digits in a given file = "",digit_cnt)
# Close the above file
file.close()<|endoftext|>"
203,"<|endoftext|>Given the number of rows of the diamond pattern, the task is to print the Hollow Half diamond Pattern in C, C++, and Python.:# Give the number of rows of the number of diamond pattern as static input and store it in a variable.
rowsnumber = 7
# Loop from 0 to the number of rows using For loop.
for m in range(0, rowsnumber):
        # Loop till the first iterator value using another For loop(Nested For loop).
    for n in range(0, m+1):
        # Check if the first loop iterator value is equal to the second loop iterator value using the If Statement.
        # Check if the second loop iterator value is equal to 0 using the If Statement.
        # Combine these two conditions using or operator.
        if(m == n or n == 0):
            # If the statement is true then print star character with space.
            print(""*"", end="" "")
          # Else print space character.
        else:
            print(' ', end=' ')
    # After the end of the inner for loop print the Newline Character.
    print()
# After the end of two For loops Loop from 1 to the number of rows using For loop.
for m in range(1, rowsnumber):
    # Loop from the first iterator value to the given number of rows using another For loop(Nested For loop).
    for n in range(m, rowsnumber):
        # Check if the first loop iterator value is equal to the second loop iterator value using the If Statement.
                # Check if the second loop iterator value is equal to the number of rows using the If Statement.
                # Combine these two conditions using or operator.
        if(m == n or n == rowsnumber-1):
         # If the statement is true then print star character with space.
            print('*', end=' ')
          # Else print space character.
        else:
            print(' ', end=' ')

    # After the end of the inner for loop print the Newline Character.
    print()<|endoftext|>"
204,"<|endoftext|>Given n cities and distances between every pair of cities, select k cities to place warehouses (or ATMs or Cloud Server) such that the maximum distance of a city to a warehouse (or ATM or Cloud Server) is minimized. :# Python3 program for the above approach
def maxindex(dist, n):
    mi = 0
    for i in range(n):
        if (dist[i] > dist[mi]):
            mi = i
    return mi
 
def selectKcities(n, weights, k):
    dist = [0]*n
    centers = []
 
    for i in range(n):
        dist[i] = 10**9
         
    # index of city having the
    # maximum distance to it's
    # closest center
    max = 0
    for i in range(k):
        centers.append(max)
        for j in range(n):
 
            # updating the distance
            # of the cities to their
            # closest centers
            dist[j] = min(dist[j], weights[max][j])
 
        # updating the index of the
        # city with the maximum
        # distance to it's closest center
        max = maxindex(dist, n)
 
    # Printing the maximum distance
    # of a city to a center
    # that is our answer
    # print()
    print(dist[max])
 
    # Printing the cities that
    # were chosen to be made
    # centers
    for i in centers:
        print(i, end = "" "")
 
# Driver Code
if __name__ == '__main__':
    n = 4
    weights = [ [ 0, 4, 8, 5 ],
              [ 4, 0, 10, 7 ],
              [ 8, 10, 0, 9 ],
              [ 5, 7, 9, 0 ] ]
    k = 2
 
    # Function Call
    selectKcities(n, weights, k)
 
# This code is contributed by mohit kumar 29.
<|endoftext|>"
205,"<|endoftext|>Parity bits are used as very simple checksum to ensure that binary data isn't corrupted during transit. Here's how they work:
If a binary string has an odd number of 1s, the parity bit is a 1.
If a binary string has an even number of 1s, the parity bit is a 0.
The parity bit is appended to the end of the binary string.
Create a function that validates whether a binary string is valid, using parity bits.
Worked Example
validate_binary(""10110010"") ➞ True

# The last digit is the parity bit.
# 0 is the last digit.
# 0 means that there should be an even number of 1s.
# There are four 1s.
# Return True.
Examples
validate_binary(""00101101"") ➞ True

validate_binary(""11000000"") ➞ True

validate_binary(""11000001"") ➞ False
Notes
All inputs will be a byte long (8 characters).
You can find another parity bit involved challenge here!:def validate_binary(b):
  return b.count('1')%2 == 0<|endoftext|>"
206,"<|endoftext|>Given an array of 0s and 1s in random order. Segregate 0s on left side and 1s on right side of the array. Traverse array only once.:# Python3 program to sort an array with
# two types of values in one traversal.

# Method for segregation 0 and
# 1 given input array
def segregate0and1(arr, n):

	type0 = 0; type1 = n - 1

	while (type0 < type1):
		if (arr[type0] == 1):
			arr[type0], arr[type1] = arr[type1], arr[type0]
			type1 -= 1
		
		else:
			type0 += 1
		
# Driver Code
arr = [1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1]
n = len(arr)
segregate0and1(arr, n)
for i in range(0, n):
	print(arr[i], end = "" "")

# This code is contributed by Smitha Dinesh Semwal<|endoftext|>"
207,"<|endoftext|>Find Position of Rightmost Set Bit of Number Using log() Function (User Input):# Import the math function using the import keyword.
import math
# Create a function getFirstSetBitPosition()
# which accepts the given number as the argument and
# returns the position of the first set bit of the given number.


def getFirstSetBitPosition(numb):
    # Inside the getFirstSetBitPosition() function.
    # Calculate and the value of log2(n&-n)+1 which gives the first set bit position
    # of the given number and store it in a variable say result_pos.
    result_pos = math.log2(numb & -numb)+1
    # Return the value of result_pos(Which is the position of the first set bit).
    return int(result_pos)


# Inside the main code.
# Give the number as user input using the int(input())) function and store it in a variable.
gvnnumb = int(input('Enter some random number = '))
# Pass the given number as the argument to getFirstSetBitPosition() 
# function and store the result in a variable(firstSetBitposi).
firstSetBitposi = getFirstSetBitPosition(gvnnumb)
# Print the firstSetBitposi value.
print('The first set bit position of the given number {', gvnnumb, '} with binary string value {', bin(
    gvnnumb)[2:], '} =', firstSetBitposi)<|endoftext|>"
208,"<|endoftext|>Python’s if-else statement is logical. Python does not use the ternary operator as other languages do for inline if statements. It instead provides a one-line code to evaluate the first expression if the condition is met. Otherwise, the second expression is evaluated.:numb = 10
temp = 3
print(numb if temp else 0)<|endoftext|>"
209,"<|endoftext|>This Python program reads number of days from user and then converts it to number of years, months and days.
Note: while converting given number of days to years, months and days integer division is used. In Python, integer division is done by using // operator.:# Python program to convert 
# given number of days to years, months and days

# Reading number of days from user
number_of_days = int(input(""Enter number of days: ""))

# Calculating years
years = number_of_days // 365

# Calculating months
months = (number_of_days - years *365) // 30

# Calculating days
days = (number_of_days - years * 365 - months*30)

# Displaying results
print(""Years = "", years)
print(""Months = "", months)
print(""Days = "", days)<|endoftext|>"
210,"<|endoftext|>Given the number of rows, the task is to print plus star Patterns in C, C++, and Python.:# Give the number of rows as static input and store it in a variable.
numberows = 9
# Loop from 1 to 2*number of rows using For loop.
for m in range(1, 2*numberows):
    # Loop from 1 to 2*number of rows using another For loop(Nested For loop).
    for n in range(1, 2*numberows):
        '''Check if the parent loop iterator value is equal to the number of rows using the If statement.
        Check if the inner loop iterator value is equal to the number of rows using the If statement.
        Merge these both statements using or operator.'''
        if(m == numberows or n == numberows):
            # If this statement is true then print star character.
            print('*', end=' ')
        else:
            # Else print space character.
            print(' ', end=' ')

    # Print the newline character after the end of the inner For loop.
    print()<|endoftext|>"
211,"<|endoftext|>Given Linked List Representation of Complete Binary Tree, construct the Binary tree. A complete binary tree can be represented in an array in the following approach.
If root node is stored at index i, its left, and right children are stored at indices 2*i+1, 2*i+2 respectively. 


 :# Python program to create a Complete Binary Tree from
# its linked list representation
 
# Linked List node
class ListNode:
 
        # Constructor to create a new node
        def __init__(self, data):
            self.data = data
            self.next = None
 
# Binary Tree Node structure
class BinaryTreeNode:
 
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
 
# Class to convert the linked list to Binary Tree
class Conversion:
 
    # Constructor for storing head of linked list
    # and root for the Binary Tree
    def __init__(self, data = None):
        self.head = None
        self.root = None
 
    def push(self, new_data):
 
        # Creating a new linked list node and storing data
        new_node = ListNode(new_data)
 
        # Make next of new node as head
        new_node.next = self.head
 
        # Move the head to point to new node
        self.head = new_node
 
    def convertList2Binary(self):
 
        # Queue to store the parent nodes
        q = []
 
        # Base Case
        if self.head is None:
            self.root = None
            return
 
        # 1.) The first node is always the root node,
        # and add it to the queue
        self.root = BinaryTreeNode(self.head.data)
        q.append(self.root)
 
        # Advance the pointer to the next node
        self.head = self.head.next
 
        # Until the end of linked list is reached, do:
        while(self.head):
 
            # 2.a) Take the parent node from the q and
            # and remove it from q
            parent = q.pop(0) # Front of queue
 
            # 2.c) Take next two nodes from the linked list.
            # We will add them as children of the current
            # parent node in step 2.b.
            # Push them into the queue so that they will be
            # parent to the future node
            leftChild= None
            rightChild = None
 
            leftChild = BinaryTreeNode(self.head.data)
            q.append(leftChild)
            self.head = self.head.next
            if(self.head):
                rightChild = BinaryTreeNode(self.head.data)
                q.append(rightChild)
                self.head = self.head.next
 
            #2.b) Assign the left and right children of parent
            parent.left = leftChild
            parent.right = rightChild
 
    def inorderTraversal(self, root):
        if(root):
            self.inorderTraversal(root.left)
            print (root.data,end="" "")
            self.inorderTraversal(root.right)
 
# Driver Program to test above function
 
# Object of conversion class
conv = Conversion()
conv.push(36)
conv.push(30)
conv.push(25)
conv.push(15)
conv.push(12)
conv.push(10)
 
conv.convertList2Binary()
 
print (""Inorder Traversal of the constructed Binary Tree is:"")
conv.inorderTraversal(conv.root)
 
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
<|endoftext|>"
212,"<|endoftext|>Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).
Return the running sum of nums.
 
Example 1:


Input: nums = [1,2,3,4]

Output: [1,3,6,10]

Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].
Example 2:


Input: nums = [1,1,1,1,1]

Output: [1,2,3,4,5]

Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].
Example 3:


Input: nums = [3,1,2,10,1]

Output: [3,4,6,16,17]


 
Constraints:

1 <= nums.length <= 1000
-10^6 <= nums[i] <= 10^6:class Solution:
  def runningSum(self, nums: List[int]) -> List[int]:
  return accumulate(nums)<|endoftext|>"
213,"<|endoftext|>Python program to convert kilometers to miles and convert miles to kilometers | Kilometers is a unit of length in the metric system, equal to 1,000 meters and the equivalent of 0.6214 miles. Miles is also the unit of length equal to 1,760 yards and standardized as exactly 1,609.344 meters by international agreement in 1959. In this post, we will develop a program to convert kilometers to miles and also convert miles to kilometers.:# Python program to convert kilometers to miles # take inputs km = float(input('Enter distance in kilometers: ')) # conversion factor conv_fac = 0.621371 # calculate Miles mile = km * conv_fac # display result print('%0.2f kilometers is equal to %0.2f miles' %(km, mile))<|endoftext|>"
214,"<|endoftext|>Given a binary matrix, find out the maximum size square sub-matrix with all 1s. 

For example, consider the below binary matrix. :# Python3 code for Maximum size
# square sub-matrix with all 1s

def printMaxSubSquare(M):
	R = len(M) # no. of rows in M[][]
	C = len(M[0]) # no. of columns in M[][]

	S = []
	for i in range(R):
	temp = []
	for j in range(C):
		if i==0 or j==0:
		temp += M[i][j],
		else:
		temp += 0,
	S += temp,
	# here we have set the first row and first column of S same as input matrix, other entries are set to 0

	# Update other entries
	for i in range(1, R):
		for j in range(1, C):
			if (M[i][j] == 1):
				S[i][j] = min(S[i][j-1], S[i-1][j],
							S[i-1][j-1]) + 1
			else:
				S[i][j] = 0
	
	# Find the maximum entry and
	# indices of maximum entry in S[][]
	max_of_s = S[0][0]
	max_i = 0
	max_j = 0
	for i in range(R):
		for j in range(C):
			if (max_of_s < S[i][j]):
				max_of_s = S[i][j]
				max_i = i
				max_j = j

	print(""Maximum size sub-matrix is: "")
	for i in range(max_i, max_i - max_of_s, -1):
		for j in range(max_j, max_j - max_of_s, -1):
			print (M[i][j], end = "" "")
		print("""")

# Driver Program
M = [[0, 1, 1, 0, 1],
	[1, 1, 0, 1, 0],
	[0, 1, 1, 1, 0],
	[1, 1, 1, 1, 0],
	[1, 1, 1, 1, 1],
	[0, 0, 0, 0, 0]]

printMaxSubSquare(M)

# This code is contributed by Soumen Ghosh<|endoftext|>"
215,"<|endoftext|>Create a function that takes a number and return a string with the number in expanded notation (AKA expanded form). See the resources tab for details on expanded notation.
Examples
expand(13) ➞ ""10 + 3""

expand(86) ➞ ""80 + 6""

expand(17000000) ➞ ""10000000 + 7000000""

expand(5325) ➞ ""5000 + 300 + 20 + 5""
Notes
You can expect only whole numbers greater than 0 as test input.:def expand(num):
  return ' + '.join([str(num)[i] + '0' *(len(str(num))-1-i) for i in range(len(str(num))) if str(num)[i] != '0'])<|endoftext|>"
216,"<|endoftext|>Given a dictionary that contains mapping of employee and his manager as a number of (employee, manager) pairs like below. 

{ ""A"", ""C"" },
{ ""B"", ""C"" },
{ ""C"", ""F"" },
{ ""D"", ""E"" },
{ ""E"", ""F"" },
{ ""F"", ""F"" } 

In this example C is manager of A, 
C is also manager of B, F is manager 
of C and so on.:class Solution():
        def __init__(self):
                pass

        def assignAndPrint(self,t):
                #We will directly permute over t. Access 2nd element(i.e. manager) of certain tuple and assign the relation in
                # dictionary. We will assign list of employees to a particular manager so that with iterations, we can append
                # more employees to that list and list grows.
                d = dict()
                for pair in t:
                        if(pair[0]==pair[1]): # because we dont want to assign self managing role
                                continue
                        if pair[0] not in d: # assign employee a empty list of employees
                                d[pair[0]] = []
                        # for managers -
                        if pair[1] not in d:
                                d[pair[1]] = [pair[0]]
                        else:
                                d[pair[1]].append(pair[0])
                #print(d)
                # now we know how many employees are directly under a particular manager.
                # now lets count the total number of employees under a particular manager.
                c = dict() # store manager:count of employee as key value
                for manager in d:
                        c[manager] = len(d[manager])
                        for employee in d[manager]:
                                c[manager] += len(d[employee])
                        print(""{} : {}"".format(manager,c[manager]))         # prints which manager has total how many employees
                # Note : Employees having no employees under are also considered as managed with 0 employees.


if __name__==""__main__"":
        # t is tuple containing employee and boss pair.
        t = ((""A"", ""C""),(""B"", ""C""),(""C"", ""F""),(""D"", ""E""),(""E"", ""F""),(""F"", ""F""))
        obj = Solution()
        obj.assignAndPrint(t)
<|endoftext|>"
217,"<|endoftext|>Print Palindrome Numbers in a Range (Static Input):# Give the lower limit range as static input and store it in a variable.
gvn_lowrlmt = 50
# Give the upper limit range as static input and store it in another variable.
gvn_upprlmt = 130
print(""The palindrome numbers between"",
      gvn_lowrlmt, ""and"", gvn_upprlmt, ""are:"")
# Loop from lower limit range to upper limit range using For loop.
for m in range(gvn_lowrlmt, gvn_upprlmt+1):
    # Inside the loop, give the iterator value as the number of the for loop.
    given_num = m
    # taking another variable to store the copy of original number
    # and initialize it with given num
    duplicate_num = given_num
    # Take a variable reverse_number and initialize it to null
    reverse_number = 0
    # using while loop to reverse the given number
    while (given_num > 0):
        # implementing the algorithm
        # getting the last digit
        remainder = given_num % 10
        reverse_number = (reverse_number * 10) + remainder
        given_num = given_num // 10
   # if duplicate_num and reverse_number are equal then it is palindrome
    if(duplicate_num == reverse_number):
        # Print ""duplicate_num ""to get the above palindrome number.
        print(duplicate_num, end="" "")<|endoftext|>"
218,"<|endoftext|>Given a triangle array, return the minimum path sum from top to bottom.

For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.

 

Example 1:

Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
Example 2:

Input: triangle = [[-10]]
Output: -10
 

Constraints:

1 <= triangle.length <= 200
triangle[0].length == 1
triangle[i].length == triangle[i - 1].length + 1
-104 <= triangle[i][j] <= 104
 :class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        for row in range(1, len(triangle)):
            for col in range(row + 1):
                smallest_above = math.inf
                if col > 0:
                    smallest_above = triangle[row - 1][col - 1]
                if col < row:
                    smallest_above = min(smallest_above, triangle[row - 1][col])
                triangle[row][col] += smallest_above
        return min(triangle[-1])<|endoftext|>"
219,"<|endoftext|>The program prompts the user for a string and determines whether it is a palindrome with the help of a stack.:class Stack:
    def __init__(self):
        self.items = []
 
    def is_empty(self):
        return self.items == []
 
    def push(self, data):
        self.items.append(data)
 
    def pop(self):
        return self.items.pop()
 
 
s = Stack()
exp = input('Please enter the expression: ')
 
for c in exp:
    if c == '(':
        s.push(1)
    elif c == ')':
        if s.is_empty():
            is_balanced = False
            break
        s.pop()
else:
    if s.is_empty():
        is_balanced = True
    else:
        is_balanced = False
 
if is_balanced:
    print('Expression is correctly parenthesized.')
else:
    print('Expression is not correctly parenthesized.')<|endoftext|>"
220,"<|endoftext|>Check Given Two Integers have Opposite signs Using Xor(^) Operator (User Input):# Create a function isOppositeSign()
# which takes the given two numbers as arguments and
# returns true if they have opposite sign
# else returns false if they have the same sign.


def isOppositeSign(first_numb, second_numb):
        # Inside the isOppositeSign() function.
        # Apply xor to the first number and second number and
    # store it in a variable say xor_result.
    xor_result = first_numb ^ second_numb
    # Check if the value of xor_result is less than 0
    # using the if conditional statement.
    if(xor_result < 0):
        # If it is true then return True
        return True
    # Else return False.
    return False


# Inside the main code.
# Give the first number as user input using the int(input()) function
# and store it in a variable.
firstnumb = int(input('Enter some random number ='))
# Give the second number using the int(input()) function and store it in another variable.
secondnumb = int(input('Enter some random number ='))
# Pass the given two numbers as the arguments to isOppositeSign() function
# and store the result in a variable signResult.
signResult = isOppositeSign(firstnumb, secondnumb)
# Check if the Value of SignResult using the If conditional statement.
if(signResult):
        # If it is true then print the given two numbers have opposite signs.
    print('The given two numbers {', firstnumb,
          ',', secondnumb, '} have opposite signs')
# Else print the given two numbers have the same sign.
else:
    print('The given two numbers {', firstnumb,
          ',', secondnumb, '} have same signs')<|endoftext|>"
221,"<|endoftext|>Given Preorder traversal of a BST, check if each non-leaf node has only one child. Assume that the BST contains unique entries.:# Check if each internal
# node of BST has only one child
 
def hasOnlyOneChild (pre, size):
    nextDiff=0; lastDiff=0
  
    for i in range(size-1):
        nextDiff = pre[i] - pre[i+1]
        lastDiff = pre[i] - pre[size-1]
        if nextDiff*lastDiff < 0:
            return False
    return True
  
# driver program to
# test above function
if __name__ == ""__main__"":
 
    pre = [8, 3, 5, 7, 6]
    size= len(pre)
 
    if (hasOnlyOneChild(pre,size) == True):
        print(""Yes"")
    else:
        print(""No"")
 
# This code is contributed by
# Harshit Saini
<|endoftext|>"
222,"<|endoftext|>Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.
 
Example 1:


Input: nums = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,4,2,7,5,3,8,6,9]

Example 2:


Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]

 
Constraints:

1 <= nums.length <= 105
1 <= nums[i].length <= 105
1 <= sum(nums[i].length) <= 105
1 <= nums[i][j] <= 105:def findDiagonalOrder(self, A):
  res = []
  for i, r in enumerate(A):
  for j, a in enumerate(r):
  if len(res) <= i + j:
  res.append([])
  res[i + j].append(a)
  return [a for r in res for a in reversed(r)]<|endoftext|>"
223,"<|endoftext|>Given a matrix of n*n size, the task is to print its elements in a diagonal pattern. 

Input : mat[3][3] = {{1, 2, 3},
                     {4, 5, 6},
                     {7, 8, 9}}
Output : 1 2 4 7 5 3 6 8 9.
Explanation: Start from 1 
Then from upward to downward diagonally i.e. 2 and 4
Then from downward to upward diagonally i.e 7, 5, 3 
Then from up to down diagonally i.e  6, 8 
Then down to up i.e. end at 9.

Input :  mat[4][4] =  {{1,  2,  3,  10},
                      {4,  5,  6,  11},
                      {7,  8,  9,  12},
                      {13, 14, 15, 16}}
Output:  1 2 4 7 5 3 10 6 8 13 14 9 11 12 15 16 .
Explanation: Start from 1 
Then from upward to downward diagonally i.e. 2 and 4
Then from downward to upward diagonally i.e 7, 5, 3 
Then from upward to downward diagonally i.e. 10 6 8 13
Then from downward to upward diagonally i.e 14 9 11
Then from upward to downward diagonally i.e. 12 15
then end at 16:# Python 3 program to print matrix in diagonal order
MAX = 100
 
def printMatrixDiagonal(mat, n):
    # Initialize indexes of element to be printed next
    i = 0
    j = 0
    k = 0
    # Direction is initially from down to up
    isUp = True
 
     # Traverse the matrix till all elements get traversed
    while k<n * n:
         # If isUp = True then traverse from downward
         # to upward
        if isUp:
            while i >= 0 and j<n :
                print(str(mat[i][j]), end = "" "")
                k += 1
                j += 1
                i -= 1
 
              # Set i and j according to direction
            if i < 0 and j <= n - 1:
                i = 0
            if j == n:
                i = i + 2
                j -= 1
 
         # If isUp = 0 then traverse up to down
        else:
            while j >= 0 and i<n :
                print(mat[i][j], end = "" "")
                k += 1
                i += 1
                j -= 1
 
              # Set i and j according to direction
            if j < 0 and i <= n - 1:
                j = 0
            if i == n:
                j = j + 2
                i -= 1
 
         # Revert the isUp to change the direction
        isUp = not isUp
 
# Driver program
if __name__ == ""__main__"":
    mat = [[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9] ]
 
   n = 3
   printMatrixDiagonal(mat, n)
 
# This code is contributed by Chitra Nayal
<|endoftext|>"
224,"<|endoftext|>Copy a Dictionary
You cannot copy a dictionary simply by typing dict2 = dict1, because: dict2 will only be a reference to dict1, and changes made in dict1 will automatically also be made in dict2.

There are ways to make a copy, one way is to use the built-in Dictionary method copy().:thisdict = {
  ""brand"": ""Ford"",
  ""model"": ""Mustang"",
  ""year"": 1964
}
mydict = thisdict.copy()
print(mydict)
<|endoftext|>"
225,"<|endoftext|>The return keyword is to exit a function and return a value.
:def myfunction():
  return 3+3

print(myfunction())<|endoftext|>"
226,"<|endoftext|>How to Compare Two Lists in Python | Python allows comparing two list elements by providing various built-in methods. The comparison checks whether the list contains the same elements or not irrespective of the index.:def compare(list1,list2): list1.sort() list2.sort() if(list1==list2): return ""Equal"" else: return ""Non equal"" l1=[1,2,3] l2=[2,1,3] print(""Comparision using 'list.sort()' comparison:-"",compare(l1,l2)) l3=[1,2,3] l4=[1,3,2] print(""Comparison using '==' operator:-"",compare(l3,l4))<|endoftext|>"
227,"<|endoftext|>Given an array, print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is the first greater element on the right side of x in the array. Elements for which no greater element exist, consider the next greater element as -1.:# Function to print element and NGE pair for all elements of list
def printNGE(arr):

	for i in range(0, len(arr), 1):

		next = -1
		for j in range(i+1, len(arr), 1):
			if arr[i] < arr[j]:
				next = arr[j]
				break
			
		print(str(arr[i]) + "" -- "" + str(next))

# Driver program to test above function
arr = [11,13,21,3]
printNGE(arr)

# This code is contributed by Sunny Karira
<|endoftext|>"
228,"<|endoftext|>Given a string s containing only lowercase English letters and the '?' character, convert all the '?' characters into lowercase letters such that the final string does not contain any consecutive repeating characters. You cannot modify the non '?' characters.
It is guaranteed that there are no consecutive repeating characters in the given string except for '?'.
Return the final string after all the conversions (possibly zero) have been made. If there is more than one solution, return any of them. It can be shown that an answer is always possible with the given constraints.
 
Example 1:

Input: s = ""?zs""
Output: ""azs""
Explanation: There are 25 solutions for this problem. From ""azs"" to ""yzs"", all are valid. Only ""z"" is an invalid modification as the string will consist of consecutive repeating characters in ""zzs"".

Example 2:

Input: s = ""ubv?w""
Output: ""ubvaw""
Explanation: There are 24 solutions for this problem. Only ""v"" and ""w"" are invalid modifications as the strings will consist of consecutive repeating characters in ""ubvvw"" and ""ubvww"".

 
Constraints:

1 <= s.length <= 100
s consist of lowercase English letters and '?'.:def modifyString(self, s: str) -> str:
res, prev = """", '?'
for i, c in enumerate(s):
next = s[i + 1] if i + 1 < len(s) else '?'
prev = c if c != '?' else {'a', 'b', 'c'}.difference({prev, next}).pop()
res += prev
return res<|endoftext|>"
229,"<|endoftext|>Definition and Usage
The seekable() method returns True if the file is seekable, False if not.

A file is seekable if it allows access to the file stream, like the seek() method.:f = open(""demofile.txt"", ""r"")
print(f.seekable())<|endoftext|>"
230,"<|endoftext|>Create a function that takes a string as the first argument, and a (string) specification as a second argument. If the specification is ""word"", return a string with each word reversed while maintaining their original order. If the specification is ""sentence"", reverse the order of the words in the string, while keeping the words intact.:def flip(txt, spec):
        txt = txt.split(' ')
        if spec == 'word':
                return ' '.join(i[::-1] for i in txt)
        elif spec == 'sentence':
                return ' '.join(i for i in txt[::-1])<|endoftext|>"
231,"<|endoftext|>Create a function that always returns True for every item in a given list. However, if an element is the word ""flick"", switch to always returning the opposite boolean value.:def flick_switch(lst):
        res, state = [], True
        for i in lst:
                if i == 'flick':
                        state = not state
                res.append(state)
        return res<|endoftext|>"
232,"<|endoftext|>Given a set of n integers, divide the set in two subsets of n/2 sizes each such that the difference of the sum of two subsets is as minimum as possible. If n is even, then sizes of two subsets must be strictly n/2 and if n is odd, then size of one subset must be (n-1)/2 and size of other subset must be (n+1)/2.
For example, let given set be {3, 4, 5, -3, 100, 1, 89, 54, 23, 20}, the size of set is 10. Output for this set should be {4, 100, 1, 23, 20} and {3, 5, -3, 89, 54}. Both output subsets are of size 5 and sum of elements in both subsets is same (148 and 148). 
Let us consider another example where n is odd. Let given set be {23, 45, -34, 12, 0, 98, -99, 4, 189, -1, 4}. The output subsets should be {45, -34, 12, 98, -1} and {23, 0, -99, 4, 189, 4}. The sums of elements in two subsets are 120 and 121 respectively.
The following solution tries every possible subset of half size. If one subset of half size is formed, the remaining elements form the other subset. We initialize current set as empty and one by one build it. There are two possibilities for every element, either it is part of current set, or it is part of the remaining elements (other subset). We consider both possibilities for every element. When the size of current set becomes n/2, we check whether this solutions is better than the best solution available so far. If it is, then we update the best solution.:# Python3 program for above approach

# function that tries every possible
# solution by calling itself recursively
def TOWUtil(arr, n, curr_elements, no_of_selected_elements,
			soln, min_diff, Sum, curr_sum, curr_position):
	
	# checks whether the it is going
	# out of bound
	if (curr_position == n):
		return

	# checks that the numbers of elements
	# left are not less than the number of
	# elements required to form the solution
	if ((int(n / 2) - no_of_selected_elements) >
						(n - curr_position)):
		return

	# consider the cases when current element
	# is not included in the solution
	TOWUtil(arr, n, curr_elements, no_of_selected_elements,
			soln, min_diff, Sum, curr_sum, curr_position + 1)

	# add the current element to the solution
	no_of_selected_elements += 1
	curr_sum = curr_sum + arr[curr_position]
	curr_elements[curr_position] = True

	# checks if a solution is formed
	if (no_of_selected_elements == int(n / 2)):
		
		# checks if the solution formed is better
		# than the best solution so far
		if (abs(int(Sum / 2) - curr_sum) < min_diff[0]):
			min_diff[0] = abs(int(Sum / 2) - curr_sum)
			for i in range(n):
				soln[i] = curr_elements[i]
	else:
		
		# consider the cases where current
		# element is included in the solution
		TOWUtil(arr, n, curr_elements, no_of_selected_elements,
				soln, min_diff, Sum, curr_sum, curr_position + 1)

	# removes current element before returning
	# to the caller of this function
	curr_elements[curr_position] = False

# main function that generate an arr
def tugOfWar(arr, n):
	
	# the boolean array that contains the
	# inclusion and exclusion of an element
	# in current set. The number excluded
	# automatically form the other set
	curr_elements = [None] * n

	# The inclusion/exclusion array
	# for final solution
	soln = [None] * n

	min_diff = [999999999999]

	Sum = 0
	for i in range(n):
		Sum += arr[i]
		curr_elements[i] = soln[i] = False

	# Find the solution using recursive
	# function TOWUtil()
	TOWUtil(arr, n, curr_elements, 0,
			soln, min_diff, Sum, 0, 0)

	# Print the solution
	print(""The first subset is: "")
	for i in range(n):
		if (soln[i] == True):
			print(arr[i], end = "" "")
	print()
	print(""The second subset is: "")
	for i in range(n):
		if (soln[i] == False):
			print(arr[i], end = "" "")

# Driver Code
if __name__ == '__main__':

	arr = [23, 45, -34, 12, 0, 98,
			-99, 4, 189, -1, 4]
	n = len(arr)
	tugOfWar(arr, n)

# This code is contributed by PranchalK<|endoftext|>"
233,"<|endoftext|>Given a Binary Tree, convert it to a Binary Search Tree. The conversion must be done in such a way that keeps the original structure of the Binary Tree.


This solution will use Sets of C++ STL instead of array-based solution.:# Python3 program to convert a Binary tree
# to BST using sets as containers.
 
# Binary Tree Node
"""""" A utility function to create a
new BST node """"""
class newNode:
 
    # Construct to create a newNode
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
 
# function to store the nodes in set
# while doing inorder traversal.
def storeinorderInSet(root, s):
 
    if (not root) :
        return
 
    # visit the left subtree first
    storeinorderInSet(root.left, s)
 
    # insertion takes order of O(logn)
    # for sets
    s.add(root.data)
 
    # visit the right subtree
    storeinorderInSet(root.right, s)
 
# Time complexity = O(nlogn)
 
# function to copy items of set one by one
# to the tree while doing inorder traversal
def setToBST(s, root) :
 
    # base condition
    if (not root):
        return
 
    # first move to the left subtree and
    # update items
    setToBST(s, root.left)
 
    # iterator initially pointing to
    # the beginning of set
    it = next(iter(s))
 
    # copying the item at beginning of
    # set(sorted) to the tree.
    root.data = it
 
    # now erasing the beginning item from set.
    s.remove(it)
 
    # now move to right subtree
    # and update items
    setToBST(s, root.right)
 
# T(n) = O(nlogn) time
 
# Converts Binary tree to BST.
def binaryTreeToBST(root):
 
    s = set()
 
    # populating the set with the tree's
    # inorder traversal data
    storeinorderInSet(root, s)
 
    # now sets are by default sorted as
    # they are implemented using self-
    # balancing BST
 
    # copying items from set to the tree
    # while inorder traversal which makes a BST
    setToBST(s, root)
 
# Time complexity = O(nlogn),
# Auxiliary Space = O(n) for set.
 
# function to do inorder traversal
def inorder(root) :
 
    if (not root) :
        return
    inorder(root.left)
    print(root.data, end = "" "")
    inorder(root.right)
 
# Driver Code
if __name__ == '__main__':
 
    root = newNode(5)
    root.left = newNode(7)
    root.right = newNode(9)
    root.right.left = newNode(10)
    root.left.left = newNode(1)
    root.left.right = newNode(6)
    root.right.right = newNode(11)
 
    """""" Constructing tree given in
        the above figure
        5
        / \
        7     9
    /\ / \
    1 6 10 11 """"""
 
    # converting the above Binary tree to BST
    binaryTreeToBST(root)
    print(""Inorder traversal of BST is: "")
    inorder(root)
 
# This code is contributed by
# Shubham Singh(SHUBHAMSINGH10)
<|endoftext|>"
234,"<|endoftext|>There are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. There exists a unique path between each pair of cities. In other words, the cities form a tree.
A subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.
For each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.
Return an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.
Notice that the distance between the two cities is the number of edges in the path between them.
 
Example 1:


Input: n = 4, edges = [[1,2],[2,3],[2,4]]
Output: [3,4,0]
Explanation:
The subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.
The subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.
No subtree has two nodes where the max distance between them is 3.

Example 2:

Input: n = 2, edges = [[1,2]]
Output: [1]

Example 3:

Input: n = 3, edges = [[1,2],[2,3]]
Output: [2,1]

 
Constraints:

2 <= n <= 15
edges.length == n-1
edges[i].length == 2
1 <= ui, vi <= n
All pairs (ui, vi) are distinct.:class Solution(object):
  def countSubgraphsForEachDiameter(self, n, edges):
  def bfs(src, cities):
  visited = {src}
  q = deque([(src, 0)])  # Pair of (vertex, distance)
  farthestNode, farthestDist = -1, 0
  while len(q) > 0:
  farthestNode, farthestDist = u, d = q.popleft()
  for v in graph[u]:
  if v not in visited and v in cities:
  visited.add(v)
  q.append((v, d + 1))
  return farthestNode, farthestDist, visited

  def diameterOfTree(cities):
  anyNode = cities.pop()
  cities.add(anyNode)
  farthestNode, _, visited = bfs(anyNode, cities)
  if len(visited) < len(cities): return 0  # Can't visit all nodes of the tree -> Invalid tree
  _, dist, _ = bfs(farthestNode, cities)
  return dist

  def maxDistance(state):  # return: maximum distance between any two cities in our subset. O(n)
  cities = set()
  for i in range(n):
  if (state >> i) & 1 == 1:
  cities.add(i)
  return diameterOfTree(cities)
  
  graph = defaultdict(list)
  for u, v in edges:
  graph[u-1].append(v-1)
  graph[v-1].append(u-1)
  
  ans = [0] * (n - 1)
  for state in range(1, 2 ** n):
  d = maxDistance(state)
  if d > 0: ans[d - 1] += 1
  return ans<|endoftext|>"
235,"<|endoftext|>In this program, we need to find out the smallest element present in the array. This can be achieved by maintaining a variable min which initially will hold the value of the first element. Loop through the array by comparing the value of min with elements of the array. If any of the element's value is less than min, store the value of the element in the min.:#Initialize array     
arr = [25, 11, 7, 75, 56];     
     
#Initialize min with the first element of the array.    
    
min = arr[0];    
     
#Loop through the array    
for i in range(0, len(arr)):    
    #Compare elements of array with min    
   if(arr[i] < min):    
       min = arr[i];    
     
print(""Smallest element present in given array: "" + str(min));    <|endoftext|>"
236,"<|endoftext|>Compute n modulo d without division(/) and modulo(%) operators, where d is a power of 2 number. 
Let ith bit from right is set in d. For getting n modulus d, we just need to return 0 to i-1 (from right) bits of n as they are and other bits as 0.
For example if n = 6 (00..110) and d = 4(00..100). Last set bit in d is at position 3 (from right side). So we need to return last two bits of n as they are and other bits as 0, i.e., 00..010. :# Python code to demonstrate
# modulus division by power of 2


# This function will
# return n % d.
# d must be one of:
# 1, 2, 4, 8, 16, 32, …
def getModulo(n, d):

	return ( n & (d-1) )
		
# Driver program to
# test above function
n = 6

#d must be a power of 2
d = 4
print(n,""modulo"",d,""is"",
	getModulo(n, d))

# This code is contributed by
# Smitha Dinesh Semwal
<|endoftext|>"
237,"<|endoftext|>Instructions
Compute the prime factors of a given natural number.

A prime number is only evenly divisible by itself and 1.

Note that 1 is not a prime number.

Example
What are the prime factors of 60?

Our first divisor is 2. 2 goes into 60, leaving 30.
2 goes into 30, leaving 15.
2 doesn't go cleanly into 15. So let's move on to our next divisor, 3.
3 goes cleanly into 15, leaving 5.
3 does not go cleanly into 5. The next possible factor is 4.
4 does not go cleanly into 5. The next possible factor is 5.
5 does go cleanly into 5.
We're left only with 1, so now, we're done.
Our successful divisors in that computation represent the list of prime factors of 60: 2, 2, 3, and 5.

You can check this yourself:

2 * 2 * 3 * 5
= 4 * 15
= 60
Success!
:def factors(value):
    prime = []
    factor = 2
    while value > 1:
        if value % factor == 0:
            prime.append(factor)
            value /= factor
        else:
            factor += 1
    return prime<|endoftext|>"
238,"<|endoftext|>In this example, we have defined two set variables and we have performed different set operations: union, intersection, difference and symmetric difference.:# Program to perform different set operations like in mathematics

# define three sets
E = {0, 2, 4, 6, 8};
N = {1, 2, 3, 4, 5};

# set union
print(""Union of E and N is"",E | N)

# set intersection
print(""Intersection of E and N is"",E & N)

# set difference
print(""Difference of E and N is"",E - N)

# set symmetric difference
print(""Symmetric difference of E and N is"",E ^ N)<|endoftext|>"
239,"<|endoftext|>If you want to build something using a Raspberry Pi, you'll probably use resistors. For this exercise, you need to know two things about them:

Each resistor has a resistance value.
Resistors are small - so small in fact that if you printed the resistance value on them, it would be hard to read.
To get around this problem, manufacturers print color-coded bands onto the resistors to denote their resistance values. Each band has a position and a numeric value.

The first 2 bands of a resistor have a simple encoding scheme: each color maps to a single number. For example, if they printed a brown band (value 1) followed by a green band (value 5), it would translate to the number 15.

In this exercise you are going to create a helpful program so that you don't have to remember the values of the bands. The program will take color names as input and output a two digit number, even if the input is more than two colors!

The band colors are encoded as follows:

Black: 0
Brown: 1
Red: 2
Orange: 3
Yellow: 4
Green: 5
Blue: 6
Violet: 7
Grey: 8
White: 9
From the example above: brown-green should return 15 brown-green-violet should return 15 too, ignoring the third color.:color_dict = {
                'black': 0,
                'brown': 1,
                'red': 2,
                'orange': 3,
                'yellow': 4,
                'green': 5,
                'blue': 6,
                'violet': 7,
                'grey': 8,
                'white': 9
              }
def value(colors):
    return int(str(color_dict[colors[0]]) + str(color_dict[colors[1]]))<|endoftext|>"
240,"<|endoftext|>Given a string s, return the number of unique palindromes of length three that are a subsequence of s.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

A palindrome is a string that reads the same forwards and backwards.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, ""ace"" is a subsequence of ""abcde"".:class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        locs = defaultdict(list)
        for i, ch in enumerate(s): locs[ch].append(i)
        
        ans = 0 
        for x in ascii_lowercase: 
            if len(locs[x]) > 1: 
                if len(locs[x]) > 2: ans += 1
                for xx in ascii_lowercase:
                    if x != xx and bisect_left(locs[xx], locs[x][0]) != bisect_left(locs[xx], locs[x][-1]): ans += 1
        return ans <|endoftext|>"
241,"<|endoftext|>Add Properties
:class Student(Person):
  def __init__(self, fname, lname):
    super().__init__(fname, lname)
    self.graduationyear = 2019<|endoftext|>"
242,"<|endoftext|>You have a list of integers, and for each index you want to find the product of every integer except the integer at that index.
Create a function that takes a list of integers and returns a list of the products.
Examples
get_products([1, 7, 3, 4]) ➞ [84, 12, 28, 21]

get_products([1, 2, 6, 5, 9]) ➞ [540, 270, 90, 108, 60]

get_products([1, 2, 3, 0, 5]) ➞ [0, 0, 0, 30, 0]
Notes
You can't use division, otherwise you might end up dividing by 0 and the universe would end.:import numpy as np
def get_products(lst):
    return [np.prod(np.array(lst[:i] + lst[i+1:])) for i in range(len(lst))]<|endoftext|>"
243,"<|endoftext|>Given a parentheses string s containing only the characters '(' and ')'. A parentheses string is balanced if:

Any left parenthesis '(' must have a corresponding two consecutive right parenthesis '))'.
Left parenthesis '(' must go before the corresponding two consecutive right parenthesis '))'.

In other words, we treat '(' as an opening parenthesis and '))' as a closing parenthesis.

For example, ""())"", ""())(())))"" and ""(())())))"" are balanced, "")()"", ""()))"" and ""(()))"" are not balanced.

You can insert the characters '(' and ')' at any position of the string to balance it if needed.
Return the minimum number of insertions needed to make s balanced.
 
Example 1:

Input: s = ""(()))""
Output: 1
Explanation: The second '(' has two matching '))', but the first '(' has only ')' matching. We need to to add one more ')' at the end of the string to be ""(())))"" which is balanced.

Example 2:

Input: s = ""())""
Output: 0
Explanation: The string is already balanced.

Example 3:

Input: s = ""))())(""
Output: 3
Explanation: Add '(' to match the first '))', Add '))' to match the last '('.

 
Constraints:

1 <= s.length <= 105
s consists of '(' and ')' only.:def minInsertions(self, s):
  res = right = 0
  for c in s:
  if c == '(':
  if right % 2:
  right -= 1
  res += 1
  right += 2
  if c == ')':
  right -= 1
  if right < 0:
  right += 2
  res += 1
  return right + res<|endoftext|>"
244,"<|endoftext|>You can use the append() method to add an element to an array:cars.append(""Honda"")
<|endoftext|>"
245,"<|endoftext|>You face 1 out of the 4 compass directions: N, S, E or W.
A left turn is a counter-clockwise turn. e.g. N (left-turn) ➞ W.
A right turn is a clockwise turn. e.g. N (right-turn) ➞ E.
Create a function that takes in a starting direction and a sequence of left and right turns, and outputs the final direction faced.
Examples
final_direction(""N"", [""L"", ""L"", ""L""]) ➞ ""E""

final_direction(""N"", [""R"", ""R"", ""R"", ""L""]) ➞ ""S""

final_direction(""N"", [""R"", ""R"", ""R"", ""R""]) ➞ ""N""

final_direction(""N"", [""R"", ""L""]) ➞ ""N""
Notes
You can only face 1 out of the 4 compass directions: N, S, E or W.:def final_direction(initial, turns):
  d = ['N', 'E', 'S', 'W']
  return d[(d.index(initial) + sum([1 if i == 'R' else -1 for i in turns]))%4]<|endoftext|>"
246,"<|endoftext|>Pre-processing refers to the transformations applied to our data before feeding it to the algorithm. Data Preprocessing is a technique that is used to convert the raw data into a clean data set. In other words, whenever the data is gathered from different sources it is collected in raw format which is not feasible for the analysis.

Standardize Data  

Standardization is a useful technique to transform attributes with a Gaussian distribution and differing means and standard deviations to a standard Gaussian distribution with a mean of 0 and a standard deviation of 1.
We can standardize data using scikit-learn with the StandardScaler class.:# importing libraries
from sklearn.preprocessing import StandardScaler
import pandas
import numpy
 
# data set link
url = ""https://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/pima-indians-diabetes.data""
# data parameters
names = ['preg', 'plas', 'pres', 'skin', 'test', 'mass', 'pedi', 'age', 'class']
 
# preparating of dataframe using the data at given link and defined columns list
dataframe = pandas.read_csv(url, names = names)
array = dataframe.values
 
# separate array into input and output components
X = array[:, 0:8]
Y = array[:, 8]
scaler = StandardScaler().fit(X)
rescaledX = scaler.transform(X)
 
# summarize transformed data
numpy.set_printoptions(precision = 3)
print(rescaledX[0:5,:])<|endoftext|>"
247,"<|endoftext|>Write a function that makes an HTTP GET request for the given url. Return the media type / content-type from the HTTP Response Header as a string.
Example
content_type(""https://edabit.com"") ➞ ""text/html; charset=utf-8""
Notes
You may want to make use of and import requests.
Do not cheat and just print out the answer, you must fetch this from edabit.com.
Return the output as a string.:import requests
def content_type(url):
  return requests.get(url).headers[""content-type""]<|endoftext|>"
248,"<|endoftext|>Create a function that counts the number of syllables a word has. Each syllable is separated with a dash -.
Examples
number_syllables(""buf-fet"") ➞ 2

number_syllables(""beau-ti-ful"") ➞ 3

number_syllables(""mon-u-men-tal"") ➞ 4

number_syllables(""on-o-mat-o-poe-ia"") ➞ 6
Notes
Don't forget to return the result.
If you get stuck on a challenge, find help in the Resources tab.
If you're really stuck, unlock solutions in the Solutions tab.:def number_syllables(word):
  return len(word.split('-'))<|endoftext|>"
249,"<|endoftext|>Boolean Values
In programming you often need to know if an expression is True or False.

You can evaluate any expression in Python, and get one of two answers, True or False.

When you compare two values, the expression is evaluated and Python returns the Boolean answer::print(10 > 9)
print(10 == 9)
print(10 < 9)<|endoftext|>"
250,"<|endoftext|>In the previous article, we have discussed Python Program to find the Sum of Series 1^1+2^2+3^3…+N^N
 Given a matrix, the task is to scan and print the elements of the given matrix in Python
 
 What is a matrix:
 
 A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.
 
 Example:
 
 
 
 Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.
 
 In this order, the dimensions of a matrix indicate the number of rows and columns.
 
 
 
 Here as there are 5 rows and 4 columns it is called a 5*4 matrix.:# Give the number of rows of the matrix as user input using the int(input()) function
 # and store it in a variable.
 mtrxrows = int(input('Enter some random number of rows of the matrix = '))
 # Give the number of columns of the matrix as user input using the int(input()) function
 # and store it in another variable.
 mtrxcols = int(input('Enter some random number of columns of the matrix = '))
 # Take a list and initialize it with an empty value using [] or list() to say gvnmatrix.
 mtrx = []
 # Loop till the given number of rows using the For loop
 for n in range(mtrxrows):
  # Inside the For loop, Give all the row elements of the given Matrix as a list using
  # the list(),map(),int(),split() functions and store it in a variable.
  l = list(map(int, input(
  'Enter {'+str(mtrxcols)+'} elements of row {'+str(n+1)+'} separated by spaces = ').split()))
  # Add the above row elements list to gvnmatrix using the append() function.
  mtrx.append(l)
 # To print all the elements of the given matrix.
 # Loop till the given number of rows using the For loop.
 for n in range(mtrxrows):
  # Inside the For loop, Iterate till the given number of rows using another
  # Nested For loop(Inner For loop).
  for m in range(mtrxcols):
  # Print the element of the matrix by printing gvnmatrix[n][m] value
  # where n is the iterator value of the parent For loop and m is the iterator
  # value of the inner For loop.
  print(mtrx[n][m], end=' ')
  print()<|endoftext|>"
251,"<|endoftext|>In this example, you will learn to convert bytes to a string.:print(b'Easy \xE2\x9C\x85'.decode(""utf-8""))<|endoftext|>"
252,"<|endoftext|>Write a function that takes a list of strings and a pattern (string) and returns the strings that contain the pattern in alphabetical order. If the pattern is an empty string, return all the strings passed in the input list.
Examples
cms_selector([""WordPress"", ""Joomla"", ""Drupal""], ""w"") ➞ [""WordPress""]

cms_selector([""WordPress"", ""Joomla"", ""Drupal"", ""Magento""], ""ru"") ➞ [""Drupal""]

cms_selector([""WordPress"", ""Joomla"", ""Drupal"", ""Magento""], """") ➞ [""Drupal"", ""Joomla"", ""Magento"", ""WordPress""]
Notes
The given letter(s) are case insensitive and can be more than one.
In the case of an empty string, return the entire list.
A CMS is a Content Management System.:def cms_selector(lst, txt):
  return sorted(i for i in lst if txt in i)<|endoftext|>"
253,"<|endoftext|>We will learn how to convert binary to grey code in Python in this tutorial. A binary number is a number written in the base-2 numeral system. As a result, a binary number is made up of only 0s and 1s. So, today, we’ll learn how to represent binary and grey code numbers, how to convert a binary number to grey code, and how to use a Python program to convert a binary number to grey code.:# function which accepts the binary string and returns the gray code of the binary string
def binToString(binStr):
    # Converting the given binary string to integer
    binStr = int(binStr, 2)
    binStr ^= (binStr >> 1)

    # Returning the binary converted string using bin() function
    return bin(binStr)[2:]


# given binary number as static
binString = input(""Enter some random binary string = "")
# passing this binString to binToString function
resultGray = binToString(binString)
print('The Gray Code of the binary string=', binString, '=', resultGray)<|endoftext|>"
254,"<|endoftext|>Given a predetermined rate from a dictionary, write the function that will return the time it takes for a certain amount of people to paint a certain amount of walls.
The ""rate"" dictionary shows how many minutes it takes ""people"" people to paint ""walls"" walls. At that same rate, how long should it take based on the new variables. Return the minutes as an integer. No rounding is necessary.
Example
# It takes 22 minutes for 10 people to paint 10 walls.
# How many minutes does it take 14 people to paint 14 walls?

rate = {
  ""people"": 10,
  ""walls"": 10,
  ""minutes"": 22
}

time(rate, people, walls) ➞ 22
Notes
Check the Resources tab if you get stuck.:def time(dct, people, walls):
  return (dct['minutes'] * dct['people'] * walls) // (dct['walls'] * people)<|endoftext|>"
255,"<|endoftext|>Create a function that takes a list of strings and return a list, sorted from shortest to longest.
Examples
sort_by_length([""Google"", ""Apple"", ""Microsoft""])
➞ [""Apple"", ""Google"", ""Microsoft""]

sort_by_length([""Leonardo"", ""Michelangelo"", ""Raphael"", ""Donatello""])
➞ [""Raphael"", ""Leonardo"", ""Donatello"", ""Michelangelo""]

sort_by_length([""Turing"", ""Einstein"", ""Jung""])
➞ [""Jung"", ""Turing"", ""Einstein""]
Notes
All test cases contain lists with strings of different lengths, so you won't have to deal with multiple strings of the same length.:def sort_by_length(lst):
  return sorted(lst, key=len)<|endoftext|>"
256,"<|endoftext|>Representation of graph:
""""""
A Python program to demonstrate the adjacency
list representation of the graph
""""""
 
# A class to represent the adjacency list of the node
 
 
class AdjNode:
    def __init__(self, data):
        self.vertex = data
        self.next = None
 
 
# A class to represent a graph. A graph
# is the list of the adjacency lists.
# Size of the array will be the no. of the
# vertices ""V""
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [None] * self.V
 
    # Function to add an edge in an undirected graph
    def add_edge(self, src, dest):
        # Adding the node to the source node
        node = AdjNode(dest)
        node.next = self.graph[src]
        self.graph[src] = node
 
        # Adding the source node to the destination as
        # it is the undirected graph
        node = AdjNode(src)
        node.next = self.graph[dest]
        self.graph[dest] = node
 
    # Function to print the graph
    def print_graph(self):
        for i in range(self.V):
            print(""Adjacency list of vertex {}\n head"".format(i), end="""")
            temp = self.graph[i]
            while temp:
                print("" -> {}"".format(temp.vertex), end="""")
                temp = temp.next
            print("" \n"")
 
 
# Driver program to the above graph class
if __name__ == ""__main__"":
    V = 5
    graph = Graph(V)
    graph.add_edge(0, 1)
    graph.add_edge(0, 4)
    graph.add_edge(1, 2)
    graph.add_edge(1, 3)
    graph.add_edge(1, 4)
    graph.add_edge(2, 3)
    graph.add_edge(3, 4)
 
    graph.print_graph()
 
# This code is contributed by Kanav Malhotra<|endoftext|>"
257,"<|endoftext|>Strings in python:

In Python, a string is a sequence of characters. It is a data type that has been derived. Strings are unchangeable. This means that once they’ve been defined, they can’t be modified. Many Python functions change strings, such as replace(), join(), and split(). They do not, however, alter the original string. They make a copy of a string, alter it, then return it to the caller.

String formatting, as the name implies, refers to the various methods for formatting strings in Python. In this article, we will go over the various methods and how to use them.:# given website
website = ""BTechGeeks""
# print the website name using % operator
print('The given website is %s' % website)<|endoftext|>"
258,"<|endoftext|>Given a Binary Tree and a number k, remove all nodes that lie only on root to leaf path(s) of length smaller than k. If a node X lies on multiple root-to-leaf paths and if any of the paths has path length >= k, then X is not deleted from Binary Tree. In other words a node is deleted if all paths going through it have lengths smaller than k.
Consider the following example Binary Tree 
 

               1
           /      \
         2          3
      /     \         \
    4         5        6
  /                   /
 7                   8 
Input: Root of above Binary Tree
       k = 4

Output: The tree should be changed to following  
           1
        /     \
      2          3
     /             \
   4                 6
 /                  /
7                  8
There are 3 paths 
i) 1->2->4->7      path length = 4
ii) 1->2->5        path length = 3
iii) 1->3->6->8    path length = 4 
There is only one path "" 1->2->5 "" of length smaller than 4.  
The node 5 is the only node that lies only on this path, so 
node 5 is removed.
Nodes 2 and 1 are not removed as they are parts of other paths
of length 4 as well.

If k is 5 or greater than 5, then whole tree is deleted. 

If k is 3 or less than 3, then nothing is deleted:# Python3 program to remove nodes on root
# to leaf paths of length < K

# New node of a tree
class newNode:
	def __init__(self, data):
		self.data = data
		self.left = self.right = None
		
# Utility method that actually removes
# the nodes which are not on the pathLen >= k.
# This method can change the root as well.
def removeShortPathNodesUtil(root, level, k) :

	# Base condition
	if (root == None) :
		return None

	# Traverse the tree in postorder fashion
	# so that if a leaf node path length is
	# shorter than k, then that node and all
	# of its descendants till the node which
	# are not on some other path are removed.
	root.left = removeShortPathNodesUtil(root.left,
										level + 1, k)
	root.right = removeShortPathNodesUtil(root.right,
										level + 1, k)

	# If root is a leaf node and it's level
	# is less than k then remove this node.
	# This goes up and check for the ancestor
	# nodes also for the same condition till
	# it finds a node which is a part of other
	# path(s) too.
	if (root.left == None and
		root.right == None and level < k) :
		return None
	
	# Return root
	return root

# Method which calls the utility method
# to remove the short path nodes.
def removeShortPathNodes(root, k) :
	pathLen = 0
	return removeShortPathNodesUtil(root, 1, k)

# Method to print the tree in
# inorder fashion.
def prInorder(root) :

	if (root) :
	
		prInorder(root.left)
		print(root.data, end = "" "" )
		prInorder(root.right)
	
# Driver Code
if __name__ == '__main__':
	k = 4
	root = newNode(1)
	root.left = newNode(2)
	root.right = newNode(3)
	root.left.left = newNode(4)
	root.left.right = newNode(5)
	root.left.left.left = newNode(7)
	root.right.right = newNode(6)
	root.right.right.left = newNode(8)
	print(""Inorder Traversal of Original tree"" )
	prInorder(root)
	print()
	print(""Inorder Traversal of Modified tree"" )
	res = removeShortPathNodes(root, k)
	prInorder(res)

# This code is contributed
# by SHUBHAMSINGH10<|endoftext|>"
259,"<|endoftext|>A farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren.

A pyramidal plot of land can be defined as a set of cells with the following criteria:

The number of cells in the set has to be greater than 1 and all cells must be fertile.
The apex of a pyramid is the topmost cell of the pyramid. The height of a pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r).
An inverse pyramidal plot of land can be defined as a set of cells with similar criteria:

The number of cells in the set has to be greater than 1 and all cells must be fertile.
The apex of an inverse pyramid is the bottommost cell of the inverse pyramid. The height of an inverse pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i).
Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.


Given a 0-indexed m x n binary matrix grid representing the farmland, return the total number of pyramidal and inverse pyramidal plots that can be found in grid.:class Solution:
    def countPyramids(self, grid: List[List[int]]) -> int:
        m,n=len(grid),len(grid[0])
        def solve(arr):
            dp=arr
            ans=0
            for i in range(1,m):
                for j in range(1,n-1):
                    if dp[i][j]:
                        dp[i][j]+=min(dp[i-1][j],dp[i-1][j-1],dp[i-1][j+1])
                        ans+=dp[i][j]-1
            return ans
        new_grid=[[0]*n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                new_grid[i][j]=grid[m-i-1][n-j-1]
        return solve(grid)+solve(new_grid)<|endoftext|>"
260,"<|endoftext|>Help the drunken programmer fix his code! The RegEx string should be designed so it can reliably test if a string has an ""A"" at the beginning and end (case insensitive) as well as a ""P"" somewhere in between (also case insensitive).
Due to the use of fullmatch, no ending $ or beginning ^ match character is permitted anywhere except for the middle. Also, requirements have changed. Now, all characters must be allowed!
Notes
Go to the Tests tab for more help.:import re
pattern = '(\A[aA]).*[pP].*([aA]\Z)'<|endoftext|>"
261,"<|endoftext|>Create a function that converts dash/underscore delimited words into camel casing. The first word within the output should be capitalized only if the original word was capitalized.
Examples
to_camel_case(""A-B-C"") ➞ ""ABC""

to_camel_case(""the-stealth-warrior"") ➞ ""theStealthWarrior""

to_camel_case(""The_Stealth_Warrior"") ➞ ""TheStealthWarrior""
Notes
An empty string as input """" should return an empty string.:def to_camel_case(text):
  text = text.replace('_','-')
  lst = text.split(""-"")
  return lst[0] + ''.join([i.capitalize() for i in lst[1:]])<|endoftext|>"
262,"<|endoftext|>Files in Python:

Python file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python’s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.

Given a file, the task is to create a filename containing the date or time in a given file in python:# Import datetime from datetime module using the import keyword
from datetime import datetime
  # Get the current date and time using the datetime.now() function
currnt_datetime = datetime.now()
# Print the current date and time
print(""The Current date and time is : "", currnt_datetime)
  # Pass the above datetime object to str() function to convert it into string and 
# store it in a variable
stringcurrnt_datetime = str(currnt_datetime)
  # Create the above file object with an extension using the string concatenation
filename = stringcurrnt_datetime+"".txt""
# Make a single variable to store the path of the file. This is a constant value. 
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in write mode. In this case, we're writing the contents into the file.
gvn_file =  open(givenFilename, 'w') 
# Print the created file name.
print(""The created File name is: "", gvn_file.name)
# Close the file using the close() function
gvn_file.close()<|endoftext|>"
263,"<|endoftext|>To develop a program to check the given number is a prime number or not in Python; first, you should know how to develop a Python program to find out all factors of a number. Because if any number has more than 2 factors then only, it is a prime number. All negative numbers, 0 and 1 are not the prime numbers.:# Python program to check if a number is prime or not # take inputs num = int(input('Enter a number: ')) # If number is greater than 1 if num > 1: for i in range(2, num//2): if (num % i) == 0: print(num, ""is not a prime number"") break else: print(num, ""is a prime number"") else: print(num, ""is not a prime number"")<|endoftext|>"
264,"<|endoftext|>Sort digits of a Number in Ascending Order Using For Loop (Static Input):# Give the number as static input and store it in a variable.
numb = 4561230008
# Convert the given number into a string number using the str() function and
# store it in another variable.
strng_numbr = str(numb)
# Sort the above-obtained string number using the sorted() function and store
# it in another variable.
sortdlst_num = sorted(strng_numbr)
# Convert this sorted list of numbers into a string using the join function and
# store it in another variable.
sortd_str = ''.join(sortdlst_num)
# Convert the above obtained sorted string to an integer using the int() function
# (This removes the leading zeros) and store it in another variable.
rslt = int(sortd_str)
# Print the sorted digits in ascending order of a given number after removal of
# leading zeros.
print(""The sorted digits in ascending order of a given number"",
      numb, ""after removal of leading zeros ="")
print(rslt)<|endoftext|>"
265,"<|endoftext|>In this example, you will learn to compute all the permutation of the string.:def get_permutation(string, i=0):

    if i == len(string):   	 
        print("""".join(string))

    for j in range(i, len(string)):

        words = [c for c in string]
   
        # swap
        words[i], words[j] = words[j], words[i]
   	 
        get_permutation(words, i + 1)

print(get_permutation('yup'))
from itertools import permutations

words = [''.join(p) for p in permutations('pro')]

print(words)<|endoftext|>"
266,"<|endoftext|>Write a Python program to print the square with all zeros except the pattern of the diagonal numbers using for loop.:rows = int(input(""Enter Square With Diagonal Numbers Rows = ""))

print(""====The Square With Diagonal Numbers and Remaining 0's Pattern===="")

for i in range(1, rows + 1):
    for j in range(1, i):
        print('0', end = ' ')
    print(i, end = ' ')
    for k in range(i, rows):
        print('0', end = ' ')
    print()<|endoftext|>"
267,"<|endoftext|>LIFO is an abbreviation for last in, first out. It is a method for handling data structures where the first element is processed last and the last element is processed first.:# Python3 program to demonstrate working of LIFO

# Pushing element on the top of the stack
def stack_push(stack):
	for i in range(5):
		stack.append(i)
	return stack

# Popping element from the top of the stack
def stack_pop(stack):
	print(""Pop :"")

	for i in range(5):
		y = stack[-1]
		stack.pop()
		print(y)
	return stack

# Displaying element on the top of the stack
def stack_peek(stack):
	element = stack[-1]
	print(""Element on stack top :"", element)

# Searching element in the stack
def stack_search(stack, element):
	pos = -1
	co = 0
	while(len(stack) > 0):
		co+=1
		if(stack[-1] == element):
			pos = co
			break
		stack.pop()

	if (pos == -1):
		print( ""Element not found"")
	else:
		print(""Element is found at position"", pos)

stack = []
stack_push(stack)
stack_pop(stack)
stack_push(stack)
stack_peek(stack)
stack_search(stack, 2)
stack_search(stack, 6)

# This code is contributed by rameshtravel07.
<|endoftext|>"
268,"<|endoftext|>You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].
Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.
If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.
 
Example 1:


Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
Output: 0.25000
Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.

Example 2:


Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
Output: 0.30000

Example 3:


Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
Output: 0.00000
Explanation: There is no path between 0 and 2.

 
Constraints:

2 <= n <= 10^4
0 <= start, end < n
start != end
0 <= a, b < n
a != b
0 <= succProb.length == edges.length <= 2*10^4
0 <= succProb[i] <= 1
There is at most one edge between every two nodes.:def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
  p, g = [0.0] * n, defaultdict(list)
  for index, (a, b) in enumerate(edges):
  g[a].append((b, index))
  g[b].append((a, index))
  p[start] = 1.0
  heap = [(-p[start], start)]  
  while heap:
  prob, cur = heapq.heappop(heap)
  if cur == end:
  return -prob
  for neighbor, index in g.get(cur, []):
  if -prob * succProb[index] > p[neighbor]:
  p[neighbor] = -prob * succProb[index]
  heapq.heappush(heap, (-p[neighbor], neighbor))
  return 0.0<|endoftext|>"
269,"<|endoftext|>Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways.
Depth First Traversals: 
(a) Inorder (Left, Root, Right) 
(b) Preorder (Root, Left, Right)
(c) Postorder (Left, Right, Root):# Python program to for tree traversals

# A class that represents an individual node in a
# Binary Tree


class Node:
	def __init__(self, key):
		self.left = None
		self.right = None
		self.val = key


# A function to do inorder tree traversal
def printInorder(root):

	if root:

		# First recur on left child
		printInorder(root.left)

		# then print the data of node
		print(root.val),

		# now recur on right child
		printInorder(root.right)


# A function to do postorder tree traversal
def printPostorder(root):

	if root:

		# First recur on left child
		printPostorder(root.left)

		# the recur on right child
		printPostorder(root.right)

		# now print the data of node
		print(root.val),


# A function to do preorder tree traversal
def printPreorder(root):

	if root:

		# First print the data of node
		print(root.val),

		# Then recur on left child
		printPreorder(root.left)

		# Finally recur on right child
		printPreorder(root.right)


# Driver code
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
print ""Preorder traversal of binary tree is""
printPreorder(root)

print ""\nInorder traversal of binary tree is""
printInorder(root)

print ""\nPostorder traversal of binary tree is""
printPostorder(root)<|endoftext|>"
270,"<|endoftext|>Given a number, the task is to swap all odd and even bits of the given number in Python.
 In binary, the number 185 is represented as 10111001. The bits in bold are in even positions, and they are 1 1 1 0, while the bits in odd positions are 0 1 0 1.
 After swapping the odd and even bits, we get 118(1110110)
 Examples:
 Example1:
 Input:
 Given Number =456
 Output:
 The original given number is = 456
 
 The modified number after swapping bits is = 708
 Example2:
 Input:
 Given Number =185
 Output:
 The original given number is = 185
 
 The modified number after swapping bits is = 118:# Give the number as static input and store it in a variable.
 
 numb = 185
 
 # To extract the odd bits from the number,
 
 # use a bitwise AND operation with hexadecimal 55555555.
 
 oddbitsnumb = numb &amp; 0x55555555
 
 # To extract the even bits from the number,
 
 # use a bitwise AND operation with hexadecimal AAAAAAAA.
 
 evenbitsnumb = numb &amp; 0xAAAAAAAA
 
 # Perform a left shift &lt;&lt; by 1 position to move odd bits to even positions.
 
 oddbitsnumb = oddbitsnumb &lt;&lt; 1
 
 # Perform a right shift &gt;&gt; by 1 place to move even bits to odd positions.
 
 evenbitsnumb = evenbitsnumb &gt;&gt; 1
 
 # Finally, using the bitwise OR operator, to combine both bits.
 
 modifdnumb = oddbitsnumb | evenbitsnumb
 
 # Print the modified Number after swapping odd and even bits of the given number.
 
 print('The original given number is =', numb)
 
 print('The modified number after swapping bits is =', modifdnumb)
 
 </pre><|endoftext|>"
271,"<|endoftext|>You are given an array of distinct positive integers locations where locations[i] represents the position of city i. You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.
At each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x.
Notice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).
Return the count of all possible routes from start to finish. Since the answer may be too large, return it modulo 109 + 7.
 
Example 1:

Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5
Output: 4
Explanation: The following are all possible routes, each uses 5 units of fuel:
1 -> 3
1 -> 2 -> 3
1 -> 4 -> 3
1 -> 4 -> 2 -> 3

Example 2:

Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6
Output: 5
Explanation: The following are all possible routes:
1 -> 0, used fuel = 1
1 -> 2 -> 0, used fuel = 5
1 -> 2 -> 1 -> 0, used fuel = 5
1 -> 0 -> 1 -> 0, used fuel = 3
1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5

Example 3:

Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3
Output: 0
Explanation: It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.

 
Constraints:

2 <= locations.length <= 100
1 <= locations[i] <= 109
All integers in locations are distinct.
0 <= start, finish < locations.length
1 <= fuel <= 200:def countRoutes(self, l: List[int], start: int, fin: int, fuel: int) -> int:
  @lru_cache(None)
  def dfs(i: int, f: int) -> int:
  return 0 if f < 0 else (1 if i == fin else 0) + sum(0 if i == j else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))
  return dfs(start, fuel) % 1000000007<|endoftext|>"
272,"<|endoftext|>This is to augment AVL tree node to store count together with regular fields like key, left and right pointers. :# Python code to delete a node in AVL tree
# Generic tree node class


class TreeNode():
	def __init__(self, val):
		self.count = 1 # assigning count variable so that during insertion in will be incremented for duplicate values
		# and during deletion, it will be decremented if has multiple copies.
		self.height = 1
		self.val = val
		self.left = None
		self.right = None
# only insertion and deletion will be affected. if multiple copies are there, entry(count) will be printed during traversal.

# AVL tree class which supports insertion,
# deletion operations


class AVL_Tree(object):

	def insert(self, root, key):

		# Step 1 - Perform normal BST
		if not root:
			return TreeNode(key)
		else if key < root.val:
			root.left = self.insert(root.left, key)
		else if key > root.val:
			root.right = self.insert(root.right, key)
		else:
			root.count += 1 # incrementing count if same entry is inserted.

		# Step 2 - Update the height of the
		# ancestor node
		root.height = 1 + max(self.getHeight(root.left),
							self.getHeight(root.right))

		# Step 3 - Get the balance factor
		balance = self.getBalance(root)

		# Step 4 - If the node is unbalanced,
		# then try out the 4 cases
		# Case 1 - Left Left
		if balance > 1 and key < root.left.val:
			return self.rightRotate(root)

		# Case 2 - Right Right
		if balance < -1 and key > root.right.val:
			return self.leftRotate(root)

		# Case 3 - Left Right
		if balance > 1 and key > root.left.val:
			root.left = self.leftRotate(root.left)
			return self.rightRotate(root)

		# Case 4 - Right Left
		if balance < -1 and key < root.right.val:
			root.right = self.rightRotate(root.right)
			return self.leftRotate(root)

		return root

	# Recursive function to delete a node with
	# given key from subtree with given root.
	# It returns root of the modified subtree.
	def delete(self, root, key):

		# Step 1 - Perform standard BST delete
		if not root:
			return root

		else if key < root.val:
			root.left = self.delete(root.left, key)

		else if key > root.val:
			root.right = self.delete(root.right, key)

		else:
			if root.count > 1: # if count is more than one i.e multiple copies are there
				root.count -= 1 # just decrement count
				return root # so that one copy will be deleted and return

			if root.left is None:
				temp = root.right
				root = None
				return temp

			else if root.right is None:
				temp = root.left
				root = None
				return temp

			temp = self.getMinValueNode(root.right)
			root.val = temp.val
			root.right = self.delete(root.right,
									temp.val)

		# If the tree has only one node,
		# simply return it
		if root is None:
			return root

		# Step 2 - Update the height of the
		# ancestor node
		root.height = 1 + max(self.getHeight(root.left),
							self.getHeight(root.right))

		# Step 3 - Get the balance factor
		balance = self.getBalance(root)

		# Step 4 - If the node is unbalanced,
		# then try out the 4 cases
		# Case 1 - Left Left
		if balance > 1 and self.getBalance(root.left) >= 0:
			return self.rightRotate(root)

		# Case 2 - Right Right
		if balance < -1 and self.getBalance(root.right) <= 0:
			return self.leftRotate(root)

		# Case 3 - Left Right
		if balance > 1 and self.getBalance(root.left) < 0:
			root.left = self.leftRotate(root.left)
			return self.rightRotate(root)

		# Case 4 - Right Left
		if balance < -1 and self.getBalance(root.right) > 0:
			root.right = self.rightRotate(root.right)
			return self.leftRotate(root)

		return root

	def leftRotate(self, z):

		y = z.right
		T2 = y.left

		# Perform rotation
		y.left = z
		z.right = T2

		# Update heights
		z.height = 1 + max(self.getHeight(z.left),
						self.getHeight(z.right))
		y.height = 1 + max(self.getHeight(y.left),
						self.getHeight(y.right))

		# Return the new root
		return y

	def rightRotate(self, z):

		y = z.left
		T3 = y.right

		# Perform rotation
		y.right = z
		z.left = T3

		# Update heights
		z.height = 1 + max(self.getHeight(z.left),
						self.getHeight(z.right))
		y.height = 1 + max(self.getHeight(y.left),
						self.getHeight(y.right))

		# Return the new root
		return y

	def getHeight(self, root):
		if not root:
			return 0

		return root.height

	def getBalance(self, root):
		if not root:
			return 0

		return self.getHeight(root.left) - self.getHeight(root.right)

	def getMinValueNode(self, root):
		if root is None or root.left is None:
			return root

		return self.getMinValueNode(root.left)

	def preOrder(self, root):

		if not root:
			return

		print(""{}({}) "".format(root.val, root.count), end="""")
		self.preOrder(root.left)
		self.preOrder(root.right)


myTree = AVL_Tree()
root = None
nums = [9, 5, 10, 5, 9, 7, 17]

for num in nums:
	root = myTree.insert(root, num)

# Preorder Traversal
print(""Preorder Traversal after insertion -"")
myTree.preOrder(root)
print()

# Delete
key = 10
root = myTree.delete(root, key)
key = 10
root = myTree.delete(root, key)
key = -1
root = myTree.delete(root, key)
key = 0
root = myTree.delete(root, key)

# Preorder Traversal
print(""Preorder Traversal after deletion -"")
myTree.preOrder(root)
print()

# This code is contributed by Ajitesh Pathak<|endoftext|>"
273,"<|endoftext|>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.

A leaf is a node with no children.

 

Example 1:


Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
Explanation: The root-to-leaf path with the target sum is shown.
Example 2:


Input: root = [1,2,3], targetSum = 5
Output: false
Explanation: There two root-to-leaf paths in the tree:
(1 --> 2): The sum is 3.
(1 --> 3): The sum is 4.
There is no root-to-leaf path with sum = 5.
Example 3:

Input: root = [], targetSum = 0
Output: false
Explanation: Since the tree is empty, there are no root-to-leaf paths.:class Solution:
    def hasPathSum(self, root, sum):
        """"""
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """"""
        if not root:
            return False

        sum -= root.val
        if not root.left and not root.right:  # if reach a leaf
            return sum == 0
        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)<|endoftext|>"
274,"<|endoftext|>Given an array of n elements. The task is to count the total number of indices (i, j) such that arr[i] = arr[j] and i < j
Examples : 
 

Input : arr[] = {1, 1, 2}
Output : 1
As arr[0] = arr[1], the pair of indices is (0, 1):# Python3 program to count of index pairs
# with equal elements in an array.
import math as mt

# Return the number of pairs with
# equal values.
def countPairs(arr, n):

        mp = dict()

        # Finding frequency of each number.
        for i in range(n):
                if arr[i] in mp.keys():
                        mp[arr[i]] += 1
                else:
                        mp[arr[i]] = 1
                        
        # Calculating pairs of each value.
        ans = 0
        for it in mp:
                count = mp[it]
                ans += (count * (count - 1)) // 2
        return ans

# Driver Code
arr = [1, 1, 2]
n = len(arr)
print(countPairs(arr, n))

# This code is contributed by mohit kumar 29
<|endoftext|>"
275,"<|endoftext|>Given a tree, the task is to find the maximum in an only left node of the binary tree.:# Python program to print maximum element
# in left node.
 
# Utility class to create a
# new tree node
class newNode:
    def __init__(self, data):
        self.data = data
        self.left = self.right = None
     
# Get max of left element using
# Inorder traversal
def maxOfLeftElement(root):
    res = -999999999999
    if (root == None):
        return res
 
    if (root.left != None):
        res = root.left.data
 
    # Return maximum of three values
    # 1) Recursive max in left subtree
    # 2) Value in left node
    # 3) Recursive max in right subtree
    return max({ maxOfLeftElement(root.left), res,
                 maxOfLeftElement(root.right) })
 
# Driver Code
if __name__ == '__main__':
 
    # Let us create binary tree shown
    # in above diagram
    root = newNode(7)
    root.left = newNode(6)
    root.right = newNode(5)
    root.left.left = newNode(4)
    root.left.right = newNode(3)
    root.right.left = newNode(2)
    root.right.right = newNode(1)
 
    #     7
    #     / \
    # 6     5
    # / \     / \
    # 4 3     2 1        
    print(maxOfLeftElement(root))
 
# This code is contributed by PranchalK
<|endoftext|>"
276,"<|endoftext|>Rotate a matrix by 90 degree without using any extra space:# Alternative implementation using numpy
import numpy

# Driven code
arr = [[1, 2, 3, 4],
	[5, 6, 7, 8],
	[9, 10, 11, 12],
	[13, 14, 15, 16]
	]

# Define flip algorithm (Note numpy.flip is a builtin f
# function for versions > v.1.12.0)


def flip(m, axis):
	if not hasattr(m, 'ndim'):
		m = asarray(m)
	indexer = [slice(None)] * m.ndim
	try:
		indexer[axis] = slice(None, None, -1)
	except IndexError:
		raise ValueError(""axis =% i is invalid for the % i-dimensional input array""
						% (axis, m.ndim))
	return m[tuple(indexer)]


# Transpose the matrix
trans = numpy.transpose(arr)

# Flip the matrix anti-clockwise (1 for clockwise)
flipmat = flip(trans, 0)

print(""\nnumpy implementation\n"")
print(flipmat)<|endoftext|>"
277,"<|endoftext|>Create a function that takes a list of numbers and returns the sum of the two lowest positive numbers.
Examples
sum_two_smallest_nums([19, 5, 42, 2, 77]) ➞ 7

sum_two_smallest_nums([10, 343445353, 3453445, 3453545353453]) ➞ 3453455

sum_two_smallest_nums([2, 9, 6, -1]) ➞ 8

sum_two_smallest_nums([879, 953, 694, -847, 342, 221, -91, -723, 791, -587]) ➞ 563

sum_two_smallest_nums([3683, 2902, 3951, -475, 1617, -2385]) ➞ 4519
Notes
Don't count negative numbers.
Floats and empty lists will not be used in any of the test cases.:def sum_two_smallest_nums(lst):
  return sum(sorted([x for x in lst if x > 0])[:2])<|endoftext|>"
278,"<|endoftext|>Given a singly linked list, find if the linked list is circular or not. A linked list is called circular if it is not NULL-terminated and all nodes are connected in the form of a cycle. Below is an example of a circular linked list.
 :# A simple Python program to check if a linked list is circular

# Node class
class Node:

	# Function to initialise the node object
	def __init__(self, data):
		self.data = data # Assign data
		self.next = None # Initialize next as null


# Linked List class contains a Node object
class LinkedList:

	# Function to initialize head
	def __init__(self):
		self.head = None

def Circular(head):
	if head==None:
		return True
		
	# Next of head
	node = head.next
	i = 0
	
	# This loop would stop in both cases (1) If
	# Circular (2) Not circular
	while((node is not None) and (node is not head)):
		i = i + 1
		node = node.next
	
	return(node==head)


# Code execution starts here
if __name__=='__main__':
	llist = LinkedList()
	llist.head = Node(1)
	second = Node(2)
	third = Node(3)
	fourth = Node(4)
	
	llist.head.next = second;
	second.next = third;
	third.next = fourth
	
	if (Circular(llist.head)):
		print('Yes')
	else:
		print('No')
	
	fourth.next = llist.head
	
	if (Circular(llist.head)):
		print('Yes')
	else:
		print('No')
		
# This code is contributed by Sanket Badhe
<|endoftext|>"
279,"<|endoftext|>Given the strings s1 and s2 of size n and the string evil, return the number of good strings.

A good string has size n, it is alphabetically greater than or equal to s1, it is alphabetically smaller than or equal to s2, and it does not contain the string evil as a substring. Since the answer can be a huge number, return this modulo 109 + 7.

 

Example 1:

Input: n = 2, s1 = ""aa"", s2 = ""da"", evil = ""b""
Output: 51 
Explanation: There are 25 good strings starting with 'a': ""aa"",""ac"",""ad"",...,""az"". Then there are 25 good strings starting with 'c': ""ca"",""cc"",""cd"",...,""cz"" and finally there is one good string starting with 'd': ""da"". 
Example 2:

Input: n = 8, s1 = ""leetcode"", s2 = ""leetgoes"", evil = ""leet""
Output: 0 
Explanation: All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix ""leet"", therefore, there is not any good string.
Example 3:

Input: n = 2, s1 = ""gx"", s2 = ""gz"", evil = ""x""
Output: 2
 

Constraints:

s1.length == n
s2.length == n
s1 <= s2
1 <= n <= 500
1 <= evil.length <= 50
All strings consist of lowercase English letters.:from functools import lru_cache

def srange(a, b):
  yield from (chr(i) for i in range(ord(a), ord(b)+1))
  
def failure(pat): 
  res = [0]
  i, target = 1, 0
  while i < len(pat): 
  if pat[i] == pat[target]: 
  target += 1
  res += target,
  i += 1
  elif target: 
  target = res[target-1] 
  else: 
  res += 0,
  i += 1
  return res  

class Solution:
  def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:
  f = failure(evil)
  @lru_cache(None)
  def dfs(idx, max_matched=0, lb=True, rb=True):
  '''
idx: current_idx_on_s1_&_s2, 
max_matched: nxt_idx_to_match_on_evil, 
lb, rb: is_left_bound, is_right_bound
'''
  if max_matched == len(evil): return 0 # evil found, break
  if idx == n: return 1 # base case
  
  l = s1[idx] if lb else 'a' # valid left bound
  r = s2[idx] if rb else 'z' # valid right bound
  candidates = [*srange(l, r)]
  
  res = 0
  for i, c in enumerate(candidates):
  nxt_matched = max_matched
  while evil[nxt_matched] != c and nxt_matched:
  nxt_matched = f[nxt_matched - 1]
  res += dfs(idx+1, nxt_matched + (c == evil[nxt_matched]), 
  lb=(lb and i == 0), rb=(rb and i == len(candidates)-1))
  return res  
  
  return dfs(0) % (10**9 + 7)<|endoftext|>"
280,"<|endoftext|>Create a function that filters out factorials from a list. A factorial is a number that can be represented in the following manner:
n! = n * (n-1) * (n-2) * ... * 3 * 2 * 1
Recursively, this can be represented as:
n! = n * (n-1)!
Examples
filter_factorials([1, 2, 3, 4, 5, 6, 7]) ➞ [1, 2, 6]

filter_factorials([1, 4, 120]) ➞ [1, 120]

filter_factorials([8, 9, 10]) ➞ []
Notes
N/A:def is_factorial(n):
  m, i = 1, 2
  while m < n:
    m *= i
    i += 1
  return m == n
def filter_factorials(numbers):
  return list(filter(is_factorial, numbers))<|endoftext|>"
281,"<|endoftext|>There is a programming language with only four operations and one variable X:

++X and X++ increments the value of the variable X by 1.
--X and X-- decrements the value of the variable X by 1.
Initially, the value of X is 0.

Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.

 :class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        ans = 0
        for operation in operations:
            ans = ans + 1 if operation in [""++X"",""X++""] else ans-1
        return ans<|endoftext|>"
282,"<|endoftext|>A number/string is a palindrome if the digits/characters are the same when read both forward and backward. Examples include ""racecar"" and 12321. Given a positive number n, check if n or the binary representation of n is palindromic. Return the following:
""Decimal only."" if only n is a palindrome.
""Binary only."" if only the binary representation of n is a palindrome.
""Decimal and binary."" if both are palindromes.
""Neither!"" if neither are palindromes.
Examples
palindrome_type(1306031) ➞ ""Decimal only.""
# decimal = 1306031
# binary  = ""100111110110110101111""

palindrome_type(427787) ➞ ""Binary only.""
# decimal = 427787
# binary  = ""1101000011100001011""

palindrome_type(313) ➞ ""Decimal and binary.""
# decimal = 313
# binary  = 100111001

palindrome_type(934) ➞ ""Neither!""
# decimal = 934
# binary  = ""1110100110""
Notes
Check the Resources tab for ways to convert to binary.:def palindrome_type(n):
  s = 0
  pal = lambda s : s == s[::-1]
  if pal(str(n)):
    s += 1
  if pal(format(n, 'b')):
    s += 2
  return ['Neither!','Decimal only.','Binary only.','Decimal and binary.'][s]<|endoftext|>"
283,"<|endoftext|>Make two functions:

consonants(word) which returns the number of consonants in a word when called.
vowels(word) which returns the number of vowels in a word when called.

Examples

vowels('Jameel SAEB') ➞ 5

consonants('He|\o mY Fr*end') ➞ 7

consonants(""Smithsonian"") ➞ 7
vowels(""Smithsonian"") ➞ 4
Notes

Vowels are: a, e, i, o, u.
Spaces and special characters count neither as consonants nor as vowels.
Check Resources for more info.:def consonants(word):
  return sum(c.lower() not in 'aeiou' for c in word if c.isalpha())
def vowels(word):
  return sum(c.lower() in 'aeiou' for c in word)<|endoftext|>"
284,"<|endoftext|>Given a binary tree root, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
 

Example 1:



Input: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
Output: 20
Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.
Example 2:



Input: root = [4,3,null,1,2]
Output: 2
Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.
Example 3:

Input: root = [-4,-2,-5]
Output: 0
Explanation: All values are negatives. Return an empty BST.
 

Constraints:

The number of nodes in the tree is in the range [1, 4 * 104].
-4 * 104 <= Node.val <= 4 * 104:class Solution:
  def maxSumBST(self, root: TreeNode) -> int:
  res = 0
  def traverse(root):
  '''return status_of_bst, size_of_bst, left_bound, right_bound'''
  nonlocal res
  if not root: return 1, 0, None, None # this subtree is empty
  
  ls, l, ll, lr = traverse(root.left)
  rs, r, rl, rr = traverse(root.right)
  
  if ((ls == 2 and lr < root.val) or ls == 1) and ((rs == 2 and rl > root.val) or rs == 1):
  # this subtree is a BST
  size = root.val + l + r
  res = max(res, size)
  return 2, size, (ll if ll is not None else root.val), (rr if rr is not None else root.val)
  return 0, None, None, None # this subtree is not a BST
  
  traverse(root)
  return res<|endoftext|>"
285,"<|endoftext|>There is a family tree rooted at 0 consisting of n nodes numbered 0 to n - 1. You are given a 0-indexed integer array parents, where parents[i] is the parent for node i. Since node 0 is the root, parents[0] == -1.

There are 105 genetic values, each represented by an integer in the inclusive range [1, 105]. You are given a 0-indexed integer array nums, where nums[i] is a distinct genetic value for node i.

Return an array ans of length n where ans[i] is the smallest genetic value that is missing from the subtree rooted at node i.

The subtree rooted at a node x contains node x and all of its descendant nodes.:class Solution:
    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        n = len(parents)
        g = [[] for _ in range(n)]
        for i, p in enumerate(parents):
            if p != -1: g[p].append(i)
        
        res = [1] * n
        if 1 not in nums: return res  # 1 is missing for all nodes
        
        seen = [False] * (n+1)  # record seen genetic values
        def scan(p, prev):  # dfs. put all values in this subtree into seen[]
            if nums[p] <= n: seen[nums[p]] = True
            for q in g[p]:
                if q != prev: scan(q, -1)  # prevent duplicated visits
        
        prev, p = -1, nums.index(1)
        cur = 0  # max genetic value seen so far
        while p != -1:
            scan(p, prev)
            while cur + 1 <= n and seen[cur+1]: cur += 1
            res[p] = cur + 1
            prev, p = p, parents[p]
            
        return res<|endoftext|>"
286,"<|endoftext|>Create a program that converts a phone number with letters to one with only numbers.
Number Letter
0 none
1 none
2 ABC
3 DEF
4 GHI
5 JKL
6 MNO
7 PQRS
8 TUV
9 WXYZ
Examples
text_to_num(""123-647-EYES"") ➞ ""123-647-3937""

text_to_num(""(325)444-TEST"") ➞ ""(325)444-8378""

text_to_num(""653-TRY-THIS"") ➞ ""653-879-8447""

text_to_num(""435-224-7613"") ➞ ""435-224-7613""
Notes
All inputs will be formatted as a string representing a proper phone number in the format XXX-XXX-XXXX or (XXX)XXX-XXXX, using numbers and capital letters.
Check the Resources tab for more info on telephone keypads.:def text_to_num(phone):
  alpha = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
  num = ""22233344455566677778889999""
  dic = dict(zip(alpha,num))
  return """".join([dic[i] if i.isalpha() else i for i in phone])<|endoftext|>"
287,"<|endoftext|>Given two points P, Q in the coordinate plane and the task is to find the equation of the line passing through both the given points.

This type of conversion is very useful in many geometric algorithms such as line intersection, finding the circumcenter of a triangle, finding the incenter of a triangle, etc.

Let P(x1, y1) and Q(x2, y2) be the given two points. We can now find the equation of the line formed by these points.

Any line can be written as

ax + by = c

Let the two points form a straight line. As a result,

ax1 + by1 = c
ax2 + by2 = c

Formulas:

We can change the following values to ensure that all of the equations hold true:

a = y2 – y1
b = x1 – x2

c = ax1 + by1:# Give the first point as static input and store it in two variables.
a1 = 4
b1 = 2
# Give the second point as static input and store it in another two variables.
a2 = 3
b2 = 8
# Subtract b1 from b2 and store it in another variable say p.
p = b2 - b1
# Subtract a2 from b1 and store it in another variable say q.
q = a1 - a2
# Calculate the value of p*(a1) + q*(b1) and store it in a variable say r.
r = p*(a1) + q*(b1)
# Check if the value of q is less than 0 using the if conditional statement.
if(q < 0):
  # If it is true, then print the respective line equation using the variables p,q,r.
    print(""The Equation of line passing through the given two points is:"",
          p, ""x "", q, ""y = "", r)
else:
  # Else, print the respective line equation using the variables p,q,r.
    print(""The Equation of line passing through the given two points is: "",
          p, ""x + "", q, ""y = "", r)<|endoftext|>"
288,"<|endoftext|>Method #1: Using For loop (Star Character)
Approach:

Give the side of the square as static input and store it in a variable.
Loop till the side length of the square using For loop.
Loop till the side length of the square using another nested For loop.
We use the If Else statement to check If the side length is 0 or maximum – 1. (For the Outer Boundary of the square)
We can say it is diagonal if a row equals a column, or a row equals N-i+1 (where i is the current row number).
We merge these two conditions using if and or operator.
We have or operator in Python,|| operator in C, C++, and Java
If it is true then print * else print space.
The Exit of the Program.:# Give the side of the square as static input and store it in a variable.
squareside = 10
# Loop till the side length of the square using For loop.
for m in range(squareside):
    # Loop till the side length of the square using another nested For loop.
    for n in range(squareside):
        # We use the If Else statement to check If the side length is 0 or maximum – 1. (For the Outer Boundary of the square)
        # We can say it is diagonal if a row equals a column, or a row equals N-i+1 (where i is the current row number).
        # We merge these two conditions using if and or operator.
        # We have or operator in Python,|| operator in C, C++, and Java
        # If it is true then print * else print space.
        if(m == 0 or m == squareside - 1 or n == 0 or n == squareside - 1 or m == n or n == (squareside - 1 - m)):
            print('*', end=' ')
        else:
            print(' ', end=' ')
    print()<|endoftext|>"
289,"<|endoftext|>You are given an alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits).
You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.
Return the reformatted string or return an empty string if it is impossible to reformat the string.
 
Example 1:

Input: s = ""a0b1c2""
Output: ""0a1b2c""
Explanation: No two adjacent characters have the same type in ""0a1b2c"". ""a0b1c2"", ""0a1b2c"", ""0c2a1b"" are also valid permutations.

Example 2:

Input: s = ""leetcode""
Output: """"
Explanation: ""leetcode"" has only characters so we cannot separate them by digits.

Example 3:

Input: s = ""1229857369""
Output: """"
Explanation: ""1229857369"" has only digits so we cannot separate them by characters.

 
Constraints:

1 <= s.length <= 500
s consists of only lowercase English letters and/or digits.:def reformat(self, s: str) -> str:
  a, b = [], []
  for c in s:
  if 'a' <= c <= 'z':
  a.append(c)
  else:
  b.append(c)
  if len(a) < len(b):
  a, b = b, a
  if len(a) - len(b) >= 2:
  return ''
  ans = ''
  for i in range(len(a)+len(b)):
  if i % 2 == 0:
  ans += a[i//2]
  else:
  ans += b[i//2]
  return ans<|endoftext|>"
290,"<|endoftext|>Create a function that returns the mean of all digits.
Examples
mean(42) ➞ 3

mean(12345) ➞ 3

mean(666) ➞ 6
Notes
The mean of all digits is the sum of digits / how many digits there are (e.g. mean of digits in 512 is (5+1+2)/3(number of digits) = 8/3=2).
The mean will always be an integer.:def mean(num):
  x = [int(x) for x in str(abs(num))]
  return sum(x)/len(x)<|endoftext|>"
291,"<|endoftext|>Given an array of integers, segregate even and odd numbers in the array. All the even numbers should be present first, and then the odd numbers.

Examples:  

Input: arr[] = 1 9 5 3 2 6 7 11
Output: 2 6 5 3 1 9 7 11

Input: arr[] = 1 3 2 4 7 6 9 10
Output:  2 4 6 10 7 1 9 3:# Python3 implementation of the above approach
def arrayEvenAndOdd(arr, n):
	
	ind = 0;
	a = [0 for i in range(n)]
	
	for i in range(n):
		if (arr[i] % 2 == 0):
			a[ind] = arr[i]
			ind += 1

	for i in range(n):
		if (arr[i] % 2 != 0):
			a[ind] = arr[i]
			ind += 1

	for i in range(n):
		print(a[i], end = "" "")
		
	print()

# Driver code
arr = [ 1, 3, 2, 4, 7, 6, 9, 10 ]
n = len(arr)

# Function call
arrayEvenAndOdd(arr, n)

# This code is contributed by rohitsingh07052<|endoftext|>"
292,"<|endoftext|>Given an array of string words. Return all strings in words which is substring of another word in any order. 
String words[i] is substring of words[j], if can be obtained removing some characters to left and/or right side of words[j].
 
Example 1:

Input: words = [""mass"",""as"",""hero"",""superhero""]
Output: [""as"",""hero""]
Explanation: ""as"" is substring of ""mass"" and ""hero"" is substring of ""superhero"".
[""hero"",""as""] is also a valid answer.

Example 2:

Input: words = [""leetcode"",""et"",""code""]
Output: [""et"",""code""]
Explanation: ""et"", ""code"" are substring of ""leetcode"".

Example 3:

Input: words = [""blue"",""green"",""bu""]
Output: []

 
Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 30
words[i] contains only lowercase English letters.
It's guaranteed that words[i] will be unique.:class Solution:
  def stringMatching(self, words: List[str]) -> List[str]:
  def add(word: str):
  node = trie
  for c in word:
  node = node.setdefault(c, {})
  node['#'] = node.get('#', 0) + 1

  def get(word: str) -> bool:
  node = trie
  for c in word:
  if (node := node.get(c)) is None: return False
  return node['#'] > 1

  trie = {}
  for word in words:
  for i in range(len(word)):
  add(word[i:])
  return [word for word in words if get(word)]<|endoftext|>"
293,"<|endoftext|>A string r is a subsequence of a string s if r can be obtained from s by dropping zero or more characters from s. A string r is a common subsequence of s and t if r is a subsequence of both s and t. A string r is a longest common subsequence (LCS) of s and t if there is no string that is longer than r and is a common subsequence of s and t. The problem is to find an LCS of two given strings.:def lcs(u, v):
    """"""Return c where c[i][j] contains length of LCS of u[i:] and v[j:].""""""
    c = [[-1]*(len(v) + 1) for _ in range(len(u) + 1)]
 
    for i in range(len(u) + 1):
        c[i][len(v)] = 0
    for j in range(len(v)):
        c[len(u)][j] = 0
 
    for i in range(len(u) - 1, -1, -1):
        for j in range(len(v) - 1, -1, -1):
            if u[i] == v[j]:
                c[i][j] = 1 + c[i + 1][j + 1]
            else:
                c[i][j] = max(c[i + 1][j], c[i][j + 1])
 
    return c
 
 
def print_lcs(u, v, c):
    """"""Print one LCS of u and v using table c.""""""
    i = j = 0
    while not (i == len(u) or j == len(v)):
        if u[i] == v[j]:
            print(u[i], end='')
            i += 1
            j += 1
        elif c[i][j + 1] > c[i + 1][j]:
            j += 1
        else:
            i += 1
 
 
u = input('Enter first string: ')
v = input('Enter second string: ')
c = lcs(u, v)
print('Longest Common Subsequence: ', end='')
print_lcs(u, v, c)<|endoftext|>"
294,"<|endoftext|>Given a string of letters, how many capital letters are there?
Examples
capital_letters(""fvLzpxmgXSDrobbgMVrc"") ➞ 6

capital_letters(""JMZWCneOTFLWYwBWxyFw"") ➞ 14

capital_letters(""mqeytbbjwqemcdrdsyvq"") ➞ 0
Notes
N/A:def capital_letters(txt):
  return sum(i.isupper() for i in txt)<|endoftext|>"
295,"<|endoftext|>Following is C++ implementation for the doubly linked list. The idea is simple, we first find out pointer to the last node. Once we have a pointer to the last node, we can recursively sort the linked list using pointers to first and last nodes of a linked list, similar to the above recursive function where we pass indexes of first and last array elements. The partition function for a linked list is also similar to partition for arrays. Instead of returning index of the pivot element, it returns a pointer to the pivot element. In the following implementation, quickSort() is just a wrapper function, the main recursive function is _quickSort() which is similar to quickSort() for array implementation.:# A Python program to sort a linked list using Quicksort
head = None

# a node of the doubly linked list
class Node:
	def __init__(self, d):
		self.data = d
		self.next = None
		self.prev = None

# A utility function to find last node of linked list
def lastNode(node):
	while(node.next != None):
			node = node.next;
	return node;

# Considers last element as pivot, places the pivot element at its
# correct position in sorted array, and places all smaller (smaller than
# pivot) to left of pivot and all greater elements to right of pivot
def partition(l, h):

	# set pivot as h element
		x = h.data;
		
		# similar to i = l-1 for array implementation
		i = l.prev;
		
		j = l
		
		# Similar to ""for (int j = l; j <= h- 1; j++)""
		while(j != h):
			if(j.data <= x):
			
				# Similar to i++ for array
				i = l if(i == None) else i.next;

				temp = i.data;
				i.data = j.data;
				j.data = temp;
			j = j.next
						
		i = l if (i == None) else i.next; # Similar to i++
		temp = i.data;
		i.data = h.data;
		h.data = temp;
		return i;

# A recursive implementation of quicksort for linked list
def _quickSort(l,h):
	if(h != None and l != h and l != h.next):
			temp = partition(l, h);
			_quickSort(l,temp.prev);
			_quickSort(temp.next, h);
		
# The main function to sort a linked list. It mainly calls _quickSort()
def quickSort(node):

	# Find last node
		head = lastNode(node);
		
		# Call the recursive QuickSort
		_quickSort(node,head);

# A utility function to print contents of arr
def printList(head):
	while(head != None):
			print(head.data, end="" "");
			head = head.next;
		
# Function to insert a node at the beginning of the Doubly Linked List
def push(new_Data):
	global head;
	new_Node = Node(new_Data);	 # allocate node
		
	# if head is null, head = new_Node
	if(head == None):
		head = new_Node;
		return;
	
	# link the old list off the new node
	new_Node.next = head;
		
	# change prev of head node to new node
	head.prev = new_Node;
		
	# since we are adding at the beginning, prev is always NULL
	new_Node.prev = None;
		
	# move the head to point to the new node
	head = new_Node;

# Driver program to test above function
push(5);
push(20);
push(4);
push(3);
push(30);


print(""Linked List before sorting "");
printList(head);
print(""\nLinked List after sorting"");
quickSort(head);
printList(head);

# This code is contributed by _saurabh_jaiswal<|endoftext|>"
296,"<|endoftext|>Given a side of a Dodecahedron, the task is to find the volume of the Dodecahedron in Python.:# Import the math module using the math keyword.
import math
# Give the side of the Dodecahedron as static input and store it in a variable.
sideval = 5
# Calculate the volume of the Dodecahedron using the above mathematical formula
# ( (15 + 7√5)*s3/4).
# We Calculate the √5 in the above formula using the sqrt() function.
# We can calculate the s^3 using the pow() function or '**' operator.
# By using the above functions we calculate the volume of the Dodecahedron
# and store it in a variable say volDode.
volDode = (((15 + (7 * (math.sqrt(5)))) / 4) * (math.pow(sideval, 3)))
# Print the volDode value.
print(
    'The Volume of the Dodecahedron with side {', sideval, '} is = ', volDode)<|endoftext|>"
297,"<|endoftext|>Strings in Python:

In Python, a string may be a sequence of characters. It is an information type that has been derived. Strings are unchangeable. This means that when they have been defined, they can not be modified. Many Python functions change strings, like replace(), join(), and split(). They do not, however, alter the original string. They make a duplicate of a string, alter it, then return it to the caller.

Given a string, the task is to scan the given two strings and print the larger string without using built-in functions in python.

Examples:

Example1:

Input:

given first string =btechgeeks

given second string =python
Output:

The string btechgeeks is larger string
Example2:

Input:

given first string =java

given second string =javascript
Output:

The string javascript is larger string:# Give the two strings as static input and store them in two separate variables.
firststrng = 'btechgeeks'
secondstrng = 'python'
# Take a variable to say stringLength1 that stores the length of the given first string.
# Initialize the stringLength1 to 0.
stringLength1 = 0
# Take a variable to say stringLength2 that stores the length of the given second string.
# Initialize the stringLength2 to 0.
stringLength2 = 0
# Using for loop to traverse over the elements of the first string.
for charact in firststrng:
  # Increment the stringLength1 (Count Variable) by 1.
  stringLength1 = stringLength1+1
# Using for loop to traverse over the elements of the second string.
for charact in secondstrng:
  # Increment the stringLength2 (Count Variable) by 1.
  stringLength2 = stringLength2+1
# Compare the count variables(stringLength1 ,stringLength2) of both
# the strings using if conditional statement.
# If the stringlength1 is greater than stringlength2 then
# print the first string using the print() function.
if(stringLength1 > stringLength2):
  print('The string', firststrng, 'is  larger string')
# If the stringlength1 is equal to stringlength2 then
# print both the strings are equal using the print() function.
elif(stringLength1 == stringLength2):
  print('The strings', firststrng, 'and', secondstrng, 'are equal in size')
# If the stringlength1 is less than stringlength2 then
# print the second string using the print() function.
else:
  print('The string', secondstrng, 'is  larger string')<|endoftext|>"
298,"<|endoftext|>Given a list, the task is to Calculate the average of all the numbers in the given list in python.:# given list
given_list = [8, 9, 1, 23, 15, 20, 19, 13, 8, 7, 5, 2, 7, 10, 14, 16]
# Take a variable say sumOfList which stores the
# sum of all list elements and initialize it to 0.
sumOfList = 0
# Traverse the given list using for loop
for eleme in given_list:
    # Add the iterator value to the sumOfList after each iteration.
    sumOfList = sumOfList+eleme
# calculating the length of given list using len() function
length = len(given_list)
# Calculate the average value of the given list by Dividing sumOfList with length
listAvg = sumOfList/length
# printng the  the average value of the given list
print(""The average value of the given list"", given_list, ""="", listAvg)<|endoftext|>"
299,"<|endoftext|>Given a directed graph and two vertices in it, source ‘s’ and destination ‘t’, find out the maximum number of edge disjoint paths from s to t. Two paths are said edge disjoint if they don’t share any edge.


 :# Python program to find maximum number of edge disjoint paths
# Complexity : (E*(V^3))
# Total augmenting path = VE
# and BFS with adj matrix takes :V^2 times
  
from collections import defaultdict
  
#This class represents a directed graph using
# adjacency matrix representation
class Graph:
  
    def __init__(self,graph):
        self.graph = graph # residual graph
        self. ROW = len(graph)
         
  
    '''Returns true if there is a path from source 's' to sink 't' in
    residual graph. Also fills parent[] to store the path '''
    def BFS(self,s, t, parent):
 
        # Mark all the vertices as not visited
        visited =[False]*(self.ROW)
         
        # Create a queue for BFS
        queue=[]
         
        # Mark the source node as visited and enqueue it
        queue.append(s)
        visited[s] = True
          
         # Standard BFS Loop
        while queue:
 
            #Dequeue a vertex from queue and print it
            u = queue.pop(0)
         
            # Get all adjacent vertices of the dequeued vertex u
            # If a adjacent has not been visited, then mark it
            # visited and enqueue it
            for ind, val in enumerate(self.graph[u]):
                if visited[ind] == False and val > 0 :
                    queue.append(ind)
                    visited[ind] = True
                    parent[ind] = u
 
        # If we reached sink in BFS starting from source, then return
        # true, else false
        return True if visited[t] else False
             
     
    # Returns the maximum number of edge-disjoint paths from
    #s to t in the given graph
    def findDisjointPaths(self, source, sink):
 
        # This array is filled by BFS and to store path
        parent = [-1]*(self.ROW)
 
        max_flow = 0 # There is no flow initially
 
        # Augment the flow while there is path from source to sink
        while self.BFS(source, sink, parent) :
 
            # Find minimum residual capacity of the edges along the
            # path filled by BFS. Or we can say find the maximum flow
            # through the path found.
            path_flow = float(""Inf"")
            s = sink
            while(s !=  source):
                path_flow = min (path_flow, self.graph[parent[s]][s])
                s = parent[s]
 
            # Add path flow to overall flow
            max_flow +=  path_flow
 
            # update residual capacities of the edges and reverse edges
            # along the path
            v = sink
            while(v !=  source):
                u = parent[v]
                self.graph[u][v] -= path_flow
                self.graph[v][u] += path_flow
                v = parent[v]
 
        return max_flow
 
  
# Create a graph given in the above diagram
 
graph = [[0, 1, 1, 1, 0, 0, 0, 0],
        [0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 1, 0],
        [0, 0, 0, 0, 0, 0, 1, 0],
        [0, 0, 1, 0, 0, 0, 0, 1],
        [0, 1, 0, 0, 0, 0, 0, 1],
        [0, 0, 0, 0, 0, 1, 0, 1],
        [0, 0, 0, 0, 0, 0, 0, 0]]
  
 
g = Graph(graph)
 
source = 0; sink = 7
  
print (""There can be maximum %d edge-disjoint paths from %d to %d"" %
            (g.findDisjointPaths(source, sink), source, sink))
 
 
# This code is contributed by Neelam Yadav
<|endoftext|>"
300,"<|endoftext|>If Statement in One Line
If you have only one statement to execute, you can put it on the same line as the if statement.:if a > b: print(""a is greater than b"")<|endoftext|>"
301,"<|endoftext|>A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).

Given a string s, return the longest happy prefix of s. Return an empty string """" if no such prefix exists.

 

Example 1:

Input: s = ""level""
Output: ""l""
Explanation: s contains 4 prefix excluding itself (""l"", ""le"", ""lev"", ""leve""), and suffix (""l"", ""el"", ""vel"", ""evel""). The largest prefix which is also suffix is given by ""l"".
Example 2:

Input: s = ""ababab""
Output: ""abab""
Explanation: ""abab"" is the largest prefix which is also suffix. They can overlap in the original string.
 

Constraints:

1 <= s.length <= 105
s contains only lowercase English letters.:def longestPrefix(self, s):
  # res stores the index of the end of the prefix, used for output the result
  # l stores the hash key for prefix
  # r stores the hash key for suffix
  # mod is used to make sure that the hash value doesn't get too big, you can choose another mod value if you want.
  res, l, r, mod = 0, 0, 0, 10**9 + 7

  # now we start from the beginning and the end of the string
  # note you shouldn't search the whole string! because the longest prefix and suffix is the string itself
  for i in range(len(s) - 1):

  # based on an idea that is similar to prefix sum, we calculate the prefix hash in O(1) time.
  # specifically, we multiply the current prefix by 128 (which is the length of ASCII, but you can use another value as well)
  # then add in the ASCII value of the upcoming letter
  l = (l * 128 + ord(s[i])) % mod

  # similarly, we can calculate the suffix hash in O(1) time.
  # Specifically, we get the ith letter from the end using s[~i], note ~i is -i-1
  # we find the pow(128, i, mod) and multiply by the letter's ASCII value
  # Actually, if we don't care about the beautifulness of the code, you can have a variable to keep track of pow(128, i, mod) as you increase i
  r = (r + pow(128, i, mod) * ord(s[~i])) % mod

  # we check if the prefix and suffix agrees, if yes, we find yet another longer prefix, so we record the index
  if l == r: res = i + 1

  # after we finish searching the string, output the prefix
  return s[:res]<|endoftext|>"
302,"<|endoftext|>aximum sum rectangle in a 2D matrix:# Python3 program to find maximum sum
# subarray in a given 2D array
 
# Implementation of Kadane's algorithm
# for 1D array. The function returns the
# maximum sum and stores starting and
# ending indexes of the maximum sum subarray
# at addresses pointed by start and finish
# pointers respectively.
 
 
def kadane(arr, start, finish, n):
 
    # initialize sum, maxSum and
    Sum = 0
    maxSum = -999999999999
    i = None
 
    # Just some initial value to check
    # for all negative values case
    finish[0] = -1
 
    # local variable
    local_start = 0
 
    for i in range(n):
        Sum += arr[i]
        if Sum < 0:
            Sum = 0
            local_start = i + 1
        elif Sum > maxSum:
            maxSum = Sum
            start[0] = local_start
            finish[0] = i
 
    # There is at-least one
    # non-negative number
    if finish[0] != -1:
        return maxSum
 
    # Special Case: When all numbers
    # in arr[] are negative
    maxSum = arr[0]
    start[0] = finish[0] = 0
 
    # Find the maximum element in array
    for i in range(1, n):
        if arr[i] > maxSum:
            maxSum = arr[i]
            start[0] = finish[0] = i
    return maxSum
 
# The main function that finds maximum
# sum rectangle in M[][]
 
 
def findMaxSum(M):
    global ROW, COL
 
    # Variables to store the final output
    maxSum, finalLeft = -999999999999, None
    finalRight, finalTop, finalBottom = None, None, None
    left, right, i = None, None, None
 
    temp = [None] * ROW
    Sum = 0
    start = [0]
    finish = [0]
 
    # Set the left column
    for left in range(COL):
 
        # Initialize all elements of temp as 0
        temp = [0] * ROW
 
        # Set the right column for the left
        # column set by outer loop
        for right in range(left, COL):
 
            # Calculate sum between current left
            # and right for every row 'i'
            for i in range(ROW):
                temp[i] += M[i][right]
 
            # Find the maximum sum subarray in
            # temp[]. The kadane() function also
            # sets values of start and finish.
            # So 'sum' is sum of rectangle between
            # (start, left) and (finish, right) which
            # is the maximum sum with boundary columns
            # strictly as left and right.
            Sum = kadane(temp, start, finish, ROW)
 
            # Compare sum with maximum sum so far.
            # If sum is more, then update maxSum
            # and other output values
            if Sum > maxSum:
                maxSum = Sum
                finalLeft = left
                finalRight = right
                finalTop = start[0]
                finalBottom = finish[0]
 
    # Prfinal values
    print(""(Top, Left)"", ""("", finalTop,
          finalLeft, "")"")
    print(""(Bottom, Right)"", ""("", finalBottom,
          finalRight, "")"")
    print(""Max sum is:"", maxSum)
 
 
# Driver Code
ROW = 4
COL = 5
M = [[1, 2, -1, -4, -20],
     [-8, -3, 4, 2, 1],
     [3, 8, 10, 1, 3],
     [-4, -1, 1, 7, -6]]
 
# Function call
findMaxSum(M)
 
# This code is contributed by PranchalK<|endoftext|>"
303,"<|endoftext|>The math.acos() method returns the arc cosine value of a number.

Note: The parameter passed in math.acos() must lie between -1 to 1.

Tip: math.acos(-1) will return the value of PI.:# Import math Library
import math

# Return the arc cosine of numbers
print(math.acos(0.55))
print(math.acos(-0.55))
print(math.acos(0))
print(math.acos(1))
print(math.acos(-1))<|endoftext|>"
304,"<|endoftext|>If you are new to Java and want to learn the java coding skills too fast. Try practicing the core java programs with the help of the Java basic programs list available.
 
 Power of a number :
 
 A number’s power (or exponent) aa represents the number of times xx must be multiplied by itself. It is written as a tiny number above and to the right of the base number.
 
 Recursion:
 
 If you’re familiar with Python functions, you’ll know that it’s typical for one function to call another. It is also feasible for a function in Python to call itself! A recursive function calls itself, and the process of using a recursive function is known as recursion.
 
 Although it may appear strange for a function to call itself, many sorts of programming challenges are better stated recursively.
 
 
 
 Given a number N and the power of P. The aim is to develop a Python program that uses recursion to find the power of a number with the given base.
 
 Examples:
 
 Example1:
 
 Input:
 
 Enter some random base =8 
 Enter some random exponent value = 3
 Output:
 
 8 ^ 3 = 512
 Example2:
 
 Input:
 
 Enter some random base =17
 Enter some random exponent value = 3
 Output:
 
 17 ^ 3 = 4913:# function which calculates the power of the number recursively
 def powerRecursion(given_base, given_exp):
  # Give the base condition in the instance where the exponent argument is 1.
  if(given_exp == 1):
  return(given_base)
  # If the exponent is not equal to 1, return the base multiplied by the function
  # with the parameter's base and exponent minus 1.
  if(given_exp != 1):
  # Until the exponent value is 1, the function calls itself.
  return(given_base*powerRecursion(given_base, given_exp-1))
 # Give the base as static input and store it in variable.
 given_base = 4
 # Enter some random exponent as static input and store it in a variable
 given_exp = 11
 # passing the given base an exponent as arguments to the recursive function powerRecursion
 print(given_base, ""^"", given_exp, ' = ', powerRecursion(given_base, given_exp))<|endoftext|>"
305,"<|endoftext|>Quantifiers indicate numbers of characters or expressions to match.
x* matches the preceding item ""x"" 0 or more times:
re.findall(""bo*"", ""A ghost boooooed"") ➞ [""booooo""]
x+ matches the preceding item ""x"" 1 or more times. Equivalent to {1,}:
re.findall(""a+"", ""caaaaaaandy"") ➞ [""aaaaaa""]
x? matches the preceding item ""x"" 0 or 1 times. If used immediately after any of the quantifiers *, +, ?, or {}, makes the quantifier lazy (matching the minimum number of times), as opposed to the default, which is greedy (matching the maximum number of times):
re.findall(""e?le?"", ""angle"") ➞ [""le""]
re.findall(""e?le?"", ""angel"") ➞ [""el""]
Write the regular expression that will match only the street. You must use a quantifier in your expression.
Example
txt = ""Harry Potter, 4 Privet Drive, Little Whinging, Surrey""
pattern = ""yourregularexpressionhere""

re.findall(pattern, txt) ➞ [""4 Privet Drive""]
Notes
You don't need to write a function, just the pattern.
Do not remove import re from the code.
Find more info on RegEx and quantifiers in Resources.
You can find all the challenges of this series in my Basic RegEx collection.:import re
pattern = ', (\d+.+?),'<|endoftext|>"
306,"<|endoftext|>Write a function that receives the time in 12-hour AM/PM format and returns a string representation of the time in military (24-hour) format.
Examples
convert_time(“07:05:45PM”) ➞ “19:05:45”

convert_time(“12:40:22AM”) ➞ “00:40:22”

convert_time(“12:45:54PM”) ➞ “12:45:54”
Notes
Midnight is 12:00:00AM on a 12-hour clock, and 00:00:00 on a 24-hour clock.
Noon is 12:00:00PM on a 12-hour clock, and 12:00:00 on a 24-hour clock.:def convert_time(txt):
  from datetime import datetime
  return datetime.strptime(txt, ""%I:%M:%S%p"").strftime(""%H:%M:%S"")<|endoftext|>"
307,"<|endoftext|>Given a Binary Tree and a key, write a function that prints all the ancestors of the key in the given binary tree.

 :# Python3 program to print all ancestors of a given key
 
# Class for a tree node
class Node:
 
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
 
# Iterative Function to print all ancestors of a given key
def printAncestors(root, key):
    if(root == None):
        return;
     
     # Create a stack to hold ancestors
    st = []
     
    # Traverse the complete tree in postorder way till we find the key
    while(True):
         
        # Traverse the left side. While traversing, append the nodes into
        # the stack so that their right subtrees can be traversed later
        while(root != None and root.data != key):
         
            st.append(root);   # append current node
            root = root.left;   # move to next node
         
        # If the node whose ancestors are to be printed is found,
        # then break the while loop.
        if(root != None and root.data == key):
            break;
         
        # Check if right sub-tree exists for the node at top
        # If not then pop that node because we don't need this
        # node any more.
        if(st[-1].right == None):
            root = st[-1];
            st.pop();
             
            # If the popped node is right child of top, then remove the top
            # as well. Left child of the top must have processed before.
            while(len(st) != 0 and st[-1].right == root):
                root = st[-1];
                st.pop();
         
        # if stack is not empty then simply set the root as right child
        # of top and start traversing right sub-tree.
        root = None if len(st) == 0 else st[-1].right;
     
    # If stack is not empty, print contents of stack
    # Here assumption is that the key is there in tree
    while(len(st) != 0):
        print(st[-1].data, end = "" "")
        st.pop();
     
# Driver program to test above functions
if __name__=='__main__':
 
     # Let us construct a binary tree
    root = Node(1);
    root.left = Node(2);
    root.right = Node(3);
    root.left.left = Node(4);
    root.left.right = Node(5);
    root.right.left = Node(6);
    root.right.right = Node(7);
    root.left.left.left = Node(8);
    root.left.right.right = Node(9);
    root.right.right.left = Node(10);
     
    print(""Following are all keys and their ancestors"");
    for key in range(1, 11):
 
        print(key, end = "": "");
        printAncestors(root, key);
        print();
     
# This code is contributed by rutvik_56.
<|endoftext|>"
308,"<|endoftext|>The Length of an Array
Use the len() method to return the length of an array (the number of elements in an array).:x = len(cars)<|endoftext|>"
309,"<|endoftext|>There are two types of persons:

The good person: The person who always tells the truth.
The bad person: The person who might tell the truth and might lie.
You are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. More specifically, statements[i][j] could be one of the following:

0 which represents a statement made by person i that person j is a bad person.
1 which represents a statement made by person i that person j is a good person.
2 represents that no statement is made by person i about person j.
Additionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 <= i < n.

Return the maximum number of people who can be good based on the statements made by the n people.:class Solution:
    def maximumGood(self, S):
        n, ans = len(S), 0
        def valid(cur):
            for i in range(n):
                if cur[i]:
                    for j in range(n):
                        if S[i][j] != 2 and S[i][j] != cur[j]: return False
            return True;
        def dfs(cur, i, cnt):
            nonlocal ans
            if i == n:
                if valid(cur): ans = max(ans, cnt)
                return
            cur.append(0)
            dfs(cur, i+1, cnt)
            cur[-1] = 1
            dfs(cur, i+1, cnt+1)
            cur.pop()
        
        dfs([], 0, 0)
        return ans<|endoftext|>"
310,"<|endoftext|>This python program generates hollow right angle triangle pattern made of stars up to n lines.
In this python example, we first read number of row in the hollow right angle triangle pattern from user using built-in function input(). And then we generate hollow right angle triangle pattern using python's for loop.:# Hollow Right Angle Triangle Pattern Using Stars

row = int(input('Enter number of rows required: '))

for i in range(row):
    for j in range(i+1):
        if j==0 or j==i or i==row-1:
            print('*',end="" "")
        else:
            print("" "", end="" "")
    print()<|endoftext|>"
311,"<|endoftext|>Write a Python program to print triangle of numbers in reverse pattern using for loop.

:rows = int(input(""Enter Triangle Reverse Numbers Pattern Rows = ""))

print(""====The Triangle of Numbers in Reverse Pattern===="")

for i in range(rows, 0, -1):
    for j in range(1, i):
        print(end = ' ')
    for k in range(i, rows + 1):
        print(k, end = ' ')
    print()<|endoftext|>"
312,"<|endoftext|>Given a read only array of size ( n+1 ), find one of the multiple repeating elements in the array where the array contains integers only between 1 and n. 
Read only array means that the contents of the array can’t be modified.
Examples: 
 

Input : n = 5
        arr[] = {1, 1, 2, 3, 5, 4}
Output : One of the numbers repeated in the array is: 1

Input : n = 10
        arr[] = {10, 1, 2, 3, 5, 4, 9, 8, 5, 6, 4}
Output : One of the numbers repeated in the array is: 4 OR 5:# Python 3program to find one of the repeating
# elements in a read only array
from math import sqrt

# Function to find one of the repeating
# elements
def findRepeatingNumber(arr, n):
	
	# Size of blocks except the
	# last block is sq
	sq = sqrt(n)

	# Number of blocks to incorporate 1 to
	# n values blocks are numbered from 0
	# to range-1 (both included)
	range__= int((n / sq) + 1)

	# Count array maintains the count for
	# all blocks
	count = [0 for i in range(range__)]

	# Traversing the read only array and
	# updating count
	for i in range(0, n + 1, 1):
		
		# arr[i] belongs to block number
		# (arr[i]-1)/sq i is considered
		# to start from 0
		count[int((arr[i] - 1) / sq)] += 1

	# The selected_block is set to last
	# block by default. Rest of the blocks
	# are checked
	selected_block = range__ - 1
	for i in range(0, range__ - 1, 1):
		if (count[i] > sq):
			selected_block = i
			break
		
	# after finding block with size > sq
	# method of hashing is used to find
	# the element repeating in this block
	m = {i:0 for i in range(n)}
	for i in range(0, n + 1, 1):
		
		# checks if the element belongs
		# to the selected_block
		if (((selected_block * sq) < arr[i]) and
			(arr[i] <= ((selected_block + 1) * sq))):
			m[arr[i]] += 1

			# repeating element found
			if (m[arr[i]] > 1):
				return arr[i]

	# return -1 if no repeating element exists
	return -1

# Driver Code
if __name__ == '__main__':
	
	# read only array, not to be modified
	arr = [1, 1, 2, 3, 5, 4]

	# array of size 6(n + 1) having
	# elements between 1 and 5
	n = 5

	print(""One of the numbers repeated in the array is:"",
							findRepeatingNumber(arr, n))
	
# This code is contributed by
# Sahil_shelangia<|endoftext|>"
313,"<|endoftext|>Create a class with a few functions like these examples.
magic.replace(""string"", 'char', char') is a function that replaces all of the specified characters with different specified characters.
magic.str_length(""string"") is a function that returns the length of the string.
magic.trim("" string "") is a function that returns a string with truncated spaces at both the beginning and end.
magic.list_slice(list, tuple) is a function that returns the items in the list that are between the specified indexes. If the length of the new list is 0, return -1.
Examples
magic.replace(""AzErty-QwErty"", ""E"", ""e"") ➞ ""Azerty-Qwerty""

magic.str_length(""hello world"") ➞ 11

magic.trim(""      python is awesome      "") ➞ ""python is awesome""

magic.list_slice([1, 2, 3, 4, 5], (2, 4)) ➞ [ 2, 3, 4 ]
Notes
N/A:class Magic:
  str_length = len
    def trim(self, string):
    return string.strip()
      def replace(self, string, char, replacement):
    return string.replace(char, replacement)
      def list_slice(self, lst, tup):
    return [i for i in lst if i in tup] or -1<|endoftext|>"
314,"<|endoftext|>Given a binary tree, the task is to flip the binary tree towards the right direction that is clockwise. See the below examples to see the transformation.
In the flip operation, the leftmost node becomes the root of the flipped tree and its parent becomes its right child and the right sibling becomes its left child and the same should be done for all left most nodes recursively. :# Python3 program to flip
# a binary tree

# A binary tree node
class Node:
	
	# Constructor to create
	# a new node
	def __init__(self, data):
	
		self.data = data
		self.right = None
		self.left = None

def flipBinaryTree(root):
	
	# Base Cases
	if root is None:
		return root
	
	if (root.left is None and
		root.right is None):
		return root

	# Recursively call the
	# same method
	flippedRoot = flipBinaryTree(root.left)

	# Rearranging main root Node
	# after returning from
	# recursive call
	root.left.left = root.right
	root.left.right = root
	root.left = root.right = None

	return flippedRoot

# Iterative method to do the level
# order traversal line by line
def printLevelOrder(root):
	
	# Base Case
	if root is None:
		return
	
	# Create an empty queue for
	# level order traversal
	from Queue import Queue
	q = Queue()
	
	# Enqueue root and initialize
	# height
	q.put(root)
	
	while(True):

		# nodeCount (queue size) indicates
		# number of nodes at current level
		nodeCount = q.qsize()
		if nodeCount == 0:
			break

		# Dequeue all nodes of current
		# level and Enqueue all nodes
		# of next level
		while nodeCount > 0:
			node = q.get()
			print node.data,
			if node.left is not None:
				q.put(node.left)
			if node.right is not None:
				q.put(node.right)
			nodeCount -= 1

		print
		
# Driver code
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.right.left = Node(4)
root.right.right = Node(5)

print ""Level order traversal of given tree""
printLevelOrder(root)

root = flipBinaryTree(root)

print ""\nLevel order traversal of the flipped tree""
printLevelOrder(root)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
<|endoftext|>"
315,"<|endoftext|>The program sorts a list by comb sort.:def comb_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]
 
    gap = len(alist)
    shrink = 1.3
 
    no_swap = False
    while not no_swap:
        gap = int(gap/shrink)
 
        if gap < 1:
            gap = 1
            no_swap = True
        else:
            no_swap = False
 
        i = 0
        while i + gap < len(alist):
            if alist[i] > alist[i + gap]:
                swap(i, i + gap)
                no_swap = False
            i = i + 1
 
 
alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
comb_sort(alist)
print('Sorted list: ', end='')
print(alist)<|endoftext|>"
316,"<|endoftext|>Removing Items from a Dictionary
There are several methods to remove items from a dictionary::thisdict = {
  ""brand"": ""Ford"",
  ""model"": ""Mustang"",
  ""year"": 1964
}
thisdict.pop(""model"")
print(thisdict)<|endoftext|>"
317,"<|endoftext|>In the previous article, we have discussed Python Program to Find Sum of Series 1/2-2/3+3/4-4/5+5/6…+N/N+1
 Given the numbers, N and X and the task is to find the sum of the given series (1+X+X^3…+X^N) for the given numbers in Python.
 Examples:
 Example1:
 Input:
 Given Number = 4
 
 Given X value = 8
 Output:
 The total sum of the series till the given number N and x value { 4 8 } = 520
 Example2:
 Input:
 Given Number = 5
 
 Given X value = 11
 Output:
 The total sum of the series till the given number N and x value { 5 11 } = 162393:# Give the number N as static input and store it in a variable.
 
 gvn_numb = 4
 
 # Give the value of x as static input and store it in another variable.
 
 gvn_x_val = 8
 
 # Take a variable say resltsum which gives the sum of the given series till N and
 
 # initialize its value to 0.
 
 resltsum = 0
 
 # Take another variable say k and initialize its value with 1.
 
 k = 1
 
 # Loop until the value of k is less than or equal to the given number using the while loop.
 
 while(k &lt;= gvn_numb):
 
  # Inside the loop, calculate the value of X raised to the power k using the pow() function
 
  # and store it in a variable say p.
 
  p = pow(gvn_x_val, k)
 
  # Add the above value of p to the resltsum and store it in the same variable.
 
  resltsum += p
 
  # Increment the value of k by 2 and store it in the same variable k.
 
  k += 2
 
 # Print the resltsum value which is the result of the series till the given Number N.
 
 print(
 
  ""The total sum of the series till the given number N and x value {"", gvn_numb, gvn_x_val, ""} = "", resltsum)
 
 </pre><|endoftext|>"
318,"<|endoftext|>Create a function that determines whether it is possible to build a palindrome from the characters in a string.
Examples
possible_palindrome(""acabbaa"") ➞ True
# Can make the following palindrome: ""aabcbaa""

possible_palindrome(""aacbdbc"") ➞ True
# Can make the following palindrome: ""abcdcba""

possible_palindrome(""aacbdb"") ➞ False

possible_palindrome(""abacbb"") ➞ False
Notes
N/A:def possible_palindrome(txt):
  return sum(txt.count(i)%2 for i in set(txt)) <= 1<|endoftext|>"
319,"<|endoftext|>Method #1: Using For Loop (Static Input)
Approach:

Give the number of rows as static input and store it in a variable.
Loop from 1 to the number of rows using For loop.
Loop from 1 to the number of rows using another for loop(Nested For loop).
Check if the iterator value of the inner For loop is less than or equal to the parent loop iterator value of theFor Loop using the If conditional Statement.
If it is true then print the iterator value of the parent For loop.
Else print the iterator value of the inner For loop.
Print the Newline character after the end of the inner loop.
The Exit of the Program.:# Give the number of rows as static input and store it in a variable.
numbrrows = 9
# Loop from 1 to the number of rows using For loop.
for m in range(1, numbrrows+1):
    # Loop from 1 to the number of rows using another for loop(Nested For loop).
    for n in range(1, numbrrows+1):
        ''' Check if the iterator value of the inner For loop is less than or equal 
            to the parent loop iterator value of the
            For Loop using the If conditional Statement.'''
        if(n <= m):
            # If it is true then print the iterator value of the parent For loop.
            print(m, end=' ')
        else:
            print(n, end=' ')
    # Print the Newline character after the end of the inner loop.
    print()<|endoftext|>"
320,"<|endoftext|>Given a Binary Tree where each node has the following structure, write a function to populate the next pointer for all nodes. The next pointer for every node should be set to point to inorder successor.:# class Node
class Node:
	def __init__(self, data):
		self.data = data
		self.next = None
		self.right = None
		self.left = None


root = None

# list to store inorder sequence
list = []

# function for populating next pointer to inorder successor


def populateNext(root):

	# list = [3,8,10,12]

	# inorder successor of the present Node is the immediate
	# right Node
	# for ex: inorder successor of 3 is 8
	for i in range(len(list)):

		# check if it is the last Node
		# point next of last Node(right most) to None
		if (i != len(list) - 1):
			list[i].next = list[i + 1]
		else:
			list[i].next = None

	# Let us see the populated values
	ptr = root.left.left
	while (ptr != None):

		# -1 is printed if there is no successor
		pt = -1
		if(ptr.next != None):
			pt = ptr.next.data
		print(""Next of "", ptr.data, "" is: "", pt)
		ptr = ptr.next

# insert the inorder into a list to keep track
# of the inorder successor


def inorder(root):
	if (root != None):
		inorder(root.left)
		list.append(root)
		inorder(root.right)


# Driver function
if __name__ == '__main__':

	'''
	* 10 / \ 8 12 / 3
	'''
	root = Node(10)
	root.left = Node(8)
	root.right = Node(12)
	root.left.left = Node(3)

	# function calls
	inorder(root)
	populateNext(root)

# This code is contributed by Rajput-Ji<|endoftext|>"
321,"<|endoftext|>Given a Binary Tree find the length of the longest path which comprises of nodes with consecutive values in increasing order. Every node is considered as a path of length 1. 
Examples: 
 

       10
      /    \     
     /      \
    11        9    
   / \        /\
  /   \      /  \
13    12    13   8
Maximum Consecutive Path Length is 3 (10, 11, 12)
Note: 10, 9 ,8 is NOT considered since
the nodes should be in increasing order.

        5
          /  \
         /    \
        8      11
        /        \
       /          \
       9      10   
      /              /
     /             /
    6           15
Maximum Consecutive Path Length is 2 (8, 9).:# Python program to find Maximum consecutive
# path length in binary tree

# A binary tree node
class Node:
	
	# Constructor to create a new node
	def __init__(self, val):
		self.val = val
		self.left = None
		self.right = None

# Returns the maximum consecutive path length
def maxPathLenUtil(root, prev_val, prev_len):
	if root is None:
		return prev_len

	# Get the value of current node
	# The value of the current node will be
	# prev node for its left and right children
	curr_val = root.val
	
	# If current node has to be a part of the
	# consecutive path then it should be 1 greater
	# than the value of the previous node
	if curr_val == prev_val +1 :
		
		# a) Find the length of the left path
		# b) Find the length of the right path
		# Return the maximum of left path and right path
		return max(maxPathLenUtil(root.left, curr_val, prev_len+1),
				maxPathLenUtil(root.right, curr_val, prev_len+1))

	# Find the length of the maximum path under subtree
	# rooted with this node
	newPathLen = max(maxPathLenUtil(root.left, curr_val, 1),
					maxPathLenUtil(root.right, curr_val, 1))

	# Take the maximum previous path and path under subtree
	# rooted with this node
	return max(prev_len , newPathLen)

# A Wrapper over maxPathLenUtil()
def maxConsecutivePathLength(root):
	
	# Return 0 if root is None
	if root is None:
		return 0
	
	# Else compute maximum consecutive increasing path
	# length using maxPathLenUtil
	return maxPathLenUtil(root, root.val -1 , 0)

# Driver program to test above function
root = Node(10)
root.left = Node(11)
root.right = Node(9)
root.left.left = Node(13)
root.left.right = Node(12)
root.right.left = Node(13)
root.right.right = Node(8)

print (""Maximum Consecutive Increasing Path Length is"",)
print (maxConsecutivePathLength(root))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)<|endoftext|>"
322,"<|endoftext|>Files in Python:

Python, like many other programming languages, offers file handling and allows users to read and write files, as well as perform a variety of other file-related tasks. The concept of file handling has been extended to a variety of other languages, but the implementation is either complicated or lengthy. However, like most Python principles, this concept is simple and straightforward. Python processes file differently depending on whether they are text or binary, which is crucial. Each line of code consists of a series of characters that together constitute a text file. A specific character called the EOL or End of Line character, such as the comma, or a newline character is used to end each line in a file.

Given two files, the task is to copy the contents of one file to the other file.:# In read mode, open the first file say  samplefile1.txt.
with open(""samplefile1.txt"") as file1:
  # In write mode, open the second file say  samplefile2.txt.
  with open(""samplefile2.txt"", ""w"") as file2:
  # Using for loop, go over the lines in the first file.
  for iline in file1:
  # Copy the ith line of the first file to the second file using the write function.
  file2.write(iline)<|endoftext|>"
323,"<|endoftext|>This program prints 54321-5432-543-54-5 pattern in Python programming language.:# 54321-5432-543-54-5 Pattern 

for i in range(1, 6):
    for j in range(5, i-1,-1):
        print(j, end="""")
    print()<|endoftext|>"
324,"<|endoftext|>Create a function that takes a string of name and checks how much good is the given name. A preloaded dictionary of alphabet scores is available in the Code tab. Add up the letters of your name to get the total score.
scores = {""A"": 100, ""B"": 14, ""C"": 9, ""D"": 28, ""E"": 145, ""F"": 12, ""G"": 3,
          ""H"": 10, ""I"": 200, ""J"": 100, ""K"": 114, ""L"": 100, ""M"": 25,
          ""N"": 450, ""O"": 80, ""P"": 2, ""Q"": 12, ""R"": 400, ""S"": 113,
          ""T"": 405, ""U"": 11, ""V"": 10, ""W"": 10, ""X"": 3, ""Y"": 210, ""Z"": 23}
Return your result as per the following rules:
score <= 60:   ""NOT TOO GOOD""

61 <= score <= 300:  ""PRETTY GOOD""

301 <= score <= 599:  ""VERY GOOD""

score >= 600:  ""THE BEST""
Examples
name_score(""MUBASHIR"") ➞ ""THE BEST""

name_score(""YOU"") ➞ ""VERY GOOD""

name_score(""MATT"") ➞ ""THE BEST""

name_score(""PUBG"") ➞ ""NOT TOO GOOD""
Notes
N/A:scores = {'A': 100, 'B': 14, 'C': 9, 'D': 28, 'E': 145, 'F': 12, 'G': 3,
          'H': 10, 'I': 200, 'J': 100, 'K': 114, 'L': 100, 'M': 25,
          'N': 450, 'O': 80, 'P': 2, 'Q': 12, 'R': 400, 'S': 113, 'T': 405,
          'U': 11, 'V': 10, 'W': 10, 'X': 3, 'Y': 210, 'Z': 23}
def name_score(name):
  score = sum(scores[ch] for ch in name if ch.isalpha())
  if score > 599: return 'THE BEST'
  elif score > 300: return 'VERY GOOD'
  elif score > 60 : return 'PRETTY GOOD'
  else: return 'NOT TOO GOOD'<|endoftext|>"
325,"<|endoftext|>There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.

Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique

 

Example 1:

Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3
Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
Example 2:

Input: gas = [2,3,4], cost = [3,4,3]
Output: -1
Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.:class Solution:
    def canCompleteCircuit(self, gas, cost):
        """"""
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        """"""
        n = len(gas)
        
        total_tank, curr_tank = 0, 0
        starting_station = 0
        for i in range(n):
            total_tank += gas[i] - cost[i]
            curr_tank += gas[i] - cost[i]
            # If one couldn't get here,
            if curr_tank < 0:
                # Pick up the next station as the starting one.
                starting_station = i + 1
                # Start with an empty tank.
                curr_tank = 0
        
        return starting_station if total_tank >= 0 else -1<|endoftext|>"
326,"<|endoftext|>In the previous article, we have discussed Python Program to Find the Mid-Point of a Line
Given two points of a line and P, Q, the task is to find the point that divides the line in the given ratio P: Q in Python.

The section formula gives us the coordinates of the point that divides a given line segment into two parts with lengths that are in the ratio m: n.

Section Formula:

(mx2+nx1)/(m+n), (my2+ny1)/(m+n):# Create a function to say Find_Midpoint() which takes the given two points of a line
# and the ratio values i.e, a1, a2, b1, b2, p, q as the arguments and prints the point
# that divides the line in the given ratio p: q.

def Find_Section(a1, a2, b1, b2, p, q):
    # Inside the function calculate the x coordinate of the point using the mathematical
    # formula (q * a1)+(p * a2))/(p + q) and convert it into float
    # using the float() function.
    # Store it in a variable.
    x_coordinate = (float)((q * a1)+(p * a2))/(p + q)
    # Calculate the y coordinate of the point using the mathematical formula
    # (q * b1)+(p * b2))/(p + q) and convert it into float using the
    # float() function.
    # Store it in another variable.
    y_coordinate = (float)((q * b1)+(p * b2))/(p + q)

    # Print the point that divides the line in the given ratio p: q.
    print(""("", x_coordinate, "","", y_coordinate, "")"")


# Give the first point as static input and store it in two variables.
a1 = 2
b1 = 4
# Give the second point as static input and store it in another two variables.
a2 = 1
b2 = 3
p = 1
q = 2
print(""The point that divides the line in the given ratio ("", p, "":"", q, "") is :"")
# Pass the given two points of a line and the ratio values i.e, a1, a2, b1, b2, p, q as
# the arguments to the Find_Section() function.
Find_Section(a1, a2, b1, b2, p, q)<|endoftext|>"
327,"<|endoftext|>Mubashir is not so good with the English language. He needs your help to correct his sentences.
Start each sentence with an uppercase alphabet.
For every uppercase letter (other than the first alphabet), you have to place a fullstop(.) followed by an empty space.
There must be only one space between the words and sentences.
Sentence must end with a full stop(.)
Two continuous spaces are not allowed.
correct_sentences (""  mubashir loves  edabit  Matt  loves  edabit  "") ➞ ""Mubashir loves edabit. Matt loves edabit.""

# Remove extra spaces.
# Capitalise first character.
# Dot followed by an empty space before ""Matt"".
# A dot at the end.
Examples
correct_sentences (""  mubashir loves  edabit  Matt  loves  edabit  "") ➞ ""Mubashir loves edabit. Matt loves edabit.""

correct_sentences (""  he is an engineer He sleeps a lot"") ➞ ""He is an engineer. He sleeps a lot.""

correct_sentences ("" his english is not good Help him     Thank you"") ➞ ""His english is not good. Help him. Thank you.""
Notes
N/A:import re
def correct_sentences(s):
  s = re.sub("" +(?=[A-Z])"", "". "", s.strip())
  s = re.sub("" +"", "" "", s)
  return s[0].upper() + s[1:] + "".""<|endoftext|>"
328,"<|endoftext|>A financial institution provides professional services to banks and claims charges from the customers based on the number of man-days provided. Internally, it has set a scheme to motivate and reward staff to meet and exceed targeted billable utilization and revenues by paying a bonus for each day claimed from customers in excess of a threshold target.
This quarterly scheme is calculated with a threshold target of 32 days per quarter, and the incentive payment for each billable day in excess of such threshold target is shown as follows:
Days Bonus
0 to 32 days Zero
33 to 40 days SGD$325 per billable day
41 to 48 days SGD$550 per billable day
Greater than 48 days SGD$600 per billable day
Please note that incentive payment is calculated progressively. As an example, if an employee reached total billable days of 45 in a quarter, his/her incentive payment is computed as follows:
32*0 + 8*325 + 5*550 = 5350
Write a function to read the billable days of an employee and return the bonus he/she has obtained in that quarter.
Examples
bonus(15) ➞ 0

bonus(37) ➞ 1625

bonus(50) ➞ 8200
Notes
N/A:def bonus(days):
  return 325*max(0,days-32) + 225*max(0,days-40) + 50*max(0,days-48)<|endoftext|>"
329,"<|endoftext|>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

 

Example 1:

Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
Example 2:

Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
Example 3:

Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
 

Constraints:

nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109:class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """"""
        Do not return anything, modify nums1 in-place instead.
        """"""
        # Write the elements of num2 into the end of nums1.
        for i in range(n):
            nums1[i + m] = nums2[i]
        
        # Sort nums1 list in-place.
        nums1.sort()<|endoftext|>"
330,"<|endoftext|>Write a function that returns True if two arrays, when combined, form a consecutive sequence. A consecutive sequence is a sequence without any gaps in the integers, e.g. 1, 2, 3, 4, 5 is a consecutive sequence, but 1, 2, 4, 5 is not.
Examples
consecutive_combo([7, 4, 5, 1], [2, 3, 6]) ➞ True

consecutive_combo([1, 4, 6, 5], [2, 7, 8, 9]) ➞ False

consecutive_combo([1, 4, 5, 6], [2, 3, 7, 8, 10]) ➞ False

consecutive_combo([44, 46], [45]) ➞ True
Notes
The input lists will have unique values.
The input lists can be in any order.:def consecutive_combo(lst1, lst2):
  lst3 = lst1 + lst2
  return max(lst3) - min(lst3) == len(lst3) - 1<|endoftext|>"
331,"<|endoftext|>Files in Python:

Python file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python’s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.

File seek() Method in Python:

The seek() function is a built-in Python method that is used to set the current file position in a file stream.

The seek() method returns the new position as well.

Syntax:

file.seek(offset)
Parameters

offset: Required. A number denoting the position at which the current file stream position should be set.

Return Value: This method’s return type is <class ‘int’>, and it returns the new file position.:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in read-only mode. In this case, we're reading the contents of the file.
gvn_file = open(givenFilename, 'r') 
# Print the content of the given file using the read() function
print(""The given file content:"")
print(gvn_file.read())
print()
# Apply seek() method to the given file by passing some random number as an argument.
# It returns the file content from that index position.
gvn_file.seek(7)
# Print  the content of the given file using the read() function after applying seek() method
print(""The given file content after applying seek method:"")
print(gvn_file.read())
# Close the given file using the close() function
gvn_file.close()<|endoftext|>"
332,"<|endoftext|>The Kempner Function, applied to a composite number, permits to find the smallest integer greater than zero whose factorial is exactly divided by the number.
kempner(6) ➞ 3

1! = 1 % 6 > 0
2! = 2 % 6 > 0
3! = 6 % 6 === 0

kempner(10) ➞ 5

1! = 1 % 10 > 0
2! = 2 % 10 > 0
3! = 6 % 10 > 0
4! = 24 % 10 > 0
5! = 120 % 10 === 0
A Kempner Function applied to a prime will always return the prime itself.
kempner(2) ➞ 2
kempner(5) ➞ 5
Given an integer n, implement a Kempner Function.
Examples
kempner(6) ➞ 3

kempner(10) ➞ 5

kempner(2) ➞ 2
Notes
Try solving this recursively, with an approach oriented to higher-order functions.
If you need to get more confident with recursion and factorials, try this challenge.:def kempner(n, i=1, total=1):
    return max(1, i-1) if total%n == 0 else kempner(n, i+1, total*i)<|endoftext|>"
333,"<|endoftext|>Create a function which takes in a date as a string, and returns the date a week after.
Examples
week_after(""12/03/2020"") ➞ ""19/03/2020""

week_after(""21/12/1989"") ➞ ""28/12/1989""

week_after(""01/01/2000"") ➞ ""08/01/2000""
Notes
Note that dates will be given in day/month/year format.
Single digit numbers should be zero padded.
See Resources for some helpful tutorials on Python dates.:from datetime import datetime, timedelta
def week_after(d):
  date = datetime.strptime(d,'%d/%m/%Y') + timedelta(days=7)
  return date.strftime('%d/%m/%Y')<|endoftext|>"
334,"<|endoftext|>Multiline Strings:a = """"""Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua.""""""
print(a)<|endoftext|>"
335,"<|endoftext|>Matryoshka dolls are traditionally wooden dolls that can be nested by fitting smaller dolls into larger ones. Suppose lists can be nested similarly, placing smaller lists into larger ones, in the following sense:
List A can be nested inside List B if:
min(list A) > min(list B)
max(list A) < max(list B)
For example, if A = [2, 3, 9, 5] and B = [10, 2, 1], then A can be nested inside B, since:
min(A) = 2 > 1 = min(B) and
max(A) = 9 < 10 = max(B)
Create a function that returns True if every single sub-list inside a list can be nested Matroyshka style, and False otherwise.
Examples
matryoshka([[2, 2, 7], [3, 4, 5, 6], [4, 5]]) ➞ True
# [4, 5] nested inside [3, 4, 5, 6], [3, 4, 5, 6] nested inside [2, 2, 7], etc.
# Dolls nested from largest to smallest.

matryoshka([[4, 5], [6, 3], [7, 6, 5, 4, 3, 2], [8, 1]]) ➞ True
# Dolls nested from smallest to largest.

matryoshka([[7, 1], [7, 6, 5, 4, 3, 2], [6, 3], [4, 5]]) ➞ False
# [7, 1] and [7, 6, 5, 4, 3, 2] share the same max.
# Second doll cannot be nested properly inside first doll.

matryoshka([[1, 5], [2, 6], [3, 7]]) ➞ False
# Elements are overlapping, cannot be nested.
Notes
Sublists can be nested from smallest to largest or largest to smallest.
Elements must be strictly nested - e.g. no two lists can share either the same MAX or the same MIN (see example #3).
Sublists may not necessarily have unique elements (see example #1).
Sublists can be in any order (see example #2).:def matryoshka(lst):
  lst.sort(key=min)
  return all(min(a) < min(b) and max(a) > max(b) for a, b in zip(lst, lst[1:]))<|endoftext|>"
336,"<|endoftext|>Every decision tree has high variance, but when we combine all of them together in parallel then the resultant variance is low as each decision tree gets perfectly trained on that particular sample data and hence the output doesn’t depend on one decision tree but multiple decision trees. In the case of a classification problem, the final output is taken by using the majority voting classifier. In the case of a regression problem, the final output is the mean of all the outputs. This part is Aggregation.
 A Random Forest is an ensemble technique capable of performing both regression and classification tasks with the use of multiple decision trees and a technique called Bootstrap and Aggregation, commonly known as bagging. The basic idea behind this is to combine multiple decision trees in determining the final output rather than relying on individual decision trees. 
Random Forest has multiple decision trees as base learning models. We randomly perform row sampling and feature sampling from the dataset forming sample datasets for every model. This part is called Bootstrap.
We need to approach the Random Forest regression technique like any other machine learning technique 

Design a specific question or data and get the source to determine the required data.
 
Make sure the data is in an accessible format else convert it to the required format.
 
Specify all noticeable anomalies and missing data points that may be required to achieve the required data.
 
Create a machine learning model
 
Set the baseline model that you want to achieve
 
Train the data machine learning model.
 
Provide an insight into the model with test data
 
Now compare the performance metrics of both the test data and the predicted data from the model.
 
If it doesn’t satisfy your expectations, you can try improving your model accordingly or dating your data or use another data modeling technique.
 
At this stage you interpret the data you have gained and report accordingly. 
 
You will be using a similar sample technique in the below example. :# Importing the libraries
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
data = pd.read_csv('Salaries.csv')
print(data)
# Fitting Random Forest Regression to the dataset
# import the regressor
from sklearn.ensemble import RandomForestRegressor

# create regressor object
regressor = RandomForestRegressor(n_estimators = 100, random_state = 0)

# fit the regressor with x and y data
regressor.fit(x, y)
Y_pred = regressor.predict(np.array([6.5]).reshape(1, 1)) # test the output by changing values
# Visualising the Random Forest Regression results

# arrange for creating a range of values
# from min value of x to max
# value of x with a difference of 0.01
# between two consecutive values
X_grid = np.arrange(min(x), max(x), 0.01)

# reshape for reshaping the data into a len(X_grid)*1 array,
# i.e. to make a column out of the X_grid value                                
X_grid = X_grid.reshape((len(X_grid), 1))

# Scatter plot for original data
plt.scatter(x, y, color = 'blue')

# plot predicted data
plt.plot(X_grid, regressor.predict(X_grid),
                color = 'green')
plt.title('Random Forest Regression')
plt.xlabel('Position level')
plt.ylabel('Salary')
plt.show()
<|endoftext|>"
337,"<|endoftext|>Simple Interest Program in Python | Simple interest is a quick and easy method of calculating the interest charge on a loan. We will give the principal amount, Rate of Interest, and Time. Simple interest is determined by multiplying the daily interest rate by the principal by the number of days that elapse between payments. In this post, Python program to calculate simple interest using various methods.:# Python program to calculate simple interest # store the inputs P = float(input('Enter principal amount: ')) R = float(input('Enter the interest rate: ')) T = float(input('Enter time: ')) # calculate simple interest SI = (P * R * T) / 100 # display result print('Simple interest = ',SI ) print('Total amount = ',( P + SI ))<|endoftext|>"
338,"<|endoftext|>Given an array (or string), the task is to reverse the array/string.
Examples : 
 

Input  : arr[] = {1, 2, 3}
Output : arr[] = {3, 2, 1}

Input :  arr[] = {4, 5, 1, 2}
Output : arr[] = {2, 1, 5, 4}:# Iterative python program to reverse an array

# Function to reverse A[] from start to end
def reverseList(A, start, end):
	while start < end:
		A[start], A[end] = A[end], A[start]
		start += 1
		end -= 1

# Driver function to test above function
A = [1, 2, 3, 4, 5, 6]
print(A)
reverseList(A, 0, 5)
print(""Reversed list is"")
print(A)
# This program is contributed by Pratik Chhajer<|endoftext|>"
339,"<|endoftext|>We are given a stack data structure with push and pop operations, the task is to implement a queue using instances of stack data structure and operations on them.


 :# Python3 program to implement Queue using
# two stacks with costly enQueue()
 
class Queue:
    def __init__(self):
        self.s1 = []
        self.s2 = []
 
    def enQueue(self, x):
         
        # Move all elements from s1 to s2
        while len(self.s1) != 0:
            self.s2.append(self.s1[-1])
            self.s1.pop()
 
        # Push item into self.s1
        self.s1.append(x)
 
        # Push everything back to s1
        while len(self.s2) != 0:
            self.s1.append(self.s2[-1])
            self.s2.pop()
 
    # Dequeue an item from the queue
    def deQueue(self):
         
            # if first stack is empty
        if len(self.s1) == 0:
            print(""Q is Empty"")
     
        # Return top of self.s1
        x = self.s1[-1]
        self.s1.pop()
        return x
 
# Driver code
if __name__ == '__main__':
    q = Queue()
    q.enQueue(1)
    q.enQueue(2)
    q.enQueue(3)
 
    print(q.deQueue())
    print(q.deQueue())
    print(q.deQueue())
 
# This code is contributed by PranchalK
<|endoftext|>"
340,"<|endoftext|>In the previous article, we have discussed Python Program to Find sum of Even Factors of a Number
 Given a number, and the task is to get the sum of odd factors of a given number.
 Factors are numbers or algebraic expressions that divide another number by themselves and leave no remainder.
 Example: let the given number = 24
 # The factors of 24 are : 1, 2, 3, 4, 6, 8, 12, 24
 The sum of odd factors of 24 = 1+3= 4
 Examples:
 Example1:
 Input:
 Given Number = 24
 Output:
 The Sum of all odd factors of { 24 } = 4
 Example2:
 Input:
 Given Number = 72
 Output:
 The Sum of all odd factors of { 72 } = 13:# Give the number as static input and store it in a variable.
 
 gvn_numb = 24
 
 # Take an empty list and store it in another variable.
 
 all_factors = []
 
 # Loop from '1' to above given number range using For loop.
 
 for itr in range(1, gvn_numb+1):
 
  # Check whether the given number modulus iterator value is equal to '0' or not
 
  # using if conditional statement.
 
  if gvn_numb % itr == 0:
 
  # If the statement is True, Check if the iterator modulus 2 is not equal to 0 using the
 
  # if conditional statement.
 
  if itr % 2 != 0:
 
  # If the statement is True ,append the iterator value to the above declared list .
 
  all_factors.append(itr)
 
  # Get the sum of all the odd factors of above got list using built-in sum() function
 
  # and store it in another variable.
 
 reslt = sum(all_factors)
 
 # Print the sum of all odd factors of a given number.
 
 print(""The Sum of all odd factors of {"", gvn_numb, ""} = "", reslt)<|endoftext|>"
341,"<|endoftext|>A number n is apocalyptic if 2^n contains a string of 3 consecutive 6s (666 being the presumptive ""number of the beast"").
Create a function that takes a number n as input. If the number is apocalyptic, find the index of 666 in 2^n, and return ""Repent! X days until the Apocalypse!"" (X being the index). If not, return ""Crisis averted. Resume sinning."".
Examples
apocalyptic(109) ➞ ""Crisis averted. Resume sinning.""

apocalyptic(157) ➞ ""Repent! 9 days until the Apocalypse!""
# 2^157 -> 182687704666362864775460604089535377456991567872
# 666 at 10th position (index 9)

apocalyptic(175) ➞ ""Crisis averted. Resume sinning.""

apocalyptic(220) ➞ ""Repent! 6 days until the Apocalypse!""
Notes
N/A:def apocalyptic(n):
  try:
    return 'Repent! ' + str(str(2**n).index('666')) + ' days until the Apocalypse!'
  except ValueError:
    return ""Crisis averted. Resume sinning.""<|endoftext|>"
342,"<|endoftext|>Remove enemies from the list of people, even if the enemy shows up twice.
Examples
remove_enemies([""Fred""], []) ➞ [""Fred""]

remove_enemies([""Adam"", ""Emmy"", ""Tanya"", ""Emmy""], [""Emmy""]) ➞ [""Adam"", ""Tanya""]

remove_enemies([""John"", ""Emily"", ""Steve"", ""Sam""], [""Sam"", ""John""]) ➞ [""Emily"", ""Steve""]
Notes
All names to be removed will be in the enemies list; simply return the list, no fancy strings.:def remove_enemies(names, enemies):
  return [i for i in names if i not in enemies]<|endoftext|>"
343,"<|endoftext|>Given an array and a sum value, find all possible unique triplets in that array whose sum is equal to the given sum value. If no such triplets can be formed from the array, then print “No triplets can be formed”, else print all the unique triplets. For example, if the given array is {12, 3, 6, 1, 6, 9} and the given sum is 24, then the unique triplets are (3, 9, 12) and (6, 6, 12) whose sum is 24.:# Python3 program to find all
# unique triplets without using
# any extra space.

# Function to all find unique
# triplets without using extra
# space
def findTriplets(a, n, sum):

        # Sort the input array
        a.sort()

        # For handling the cases
        # when no such triplets exits.
        flag = False

        # Iterate over the array from
        # start to n-2.
        for i in range(n - 2):
                if (i == 0 or
                        a[i] > a[i - 1]):

                        # Index of the first
                        # element in remaining
                        # range.
                        start = i + 1

                        # Index of the last
                        # element
                        end = n - 1

                        # Setting our new target
                        target = sum - a[i]

                        while (start < end):

                                # Checking if current element
                                # is same as previous
                                if (start > i + 1 and
                                        a[start] == a[start - 1]):

                                        start += 1
                                        continue

                                # Checking if current
                                # element is same as
                                # previous
                                if (end < n - 1 and
                                        a[end] == a[end + 1]):
                                        end -= 1
                                        continue

                                # If we found the triplets
                                # then print it and set the
                                # flag
                                if (target == a[start] + a[end]):
                                        print(""["", a[i], "","",
                                                a[start], "","",
                                                a[end], ""]"",
                                                end = "" "")
                                        flag = True
                                        start += 1
                                        end -= 1

                                # If target is greater then
                                # increment the start index
                                elif (target >
                                        (a[start] + a[end])):
                                        start += 1

                                # If target is smaller than
                                # decrement the end index
                                else:
                                        end -= 1

        # If no such triplets found
        if (flag == False):
                print(""No Such Triplets Exist"")

# Driver code
if __name__ == ""__main__"":

        a = [12, 3, 6, 1, 6, 9]
        n = len(a)
        sum = 24

        # Function call
        findTriplets(a, n, sum)

# This code is contributed by Chitranayal
<|endoftext|>"
344,"<|endoftext|>You are given an integer n representing the length of an unknown array that you are trying to recover. You are also given an array sums containing the values of all 2n subset sums of the unknown array (in no particular order).

Return the array ans of length n representing the unknown array. If multiple answers exist, return any of them.

An array sub is a subset of an array arr if sub can be obtained from arr by deleting some (possibly zero or all) elements of arr. The sum of the elements in sub is one possible subset sum of arr. The sum of an empty array is considered to be 0.

Note: Test cases are generated such that there will always be at least one correct answer.

 :class Solution:
    def recoverArray(self, n, sums):
        def dfs(n, sums):
            if n == 1 and 0 in sums: return [max(sums, key = abs)]
            cands = []

            d = sums[1] - sums[0]

            for dr in [1, -1]:
                cnt, new = Counter(sums), []
                if cnt[0] == 0: return []
                for num in sums[::-dr]:
                    if cnt[num] == 0: continue
                    if cnt[num - d*dr] == 0: break
                    cnt[num] -= 1
                    new += [num]
                    cnt[num - d*dr] -= 1
                    
                if len(new) == 1 << (n-1):
                    cands += [[-d*dr] + dfs(n - 1, new[::-dr])]

            return max(cands, key = len)
        
        sums = sorted(sums)
        return dfs(n, sums)<|endoftext|>"
345,"<|endoftext|>Given an array of n distinct and positive elements, the task is to find pair whose sum already exists in the given array. 
Examples : 
 

Input : arr[] = {2, 8, 7, 1, 5};
Output : 2 5
         7 1    
     
Input : arr[] = {7, 8, 5, 9, 11};
Output : Not Exist:# Python3 program to find pair whose
# sum already exist in array

# Function to find pair whose
# sum sxists in arr[]
def findPair(arr, n):
	
	# hash to store all element of array
	s = {i : 1 for i in arr}
	
	found = False
	
	for i in range(n):
		for j in range(i + 1, n):
			
			# check if sum already exists or not
			if arr[i] + arr[j] in s.keys():
				print(arr[i], arr[j])
				found = True
	if found == False:
		print(""Not exist"")
		
# Driver code
arr = [10, 4, 8, 13, 5]

n = len(arr)

findPair(arr, n)
	
# This code is contributed
# by Mohit Kumar<|endoftext|>"
346,"<|endoftext|>Create a function that takes damage and speed (attacks per second) and returns the amount of damage after a given time.
Examples
damage(40, 5, ""second"") ➞ 200

damage(100, 1, ""minute"") ➞ 6000

damage(2, 100, ""hour"") ➞ 720000
Notes
Return ""invalid"" if damage or speed is negative.:def damage(damage, speed, time):
  secs = {'second':1, 'minute':60, 'hour':3600}
  ans = damage*speed*secs[time]
  return ans if ans>0 and speed>0 else 'invalid'<|endoftext|>"
347,"<|endoftext|>In the previous article, we have discussed Python Program to Print Series 1, 22, 333, 4444…n
 Given a number N and the task is to print the series ( 0,2,8,14,24,34 …N) till the given number N in Python.
 Examples:
 Example1:
 Input:
 Given Number = 5
 Output:
 The above series till the given number{ 5 } is :
 
 0 2 8 14 24
 Example2:
 Input:
 Given Number = 9
 Output:
 The above series till the given number{ 9 } is :
 
 0 2 8 14 24 34 48 62 80:# Give the number N as static input and store it in a variable.
 
 gvn_numb = 5
 
 # Take a variable to say itr and initialize its value to 1.
 
 itr = 1
 
 # Take another variable say previous_val and initialize its value to 0.
 
 previous_val = 0
 
 print(""The above series till the given number{"", gvn_numb, ""} is :"")
 
 # Loop until the above-declared variable itr value is less than or equal to the
 
 # given number using the while loop.
 
 while itr &lt;= gvn_numb:
 
  # Inside the loop, check if the above itr value is even or not using the if
 
  # conditional statement.
 
  if(itr % 2 == 0):
 
  # If it is true, calculate the value of itr raised to the power 2 using the pow()
 
  # function and subtract 2 from it.
 
  # Store it in the same variable previous_val.
 
  previous_val = pow(itr, 2) - 2
 
  # Print the value of the above previous_val separated by spaces.
 
  print(previous_val, end="" "")
 
  else:
 
  # Else, If it is false calculate the value of itr raised to the power 2 using the pow()
 
  # function and subtract 1 from it.
 
  # Store it in the same variable previous_val.
 
  previous_val = pow(itr, 2) - 1
 
  # Print the value of the above previous_val separated by spaces.
 
  print(previous_val, end="" "")
 
  # Increment the above itr value by 1.
 
  itr += 1
 
 </pre><|endoftext|>"
348,"<|endoftext|>Given a number n, write a function that returns true if n is divisible by 9, else false. The most simple way to check for n’s divisibility by 9 is to do n%9. 
Another method is to sum the digits of n. If sum of digits is multiple of 9, then n is multiple of 9. 
The above methods are not bitwise operators based methods and require use of % and /. 
The bitwise operators are generally faster than modulo and division operators. Following is a bitwise operator based method to check divisibility by 9. :# Bitwise operator based
# function to check divisibility by 9

def isDivBy9(n):

	# Base cases
	if (n == 0 or n == 9):
		return True
	if (n < 9):
		return False

	# If n is greater than 9,
	# then recur for [floor(n / 9) - n % 8]
	return isDivBy9((int)(n>>3) - (int)(n&7))

# Driver code

# Let us print all multiples
# of 9 from 0 to 100
# using above method
for i in range(100):
	if (isDivBy9(i)):
		print(i, "" "", end ="""")

# This code is contributed
# by Anant Agarwal.
<|endoftext|>"
349,"<|endoftext|>The math.log1p() method returns log(1+number), computed in a way that is accurate even when the value of number is close to zero.
:# Import math Library
import math

# Return the log(1+number) for different numbers
print(math.log1p(2.7183))
print(math.log1p(2))
print(math.log1p(1))<|endoftext|>"
350,"<|endoftext|>Write a function to delete a given node in a doubly-linked list. 
Original Doubly Linked List 
:# Program to delete a node in a doubly-linked list

# for Garbage collection
import gc

# A node of the doubly linked list
class Node:
	
	# Constructor to create a new node
	def __init__(self, data):
		self.data = data
		self.next = None
		self.prev = None

class DoublyLinkedList:
	# Constructor for empty Doubly Linked List
	def __init__(self):
		self.head = None

# Function to delete a node in a Doubly Linked List.
# head_ref --> pointer to head node pointer.
# dele --> pointer to node to be deleted

	def deleteNode(self, dele):
		
		# Base Case
		if self.head is None or dele is None:
			return
		
		# If node to be deleted is head node
		if self.head == dele:
			self.head = dele.next

		# Change next only if node to be deleted is NOT
		# the last node
		if dele.next is not None:
			dele.next.prev = dele.prev
	
		# Change prev only if node to be deleted is NOT
		# the first node
		if dele.prev is not None:
			dele.prev.next = dele.next
		# Finally, free the memory occupied by dele
		# Call python garbage collector
		gc.collect()


	# Given a reference to the head of a list and an
	# integer, inserts a new node on the front of list
	def push(self, new_data):

		# 1. Allocates node
		# 2. Put the data in it
		new_node = Node(new_data)

		# 3. Make next of new node as head and
		# previous as None (already None)
		new_node.next = self.head

		# 4. change prev of head node to new_node
		if self.head is not None:
			self.head.prev = new_node

		# 5. move the head to point to the new node
		self.head = new_node


	def printList(self, node):
		while(node is not None):
			print(node.data,end=' ')
			node = node.next


# Driver program to test the above functions

# Start with empty list
dll = DoublyLinkedList()

# Let us create the doubly linked list 10<->8<->4<->2
dll.push(2);
dll.push(4);
dll.push(8);
dll.push(10);

print (""\n Original Linked List"",end=' ')
dll.printList(dll.head)

# delete nodes from doubly linked list
dll.deleteNode(dll.head)
dll.deleteNode(dll.head.next)
dll.deleteNode(dll.head.next)
# Modified linked list will be NULL<-8->NULL
print(""\n Modified Linked List"",end=' ')
dll.printList(dll.head)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
<|endoftext|>"
351,"<|endoftext|>In Python, grouping words with the same set of characters is also known as Group Anagrams. We are given a list of words with the same set of characters but in various positions in the word, such as ‘clock’ and ‘klocc’ and we must group them together in a list.

Given the list of words, the task is to group words with the Same set of Characters.:# Import the defaultdict from collections using the import keyword.

from collections import defaultdict
# Give the list of strings as static input and store it in a variable.
gvnstrnglist = ['ehlo', 'this', 'is', 'olhe', 'helo', 'si', 'btechgeeks']
# The defaultdict method is used to construct a dictionary
# corresponding to a key that contains word characters.
# The list argument is used to generate key-value list pairs.
grpwords = defaultdict(list)

# Loop over the list of strings using For loop.
for strngword in gvnstrnglist:
    # The str method on sorted(word) returns a list of keys
    # that include the alphabets of words.
    # Append the word using append(word) joins together words that are related.
    grpwords[str(sorted(strngword))].append(strngword)

# Get all the values of the defaultdict using the values() function.
simipairs = list(grpwords.values())
# Print the defaultdict.
print('The group of words which are similar in given list of strings ',
      gvnstrnglist, 'is :')
print(simipairs)<|endoftext|>"
352,"<|endoftext|>Given a list, the task is to write a program to print all perfect squares from the given list using list comprehension and Math Module.
 
 Using list comprehension and the math module, you’ll learn how to check whether the elements in a Python list entered by the user are perfect squares or not.
 
 
 
 List comprehensions are a neat trick that allows us to create a new list depending on the values of an existing list in only one line, making the code look shorter and more concise because we aren’t committing to the problem with an entire loop.
 Python’s math module is a highly valuable tool because it offers a large number of mathematical functions that we may utilize in our programs.
 
 Examples:
 
 Example1:
 
 Input:
 
 Given list =[19, 24, 25, 36, 81, 144, 600, 900, 225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]
 Output:
 
 The given list is = [19, 24, 25, 36, 81, 144, 600, 900, 225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]
 The perfect squares numbers of the given list is = [25, 36, 81, 144, 900, 225, 4, 9, 1, 16, 49, 49, 25, 25]
 Example2:
 
 Input:
 
 Given list =[37, 82, 81, 467, 839, 8383, 1000, 1900, 10000, 9, 48, 49, 64, 121, 56]
 Output:
 
 Enter some random List Elements separated by spaces = 37 82 81 467 839 8383 1000 1900 10000 9 48 49 64 121 56
 The given list is = [37, 82, 81, 467, 839, 8383, 1000, 1900, 10000, 9, 48, 49, 64, 121, 56]
 The perfect squares numbers of the given list is = [81, 10000, 9, 49, 64, 121]:# Import the math module using the import statement.
 import math
 # Give the list as static input and store it in a variable.
 gvnlst = [19, 24, 25, 36, 81, 144, 600, 900,
  225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]
 print('The given list is =', gvnlst)
 # Using List comprehension, floor(), and sqrt() functions
 # to check whether the element value of the list is a perfect square or not.
 # (An Element is said to be a perfect square if the floor value of the square root
 # of the number is equal to the sqrt of the number)
 prftsquareslist = [elemen for elemen in gvnlst if (
  math.sqrt(elemen) == math.floor(math.sqrt(elemen)))]
 # Print the new list which contains only perfect squares of the original list.
 print('The perfect squares numbers of the given list is =', prftsquareslist)<|endoftext|>"
353,"<|endoftext|>Given a Queue consisting of first n natural numbers (in random order). The task is to check whether the given Queue elements can be arranged in increasing order in another Queue using a stack. The operation allowed are: 

1. Push and pop elements from the stack 
2. Pop (Or Dequeue) from the given Queue. 
3. Push (Or Enqueue) in the another Queue.:# Python Program to check if a queue of first
# n natural number can be sorted using a stack
from queue import Queue
 
# Function to check if given queue element
# can be sorted into another queue using a
# stack.
def checkSorted(n, q):
    st = []
    expected = 1
    fnt = None
 
    # while given Queue is not empty.
    while (not q.empty()):
        fnt = q.queue[0]
        q.get()
 
        # if front element is the
        # expected element
        if (fnt == expected):
            expected += 1
 
        else:
             
            # if stack is empty, put the element
            if (len(st) == 0):
                st.append(fnt)
 
            # if top element is less than element which
            # need to be puted, then return false.
            elif (len(st) != 0 and st[-1] < fnt):
                return False
 
            # else put into the stack.
            else:
                st.append(fnt)
 
        # while expected element are coming
        # from stack, pop them out.
        while (len(st) != 0 and
                   st[-1] == expected):
            st.pop()
            expected += 1
 
    # if the final expected element value is equal
    # to initial Queue size and the stack is empty.
    if (expected - 1 == n and len(st) == 0):
        return True
 
    return False
 
# Driver Code
if __name__ == '__main__':
    q = Queue()
    q.put(5)
    q.put(1)
    q.put(2)
    q.put(3)
    q.put(4)
 
    n = q.qsize()
 
    if checkSorted(n, q):
        print(""Yes"")
    else:
        print(""No"")
 
# This code is contributed by PranchalK
<|endoftext|>"
354,"<|endoftext|>A number n is automorphic if n^2 ends in n.
For example: n=5, n^2=25
Create a function that takes a number and returns True if the number is automorphic, False if it isn't.
Examples
is_automorphic(5) ➞ True

is_automorphic(8) ➞ False

is_automorphic(76) ➞ True
Notes
N/A:def is_automorphic(n):
  return str(n**2).endswith(str(n))<|endoftext|>"
355,"<|endoftext|>In the previous article, we have discussed Python Program to Sort the Given Matrix
 
 Given a list and the task is to find the elements in a list that are greater than half of the total number of elements in the given list.
 
 
 
 In the case of odd elements, we must print elements greater than floor(n/2) where n is the total number of elements in the given list.
 
 Examples:
 
 Example1:
 
 Input:
 
 Given List = [4, 6, 3, 1, 8, 9]
 Output:
 
 The elements in a list that are greater than half of the total number of elements in the given list
 6
 8
 9
 Explanation:
 
 Here the elements which are greater than 4 are 6,8,9
 Example2:
 
 Input:
 
 Given List = [1, 0, 6, 9, 3, 4, 2, 6, 3]
 Output:
 
 The elements in a list that are greater than half of the total number of elements in the given list
 3
 4
 6
 6
 9:# Create a function to say getElementsLarger() which takes the given list and length of
 # the given list as the arguments and prints the elements in a list that are greater than
 # half of the total number of elements in the given list.
 def getElementsLarger(gvn_lst, lengt_lst):
  # Inside the function, sort the given list using the sorted() function and store
  # it in a variable.
  k = sorted(gvn_lst)
  # Loop from half the length of the given list to the length of the given list-1
  # using the for loop.
  for itr in range(lengt_lst//2, lengt_lst):
  # Inside the loop, print the element present at the iterator value of the
  # above-sorted list.
  print(k[itr])
 # Give the list as static input and store it in a variable.
 gvn_lst = [4, 6, 3, 1, 8, 9]
 # Calculate the length of the given list using the len() function and store it in
 # another variable.
 lengt_lst = len(gvn_lst)
 print(""The elements in a list that are greater than half of the total number of elements in the given list"")
 # Pass the given list and length of the given list as the arguments to the
 # getElementsLarger() function.
 getElementsLarger(gvn_lst, lengt_lst)<|endoftext|>"
356,"<|endoftext|>Instructions
There are 10 types of people in the world: Those who understand binary, and those who don't.

You and your fellow cohort of those in the ""know"" when it comes to binary decide to come up with a secret ""handshake"".

1 = wink
10 = double blink
100 = close your eyes
1000 = jump


10000 = Reverse the order of the operations in the secret handshake.
Given a decimal number, convert it to the appropriate sequence of events for a secret handshake.

Here's a couple of examples:

Given the input 3, the function would return the array [""wink"", ""double blink""] because 3 is 11 in binary.

Given the input 19, the function would return the array [""double blink"", ""wink""] because 19 is 10011 in binary. Notice that the addition of 16 (10000 in binary) has caused the array to be reversed.

To keep things simple (and to let you focus on the important part of this exercise), your function will receive its inputs as binary strings:

>>> commands(""00011"")
[""wink"", ""double blink""]:ACTIONS = ['wink', 'double blink', 'close your eyes', 'jump', 'reverse']
def commands(code):
    code = int(code, 2)
    actions = []
    for i, a in enumerate(ACTIONS):
        if code & (1 << i) != 0:
            actions.append(a)
    if 'reverse' in actions:
        actions = actions[-2::-1]
    return actions
<|endoftext|>"
357,"<|endoftext|>Upper Triangular Matrix:

An upper triangular matrix is a square matrix in which all of the entries below the major diagonal are zero. Given a matrix and the task is to display an upper triangular matrix of the given matrix in Python.:# Give the matrix as static input and store it in a variable.
mtrx = [[5, 3, 2], [6, 1, 5], [4, 8, 2]]
# Calculate the number of rows of the given matrix by
# calculating the length of the nested list using the len() function
# and store it in a variable mtrxrows.
mtrxrows = len(mtrx)
# Calculate the number of columns of the given matrix by
# calculating the length of the first list in the nested list
# using the len() function and store it in a variable mtrxcols.
mtrxcols = len(mtrx[0])
print(""The Upper Triangular matrix of the given matrix is :"")
# To print all the elements of the given matrix.
# Loop till the given number of rows using the For loop.
for n in range(mtrxrows):
        # Inside the For loop, Iterate till the given number of columns using another
        # Nested For loop(Inner For loop).
    for m in range(mtrxcols):
      # Check if the condition n is greater than m using the if conditional statement where n
      # is the iterator value of the parent For loop and m is the iterator value of the
      # inner For loop.
        if n > m:
          # If the statement is true, then print 0.
            print(""0 "", end="""")
        else:
          # Else Print the element of the matrix by printing gvnmatrix[n][m] value.
            print(mtrx[n][m], end="" "")
    print()<|endoftext|>"
358,"<|endoftext|>You are in the process of creating a chat application and want to add an anonymous name feature. This anonymous name feature will create an alias that consists of two capitalized words beginning with the same letter as the users first name.
Create a function that determines if the list of users is mapped to a list of anonymous names correctly.
Examples
is_correct_aliases([""Adrian M."", ""Harriet S."", ""Mandy T.""], [""Amazing Artichoke"", ""Hopeful Hedgehog"", ""Marvelous Mouse""]) ➞ True

is_correct_aliases([""Rachel F."", ""Pam G."", ""Fred Z."", ""Nancy K.""], [""Reassuring Rat"", ""Peaceful Panda"", ""Fantastic Frog"", ""Notable Nickel""]) ➞ True

is_correct_aliases([""Beth T.""], [""Brandishing Mimosa""]) ➞ False
# Both words in ""Brandishing Mimosa"" should begin with a ""B"" - ""Brandishing Beaver"" would do the trick.
Notes
Both words in the alias should be capitalized.:def is_correct_aliases(names, aliases):
  return all(i[0] == j.split()[0][0] == j.split()[1][0] for i, j in zip(names, ))<|endoftext|>"
359,"<|endoftext|>Create a function that adds a string ending to each member in a list.
Examples
add_ending([""clever"", ""meek"", ""hurried"", ""nice""], ""ly"")
➞ [""cleverly"", ""meekly"", ""hurriedly"", ""nicely""]

add_ending([""new"", ""pander"", ""scoop""], ""er"")
➞ [""newer"", ""panderer"", ""scooper""]

add_ending([""bend"", ""sharpen"", ""mean""], ""ing"")
➞ [""bending"", ""sharpening"", ""meaning""]
Notes
Don't forget to return the result.
If you get stuck on a challenge, find help in the Resources tab.
If you're really stuck, unlock solutions in the Solutions tab.:def add_ending(lst, ending):
  return [ word + ending for word in lst]<|endoftext|>"
360,"<|endoftext|>Given n cities and distances between every pair of cities, select k cities to place warehouses (or ATMs or Cloud Server) such that the maximum distance of a city to a warehouse (or ATM or Cloud Server) is minimized. 

For example consider the following four cities, 0, 1, 2, and 3, and distances between them, how to do place 2 ATMs among these 4 cities so that the maximum distance of a city to an ATM is minimized. 
There is no polynomial-time solution available for this problem as the problem is a known NP-Hard problem. There is a polynomial-time Greedy approximate algorithm, the greedy algorithm provides a solution that is never worse than twice the optimal solution. The greedy solution works only if the distances between cities follow Triangular Inequality (The distance between two points is always smaller than the sum of distances through a third point). 

The 2-Approximate Greedy Algorithm: 
1) Choose the first center arbitrarily. 
2) Choose remaining k-1 centers using the following criteria. 
       Let c1, c2, c3, … ci be the already chosen centers. Choose 
       (i+1)’th center by picking the city which is farthest from already 
       selected centers, i.e, the point p which has following value as maximum 
                 Min[dist(p, c1), dist(p, c2), dist(p, c3), …. dist(p, ci)] 
Example (k = 3 in the above-shown Graph) 
a) Let the first arbitrarily picked vertex be 0. 
b) The next vertex is 1 because 1 is the farthest vertex from 0. 
c) Remaining cities are 2 and 3. Calculate their distances from already selected centers (0 and 1). The greedy algorithm basically calculates the following values. 
        Minimum of all distanced from 2 to already considered centers 
        Min[dist(2, 0), dist(2, 1)] = Min[7, 8] = 7 
        Minimum of all distanced from 3 to already considered centers 
        Min[dist(3, 0), dist(3, 1)] = Min[6, 5] = 5 
        After computing the above values, city 2 is picked as the value corresponding to 2 is maximum. 

Note that the greedy algorithm doesn’t give the best solution for k = 2 as this is just an approximate algorithm with a bound as twice optimal. 

Proof that the above greedy algorithm is 2 approximate. 
Let OPT be the maximum distance of a city from a center in the Optimal solution. We need to show that the maximum distance obtained from the Greedy algorithm is 2*OPT. 
The proof can be done using contradiction. 
a) Assume that the distance from the furthest point to all centers is > 2·OPT. 
b) This means that distances between all centers are also > 2·OPT. 
c) We have k + 1 points with distances > 2·OPT between every pair. 
d) Each point has a center of the optimal solution with distance <= OPT to it. 
e) There exists a pair of points with the same center X in the optimal solution (pigeonhole principle: k optimal centers, k+1 points) 
f) The distance between them is at most 2·OPT (triangle inequality) which is a contradiction. :# Python3 program for the above approach
def maxindex(dist, n):
	mi = 0
	for i in range(n):
		if (dist[i] > dist[mi]):
			mi = i
	return mi

def selectKcities(n, weights, k):
	dist = [0]*n
	centers = []

	for i in range(n):
		dist[i] = 10**9
		
	# index of city having the
	# maximum distance to it's
	# closest center
	max = 0
	for i in range(k):
		centers.append(max)
		for j in range(n):

			# updating the distance
			# of the cities to their
			# closest centers
			dist[j] = min(dist[j], weights[max][j])

		# updating the index of the
		# city with the maximum
		# distance to it's closest center
		max = maxindex(dist, n)

	# Printing the maximum distance
	# of a city to a center
	# that is our answer
	# print()
	print(dist[max])

	# Printing the cities that
	# were chosen to be made
	# centers
	for i in centers:
		print(i, end = "" "")

# Driver Code
if __name__ == '__main__':
	n = 4
	weights = [ [ 0, 4, 8, 5 ],
			[ 4, 0, 10, 7 ],
			[ 8, 10, 0, 9 ],
			[ 5, 7, 9, 0 ] ]
	k = 2

	# Function Call
	selectKcities(n, weights, k)

# This code is contributed by mohit kumar 29.<|endoftext|>"
361,"<|endoftext|>Create a function that takes a list of strings and integers, and filters out the list so that it returns a list of integers only.
Examples
filter_list([1, 2, 3, ""a"", ""b"", 4]) ➞ [1, 2, 3, 4]

filter_list([""A"", 0, ""Edabit"", 1729, ""Python"", ""1729""]) ➞ [0, 1729]

filter_list([""Nothing"", ""here""]) ➞ []
Notes
Don't overthink this one.:def filter_list(l):
  return [i for i in l if type(i)==int]<|endoftext|>"
362,"<|endoftext|>The best and excellent way to learn a java programming language is by practicing Simple Java Program Examples as it includes basic to advanced levels of concepts.
 
 Recursion in Python:
 
 Python also supports function recursion, which means that a specified function can call itself.
 
 Recursion is a mathematical and programming concept that is widely used. It signifies that a function calls itself. This has the advantage of allowing you to loop through data to obtain a result.
 
 
 
 The developer must exercise extreme caution when using recursion since it is quite easy to write a function that never terminates or consumes excessive amounts of memory or computing power. However, when performed correctly, recursion may be a tremendously efficient and mathematically elegant way to programming.
 
 Examples:
 
 Example1:
 
 Input:
 
 given string = btechgeeks
 Output:
 
 The modified given string{after reversing} = skeeghcetb
 Example2:
 
 Input:
 
 The original given string = aplustopper
 Output:
 
 The modified given string{after reversing} = reppotsulpa:# function which accepts the given string as an argument and
 # reverse the given string using recursion and return the reversed string
 def reverseRecursion(given_string):
  # Calculate the length of the given string using the len() function.
  stringLen = len(given_string)
  # if len(str1) == 1 is used to check the length of the string, which is the fundamental condition of recursion. If the length of the string is 1,
  # the string is returned, otherwise, the function is called recursively.
  if stringLen == 1:
  return given_string
  else:
  # The slice operator will slice the string and concatenate it to the end of the
  # slice string if it anticipates the first character.
  return reverseRecursion(given_string[1:]) + given_string[0]
 # Give the string from the user as static input and store it in a variable.
 givenstring = 'btechgeeks'
 # printing the original given string
 print('The original given string =', givenstring)
 # passing the given string as an argument to the recursive function
 # 'reverseRecursion' which reverses the given string.
 print('The modified given string{after reversing} = ',
  reverseRecursion(givenstring))<|endoftext|>"
363,"<|endoftext|>OOP Exercise 4: Create a Bus class that inherits from the Vehicle class. Give the capacity argument of Bus.seating_capacity() a default value of 50.:class Vehicle:
    def __init__(self, name, max_speed, mileage):
        self.name = name
        self.max_speed = max_speed
        self.mileage = mileage

    def seating_capacity(self, capacity):
        return f""The seating capacity of a {self.name} is {capacity} passengers""

class Bus(Vehicle):
    # assign default value to capacity
    def seating_capacity(self, capacity=50):
        return super().seating_capacity(capacity=50)

School_bus = Bus(""School Volvo"", 180, 12)
print(School_bus.seating_capacity())<|endoftext|>"
364,"<|endoftext|>Level order traversal of a tree is breadth first traversal for the tree. :# Recursive Python program for level
# order traversal of Binary Tree
 
# A node structure
 
 
class Node:
 
    # A utility function to create a new node
    def __init__(self, key):
        self.data = key
        self.left = None
        self.right = None
 
 
# Function to  print level order traversal of tree
def printLevelOrder(root):
    h = height(root)
    for i in range(1, h+1):
        printCurrentLevel(root, i)
 
 
# Print nodes at a current level
def printCurrentLevel(root, level):
    if root is None:
        return
    if level == 1:
        print(root.data, end="" "")
    elif level > 1:
        printCurrentLevel(root.left, level-1)
        printCurrentLevel(root.right, level-1)
 
 
"""""" Compute the height of a tree--the number of nodes
    along the longest path from the root node down to
    the farthest leaf node
""""""
 
 
def height(node):
    if node is None:
        return 0
    else:
        # Compute the height of each subtree
        lheight = height(node.left)
        rheight = height(node.right)
 
        # Use the larger one
        if lheight > rheight:
            return lheight+1
        else:
            return rheight+1
 
 
# Driver program to test above function
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
 
print(""Level order traversal of binary tree is -"")
printLevelOrder(root)
 
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)<|endoftext|>"
365,"<|endoftext|>We have discussed iterative inorder and iterative preorder traversals. In this post, iterative postorder traversal is discussed, which is more complex than the other two traversals (due to its nature of non-tail recursion, there is an extra statement after the final recursive call to itself). Postorder traversal can easily be done using two stacks, though. The idea is to push reverse postorder traversal to a stack. Once we have the reversed postorder traversal in a stack, we can just pop all items one by one from the stack and print them; this order of printing will be in postorder because of the LIFO property of stacks. Now the question is, how to get reversed postorder elements in a stack – the second stack is used for this purpose. For example, in the following tree, we need to get 1, 3, 7, 6, 2, 5, 4 in a stack. If take a closer look at this sequence, we can observe that this sequence is very similar to the preorder traversal. The only difference is that the right child is visited before left child, and therefore the sequence is “root right left” instead of “root left right”. So, we can do something like iterative preorder traversal with the following differences: 

a) Instead of printing an item, we push it to a stack. 
b) We push the left subtree before the right subtree.


 :# Python program for iterative postorder
# traversal using two stacks
 
# A binary tree node
class Node:
     
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
 
# An iterative function to do postorder
# traversal of a given binary tree
def postOrderIterative(root):
 
    if root is None:
        return       
     
    # Create two stacks
    s1 = []
    s2 = []
     
    # Push root to first stack
    s1.append(root)
     
    # Run while first stack is not empty
    while s1:
         
        # Pop an item from s1 and
        # append it to s2
        node = s1.pop()
        s2.append(node)
     
        # Push left and right children of
        # removed item to s1
        if node.left:
            s1.append(node.left)
        if node.right:
            s1.append(node.right)
 
        # Print all elements of second stack
    while s2:
        node = s2.pop()
        print(node.data,end="" "")
 
# Driver program to test above function
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.left = Node(6)
root.right.right = Node(7)
postOrderIterative(root)
<|endoftext|>"
366,"<|endoftext|>Given an array, rearrange the array such that : 

If index i is even, arr[i] <= arr[i+1]
If index i is odd, arr[i] >= arr[i+1]
Note : There can be multiple answers.
Examples:  



Input  : arr[] = {2, 3, 4, 5} 
Output : arr[] = {2, 4, 3, 5}
Explanation : Elements at even indexes are
smaller and elements at odd indexes are greater
than their next elements

Note : Another valid answer
is arr[] = {3, 4, 2, 5}

Input  :arr[] = {6, 4, 2, 1, 8, 3}
Output :arr[] = {4, 6, 1, 8, 2, 3}:# Python code to rearrange
# an array such that
# even index elements
# are smaller and odd
# index elements are
# greater than their
# next.

def rearrange(arr, n):

	for i in range(n - 1):
		if (i % 2 == 0 and arr[i] > arr[i + 1]):
		
			temp = arr[i]
			arr[i]= arr[i + 1]
			arr[i + 1]= temp
		
		if (i % 2 != 0 and arr[i] < arr[i + 1]):
		
			temp = arr[i]
			arr[i]= arr[i + 1]
			arr[i + 1]= temp
			

# Utility that prints out an array in
# a line
def printArray(arr, size):

	for i in range(size):
		print(arr[i], "" "", end ="""")

	print()

# Driver code

arr = [ 6, 4, 2, 1, 8, 3 ]
n = len(arr)

print(""Before rearranging: "")
printArray(arr, n)

rearrange(arr, n)

print(""After rearranging:"")
printArray(arr, n);

# This code is contributed
# by Anant Agarwal.<|endoftext|>"
367,"<|endoftext|>Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.

 

Example 1:

Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Example 2:

Input: nums = [2,0,1]
Output: [0,1,2]
 

Constraints:

n == nums.length
1 <= n <= 300
nums[i] is either 0, 1, or 2.
 

Follow up: Could you come up with a one-pass algorithm using only constant extra space?:class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Dutch National Flag problem solution.
        """"""
        # for all idx < p0 : nums[idx < p0] = 0
        # curr is an index of element under consideration
        p0 = curr = 0
        # for all idx > p2 : nums[idx > p2] = 2
        p2 = len(nums) - 1

        while curr <= p2:
            if nums[curr] == 0:
                nums[p0], nums[curr] = nums[curr], nums[p0]
                p0 += 1
                curr += 1
            elif nums[curr] == 2:
                nums[curr], nums[p2] = nums[p2], nums[curr]
                p2 -= 1
            else:
                curr += 1<|endoftext|>"
368,"<|endoftext|>Counting sort is a sorting technique based on keys between a specific range. It works by counting the number of objects having distinct key values (kind of hashing). Then doing some arithmetic to calculate the position of each object in the output sequence.

Let us understand it with the help of an example. 



For simplicity, consider the data in the range 0 to 9. 
Input data: 1, 4, 1, 2, 7, 5, 2
  1) Take a count array to store the count of each unique object.
  Index:     0  1  2  3  4  5  6  7  8  9
  Count:     0  2  2  0   1  1  0  1  0  0

  2) Modify the count array such that each element at each index 
  stores the sum of previous counts. 
  Index:     0  1  2  3  4  5  6  7  8  9
  Count:     0  2  4  4  5  6  6  7  7  7

The modified count array indicates the position of each object in 
the output sequence.

  3) Rotate the array clockwise for one time.
   Index:     0 1 2 3 4 5 6 7 8 9
   Count:     0 0 2 4 4 5 6 6 7 7
  
  4) Output each object from the input sequence followed by 
  increasing its count by 1.
  Process the input data: 1, 4, 1, 2, 7, 5, 2. Position of 1 is 0.
  Put data 1 at index 0 in output. Increase count by 1 to place 
  next data 1 at an index 1 greater than this index.:# Python program for counting sort

# The main function that sort the given string arr[] in
# alphabetical order
def countSort(arr):

	# The output character array that will have sorted arr
	output = [0 for i in range(len(arr))]

	# Create a count array to store count of individual
	# characters and initialize count array as 0
	count = [0 for i in range(256)]

	# For storing the resulting answer since the
	# string is immutable
	ans = ["""" for _ in arr]

	# Store count of each character
	for i in arr:
		count[ord(i)] += 1

	# Change count[i] so that count[i] now contains actual
	# position of this character in output array
	for i in range(256):
		count[i] += count[i-1]

	# Build the output character array
	for i in range(len(arr)):
		output[count[ord(arr[i])]-1] = arr[i]
		count[ord(arr[i])] -= 1

	# Copy the output array to arr, so that arr now
	# contains sorted characters
	for i in range(len(arr)):
		ans[i] = output[i]
	return ans

# Driver program to test above function
arr = ""geeksforgeeks""
ans = countSort(arr)
print(""Sorted character array is % s"" %("""".join(ans)))

# This code is contributed by Nikhil Kumar Singh<|endoftext|>"
369,"<|endoftext|>In this example, you will learn to count the number of occurrences of a character in a string.:count = 0

my_string = ""Programiz""
my_char = ""r""

for i in my_string:
    if i == my_char:
        count += 1

print(count)
my_string = ""Programiz""
my_char = ""r""

print(my_string.count(my_char))<|endoftext|>"
370,"<|endoftext|>Join Two Sets
There are several ways to join two or more sets in Python.

You can use the union() method that returns a new set containing all items from both sets, or the update() method that inserts all the items from one set into another::set1 = {""a"", ""b"" , ""c""}
set2 = {1, 2, 3}

set3 = set1.union(set2)
print(set3)<|endoftext|>"
371,"<|endoftext|>Given a number, return the difference between the maximum and minimum numbers that can be formed when the digits are rearranged.
Examples
rearranged_difference(972882) ➞ 760833
# 988722 - 227889 = 760833

rearranged_difference(3320707) ➞ 7709823
# 7733200 - 23377 = 7709823

rearranged_difference(90010) ➞ 90981
# 91000 - 19 = 90981
Notes
N/A:def rearranged_difference(num):
  n = ''.join(sorted(str(num)))
  return int(n[::-1]) - int(n)<|endoftext|>"
372,"<|endoftext|>Given two integers and the task is to find the modular multiplicative inverse of ‘first number’ under modulo ‘second number’.:# Create a function to say modular_MultInverse which takes the given first and second
# numbers as the arguments and returns the modular multiplicative inverse of
# ‘first number’ under modulo ‘second number’.


def modular_MultInverse(fst_numb, secnd_numb):
  # Calculate the value of the given first number modulus second number and store it in the
  # same variable first number.
    fst_numb = fst_numb % secnd_numb
    # Loop from 1 to the given second number using the for loop.
    for itror in range(1, secnd_numb):
        # Multiply the given first number with the iterator value and store it in
        # another variable.
        mul = (fst_numb * itror)
      # Check if the above result modulus second number is equal to 1 using the if conditional
      # statement.
        if (mul % secnd_numb == 1):
          # If it is true, then return the iterator value.
            return itror
    # Return 1.
    return 1


# Give the first number as user input using the int(input()) function and store it in a variable.
fst_numb = int(input(""Enter some random number = ""))
# Give the second number as user input using the int(input()) function and store it in
# another variable.
secnd_numb = int(input(""Enter some random number = ""))
# Pass the given first and second numbers as the arguments to the modular_MultInverse
# function.
# Print the modular multiplicative inverse of ‘first number’ under modulo ‘second number'.
print(""The modular multiplicative inverse of given first number under modulo second number = "",
      modular_MultInverse(fst_numb, secnd_numb))<|endoftext|>"
373,"<|endoftext|>Given a N x N binary matrix (elements in matrix can be either 1 or 0) where each row and column of the matrix is sorted in ascending order, count number of 0s present in it.

Expected time complexity is O(N).

 :# Python program to count number
# of 0s in the given row-wise
# and column-wise sorted
# binary matrix.
 
# Function to count number
# of 0s in the given
# row-wise and column-wise
# sorted binary matrix.
def countZeroes(mat):
     
    # start from bottom-left
    # corner of the matrix
    N = 5;
    row = N - 1;
    col = 0;
 
    # stores number of
    # zeroes in the matrix
    count = 0;
 
    while (col < N):
         
        # move up until
        # you find a 0
        while (mat[row][col]):
             
            # if zero is not found
            # in current column, we
            # are done
            if (row < 0):
                return count;
            row = row - 1;
 
        # add 0s present in
        # current column to result
        count = count + (row + 1);
 
        # move right to
        # next column
        col = col + 1;
 
    return count;
     
# Driver Code
mat = [[0, 0, 0, 0, 1],
       [0, 0, 0, 1, 1],
       [0, 1, 1, 1, 1],
       [1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1]];
 
print( countZeroes(mat));
 
# This code is contributed
# by chandan_jnu
<|endoftext|>"
374,"<|endoftext|>Definition and Usage
The statistics.mean() method calculates the mean (average) of the given data set.

Tip: Mean = add up all the given values, then divide by how many values there are.:# Import statistics Library
import statistics

# Calculate average values
print(statistics.mean([1, 3, 5, 7, 9, 11, 13]))
print(statistics.mean([1, 3, 5, 7, 9, 11]))
print(statistics.mean([-11, 5.5, -3.4, 7.1, -9, 22]))<|endoftext|>"
375,"<|endoftext|>When two numbers are added together, the strange Lunar arithmetic is used on the Moon. The Lunar sum of two numbers is not determined by the sum of their individual digits, but by the highest digit of the two taken into account at each step, in columnar form.

2  4  6  +
3  1  7  =
--------
3  4  7

# 3 > 2 | 4 > 1 | 7 > 6

1  3  4  +
   5  4  =
--------
1  5  4

#  1 > 0 | 5 > 3 | 4 == 4
# Blank spots in the columnar form are equals to 0

   2  0  +
1  4  0  =
-------
1  4  0

# 1 > 0 | 4 > 2 | 0 == 0
Given two positive integers number1 and number2, implement a function that returns their sum as a new integer.

Examples
lunar_sum(246, 317) ➞ 347

lunar_sum(134, 54) ➞ 154

lunar_sum(20, 140) ➞ 140
Notes
The given numbers will be always positive integers: no exceptions to handle.:def lunar_sum(num1, num2):
  s = str(num1)
  t = str(num2)
  m = max(len(s), len(t))
  s = s.rjust(m,'0')
  t = t.rjust(m,'0')
  return int(''.join(max(z) for z in zip(s,t)))<|endoftext|>"
376,"<|endoftext|>A given array represents a tree in such a way that the array value gives the parent node of that particular index. The value of the root node index would always be -1. Find the height of the tree. 
The height of a Binary Tree is the number of nodes on the path from the root to the deepest leaf node, and the number includes both root and leaf. 
 

Input: parent[] = {1 5 5 2 2 -1 3}
Output: 4
The given array represents following Binary Tree 
         5
        /  \
       1    2
      /    / \
     0    3   4
         /
        6 


Input: parent[] = {-1, 0, 0, 1, 1, 3, 5};
Output: 5
The given array represents following Binary Tree 
         0
       /   \
      1     2
     / \
    3   4
   /
  5 
 /
6:# Python program to find height using parent array

# This functio fills depth of i'th element in parent[]
# The depth is filled in depth[i]


def fillDepth(parent, i, depth):

	# If depth[i] is already filled
	if depth[i] != 0:
		return

	# If node at index i is root
	if parent[i] == -1:
		depth[i] = 1
		return

	# If depth of parent is not evaluated before,
	# then evaluate depth of parent first
	if depth[parent[i]] == 0:
		fillDepth(parent, parent[i], depth)

	# Depth of this node is depth of parent plus 1
	depth[i] = depth[parent[i]] + 1

# This function returns height of binary tree represented
# by parent array


def findHeight(parent):
	n = len(parent)
	# Create an array to store depth of all nodes and
	# initialize depth of every node as 0
	# Depth of root is 1
	depth = [0 for i in range(n)]

	# fill depth of all nodes
	for i in range(n):
		fillDepth(parent, i, depth)

	# The height of binary tree is maximum of all
	# depths. Find the maximum in depth[] and assign
	# it to ht
	ht = depth[0]
	for i in range(1, n):
		ht = max(ht, depth[i])

	return ht


# Driver program to test above function
parent = [-1, 0, 0, 1, 1, 3, 5]
print (""Height is %d"" % (findHeight(parent)))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
<|endoftext|>"
377,"<|endoftext|>Write a function to print spiral order traversal of a tree. For below tree, function should print 1, 2, 3, 4, 5, 6, 7. :# Python3 program for recursive level order
# traversal in spiral form

class newNode:

	# Construct to create a newNode
	def __init__(self, key):
		self.data = key
		self.left = None
		self.right = None

"""""" Function to print spiral traversal of a tree""""""
def printSpiral(root):

	h = height(root)
	
	""""""ltr Left to Right. If this variable
	is set, then the given level is traversed
	from left to right. """"""
	ltr = False
	for i in range(1, h + 1):
	
		printGivenLevel(root, i, ltr)

		""""""Revert ltr to traverse next level
		in opposite order""""""
		ltr = not ltr
	
"""""" Print nodes at a given level """"""
def printGivenLevel(root, level, ltr):

	if(root == None):
		return
	if(level == 1):
		print(root.data, end = "" "")
	elif (level > 1):
	
		if(ltr):
			printGivenLevel(root.left, level - 1, ltr)
			printGivenLevel(root.right, level - 1, ltr)
		
		else:
			printGivenLevel(root.right, level - 1, ltr)
			printGivenLevel(root.left, level - 1, ltr)
		
"""""" Compute the ""height"" of a tree -- the number of
	nodes along the longest path from the root node
	down to the farthest leaf node.""""""
def height(node):

	if (node == None):
		return 0
	else:
	
		"""""" compute the height of each subtree """"""
		lheight = height(node.left)
		rheight = height(node.right)

		"""""" use the larger one """"""
		if (lheight > rheight):
			return(lheight + 1)
		else:
			return(rheight + 1)
	
# Driver Code
if __name__ == '__main__':
	root = newNode(1)
	root.left = newNode(2)
	root.right = newNode(3)
	root.left.left = newNode(7)
	root.left.right = newNode(6)
	root.right.left = newNode(5)
	root.right.right = newNode(4)
	print(""Spiral Order traversal of binary tree is"")
	printSpiral(root)
	
# This code is contributed
# by SHUBHAMSINGH10<|endoftext|>"
378,"<|endoftext|>Reverse a string

For example: input: ""cool"" output: ""looc""
:
def reverse(input=''):
    return str(input)[::-1]<|endoftext|>"
379,"<|endoftext|>In the previous article, we have discussed Python Program to Count Minimum Bits to Flip such that XOR of A and B Equal to C
 Given a number n, the task is to toggle the last m bits of the given number in its binary representation.
 Toggling: 
 A toggling operation changes the value of a bit from 0 to 1 and from 1 to 0.
 let Given number =30 m=3
 The binary representation of 30=11110
 Binary representation after toggling the last 3 bits is =11001
 Decimal equivalent after toggling =25
 Examples:
 Example1:
 Input:
 Given Number = 30
 
 Given m value = 3
 Output:
 The given number{ 30 } after toggling the given last m { 3 } bits = 25
 Example2:
 Input:
 Given Number = 45
 
 Given m value = 2
 Output:
 The given number{ 45 } after toggling the given last m { 2 } bits = 46:# Create a function to say toglng_lstmbits which takes the given number, m value as the
 
 # arguments and returns the number after toggling the given last m bits.
 
 
 
 
 
 def toglng_lstmbits(gvn_numb, m):
 
  # Apply the left shift operator to 1 and the above-given m value and subtract 1 from it.
 
  # Store it in another variable.
 
  fnl_numbr = (1 &lt;&lt; m) - 1
 
  # Return the XOR value of the given number and the above result.
 
  return (gvn_numb ^ fnl_numbr)
 
 
 
 
 
 # Give the number as static input and store it in a variable.
 
 gvn_numb = 30
 
 # Give the value of m as static input and store it in another variable.
 
 m = 3
 
 # Pass the given number, m value as the arguments to the toglng_lstmbits function.
 
 # Print the number after toggling the given last m bits.
 
 print(""The given number{"", gvn_numb, ""} after toggling the given last m {"",
 
  m, ""} bits = "", toglng_lstmbits(gvn_numb, m))
 
 </pre><|endoftext|>"
380,"<|endoftext|>Write a function that takes a list and a number as arguments. Add the number to the end of the list, then remove the first element of the list. The function should then return the updated list.
Examples
next_in_line([5, 6, 7, 8, 9], 1) ➞ [6, 7, 8, 9, 1]

next_in_line([7, 6, 3, 23, 17], 10) ➞ [6, 3, 23, 17, 10]

next_in_line([1, 10, 20, 42 ], 6) ➞ [10, 20, 42, 6]

next_in_line([], 6) ➞ ""No list has been selected""
Notes
For an empty list input, return: ""No list has been selected"":def next_in_line(lst, num):
  return lst[1:] + [num] if lst else ""No list has been selected""<|endoftext|>"
381,"<|endoftext|>Given two sorted arrays of size m and n of distinct elements. Given a value x. The problem is to count all pairs from both arrays whose sum is equal to x. 
Note: The pair has an element from each array.
Examples : 
 

Input : arr1[] = {1, 3, 5, 7}
        arr2[] = {2, 3, 5, 8}
        x = 10

Output : 2
The pairs are:
(5, 5) and (7, 3)

Input : arr1[] = {1, 2, 3, 4, 5, 7, 11} 
        arr2[] = {2, 3, 4, 5, 6, 8, 12} 
        x = 9

Output : 5:# python implementation to count
# pairs from both sorted arrays
# whose sum is equal to a given
# value

# function to count all pairs from
# both the sorted arrays whose sum
# is equal to a given value
def countPairs(arr1, arr2, m, n, x):
	count = 0

	# generating pairs from both
	# the arrays
	for i in range(m):
		for j in range(n):

			# if sum of pair is equal
			# to 'x' increment count
			if arr1[i] + arr2[j] == x:
				count = count + 1

	# required count of pairs
	return count

# Driver Program
arr1 = [1, 3, 5, 7]
arr2 = [2, 3, 5, 8]
m = len(arr1)
n = len(arr2)
x = 10
print(""Count = "",
		countPairs(arr1, arr2, m, n, x))

# This code is contributed by Shrikant13.<|endoftext|>"
382,"<|endoftext|>Infix expression: The expression of the form a op b. When an operator is in-between every pair of operands.
Postfix expression: The expression of the form a b op. When an operator is followed for every pair of operands.
Why postfix representation of the expression? 
The compiler scans the expression either from left to right or from right to left. 
Consider the below expression: a op1 b op2 c op3 d 
If op1 = +, op2 = *, op3 = +
The compiler first scans the expression to evaluate the expression b * c, then again scans the expression to add a to it. The result is then added to d after another scan.
The repeated scanning makes it very in-efficient. It is better to convert the expression to postfix(or prefix) form before evaluation.
The corresponding expression in postfix form is abc*+d+. The postfix expressions can be evaluated easily using a stack. We will cover postfix expression evaluation in a separate post.:# Python program to convert infix expression to postfix

# Class to convert the expression


class Conversion:

        # Constructor to initialize the class variables
        def __init__(self, capacity):
                self.top = -1
                self.capacity = capacity
                # This array is used a stack
                self.array = []
                # Precedence setting
                self.output = []
                self.precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}

        # check if the stack is empty
        def isEmpty(self):
                return True if self.top == -1 else False

        # Return the value of the top of the stack
        def peek(self):
                return self.array[-1]

        # Pop the element from the stack
        def pop(self):
                if not self.isEmpty():
                        self.top -= 1
                        return self.array.pop()
                else:
                        return ""$""

        # Push the element to the stack
        def push(self, op):
                self.top += 1
                self.array.append(op)

        # A utility function to check is the given character
        # is operand
        def isOperand(self, ch):
                return ch.isalpha()

        # Check if the precedence of operator is strictly
        # less than top of stack or not
        def notGreater(self, i):
                try:
                        a = self.precedence[i]
                        b = self.precedence[self.peek()]
                        return True if a <= b else False
                except KeyError:
                        return False

        # The main function that
        # converts given infix expression
        # to postfix expression
        def infixToPostfix(self, exp):

                # Iterate over the expression for conversion
                for i in exp:
                        # If the character is an operand,
                        # add it to output
                        if self.isOperand(i):
                                self.output.append(i)

                        # If the character is an '(', push it to stack
                        elif i == '(':
                                self.push(i)

                        # If the scanned character is an ')', pop and
                        # output from the stack until and '(' is found
                        elif i == ')':
                                while((not self.isEmpty()) and
                                        self.peek() != '('):
                                        a = self.pop()
                                        self.output.append(a)
                                if (not self.isEmpty() and self.peek() != '('):
                                        return -1
                                else:
                                        self.pop()

                        # An operator is encountered
                        else:
                                while(not self.isEmpty() and self.notGreater(i)):
                                                # this is to pass cases like a^b^c
                                        # without if ab^c^
                                        # with if abc^^
                                        if i == ""^"" and self.array[-1] == i:
                                                break
                                        self.output.append(self.pop())
                                self.push(i)

                # pop all the operator from the stack
                while not self.isEmpty():
                        self.output.append(self.pop())

                print """".join(self.output)


# Driver program to test above function
exp = ""a+b*(c^d-e)^(f+g*h)-i""
obj = Conversion(len(exp))
obj.infixToPostfix(exp)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
<|endoftext|>"
383,"<|endoftext|>Design a stack which supports the following operations.

Implement the CustomStack class:

CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack or do nothing if the stack reached the maxSize.
void push(int x) Adds x to the top of the stack if the stack hasn't reached the maxSize.
int pop() Pops and returns the top of stack or -1 if the stack is empty.
void inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, just increment all the elements in the stack.
 

Example 1:

Input
[""CustomStack"",""push"",""push"",""pop"",""push"",""push"",""push"",""increment"",""increment"",""pop"",""pop"",""pop"",""pop""]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
Output
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
Explanation
CustomStack customStack = new CustomStack(3); // Stack is Empty []
customStack.push(1);  // stack becomes [1]
customStack.push(2);  // stack becomes [1, 2]
customStack.pop();  // return 2 --> Return top of the stack 2, stack becomes [1]
customStack.push(2);  // stack becomes [1, 2]
customStack.push(3);  // stack becomes [1, 2, 3]
customStack.push(4);  // stack still [1, 2, 3], Don't add another elements as size is 4
customStack.increment(5, 100);  // stack becomes [101, 102, 103]
customStack.increment(2, 100);  // stack becomes [201, 202, 103]
customStack.pop();  // return 103 --> Return top of the stack 103, stack becomes [201, 202]
customStack.pop();  // return 202 --> Return top of the stack 102, stack becomes [201]
customStack.pop();  // return 201 --> Return top of the stack 101, stack becomes []
customStack.pop();  // return -1 --> Stack is empty return -1.
 

Constraints:

1 <= maxSize <= 1000
1 <= x <= 1000
1 <= k <= 1000
0 <= val <= 100
At most 1000 calls will be made to each method of increment, push and pop each separately.:def __init__(self, maxSize):
  self.n = maxSize
  self.stack = []
  self.inc = []

  def push(self, x):
  if len(self.inc) < self.n:
  self.stack.append(x)
  self.inc.append(0)

  def pop(self):
  if not self.inc: return -1
  if len(self.inc) > 1:
  self.inc[-2] += self.inc[-1]
  return self.stack.pop() + self.inc.pop()

  def increment(self, k, val):
  if self.inc:
  self.inc[min(k, len(self.inc)) - 1] += val<|endoftext|>"
384,"<|endoftext|>A binary search tree (BST) is a node based binary tree data structure which has the following properties. 
The left subtree of a node contains only nodes with keys less than the node’s key.
The right subtree of a node contains only nodes with keys greater than the node’s key.
Both the left and right subtrees must also be binary search trees.:def isBST(node):
    if (node == None):
        return 1
         
    ''' false if left is > than node '''
    if (node.left != None and node.left.data > node.data):
        return 0
     
    ''' false if right is < than node '''
    if (node.right != None and node.right.data < node.data):
        return 0
     
    ''' false if, recursively, the left or right is not a BST '''
    if (!isBST(node.left) or !isBST(node.right)):
        return 0
     
    ''' passing all that, it's a BST '''
    return 1
     
# This code is contributed by Shubham Singh
''' Returns true if a binary tree is a binary search tree '''
def isBST(node):
	if (node == None):
		return 1
	''' false if the max of the left is > than us '''
	if (node.left != None and maxValue(node.left) >= node.data):
		return 0
	
	''' false if the min of the right is <= than us '''
	if (node.right != None and minValue(node.right) <= node.data):
		return 0
	
	''' false if, recursively, the left or right is not a BST '''
	if (!isBST(node.left) or !isBST(node.right)):
		return 0
	
	''' passing all that, it's a BST '''
	return 1
	
# This code is contributed by Shubham Singh
# Python program to check if a binary tree is bst or not

INT_MAX = 4294967296
INT_MIN = -4294967296

# A binary tree node
class Node:

	# Constructor to create a new node
	def __init__(self, data):
		self.data = data
		self.left = None
		self.right = None


# Returns true if the given tree is a binary search tree
# (efficient version)
def isBST(node):
	return (isBSTUtil(node, INT_MIN, INT_MAX))

# Retusn true if the given tree is a BST and its values
# >= min and <= max
def isBSTUtil(node, mini, maxi):
	
	# An empty tree is BST
	if node is None:
		return True

	# False if this node violates min/max constraint
	if node.data < mini or node.data > maxi:
		return False

	# Otherwise check the subtrees recursively
	# tightening the min or max constraint
	return (isBSTUtil(node.left, mini, node.data -1) and
		isBSTUtil(node.right, node.data+1, maxi))

# Driver program to test above function
root = Node(4)
root.left = Node(2)
root.right = Node(5)
root.left.left = Node(1)
root.left.right = Node(3)

if (isBST(root)):
	print (""Is BST"")
else:
	print (""Not a BST"")

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
"""""" Program to check if a given Binary
Tree is balanced like a Red-Black Tree """"""

# Helper function that allocates a new
# node with the given data and None
# left and right poers.								
class newNode:

	# Construct to create a new node
	def __init__(self, key):
		self.data = key
		self.left = None
		self.right = None

# Returns true if given tree is BST.
def isBST(root, l = None, r = None):

	# Base condition
	if (root == None) :
		return True

	# if left node exist then check it has
	# correct data or not i.e. left node's data
	# should be less than root's data
	if (l != None and root.data <= l.data) :
		return False

	# if right node exist then check it has
	# correct data or not i.e. right node's data
	# should be greater than root's data
	if (r != None and root.data >= r.data) :
		return False

	# check recursively for every node.
	return isBST(root.left, l, root) and \
		isBST(root.right, root, r)


# Driver Code
if __name__ == '__main__':
	root = newNode(3)
	root.left = newNode(2)
	root.right = newNode(5)
	root.right.left = newNode(1)
	root.right.right = newNode(4)
	#root.right.left.left = newNode(40)
	if (isBST(root,None,None)):
		print(""Is BST"")
	else:
		print(""Not a BST"")

# This code is contributed by
# Shubham Singh(SHUBHAMSINGH10)
# Python implementation to check if
# given Binary tree is a BST or not

# A binary tree node containing data
# field, left and right pointers
class Node:
	# constructor to create new node
	def __init__(self, val):
		self.data = val
		self.left = None
		self.right = None

# global variable prev - to keep track
# of previous node during Inorder
# traversal
prev = None

# function to check if given binary
# tree is BST
def isbst(root):
	
	# prev is a global variable
	global prev
	prev = None
	return isbst_rec(root)


# Helper function to test if binary
# tree is BST
# Traverse the tree in inorder fashion
# and keep track of previous node
# return true if tree is Binary
# search tree otherwise false
def isbst_rec(root):
	
	# prev is a global variable
	global prev

	# if tree is empty return true
	if root is None:
		return True

	if isbst_rec(root.left) is False:
		return False

	# if previous node'data is found
	# greater than the current node's
	# data return false
	if prev is not None and prev.data > root.data:
		return False

	# store the current node in prev
	prev = root
	return isbst_rec(root.right)


# driver code to test above function
root = Node(4)
root.left = Node(2)
root.right = Node(5)
root.left.left = Node(1)
root.left.right = Node(3)

if isbst(root):
	print(""is BST"")
else:
	print(""not a BST"")

# This code is contributed by
# Shweta Singh(shweta44)
# Python3 program to check
# if a given tree is BST.
import math

# A binary tree node has data,
# pointer to left child and
# a pointer to right child
class Node:
	def __init__(self, data):
		self.data = data
		self.left = None
		self.right = None
	
def isBSTUtil(root, prev):
	
	# traverse the tree in inorder fashion
	# and keep track of prev node
	if (root != None):
		if (isBSTUtil(root.left, prev) == True):
			return False

		# Allows only distinct valued nodes
		if (prev != None and
			root.data <= prev.data):
			return False

		prev = root
		return isBSTUtil(root.right, prev)
	
	return True

def isBST(root):
	prev = None
	return isBSTUtil(root, prev)

# Driver Code
if __name__ == '__main__':
	root = Node(3)
	root.left = Node(2)
	root.right = Node(5)
	root.right.left = Node(1)
	root.right.right = Node(4)
	#root.right.left.left = Node(40)
	
	if (isBST(root) == None):
		print(""Is BST"")
	else:
		print(""Not a BST"")

# This code is contributed by Srathore
<|endoftext|>"
385,"<|endoftext|>Given a 2D array, find the maximum sum subarray in it.:# Python3 program to find maximum sum
# subarray in a given 2D array
 
# Implementation of Kadane's algorithm
# for 1D array. The function returns the
# maximum sum and stores starting and
# ending indexes of the maximum sum subarray
# at addresses pointed by start and finish
# pointers respectively.
 
 
def kadane(arr, start, finish, n):
 
    # initialize sum, maxSum and
    Sum = 0
    maxSum = -999999999999
    i = None
 
    # Just some initial value to check
    # for all negative values case
    finish[0] = -1
 
    # local variable
    local_start = 0
 
    for i in range(n):
        Sum += arr[i]
        if Sum < 0:
            Sum = 0
            local_start = i + 1
        elif Sum > maxSum:
            maxSum = Sum
            start[0] = local_start
            finish[0] = i
 
    # There is at-least one
    # non-negative number
    if finish[0] != -1:
        return maxSum
 
    # Special Case: When all numbers
    # in arr[] are negative
    maxSum = arr[0]
    start[0] = finish[0] = 0
 
    # Find the maximum element in array
    for i in range(1, n):
        if arr[i] > maxSum:
            maxSum = arr[i]
            start[0] = finish[0] = i
    return maxSum
 
# The main function that finds maximum
# sum rectangle in M[][]
 
 
def findMaxSum(M):
    global ROW, COL
 
    # Variables to store the final output
    maxSum, finalLeft = -999999999999, None
    finalRight, finalTop, finalBottom = None, None, None
    left, right, i = None, None, None
 
    temp = [None] * ROW
    Sum = 0
    start = [0]
    finish = [0]
 
    # Set the left column
    for left in range(COL):
 
        # Initialize all elements of temp as 0
        temp = [0] * ROW
 
        # Set the right column for the left
        # column set by outer loop
        for right in range(left, COL):
 
            # Calculate sum between current left
            # and right for every row 'i'
            for i in range(ROW):
                temp[i] += M[i][right]
 
            # Find the maximum sum subarray in
            # temp[]. The kadane() function also
            # sets values of start and finish.
            # So 'sum' is sum of rectangle between
            # (start, left) and (finish, right) which
            # is the maximum sum with boundary columns
            # strictly as left and right.
            Sum = kadane(temp, start, finish, ROW)
 
            # Compare sum with maximum sum so far.
            # If sum is more, then update maxSum
            # and other output values
            if Sum > maxSum:
                maxSum = Sum
                finalLeft = left
                finalRight = right
                finalTop = start[0]
                finalBottom = finish[0]
 
    # Prfinal values
    print(""(Top, Left)"", ""("", finalTop,
          finalLeft, "")"")
    print(""(Bottom, Right)"", ""("", finalBottom,
          finalRight, "")"")
    print(""Max sum is:"", maxSum)
 
 
# Driver Code
ROW = 4
COL = 5
M = [[1, 2, -1, -4, -20],
     [-8, -3, 4, 2, 1],
     [3, 8, 10, 1, 3],
     [-4, -1, 1, 7, -6]]
 
# Function call
findMaxSum(M)
 
# This code is contributed by PranchalK<|endoftext|>"
386,"<|endoftext|>Instructions
To try and encourage more sales of different books from a popular 5 book series, a bookshop has decided to offer discounts on multiple book purchases.

One copy of any of the five books costs $8.

If, however, you buy two different books, you get a 5% discount on those two books.

If you buy 3 different books, you get a 10% discount.

If you buy 4 different books, you get a 20% discount.

If you buy all 5, you get a 25% discount.

Note: that if you buy four books, of which 3 are different titles, you get a 10% discount on the 3 that form part of a set, but the fourth book still costs $8.

Your mission is to write a piece of code to calculate the price of any conceivable shopping basket (containing only books of the same series), giving as big a discount as possible.

For example, how much does this basket of books cost?

2 copies of the first book
2 copies of the second book
2 copies of the third book
1 copy of the fourth book
1 copy of the fifth book
One way of grouping these 8 books is:

1 group of 5 --> 25% discount (1st,2nd,3rd,4th,5th)
+1 group of 3 --> 10% discount (1st,2nd,3rd)
This would give a total of:

5 books at a 25% discount
+3 books at a 10% discount
Resulting in:

5 × (8 - 2.00) = 5 × 6.00 = $30.00
+3 × (8 - 0.80) = 3 × 7.20 = $21.60
For a total of $51.60

However, a different way to group these 8 books is:

1 group of 4 books --> 20% discount (1st,2nd,3rd,4th)
+1 group of 4 books --> 20% discount (1st,2nd,3rd,5th)
This would give a total of:

4 books at a 20% discount
+4 books at a 20% discount
Resulting in:

4 × (8 - 1.60) = 4 × 6.40 = $25.60
+4 × (8 - 1.60) = 4 × 6.40 = $25.60
For a total of $51.20

And $51.20 is the price with the biggest discount.:""""""
Exercism solution for ""book-store""
""""""
import math
from collections import Counter
from decimal import Decimal
from functools import lru_cache, reduce
from typing import List, Tuple
PER_BOOK = Decimal(""800.00"")
PER_GROUP = {
    1: 1 * PER_BOOK * Decimal(""1.00""),
    2: 2 * PER_BOOK * Decimal(""0.95""),
    3: 3 * PER_BOOK * Decimal(""0.90""),
    4: 4 * PER_BOOK * Decimal(""0.80""),
    5: 5 * PER_BOOK * Decimal(""0.75""),
}
# memoize the results; cap memory and degrade performance with HUGE number of books
@lru_cache(maxsize=1024)
def _recursive_total(books: Tuple[int]) -> float:
    """"""
    Recurse to find the best discounted price for a non-empty, pre-sorted tuple of books.
    """"""
    volumes = Counter(books)
    num_books, num_volumes = len(books), len(volumes)
    # optimization 1: we only have N copies of the same volume
    if num_volumes == 1:
        return num_books * PER_BOOK
    # optimization 2: we only have 1 copy of each unique volume
    if num_books == num_volumes:
        return PER_GROUP[num_books]
    # optimization 3: we happen to have gotten counts that share a GCD > 1
    gcd = reduce(math.gcd, volumes.values())
    if gcd != 1:
        minimal = Counter({k: v // gcd for k, v in volumes.items()})
        minimal_books = tuple(sorted(minimal.elements()))
        return _recursive_total(minimal_books) * gcd
    # in all other cases we recurse into the groups to find the minimum discount
    price = num_books * PER_BOOK
    for num in range(num_volumes, 1, -1):
        # remove the first copy of each of the num most common volumes
        group = volumes - Counter(k for k, _ in volumes.most_common(num))
        group_books = tuple(sorted(group.elements()))
        # calculate the minimum price for the group
        price = min(price, PER_GROUP[num] + _recursive_total(group_books))
    return price
def total(books: List[int]) -> float:
    """"""
    Calculate the best discounted price for a list of books.
    """"""
    if not books:
        return 0
    return _recursive_total(tuple(sorted(books)))<|endoftext|>"
387,"<|endoftext|>I am trying to filter out empty arrays from an array. In other words, I want to transform something that looks like this: [""a"", ""b"", [], [], [1, 2, 3]] to look like [""a"", ""b"", [1, 2, 3]]. My code looks like this:
def remove_empty_arrays(arr):
    return [x for x in arr if len(x) != 0]
However, it seems that I've run into a problem, with an error message of object of type 'int' has no len(). Fix my code so that all tests pass.
Examples
# What I want:
remove_empty_arrays([1, 2, [], 4]) ➞ [1, 2, 4]

# What I am getting:
ERROR: Traceback:
   in <module>
   in remove_empty_arrays
   in <listcomp>
TypeError: object of type 'int' has no len()
Notes
N/A:def remove_empty_arrays(arr):
    return [x for x in arr if x != []]<|endoftext|>"
388,"<|endoftext|>Given a stack, sort it using recursion. Use of any loop constructs like while, for..etc is not allowed. We can only use the following ADT functions on Stack S: 

is_empty(S)  : Tests whether stack is empty or not.
push(S)         : Adds new element to the stack.
pop(S)         : Removes top element from the stack.
top(S)         : Returns value of the top element. Note that this
               function does not remove element from the stack.:# Python program to sort a stack using recursion

# Recursive method to insert element in sorted way


def sortedInsert(s, element):

        # Base case: Either stack is empty or newly inserted
        # item is greater than top (more than all existing)
        if len(s) == 0 or element > s[-1]:
                s.append(element)
                return
        else:

                # Remove the top item and recur
                temp = s.pop()
                sortedInsert(s, element)

                # Put back the top item removed earlier
                s.append(temp)

# Method to sort stack


def sortStack(s):

        # If stack is not empty
        if len(s) != 0:

                # Remove the top item
                temp = s.pop()

                # Sort remaining stack
                sortStack(s)

                # Push the top item back in sorted stack
                sortedInsert(s, temp)

# Printing contents of stack


def printStack(s):
        for i in s[::-1]:
                print(i, end="" "")
        print()


# Driver Code
if __name__ == '__main__':
        s = []
        s.append(30)
        s.append(-5)
        s.append(18)
        s.append(14)
        s.append(-3)

        print(""Stack elements before sorting: "")
        printStack(s)

        sortStack(s)

        print(""\nStack elements after sorting: "")
        printStack(s)

# This code is contributed by Muskan Kalra.
<|endoftext|>"
389,"<|endoftext|>Alice and Bob take turns playing a game, with Alice starting first.

You are given a string num of even length consisting of digits and '?' characters. On each turn, a player will do the following if there is still at least one '?' in num:

Choose an index i where num[i] == '?'.
Replace num[i] with any digit between '0' and '9'.
The game ends when there are no more '?' characters in num.

For Bob to win, the sum of the digits in the first half of num must be equal to the sum of the digits in the second half. For Alice to win, the sums must not be equal.

For example, if the game ended with num = ""243801"", then Bob wins because 2+4+3 = 8+0+1. If the game ended with num = ""243803"", then Alice wins because 2+4+3 != 8+0+3.
Assuming Alice and Bob play optimally, return true if Alice will win and false if Bob will win.

 :class Solution:
    def sumGame(self, num: str) -> bool:
        lf_qst, rt_qst = num[: len(num) // 2].count('?'), num[len(num) // 2:].count('?')
        lf_sum, rt_sum = sum([int(num[i]) for i in range(len(num) // 2) if num[i] != '?']), sum([int(num[i]) for i in range(len(num) // 2, len(num)) if num[i] != '?'])
        
        if lf_qst == rt_qst: return lf_sum != rt_sum
        if lf_sum == rt_sum: return lf_qst != rt_qst
        if lf_qst > rt_qst and lf_sum > rt_sum or lf_qst < rt_qst and lf_sum < rt_sum: return True
        
        q_diff, n_diff = abs(lf_qst - rt_qst), abs(lf_sum - rt_sum)
        
        if q_diff % 2 == 1: return True
        
        return q_diff // 2 * 9 != n_diff<|endoftext|>"
390,"<|endoftext|>You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].
The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.
Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.
 
Example 1:


Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20
Explanation: 

We can connect the points as shown above to get the minimum cost of 20.
Notice that there is a unique path between every pair of points.

Example 2:

Input: points = [[3,12],[-2,5],[-4,1]]
Output: 18

 
Constraints:

1 <= points.length <= 1000
-106 <= xi, yi <= 106
All pairs (xi, yi) are distinct.:class Solution:
  def minCostConnectPoints(self, points: List[List[int]]) -> int:
  manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])
  n, c = len(points), collections.defaultdict(list)
  for i in range(n):
  for j in range(i+1, n):
  d = manhattan(points[i], points[j])
  c[i].append((d, j))
  c[j].append((d, i))
  cnt, ans, visited, heap = 1, 0, [0] * n, c[0]
  visited[0] = 1
  heapq.heapify(heap)
  while heap:
  d, j = heapq.heappop(heap)
  if not visited[j]:
  visited[j], cnt, ans = 1, cnt+1, ans+d
  for record in c[j]: heapq.heappush(heap, record)
  if cnt >= n: break  
  return ans<|endoftext|>"
391,"<|endoftext|>1)Quadratic Equation

Quadratics or quadratic equations are polynomial equations of the second degree, which means that they contain at least one squared word.

ax2 + bx + c = 0

where x is an unknown variable and the numerical coefficients a , b , c.

2)Discriminant value

Discriminant = b ^ 2 - 4 * a *c
Based on the value of discriminant there are three types of roots for Quadratic Equation

3)Calculating roots of Quadratic Equation

roots = ( -b + sqrt(b ^ 2 - 4 * a *c) ) / (2 * a)  , ( -b - sqrt(b ^ 2 - 4 * a *c) ) / (2 * a)
Where sqrt is square root.:# importing cmath
 import cmath
 # given a,b,c values
 a = 2
 b = -7
 c = 6
 discriminant = (b**2) - (4*a*c)
 # checking if the value of discriminant is greater than 0
 if(discriminant > 0):
  # here exist the two distinct roots and we print them
  # calculating the roots
  root1 = (-b+discriminant) / (2 * a)
  root2 = (-b-discriminant) / (2 * a)
  # printing the roots
  print(""The two distinct roots are : "")
  print(root1)
  print(root2)
 # checking if the value of discriminant is equal to 0
 elif(discriminant == 0):
  # here exist the two equal roots
  # calculating single root here discriminant is 0 so we dont need to write full formulae
  root = (-b)/(2*a)
  # printing the root
  print(""The two equal roots are : "")
  print(root, root)
 # else there exists complex roots
 else:
  # here exist the two complex roots
  # calculating complex roots
  realpart = -b/(2*a)
  complexpart = discriminant/(2*a)*(-1)
  # printing the roots
  print(""There exists two complex roots:"")
  print(realpart, ""+"", complexpart, ""i"")
  print(realpart, ""-"", complexpart, ""i"")<|endoftext|>"
392,"<|endoftext|>Given a graph and a source vertex src in graph, find shortest paths from src to all vertices in the given graph. The graph may contain negative weight edges. :# Python3 program for Bellman-Ford's single source
# shortest path algorithm.
 
# Class to represent a graph
class Graph:
 
    def __init__(self, vertices):
        self.V = vertices # No. of vertices
        self.graph = []
 
    # function to add an edge to graph
    def addEdge(self, u, v, w):
        self.graph.append([u, v, w])
         
    # utility function used to print the solution
    def printArr(self, dist):
        print(""Vertex Distance from Source"")
        for i in range(self.V):
            print(""{0}\t\t{1}"".format(i, dist[i]))
     
    # The main function that finds shortest distances from src to
    # all other vertices using Bellman-Ford algorithm. The function
    # also detects negative weight cycle
    def BellmanFord(self, src):
 
        # Step 1: Initialize distances from src to all other vertices
        # as INFINITE
        dist = [float(""Inf"")] * self.V
        dist[src] = 0
 
 
        # Step 2: Relax all edges |V| - 1 times. A simple shortest
        # path from src to any other vertex can have at-most |V| - 1
        # edges
        for _ in range(self.V - 1):
            # Update dist value and parent index of the adjacent vertices of
            # the picked vertex. Consider only those vertices which are still in
            # queue
            for u, v, w in self.graph:
                if dist[u] != float(""Inf"") and dist[u] + w < dist[v]:
                        dist[v] = dist[u] + w
 
        # Step 3: check for negative-weight cycles. The above step
        # guarantees shortest distances if graph doesn't contain
        # negative weight cycle. If we get a shorter path, then there
        # is a cycle.
 
        for u, v, w in self.graph:
                if dist[u] != float(""Inf"") and dist[u] + w < dist[v]:
                        print(""Graph contains negative weight cycle"")
                        return
                         
        # print all distance
        self.printArr(dist)
 
g = Graph(5)
g.addEdge(0, 1, -1)
g.addEdge(0, 2, 4)
g.addEdge(1, 2, 3)
g.addEdge(1, 3, 2)
g.addEdge(1, 4, 2)
g.addEdge(3, 2, 5)
g.addEdge(3, 1, 1)
g.addEdge(4, 3, -3)
 
# Print the solution
g.BellmanFord(0)
 
# Initially, Contributed by Neelam Yadav
# Later On, Edited by Himanshu Garg<|endoftext|>"
393,"<|endoftext|>Given the radius of a circle and the area of a square, return True if the circumference of the circle is greater than the square's perimeter and False if the square's perimeter is greater than the circumference of the circle.
Examples
circle_or_square(16, 625) ➞ True

circle_or_square(5, 100) ➞ False

circle_or_square(8, 144) ➞ True
Notes
You can use Pi to 2 decimal places (3.14).
Circumference of a circle equals 2 * Pi * radius.
To find the perimeter of a square using its area, find the square root of area (to get side length) and multiply that by 4.:def circle_or_square(r, s):
  return 1.57*r > s**0.5<|endoftext|>"
394,"<|endoftext|>Given a list, the task is to find the minimum operations needed to make all the elements of the given list equal in Python:# Import the Counter() function from collections using the import keyword.
from collections import Counter
# Give the list as static input and store it in a variable.
givnlst = [11, 3, 7, 1, 2, 7, 3, 6, 7, 9, 3, 9, 1, 19]
# Calculate the frequency of all the given list
# elements using the Counter() function which returns
# the element and its frequency as key-value pair and
# store this dictionary in a variable(say freqyValues)
freqncyValues = Counter(givnlst)
# Calculate the max value of the freqyValues using values()
# and max() function and store it in a variable(say mxfrqncyval)
mxfrqncyval = max(freqncyValues.values())
# Calculate the length of the given list using the len() function
# and store it in a variable.
lstlengt = len(givnlst)
# Subtract the mxfrqncyval from the length of the given list.
minresul = lstlengt-mxfrqncyval
print('The minimum operations to make all the elements of the given list',
      givnlst, 'equal is:')
print('[', minresul, ']')<|endoftext|>"
395,"<|endoftext|>In this program, you'll learn to sort the words in alphabetic order using for loop and display it.:# Program to sort alphabetically the words form a string provided by the user

my_str = ""Hello this Is an Example With cased letters""

# To take input from the user
#my_str = input(""Enter a string: "")

# breakdown the string into a list of words
words = [word.lower() for word in my_str.split()]

# sort the list
words.sort()

# display the sorted words

print(""The sorted words are:"")
for word in words:
   print(word)<|endoftext|>"
396,"<|endoftext|>Given the list of numbers, the task is to count the Numbers which doesn’t contain Digit 3 in them.
 Examples:
 Example1:
 Input:
 Given list =[125, 94, 32, 138, 349, 5783, 12394297, 975686138, 3589295]
 Output:
 The Count of numbers that doesnt contain three in the given list [125, 94, 32, 138, 349, 5783, 12394297, 
 
 975686138, 3589295] is [ 2 ]
 Example2:
 Input:
 Given list =[2949, 1358, 927482, 6582913, 19, 24, 123, 56723, 194]
 Output:
 The Count of numbers that doesnt contain three in the given list [2949, 1358, 927482, 6582913, 19, 24, 123, 
 
 56723, 194] is [ 5 ]:# Give the list as static input and store it in a variable.
 
 lstnmbs = [2949, 1358, 927482, 6582913, 19, 24, 123, 56723, 194]
 
 # Take a variable that stores the count of numbers
 
 # that doesn't contain digit 3 in them(say cunt)
 
 cunt = 0
 
 # Traverse the given list using For loop.
 
 for numbr in lstnmbs:
 
  # Convert the list element to a string and store it in a variable.
 
  strnumbr = str(numbr)
 
  # Check if this string contains digit 3 in it using not in operator and If statement.
 
  if '3' not in strnumbr:
 
  # If it is true then increment the cunt by 1.
 
  cunt = cunt+1
 
 # Print the cunt value.
 
 print('The Count of numbers that doesnt contain three in the given list',
 
  lstnmbs, 'is [', cunt, ']')<|endoftext|>"
397,"<|endoftext|>You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:

1 which means a street connecting the left cell and the right cell.
2 which means a street connecting the upper cell and the lower cell.
3 which means a street connecting the left cell and the lower cell.
4 which means a street connecting the right cell and the lower cell.
5 which means a street connecting the left cell and the upper cell.
6 which means a street connecting the right cell and the upper cell.

You will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.

Notice that you are not allowed to change any street.

Return true if there is a valid path in the grid or false otherwise.

 

Example 1:


Input: grid = [[2,4,3],[6,5,2]]
Output: true
Explanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).
Example 2:


Input: grid = [[1,2,1],[1,2,1]]
Output: false
Explanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)
Example 3:

Input: grid = [[1,1,2]]
Output: false
Explanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 300
1 <= grid[i][j] <= 6:def hasValidPath(self, A):
  m, n = len(A), len(A[0])
  uf = {(i, j): (i, j) for i in xrange(-1, m * 2) for j in xrange(-1, n * 2)}

  def find(x):
  if uf[x] != x:
  uf[x] = find(uf[x])
  return uf[x]

  def merge(i, j, di, dj):
  uf[find((i, j))] = find((i + di, j + dj))

  for i in xrange(m):
  for j in xrange(n):
  if A[i][j] in [2, 5, 6]: merge(i * 2, j * 2, -1, 0)
  if A[i][j] in [1, 3, 5]: merge(i * 2, j * 2, 0, -1)
  if A[i][j] in [2, 3, 4]: merge(i * 2, j * 2, 1, 0)
  if A[i][j] in [1, 4, 6]: merge(i * 2, j * 2, 0, 1)
  return find((0, 0)) == find((m * 2 - 2, n * 2 - 2))<|endoftext|>"
398,"<|endoftext|>Dictionaries in Python:

In Python, a dictionary dict is a one-to-one mapping; it includes a set of (key, value) pairs, with each key mapped to a value. It exemplifies a hash map or hash table (from Computer Science).

Each key denotes a value and is separated by a colon (:).



Curly brackets are used to define a dictionary. The value to the left of the colon is known as the key, while the value to the right of the colon is known as the value. A comma separates each (key, value) pair.

Example:

Example1:

Input:

Enter some random key = aplustopper
Enter some random value of integer type = 2451
Output:

The dictionary after adding the key = aplustopper and value element = 2451 is : 
{'aplustopper': 2451}
Example2:

Input:

Enter some random key = 752
Enter some random value of integer type = 251
Output:

The dictionary after adding the key = 752 and value element = 251 is : 
{752: 251}
Example3:

Input:

Enter some random key = 234
Enter some random value of string type = btechgeeks
Output:

The dictionary after adding the key = 234 and value element = btechgeeks is : 
{234: 'btechgeeks'}:# given some random key
keyelement = input(""Enter some random key = "")
# given some random value of int datatype
valueelement = int(input(""Enter some random value of integer type = ""))
# Declare a dictionary and set its initial value to empty using {} or dict()
sampledictionary = {}
# To add the key-value pair to the dictionary, use the update() function.
sampledictionary.update({keyelement: valueelement})
# The Modified dictionary is printed
print(""The dictionary after adding the key ="", keyelement,
  ""and value element ="", valueelement, "" is : "")
print(sampledictionary)<|endoftext|>"
399,"<|endoftext|>The task is to remove spaces from a sentence and rewrite it in the Snake case. It is a writing style in which spaces are replaced with underscores and all words begin with small letters.:# Give the string/sentence as user input using the input() function
# and store it in a variable.
gvn_strng = input(""Enter some random string= "")
# Calculate the length of the given string using the len() function and
# store it in another variable.
str_lengt = len(gvn_strng)
# Convert the given string into a list of characters using the list() function and
# store it in another variable say lst_strng.
lst_strng = list(gvn_strng)
# Iterate up to the length of the given string using the for loop.
print(""The given sentence {"", gvn_strng,
      ""} after Converting into Snake case :"")
for itr in range(str_lengt):
 # Check if the element of the list of characters ( lst_strng ) is equal to space ( ' ' )
    # using the if conditional statement.
    if (lst_strng[itr] == ' '):
      # If the statement is true, then replace the space with the underscore( _ ).
        lst_strng[itr] = '_'
    else:
        # If the statement is false, then convert the elements of the list of characters ( lst_strng )
        # into lower case using the lower() function.
        lst_strng[itr] = lst_strng[itr].lower()
# Convert the above list lst_strng into the string using the join function.
# Store it in the same variable lst_strng.
lst_strng = """".join(lst_strng)
# Print the lst_strng to remove spaces from a given sentence and rewrite it in the
# Snake case.
print(lst_strng)<|endoftext|>"
400,"<|endoftext|>Print unique rows in a given binary ,atrix:
# Given a binary matrix of M X N of
# integers, you need to return only
# unique rows of binary array
ROW = 4
COL = 5
 
# The main function that prints
# all unique rows in a given matrix.
def findUniqueRows(M):
     
    # Traverse through the matrix
    for i in range(ROW):
        flag = 0
 
        # Check if there is similar column
        # is already printed, i.e if i and
        # jth column match.
        for j in range(i):
            flag = 1
 
            for k in range(COL):
                if (M[i][k] != M[j][k]):
                    flag = 0
 
            if (flag == 1):
                break
 
        # If no row is similar
        if (flag == 0):
             
            # Print the row
            for j in range(COL):
                print(M[i][j], end = "" "")
                 
            print()   
 
# Driver Code
if __name__ == '__main__':
     
    M = [ [ 0, 1, 0, 0, 1 ],
          [ 1, 0, 1, 1, 0 ],
          [ 0, 1, 0, 0, 1 ],
          [ 1, 0, 1, 0, 0 ] ]
 
    findUniqueRows(M)
 
# This code is contributed by mohit kumar 29<|endoftext|>"
401,"<|endoftext|>Given a polynomial of the form cnxn + cn-1xn-1 + cn-2xn-2 + … + c1x + c0 and a value of x, find the value of polynomial for a given value of x. Here cn, cn-1, .. are integers (may be negative) and n is a positive integer.
Input is in the form of an array say poly[] where poly[0] represents coefficient for xn and poly[1] represents coefficient for xn-1 and so on.
Examples: 

// Evaluate value of 2x3 - 6x2 + 2x - 1 for x = 3
Input: poly[] = {2, -6, 2, -1}, x = 3
Output: 5

// Evaluate value of 2x3 + 3x + 1 for x = 2
Input: poly[] = {2, 0, 3, 1}, x = 2
Output: 23:# Python program for
# implementation of Horner Method
# for Polynomial Evaluation

# returns value of poly[0]x(n-1)
# + poly[1]x(n-2) + .. + poly[n-1]
def horner(poly, n, x):

	# Initialize result
	result = poly[0]

	# Evaluate value of polynomial
	# using Horner's method
	for i in range(1, n):

		result = result*x + poly[i]

	return result

# Driver program to
# test above function.

# Let us evaluate value of
# 2x3 - 6x2 + 2x - 1 for x = 3
poly = [2, -6, 2, -1]
x = 3
n = len(poly)

print(""Value of polynomial is "" , horner(poly, n, x))

# This code is contributed
# by Anant Agarwal.<|endoftext|>"
402,"<|endoftext|>Files in Python:

Python file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python’s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.

File readlines() Method in Python:

The readlines() method returns a list with each line in the file represented as a list item.

To limit the number of lines returned, use the length parameter. No additional lines are returned if the total number of bytes returned exceeds the specified number.

Syntax:

file.readlines(length)
Parameters

length: This is optional. No additional lines will be returned if the number of bytes returned exceeds the length number. The default value is -1, which means that all lines are returned.

Return Value:

This method’s return type is <class ‘list’>, and it returns the lines as a list.:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in read mode. In this case, we're simply reading the contents of the file.
gvn_file = open(givenFilename, 'r') 
# Print all the lines of the file using the readlines() function.
print(gvn_file.readlines())
# Close the given file using the close function
gvn_file.close()<|endoftext|>"
403,"<|endoftext|>In this tutorial, we will learn how to find the ASCII value of a character and display the result.

ASCII: ASCII is an acronym that stands for American Standard Code for Information Interchange. A specific numerical value is given to different characters and symbols for computers to store and manipulate in ASCII.

It is case sensitive. The same character, having different formats (upper case and lower case), has a different value. For example, The ASCII value of ""A"" is 65 while the ASCII value of ""a"" is 97.:K = input(""Please enter a character: "")    
    
print (""The ASCII value of '"" + K + ""' is "", ord(K))  <|endoftext|>"
404,"<|endoftext|>In the previous article, we have discussed Python Program to Find Two Odd Occurring Elements in an Array/List
 The task is to check whether all characters in the given string made up entirely of lowercase letters have an even frequency.
 Counter function in Python:
 The counter is a set and dict subset. Counter() takes an iterable entity as an argument and stores the elements as keys and the frequency of the elements as a value. So, in collections, if we transfer a string. When you call Counter(), you’ll get a Counter class object with characters as keys and their frequency in a string as values.
 Counter() returns a Counter type object (a subclass of dict) with all characters in the string as keys and their occurrence count as values. We’ll use the [] operator to get the occurrence count of the characters from it.
 For example:
 let given string = “pqrspqrspp”.
 In this p occurred 4 times, q,r,s occurred 2 times.
 Therefore the frequency of all the characters in a given string is Even.
 Examples:
 Example1:
 Input:
 Given String = ""pqrspqrstutu""
 Output:
 Yes,the given string { pqrspqrstutu } contains all characters at even intervals
 Example2:
 Input:
 Given String = ""btechgeeks""
 Output:
 No,the given string { btechgeeks } does not contains all characters at even intervals:# Import the Counter() function from collections using the import keyword.
 
 from collections import Counter
 
 # Pass the given string as an argument to the function determine.
 
 
 
 
 
 def determine(gvn_strng):
 
  # Calculate the frequency of all the given string elements using the Counter() function
 
  # which returns the element and its frequency as a key-value pair and stores this
 
  # dictionary in another variable (say strngfreqelements).
 
 
 
  strngfreqelements = Counter(gvn_strng)
 
  # Traverse in this frequency dictionary using the for loop.
 
  for key in strngfreqelements:
 
  # Inside the loop, check if the Key has a value even or odd using the modulus operator
 
  # and if conditional statement.
 
  if (strngfreqelements[key] % 2 == 1):
 
  # If the statement is true, then return False.
 
  return False
 
  # Return true after the for loop.
 
  return True
 
 
 
 
 
 # Give the string as static input and store it in a variable.
 
 gvn_strng = ""pqrspqrstutu""
 
 # Check if the function returns true or false using the if conditional statement.
 
 if(determine(gvn_strng)):
 
  # If it is true, print ""yes, the given string contains all characters at even intervals"".
 
  print(""Yes,the given string {"", gvn_strng,
 
  ""} contains all characters at even intervals"")
 
 else:
 
  # Else print ""No, the given string does not contain all characters at even intervals"".
 
  print(""No,the given string {"", gvn_strng,
 
  ""} does not contains all characters at even intervals"")<|endoftext|>"
405,"<|endoftext|>Given preorder traversal of a binary search tree, construct the BST.


For example, if the given traversal is {10, 5, 1, 7, 40, 50}, then the output should be root of following tree. 


 :# Python3 program to construct BST
# from given preorder traversal
 
# A binary tree node
class Node:
 
    def __init__(self, data = 0):
        self.data = data
        self.left = None
        self.right = None
 
class BinaryTree :
 
    # The main function that constructs BST from pre[]
    def constructTree(self, pre, size):
 
        # The first element of pre[] is always root
        root = Node(pre[0])
 
        s = []
 
        # append root
        s.append(root)
 
        i = 1
 
        # Iterate through rest of the size-1
        # items of given preorder array
        while ( i < size):
            temp = None
 
            # Keep on popping while the next value
            # is greater than stack's top value.
            while (len(s) > 0 and pre[i] > s[-1].data):
                temp = s.pop()
             
            # Make this greater value as the right child
            # and append it to the stack
            if (temp != None):
                temp.right = Node(pre[i])
                s.append(temp.right)
             
            # If the next value is less than the stack's top
            # value, make this value as the left child of the
            # stack's top node. append the new node to stack
            else :
                temp = s[-1]
                temp.left = Node(pre[i])
                s.append(temp.left)
            i = i + 1
         
        return root
     
    # A utility function to print
    # inorder traversal of a Binary Tree
    def printInorder(self,node):
        if (node == None):
            return
         
        self.printInorder(node.left)
        print(node.data, end = "" "")
        self.printInorder(node.right)
 
# Driver code
tree = BinaryTree()
pre = [10, 5, 1, 7, 40, 50]
size = len(pre)
root = tree.constructTree(pre, size)
print(""Inorder traversal of the constructed tree is "")
tree.printInorder(root)
 
# This code is contributed by Arnab Kundu
<|endoftext|>"
406,"<|endoftext|>Check if a Number has Bits in Alternate Pattern Using While loop (User Input):# Create a function to say chek_alterntebit which takes the given number as an
# argument and returns true if it has an alternate bit pattern else returns False.


def chek_alterntebit(gvn_numbr):
    # Apply given number modulus 2 to get the last bit and store it in a variable.
    lst_bit = gvn_numbr % 2
    # Divide the given number by 2 and store it in the same variable gvn_numbr.
    gvn_numbr = gvn_numbr // 2
    # Loop until the given number is greater than 0 using a while loop.
    while (gvn_numbr > 0):
      # Inside the loop, calculate the current bit by applying the given number modulus 2
      # and store it in another variable.

        prsent_bit = gvn_numbr % 2
      # Check if the current bit is equal to the last bit using the if conditional
      # statement.
        if (prsent_bit == lst_bit):
          # If the statement is true, then return false.
            return False
        # Assign the current bit to the last bit.
        lst_bit = prsent_bit
        # Divide the given number by 2 and store it in the same variable gvn_numbr.
        gvn_numbr = gvn_numbr // 2
    # Return True. (out of while loop)
    return True


# Give the number as user input using the int(input()) function and store it in a variable.
gvn_numbr = int(input('Enter some random number = '))
# Pass the given number as an argument to the chek_alterntebit function.
# Check if the chek_alterntebit(gvn_numbr) using the if conditional statement.
if(chek_alterntebit(gvn_numbr)):
  # If the statement is true, print ""Yes, the given number has an alternate bit pattern"".
    print(""Yes, the given number{"", gvn_numbr,
          ""} has an alternate bit pattern"")
else:
  # Else print ""No, the given number doesn't have an alternate bit pattern"".
    print(""No, the given number{"", gvn_numbr,
          ""} doesn't have an alternate bit pattern"")<|endoftext|>"
407,"<|endoftext|>A scenic location is represented by its name and attractiveness score, where name is a unique string among all locations and score is an integer. Locations can be ranked from the best to the worst. The higher the score, the better the location. If the scores of two locations are equal, then the location with the lexicographically smaller name is better.

You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports:

Adding scenic locations, one at a time.
Querying the ith best location of all locations already added, where i is the number of times the system has been queried (including the current query).
For example, when the system is queried for the 4th time, it returns the 4th best location of all locations already added.
Note that the test data are generated so that at any time, the number of queries does not exceed the number of locations added to the system.

Implement the SORTracker class:

SORTracker() Initializes the tracker system.
void add(string name, int score) Adds a scenic location with name and score to the system.
string get() Queries and returns the ith best location, where i is the number of times this method has been invoked (including this invocation).
 :from sortedcontainers import SortedList
class SORTracker:

    def __init__(self):
        self.i=0
        self.sl=SortedList()

    def add(self, name: str, score: int) -> None:
        self.sl.add((-score,name))

    def get(self) -> str:
        self.i+=1
        return self.sl[self.i-1][1]<|endoftext|>"
408,"<|endoftext|>In the previous article, we have discussed Python Program to Check Strontio Number or Not.
Given the Date of Birth and task is to calculate the corresponding age in days.

datetime module:

The datetime module contains numerous classes that can be used to manipulate date and time in both simple and complex ways.

In this, the date is formatted as the year month date (YY, MM, DD).

datetime.today() :The current date/system date is returned by datetime.today().

To calculate age from date of birth, subtract the date of birth from the current date.

timedelta() function in Python:

The Python timedelta() function is part of the datetime library and is commonly used for calculating date differences. It can also be used for date manipulation in Python. It is one of the simplest methods for manipulating dates.

Examples:

Example1:

Input:

Given Date of Birth = (2000, 3, 14)
Output:

The age in days and time for the Given DOB =  7823 days, 14:16:13.409557:# Import datetime(), timedelta() functions from datetime module using import keyword.
from datetime import datetime, timedelta
# Give the date of birth as static input in the format (YY, MM, DD) using datetime() function
# and store it in a variable.
gvn_DOB = datetime(1999, 5, 16)
# Get the current/today date using datetime.today() function and store it in
# another variable.
current_date = datetime.today()
# Subtract the given date of birth from the current date to get the age in days
# and store it in another variable.
age_in_days = current_date - gvn_DOB
# Print the age in days and time from the given date of birth.
print(""The age in days and time for the Given DOB = "", age_in_days)<|endoftext|>"
409,"<|endoftext|>There are n cars on an infinitely long road. The cars are numbered from 0 to n - 1 from left to right and each car is present at a unique point.

You are given a 0-indexed string directions of length n. directions[i] can be either 'L', 'R', or 'S' denoting whether the ith car is moving towards the left, towards the right, or staying at its current point respectively. Each moving car has the same speed.

The number of collisions can be calculated as follows:

When two cars moving in opposite directions collide with each other, the number of collisions increases by 2.
When a moving car collides with a stationary car, the number of collisions increases by 1.
After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.

Return the total number of collisions that will happen on the road.:class Solution:
    def countCollisions(self, directions: str) -> int:
        l, r = 0, 0
        ans = 0
        
        for i in directions:
            if i == ""L"":
                ans += l
            else:
                l = 1
        
        for i in directions[::-1]:
            if i == ""R"":
                ans += r
            else:
                r = 1
        
        return ans<|endoftext|>"
410,"<|endoftext|>You are given an integer array nums. We call a subset of nums good if its product can be represented as a product of one or more distinct prime numbers.

For example, if nums = [1, 2, 3, 4]:
[2, 3], [1, 2, 3], and [1, 3] are good subsets with products 6 = 2*3, 6 = 2*3, and 3 = 3 respectively.
[1, 4] and [4] are not good subsets with products 4 = 2*2 and 4 = 2*2 respectively.
Return the number of different good subsets in nums modulo 109 + 7.

A subset of nums is any array that can be obtained by deleting some (possibly none or all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.

 :class Solution:
    @staticmethod
    def getMask(num: int) -> Optional[int]:
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
        mask, power = 0, 1
        for i, p in enumerate(primes):
            if num % p == 0:
                if num % (p*p) == 0: return None
                mask += power
            power *= 2
        return mask
    
    @staticmethod
    def getSubsets(mask):
        subset = mask
        while subset != 0:
            yield subset
            subset = mask & (subset - 1)
        yield subset
    
    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        PRIME = int(1e9 + 7)
        counter = [0 for _ in range(31)]
        for num in nums:
            counter[num] += 1
        dp = [0 for _ in range(1024)]
        dp[0] = 2 ** counter[1]
        universal_mask = 0
        for num in range(2, 31):
            if counter[num] == 0: continue
            mask = self.getMask(num)
            if mask is None: continue
            universal_mask |= mask
            for complement_subset_mask in self.getSubsets(universal_mask - mask):
                dp[complement_subset_mask + mask] += dp[complement_subset_mask] * counter[num]
                dp[complement_subset_mask + mask] %= PRIME
        return sum(dp[1:]) % PRIME<|endoftext|>"
411,"<|endoftext|>The arithmetic operations are performed by calculator where we can perform addition, subtraction, multiplication and division. This example shows the basic arithmetic operations i.e.

Addition
Subtraction
Multiplication
Division:# Store input numbers:  
num1 = input('Enter first number: ')  
num2 = input('Enter second number: ')  
  
# Add two numbers  
sum = float(num1) + float(num2)  
# Subtract two numbers  
min = float(num1) - float(num2)  
# Multiply two numbers  
mul = float(num1) * float(num2)  
#Divide two numbers  
div = float(num1) / float(num2)  
# Display the sum  
print('The sum of {0} and {1} is {2}'.format(num1, num2, sum))  
  
# Display the subtraction  
print('The subtraction of {0} and {1} is {2}'.format(num1, num2, min))  
# Display the multiplication  
print('The multiplication of {0} and {1} is {2}'.format(num1, num2, mul))  
# Display the division  
print('The division of {0} and {1} is {2}'.format(num1, num2, div)) <|endoftext|>"
412,"<|endoftext|>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Given two integers x and y, return the Hamming distance between them.

:class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        x_b = bin(x)[2:]
        y_b = bin(y)[2:]
        
        size = max(len(x_b),len(y_b)) # ensure both binary strings are of same length
        x_b = x_b.zfill(size)
        y_b = y_b.zfill(size)
        
        count = 0
        for i in range(size):
            if x_b[i] != y_b[i]: #count every instance where bits are different
                count +=1
        return count<|endoftext|>"
413,"<|endoftext|>The program creates a graph object and allows the user to find all nodes reachable from a node.:class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}
 
    def add_vertex(self, key):
        """"""Add a vertex with the given key to the graph.""""""
        vertex = Vertex(key)
        self.vertices[key] = vertex
 
    def get_vertex(self, key):
        """"""Return vertex object with the corresponding key.""""""
        return self.vertices[key]
 
    def __contains__(self, key):
        return key in self.vertices
 
    def add_edge(self, src_key, dest_key, weight=1):
        """"""Add edge from src_key to dest_key with given weight.""""""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)
 
    def does_edge_exist(self, src_key, dest_key):
        """"""Return True if there is an edge from src_key to dest_key.""""""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])
 
    def __iter__(self):
        return iter(self.vertices.values())
 
 
class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}
 
    def get_key(self):
        """"""Return key corresponding to this vertex object.""""""
        return self.key
 
    def add_neighbour(self, dest, weight):
        """"""Make this vertex point to dest with given edge weight.""""""
        self.points_to[dest] = weight
 
    def get_neighbours(self):
        """"""Return all vertices pointed to by this vertex.""""""
        return self.points_to.keys()
 
    def get_weight(self, dest):
        """"""Get weight of edge from this vertex to dest.""""""
        return self.points_to[dest]
 
    def does_it_point_to(self, dest):
        """"""Return True if this vertex points to dest.""""""
        return dest in self.points_to
 
 
class Queue:
    def __init__(self):
        self.items = []
 
    def is_empty(self):
        return self.items == []
 
    def enqueue(self, data):
        self.items.append(data)
 
    def dequeue(self):
        return self.items.pop(0)
 
 
def find_all_reachable_nodes(vertex):
    """"""Return set containing all vertices reachable from vertex.""""""
    visited = set()
    q = Queue()
    q.enqueue(vertex)
    visited.add(vertex)
    while not q.is_empty():
        current = q.dequeue()
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                q.enqueue(dest)
    return visited
 
 
g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <src> <dest>')
print('reachable <vertex key>')
print('display')
print('quit')
 
while True:
    do = input('What would you like to do? ').split()
 
    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            src = int(do[2])
            dest = int(do[3])
            if src not in g:
                print('Vertex {} does not exist.'.format(src))
            elif dest not in g:
                print('Vertex {} does not exist.'.format(dest))
            else:
                if not g.does_edge_exist(src, dest):
                    g.add_edge(src, dest)
                else:
                    print('Edge already exists.')
 
    elif operation == 'reachable':
        key = int(do[1])
        vertex = g.get_vertex(key)
        reachable = find_all_reachable_nodes(vertex)
        print('All nodes reachable from {}:'.format(key),
              [v.get_key() for v in reachable])
 
    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()
 
        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()
 
    elif operation == 'quit':
        break<|endoftext|>"
414,"<|endoftext|>In this post, we will develop a Python program to capitalize the first letter of a sentence. If the string is “know program” then after capitalization string will be “Know program”. We will also develop a Python program to capitalize the first letter of every word in a string. If the string is “know program” then after capitalization string will be “Know Program”.:# Python program to capitalize the first letter of string # take string string = input('Enter any string: ') # capitalize using capitalize() function cap_string = string.capitalize() # printing capitalize string print('Capitalized String:', cap_string)<|endoftext|>"
415,"<|endoftext|>There are two types of potions:
Growing potion: ""A""
Shrinking potion: ""B""
If ""A"" immediately follows a digit, add 1 to the digit.
If ""B"" immediately follows a digit, subtract 1 from the digit.
Create a function that returns a string according to these rules, removing the potions once they've been consumed.
Examples
after_potion(""3A78B51"") ➞ ""47751""
# 3 grows to 4, 8 shrinks to 7

after_potion(""9999B"") ➞ ""9998""

after_potion(""9A123"") ➞ ""10123""

after_potion(""567"") ➞ ""567""
Notes
Digits that do not have a potion on their immediate right should be left alone.
A digit will always either be followed by zero or exactly 1 potion.:def after_potion(txt):
  s = []
  for i in txt:
    if i == 'A':
      s[-1] += 1
    elif i == 'B':
      s[-1] -= 1
    else:
      s.append(int(i))
  return ''.join([str(k) for k in s])<|endoftext|>"
416,"<|endoftext|>Mary wants to run a 25-mile marathon. When she attempts to sign up for the marathon, she notices the sign-up sheet doesn't directly state the marathon's length. Instead, the marathon's length is listed in small, different portions. Help Mary find out how long the marathon actually is.
Return True if the marathon is 25 miles long, otherwise, return False.
Examples
marathon_distance([1, 2, 3, 4]) ➞ False

marathon_distance([1, 9, 5, 8, 2]) ➞ True

marathon_distance([-6, 15, 4]) ➞ True
Notes
Items in the list will always be integers.
Items in the list may be negative or positive, but since negative distance isn't possible, find a way to convert negative integers into positive integers.
Return False if the arguments are empty or not provided.:def marathon_distance(d):
    return sum(map(abs, d)) == 25<|endoftext|>"
417,"<|endoftext|>In the rod-cutting problem, we are given a rod of length n inches and a table of prices p[i] for i = 1, 2, …, n. Here p[i] is the price of a rod of length i inches. We have to find the optimal way of cutting the rod so that maximum revenue can be generated by selling the pieces.:def cut_rod(p, n):
    """"""Take a list p of prices and the rod length n and return lists r and s.
    r[i] is the maximum revenue that you can get and s[i] is the length of the
    first piece to cut from a rod of length i.""""""
    # r[i] is the maximum revenue for rod length i
    # r[i] = -1 means that r[i] has not been calculated yet
    r = [-1]*(n + 1)
    r[0] = 0
 
    # s[i] is the length of the initial cut needed for rod length i
    # s[0] is not needed
    s = [-1]*(n + 1)
 
    for i in range(1, n + 1):
        q = -1
        for j in range(1, i + 1):
            temp = p[j] + r[i - j]
            if q < temp:
                q = temp
                s[i] = j
        r[i] = q
 
    return r, s
 
 
n = int(input('Enter the length of the rod in inches: '))
 
# p[i] is the price of a rod of length i
# p[0] is not needed, so it is set to None
p = [None]
for i in range(1, n + 1):
    price = input('Enter the price of a rod of length {} in: '.format(i))
    p.append(int(price))
 
r, s = cut_rod(p, n)
print('The maximum revenue that can be obtained:', r[n])
print('The rod needs to be cut into length(s) of ', end='')
while n > 0:
    print(s[n], end=' ')
    n -= s[n]<|endoftext|>"
418,"<|endoftext|>The task is to print all the numbers from 1 to 50 which are not divisible by 2 or 3 in C++ and Python.:# Use a for loop and a range() function which iterates from 1 to 50.
print(""The numbers from 1 to 50 which are not divisible by 2 and 3 are:"")
for numb in range(1, 51):
    # Then, using an if statement, determine whether the integer is
    # not divisible by both 2 and 3.
    if(numb % 2 != 0 and numb % 3 != 0):
        # If the number is not divisible by 2 and 3 then print it.
        print(""Number = "", numb)<|endoftext|>"
419,"<|endoftext|>The program sorts a list by merge sort.:def merge_sort(alist, start, end):
    '''Sorts the list from indexes start to end - 1 inclusive.'''
    if end - start > 1:
        mid = (start + end)//2
        merge_sort(alist, start, mid)
        merge_sort(alist, mid, end)
        merge_list(alist, start, mid, end)
 
def merge_list(alist, start, mid, end):
    left = alist[start:mid]
    right = alist[mid:end]
    k = start
    i = 0
    j = 0
    while (start + i < mid and mid + j < end):
        if (left[i] <= right[j]):
            alist[k] = left[i]
            i = i + 1
        else:
            alist[k] = right[j]
            j = j + 1
        k = k + 1
    if start + i < mid:
        while k < end:
            alist[k] = left[i]
            i = i + 1
            k = k + 1
    else:
        while k < end:
            alist[k] = right[j]
            j = j + 1
            k = k + 1
 
 
alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
merge_sort(alist, 0, len(alist))
print('Sorted list: ', end='')
print(alist)<|endoftext|>"
420,"<|endoftext|>You are given a 2D integer array groups of length n. You are also given an integer array nums.
You are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups).
Return true if you can do this task, and false otherwise.
Note that the subarrays are disjoint if and only if there is no index k such that nums[k] belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.
 
Example 1:

Input: groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]
Output: true
Explanation: You can choose the 0th subarray as [1,-1,0,1,-1,-1,3,-2,0] and the 1st one as [1,-1,0,1,-1,-1,3,-2,0].
These subarrays are disjoint as they share no common nums[k] element.

Example 2:

Input: groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]
Output: false
Explanation: Note that choosing the subarrays [1,2,3,4,10,-2] and [1,2,3,4,10,-2] is incorrect because they are not in the same order as in groups.
[10,-2] must come before [1,2,3,4].

Example 3:

Input: groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]
Output: false
Explanation: Note that choosing the subarrays [7,7,1,2,3,4,7,7] and [7,7,1,2,3,4,7,7] is invalid because they are not disjoint.
They share a common elements nums[4] (0-indexed).

 
Constraints:

groups.length == n
1 <= n <= 103
1 <= groups[i].length, sum(groups[i].length) <= 103
1 <= nums.length <= 103
-107 <= groups[i][j], nums[k] <= 107:class Solution:
  def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:
  i = 0
  for grp in groups: 
  for ii in range(i, len(nums)):
  if nums[ii:ii+len(grp)] == grp: 
  i = ii + len(grp)
  break 
  else: return False
  return True<|endoftext|>"
421,"<|endoftext|>Method #1: Using For Loop (Static Input)
Approach:

Give the number of rows as static input and store it in a variable.
Loop from 1 to the number of rows using For loop.
Loop from iterator value of the parent For loop -1 to 0 in decreasing order using another for loop(Nested For loop).
Print the 2 power n value with space where n is the value of the inner for loop.
Print the Newline character after the end of the inner loop.
The Exit of the Program.:# Give the number of rows as static input and store it in a variable.
numbrrows = 7
# Loop from 1 to the number of rows using For loop.
for m in range(1, numbrrows):
    # Loop from iterator value of the parent For loop -1 to 0
    # in decreasing order using another for loop(Nested For loop).
    for n in range(m - 1, -1, -1):
        # Print the 2 power n value with space where n is the value of the inner for loop.
        print(2**n, end=' ')
    # Print the Newline character after the end of the inner loop.
    print()<|endoftext|>"
422,"<|endoftext|>Write a function that takes two parameters n and k and returns the value of Binomial Coefficient C(n, k). 
Example: 
 

Input: n = 4 and k = 2
Output: 6
Explanation: 4 C 2 is 4!/(2!*2!) = 6

Input: n = 5 and k = 2
Output: 10
Explanation: 5 C 2 is 5!/(3!*2!) = 20:# Python program to calculate C(n, k)

# Returns value of Binomial Coefficient
# C(n, k)
def binomialCoefficient(n, k):
	# since C(n, k) = C(n, n - k)
	if(k > n - k):
		k = n - k
	# initialize result
	res = 1
	# Calculate value of
	# [n * (n-1) *---* (n-k + 1)] / [k * (k-1) *----* 1]
	for i in range(k):
		res = res * (n - i)
		res = res // (i + 1)
	return res

# Driver program to test above function
n = 8
k = 2
res = binomialCoefficient(n, k)
print(""Value of C(% d, % d) is % d"" %(n, k, res))

# This code is contributed by Aditi Sharma<|endoftext|>"
423,"<|endoftext|>Dictionaries in Python:

Dictionary is a mutable built-in Python Data Structure. It is conceptually related to List, Set, and Tuples. It is, however, indexed by keys rather than a sequence of numbers and can be thought of as associative arrays. On a high level, it consists of a key and its associated value. The Dictionary class in Python represents a hash-table implementation.

Given a string , the task is to create a Python program for creating a dictionary with the Key as the first character and the Value as words beginning with that character.:# Scanning the given string
given_string = input(""Enter some random string separated by spaces = "")
# Split the given string into words using split() function
# Convert this into list using list() function.
listString = given_string.split()
# Declare a dictionary which is empty using {} or dict()
resultdict = {}
# Traverse the list String
for stringword in listString:
  # checking if the first character of the word exists in dictionary resultdict keys or not
    if(stringword[0] not in resultdict.keys()):
        resultdict[stringword[0]] = []
        # adding this character to the resultdict
        resultdict[stringword[0]].append(stringword)
    else:
      # If it is present, add the word to the associated sublist as the value.
        if(stringword not in resultdict[stringword[0]]):
            resultdict[stringword[0]].append(stringword)
for key, value in resultdict.items():
    print(key, "":::"", value)<|endoftext|>"
424,"<|endoftext|>Strings in Python:

“String is a character collection or array”

Well in Python too, for the string data type, we say the same definition. The string is a sequenced character array and is written within single, double, or three quotes. Also, Python does not have the data type character, thus it is used as a string of length 1 if we write ‘r’.

Given a string, the task is to form a new string which is made of the First 2 and Last 2 characters From a Given String in Python.

Examples:

Example1:

Input:

given string =BTechGeeks
Output:

BTks
Example2:

Input:

given string =AplusTopper
Output:

Aper:# Give the string as static input and store it in a variable.
given_strng = 'BTechGeeks'
# Take a variable to say stringcharacters that stores the total characters in the given string.
# Initialize the stringcharacters to 0.
stringcharacters = 0
# Traverse the given string using for loop.
for charact in given_strng:
  # Increment the value of stringcharacters by 1.
  stringcharacters = stringcharacters+1
# Using String Concatenation and slicing form the new string with which is made of the First two
# and Last two characters From a Given String.
resstring = given_strng[0:2]+given_strng[stringcharacters-2:stringcharacters]
# print the result string
print(resstring)<|endoftext|>"
425,"<|endoftext|>Create a function that takes a list with temperature type, temperature, and a second temperature type. The temperature types can be Celsius, Fahrenheit, or Kelvin. Return the temperature type (in the list) converted into the second temperature type.
Examples
converter([""fahrenheit"", 3] , ""kelvin"") ➞ 257.0

converter([""celsius"", 10] , ""fahrenheit"") ➞ 50.0

converter([""celsius"", 20] , ""kelvin"") ➞ 293.1
Notes
Round to one decimal place.:def converter(a, b):
    a, t = a
    d = {('celsius', 'kelvin'): t + 273.15, 
         ('celsius', 'fahrenheit'): t * 9/5 + 32, 
         ('fahrenheit', 'celsius'): (t - 32) * 5/9, 
         ('fahrenheit', 'kelvin'): (t + 459.67) * 5/9, 
         ('kelvin', 'celsius'): t - 273.15, 
         ('kelvin', 'fahrenheit'): t * 9/5 - 459.67}
    return round(d[(a, b)], 1)<|endoftext|>"
426,"<|endoftext|>Given a singly linked list, write a function to swap elements pairwise. 

Input : 1->2->3->4->5->6->NULL 
Output : 2->1->4->3->6->5->NULL

Input : 1->2->3->4->5->NULL 
Output : 2->1->4->3->5->NULL

Input : 1->NULL 
Output : 1->NULL 
 

For example, if the linked list is 1->2->3->4->5 then the function should change it to 2->1->4->3->5, and if the linked list is then the function should change it to.  :# Python program to swap the elements of linked list pairwise

# Node class


class Node:

	# Constructor to initialize the node object
	def __init__(self, data):
		self.data = data
		self.next = None


class LinkedList:

	# Function to initialize head
	def __init__(self):
		self.head = None

	# Function to pairwise swap elements of a linked list
	def pairwiseSwap(self):
		temp = self.head

		# There are no nodes in linked list
		if temp is None:
			return

		# Traverse furthethr only if there are at least two
		# left
		while(temp and temp.next):

			# If both nodes are same,
			# no need to swap data
			if(temp.data != temp.next.data):

				# Swap data of node with its next node's data
				temp.data, temp.next.data = temp.next.data, temp.data

			# Move temp by 2 to the next pair
			temp = temp.next.next

	# Function to insert a new node at the beginning
	def push(self, new_data):
		new_node = Node(new_data)
		new_node.next = self.head
		self.head = new_node

	# Utility function to print the linked LinkedList
	def printList(self):
		temp = self.head
		while(temp):
			print temp.data,
			temp = temp.next


# Driver program
llist = LinkedList()
llist.push(5)
llist.push(4)
llist.push(3)
llist.push(2)
llist.push(1)

print ""Linked list before calling pairWiseSwap() ""
llist.printList()

llist.pairwiseSwap()

print ""\nLinked list after calling pairWiseSwap()""
llist.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
<|endoftext|>"
427,"<|endoftext|>Solve Quadratic Equation using Python:# importing cmath
import cmath
# given a,b,c values
a = 2
b = -7
c = 6
discriminant = (b**2) - (4*a*c)
# checking if the value of discriminant is greater than 0
if(discriminant > 0):
    # here exist the two distinct roots and we print them
    # calculating the roots
    root1 = (-b+discriminant) / (2 * a)
    root2 = (-b-discriminant) / (2 * a)
    # printing the roots

    print(""The two distinct roots are : "")
    print(root1)
    print(root2)
# checking if the value of discriminant is equal to 0
elif(discriminant == 0):
    # here exist the two equal roots
    # calculating single root here discriminant is 0 so we dont need to write full formulae
    root = (-b)/(2*a)
    # printing the root
    print(""The two equal roots are : "")
    print(root, root)
# else there exists complex roots
else:
    # here exist the two complex roots
    # calculating complex roots
    realpart = -b/(2*a)
    complexpart = discriminant/(2*a)*(-1)
    # printing the roots
    print(""There exists two complex roots:"")
    print(realpart, ""+"", complexpart, ""i"")
    print(realpart, ""-"", complexpart, ""i"")<|endoftext|>"
428,"<|endoftext|>You are given a string that represent an expression of digits and operands. E.g. 1+2*3, 1-2+4. You need to evaluate the string or the expression. NO BODMAS is followed. If the expression is of incorrect syntax return -1. :# Python3 program to evaluate a
# given expression
 
# A utility function to check if
# a given character is operand
def isOperand(c):
  
    return (c >= '0' and c <= '9');
 
# utility function to find
# value of and operand
def value(c):
    return ord(c) - ord('0');
 
# This function evaluates simple
# expressions. It returns -1 if the
# given expression is invalid.
def evaluate(exp):
 
    len1 = len(exp);
     
    # Base Case: Given expression is empty
    if (len1 == 0):
        return -1;
 
    # The first character must be
    # an operand, find its value
    res = value(exp[0]);
 
    # Traverse the remaining
    # characters in pairs
    for i in range(1,len1,2):
        # The next character must be
        # an operator, and next to
        # next an operand
        opr = exp[i];
        opd = exp[i + 1];
 
        # If next to next character
        # is not an operand
        if (isOperand(opd)==False):
            return -1;
 
        # Update result according
        # to the operator
        if (opr == '+'):
            res += value(opd);
        elif (opr == '-'):
            res -= int(value(opd));
        elif (opr == '*'):
            res *= int(value(opd));
        elif (opr == '/'):
            res /= int(value(opd));
 
        # If not a valid operator
        else:
            return -1;
     
    return res;
 
# Driver Code
expr1 = ""1+2*5+3"";
res = evaluate(expr1);
print(expr1,""is Invalid"") if (res == -1) else print(""Value of"",expr1,""is"",res);
 
expr2 = ""1+2*3"";
res = evaluate(expr2);
print(expr2,""is Invalid"") if (res == -1) else print(""Value of"",expr2,""is"",res);
 
expr3 = ""4-2+6*3"";
res = evaluate(expr3);
print(expr3,""is Invalid"") if (res == -1) else print(""Value of"",expr3,""is"",res);
 
expr4 = ""1++2"";
res = evaluate(expr4);
print(expr4,""is Invalid"") if (res == -1) else print(""Value of"",expr4,""is"",res);
 
# This code is contributed by mits<|endoftext|>"
429,"<|endoftext|>A sexy (from sex, the Latin word for six) prime triplet is a group of three primes that differ by each other by 6, with the sum of the smallest prime plus 18 being a composite number.
You must implement a function that returns a list of triplets (triplets being lists in turn) found in a range, which included bounds are the two given integers low and high.
Examples
sexy_triplets(1, 19) ➞ [ [7, 13, 19] ]
# 7 + 6 = 13 + 6 = 19 and 7 + 18 = 25 (composite)

sexy_triplets(5, 17) ➞ []
# Despite [5, 11, 17] can seem a triplet, 5 + 18 = 23 (not composite)

sexy_triplets(64, 88) ➞ [ [67, 73, 79] ]
# 67 + 6 = 73 + 6 = 79 and 67 + 18 = 85 (composite)
Notes
If no triplets are found in the range, return an empty list (see example #2).
A composite number is trivially a not prime number.:def sexy_triplets(low, high):
    p, r = [], []
    for i in range(low, high + 1):
        if i % 2 == 1:
            if check(i):
                p.append(i)
    for j in range(len(p) - 2):
        if p[j] + 6 in p and p[j] + 12 in p and not check(p[j] + 18):
            add = [p[j], p[j] + 6, p[j] + 12]
            r.append(add)
    return r    
    def check(x):            
    for i in range(2, x):
        if x % i == 0:
            return False
    return True<|endoftext|>"
430,"<|endoftext|>This python program finds smallest of three numbers given by user.
In this program, three numbers are read from user and stored in variable first, second and third. After that decision of smallest among three is made using python'sif elif else statement.:# Finding smallest of three numbers

# Reading numbers
first = float(input('Enter first number: '))
second = float(input('Enter second number: '))
third = float(input('Enter third number: '))

# Making decision and displaying
if first >= second and first>=third:
    small = first
elif second >= first and second >= third:
    small = second
else:
    small = third

print('Smallest = %d' %(large))<|endoftext|>"
431,"<|endoftext|>Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.
 
Example 1:

Input: s = ""00110110"", k = 2
Output: true
Explanation: The binary codes of length 2 are ""00"", ""01"", ""10"" and ""11"". They can be all found as substrings at indices 0, 1, 3 and 2 respectively.

Example 2:

Input: s = ""0110"", k = 1
Output: true
Explanation: The binary codes of length 1 are ""0"" and ""1"", it is clear that both exist as a substring. 

Example 3:

Input: s = ""0110"", k = 2
Output: false
Explanation: The binary code ""00"" is of length 2 and does not exist in the array.

 
Constraints:

1 <= s.length <= 5 * 105
s[i] is either '0' or '1'.
1 <= k <= 20:class Solution:
  def hasAllCodes(self, s: str, k: int) -> bool:
  seen = set()
  q = deque()
  for c in s:
  q.append(c)
  if len(q) == k: seen.add(''.join(q)); q.popleft()
  return len(seen) == 1 << k<|endoftext|>"
432,"<|endoftext|>Instructions
Use the Sieve of Eratosthenes to find all the primes from 2 up to a given number.

The Sieve of Eratosthenes is a simple, ancient algorithm for finding all prime numbers up to any given limit. It does so by iteratively marking as composite (i.e. not prime) the multiples of each prime, starting with the multiples of 2. It does not use any division or remainder operation.

Create your range, starting at two and continuing up to and including the given limit. (i.e. [2, limit])

The algorithm consists of repeating the following over and over:

take the next available unmarked number in your list (it is prime)
mark all the multiples of that number (they are not prime)
Repeat until you have processed each number in your range.

When the algorithm terminates, all the numbers in the list that have not been marked are prime.

The wikipedia article has a useful graphic that explains the algorithm: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

Notice that this is a very specific algorithm, and the tests don't check that you've implemented the algorithm, only that you've come up with the correct list of primes. A good first test is to check that you do not use division or remainder operations (div, /, mod or % depending on the language).:def primes(limit):
    result = []
    candidates = list(range(2, limit + 1))
    while candidates:
        p = candidates[0]
        result.append(p)
        candidates = list(filter(lambda c: c % p, candidates))
    return result
<|endoftext|>"
433,"<|endoftext|>You are given an integer mass, which represents the original mass of a planet. You are further given an integer array asteroids, where asteroids[i] is the mass of the ith asteroid.

You can arrange for the planet to collide with the asteroids in any arbitrary order. If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass of the asteroid. Otherwise, the planet is destroyed.

Return true if all asteroids can be destroyed. Otherwise, return false.:class Solution:
    def asteroidsDestroyed(self, mass: int, a: List[int]) -> bool:
        
        a.sort()
        
        for i in range(len(a)):
            if mass>=a[i]:
                mass+=a[i]
            else:
                return False
        return True
                <|endoftext|>"
434,"<|endoftext|>Definition and Usage
The readlines() method returns a list containing each line in the file as a list item.

Use the hint parameter to limit the number of lines returned. If the total number of bytes returned exceeds the specified number, no more lines are returned.:f = open(""demofile.txt"", ""r"")
print(f.readlines())<|endoftext|>"
435,"<|endoftext|>In this challenge you will be given a list of numbers. Your task is to ""marry"" each pair of adjacent numbers by adding them, and return the list of ""couples"" (i.e. sums).
If the list has an odd length, one number is (sadly) left out, so you should return ""bad match"".
Examples
is_good_match([1, 2, 4, 7]) ➞ [1+2, 4+7] ➞ [3, 11]

is_good_match([5, 7, 9, -1, 4, 2]) ➞ [12, 8, 6]

is_good_match([5, 7, 9, -1, 4, 2, 3]) ➞ ""bad match""

is_good_match([2, 6, 7, -2, 4]) ➞ ""bad match""
Notes
N/A:def is_good_match(lst):
  return 'bad match' if len(lst) % 2 else [sum(lst[i:i+2]) for i in range(0, len(), 2)]<|endoftext|>"
436,"<|endoftext|>Create a function that calculates an energy bill.
Given a billing start date and end date, start and end meter reading, a unit price in pence, and a standing charge (a daily rental fee for your meter) as arguments, calculate your bill.
An energy bill is calculated by multiplying the difference between meter readings with the unit price and adding the number of days multiplied by the standing charge. You then have to add 5% tax.
(days between dates x standing charge) + (diference bewteen meter readings x unit price) + 5% tax
Examples
energy_bill(""2020,01,01"", ""2020,04,01"", 1000, 2000, 0.188, 0.243),  = ""$220.62""
""2020,04,01"" (end date) - ""2020,01,01"" ( start date ),  = 91 days
  2000 ( end meter read )- 1000 ( start meter read ) = 1000 units used
  1000 (units) * 0.188p (each unit cost) = $188
  91 (days) * 0.243p (standing charge) == $22.113
  22.113 (Total standing charge cost) + $188 (total unit cost) = $210.113
  210.113 (cost) * 0.05 (uk tax on energy) = 10.50565
  210.113 (cost) + 10.50565 (tax) = 220.61865
  answer = ""$220.62""
Notes
If the end date is an earlier date from the start date return ""Invalid date"".
If the end meter reading is less then the start meter reading return ""Invalid meter readings"".
Please bring to my attention any clarity issues.:from datetime import datetime as dt
def energy_bill(start_date, end_date, start_read, end_read, tariff, stand):
    t1 = dt.strptime(start_date, ""%Y,%m,%d"")
    t2 = dt.strptime(end_date, ""%Y,%m,%d"")
    if t2 < t1:
        return ""Invalid date""
    if end_read < start_read:
        return ""Invalid meter readings""
    res = ((end_read - start_read) * tariff + (t2 - t1).days * stand) * 1.05
    return ""${:.2f}"".format(res)<|endoftext|>"
437,"<|endoftext|>Write a function that returns the longest sequence of consecutive zeroes in a binary string.
Examples
longest_zero(""01100001011000"") ➞ ""0000""

longest_zero(""100100100"") ➞ ""00""

longest_zero(""11111"") ➞ """"
Notes
If no zeroes exist in the input, return an empty string.:def longest_zero(s):
  return max(s.split('1'), key=len)<|endoftext|>"
438,"<|endoftext|>Given three numbers, x, y and z, determine whether they are the edges of a right angled triangle.

Examples
right_triangle(3, 4, 5) ➞ True
# This is the classic example of a ""nice"" right angled triangle.

right_triangle(145, 105, 100) ➞ True
# This is a less famous example.

right_triangle(70, 130, 110) ➞ False
# This isn't a right angled triangle.
:def right_triangle(x, y, z):
        if x>0 and y>0 and z>0:
                return (x*x + y*y + z*z) - max(x,y,z)**2 == max(x,y,z)**2
        return False<|endoftext|>"
439,"<|endoftext|>Given a Binary Tree find the length of the longest path which comprises of nodes with consecutive values in increasing order. Every node is considered as a path of length 1.:# Python3 program to find longest consecutive
# sequence in binary tree

# A utility class to create a node
class newNode:
	def __init__(self, data):
		self.data = data
		self.left = self.right = None

# Utility method to return length of
# longest consecutive sequence of tree
def longestConsecutiveUtil(root, curLength,
						expected, res):
	if (root == None):
		return

	# if root data has one more than its
	# parent then increase current length
	if (root.data == expected):
		curLength += 1
	else:
		curLength = 1

	# update the maximum by current length
	res[0] = max(res[0], curLength)

	# recursively call left and right subtree
	# with expected value 1 more than root data
	longestConsecutiveUtil(root.left, curLength,
						root.data + 1, res)
	longestConsecutiveUtil(root.right, curLength,
						root.data + 1, res)

# method returns length of longest consecutive
# sequence rooted at node root
def longestConsecutive(root):
	if (root == None):
		return 0

	res = [0]

	# call utility method with current length 0
	longestConsecutiveUtil(root, 0, root.data, res)

	return res[0]

# Driver Code
if __name__ == '__main__':

	root = newNode(6)
	root.right = newNode(9)
	root.right.left = newNode(7)
	root.right.right = newNode(10)
	root.right.right.right = newNode(11)

	print(longestConsecutive(root))

# This code is contributed by PranchalK<|endoftext|>"
440,"<|endoftext|>Python also accepts function recursion, which means a defined function can call itself.

Recursion is a common mathematical and programming concept. It means that a function calls itself. This has the benefit of meaning that you can loop through data to reach a result.

The developer should be very careful with recursion as it can be quite easy to slip into writing a function which never terminates, or one that uses excess amounts of memory or processor power. However, when written correctly recursion can be a very efficient and mathematically-elegant approach to programming.

In this example, tri_recursion() is a function that we have defined to call itself (""recurse""). We use the k variable as the data, which decrements (-1) every time we recurse. The recursion ends when the condition is not greater than 0 (i.e. when it is 0).

To a new developer it can take some time to work out how exactly this works, best way to find out is by testing and modifying it.:def tri_recursion(k):
  if(k>0):
    result = k+tri_recursion(k-1)
    print(result)
  else:
    result = 0
  return result

print(""\n\nRecursion Example Results"")
tri_recursion(6)<|endoftext|>"
441,"<|endoftext|>Given the sides of a parallelogram, the task is to calculate the circumference of a parallelogram for the given sides in python.

Circumference of Parallelogram:

A parallelogram’s opposite sides are equal in length and parallel. Angles are equal when paired, but not always at 90 degrees. The circumference of a parallelogram can be calculated by multiplying the sum of two adjacent sides by two.

Formula:

The circumference of parallelogram = (2*a)+(2*b)

where a, b are the sides of a parallelogram

Python round() function:

The round() function returns a floating-point number with the specified number of decimals that is a rounded version of the specified number.:# Create a function to say parallelogram_circumference() which takes the given two
# sides as the argument and returns the circumference of the given parallelogram.


def parallelogram_circumference(fst_side, scnd_side):
    # Inside the function, calculate the circumference of the parallelogram using the
        # above given mathematical formula and store it in another variable.
    paralgrm_circum = (2 * fst_side) + (2 * scnd_side)
    # Return the above result.
    return paralgrm_circum


# Give the first side as static input and store it in a variable.
fst_side = 5
# Give the second side as static input and store it in another variable.
scnd_side = 6
# Pass the given two sides as the arguments to the parallelogram_circumference() function
# and round it off to up to 3 places after the decimal point using the round() function.
# Store it in another variable.
circumfrnce = round(parallelogram_circumference(fst_side, scnd_side), 3)
# Print the above result which gives the circumference of the parallelogram for
# the given sides.
print(
    ""The Circumference of a parallelogram for the given two sides{"", fst_side, "","", scnd_side, ""} = "", circumfrnce)<|endoftext|>"
442,"<|endoftext|>For each challenge of this series you do not need to submit a function. Instead, you need to submit a template string that can formatted in order to get a certain outcome.
Write a template string according to the following example. All final strings must have a length of 20 characters:
Example
template = ""yourtemplatestringhere""
template.format(fname = ""John"", lname = ""Doe"") ➞ ""JoDo###############.""
Tips
The placeholder {:.x} will truncate a string at index x:
""My initial is {:.1}."".format(""Edabit"") ➞ ""My initial is E.""
Notes
Sumbit a string, not a function.
Do not change the name of the variable template.
You can find all the exercises in this series over here.:template = ""{fname:2.2}{lname:#<17.2}.""<|endoftext|>"
443,"<|endoftext|>Given an array of n distinct elements and a number x, arrange array elements according to the absolute difference with x, i. e., an element having minimum difference comes first, and so on. 
Note: If two or more elements are at equal distance arrange them in the same sequence as in the given array.:# Python3 program to sort an
# array according absolute
# difference with x.

# Function to sort an array
# according absolute difference
# with x.
def rearrange(arr, n, x):

        m = {}

        # Store values in a map
        # with the difference
        # with X as key
        for i in range(n):
                m[arr[i]] = abs(x - arr[i])

        m = {k : v for k, v in sorted(m.items(),
                key = lambda item : item[1])}

        # Update the values of array
        i = 0

        for it in m.keys():
                arr[i] = it
                i += 1

# Function to print the array
def printArray(arr, n):

        for i in range(n):
                print(arr[i], end = "" "")
                
# Driver code
if __name__ == ""__main__"":

        arr = [10, 5, 3, 9, 2]
        n = len(arr)
        x = 7
        rearrange(arr, n, x)
        printArray(arr, n)

# This code is contributed by Chitranayal<|endoftext|>"
444,"<|endoftext|>Fibonacci Sequence:

The Fibonacci Sequence is a series of integers named after the Italian mathematician Fibonacci. It is merely a string of numbers that begins with 0 and 1 and is then followed by the addition of the two numbers before it.

Recursion:

If you’re familiar with Python functions, you’ll know that it’s typical for one function to call another. It is also feasible for a function in Python to call itself! A recursive function calls itself, and the process of using a recursive function is known as recursion.

Although it may appear strange for a function to call itself, many sorts of programming challenges are better stated recursively.

Given a number, the task is to find the Fibonacci sequence till the given number using recursion.

Examples:

Example1:

Input:

given number = 23
Output:

The Fibonacci Sequence till the given number 23  = 
Number =  0
Number =  1
Number =  1
Number =  2
Number =  3
Number =  5
Number =  8
Number =  13
Number =  21
Number =  34
Number =  55
Number =  89
Number =  144
Number =  233
Number =  377
Number =  610
Number =  987
Number =  1597
Number =  2584
Number =  4181
Number =  6765
Number =  10946
Number =  17711:# function which finds the fibonacci sequence recursively
def fibonacciRecursion(numb):
  # The base condition is defined as a value that is less than or equal to 1.
    if(numb <= 1):
        return numb
    else:
      # Otherwise, call the function recursively with the argument as the number minus 1 plus the function that was called
      # recursively with the parameter as the number minus 2.
        return(fibonacciRecursion(numb-1) + fibonacciRecursion(numb-2))


# The user must give the number as static input and store it in a variable.
numb = 23
print(""The Fibonacci Sequence till the given number"", numb, ' = ')
# Looping from 1 to given number using for loop
for n in range(numb):
  # passing the iterter value as argument to the recursive function fibonacciRecursion
    print('Number = ', fibonacciRecursion(n))<|endoftext|>"
445,"<|endoftext|>Create a function that takes a list and a string as arguments and returns the index of the string.
Examples
find_index([""hi"", ""edabit"", ""fgh"", ""abc""], ""fgh"") ➞ 2

find_index([""Red"", ""blue"", ""Blue"", ""Green""], ""blue"") ➞ 1

find_index([""a"", ""g"", ""y"", ""d""], ""d"") ➞ 3

find_index([""Pineapple"", ""Orange"", ""Grape"", ""Apple""], ""Pineapple"") ➞ 0
Notes
Don't forget to return the result.
If you are stuck, find help in the Resources tab.
The variable for list is lst, not 1st.:def find_index(lst, str):
  return lst.index(str)<|endoftext|>"
446,"<|endoftext|>Consider lines of slope -1 passing between nodes (dotted lines in below diagram). The diagonal sum in a binary tree is the sum of all node’s data lying between these lines. Given a Binary Tree, print all diagonal sums.
For the following input tree, the output should be 9, 19, 42. 
9 is sum of 1, 3 and 5. 
19 is sum of 2, 6, 4 and 7. 
42 is sum of 9, 10, 11 and 12.:# Program to find diagonal sum in a Binary Tree

class newNode:
	def __init__(self, data):
		self.data = data
		self.left = self.right = None
		
# Function to compute height and
# root - root of the binary tree
# vd - vertical distance diagonally
# diagonalSum - map to store Diagonal
# Sum(Passed by Reference)
def diagonalSumUtil(root, vd, diagonalSum) :

	if(not root):
		return
		
	if vd not in diagonalSum:
		diagonalSum[vd] = 0
	diagonalSum[vd] += root.data

	# increase the vertical distance
	# if left child
	diagonalSumUtil(root.left, vd + 1,
						diagonalSum)

	# vertical distance remains same
	# for right child
	diagonalSumUtil(root.right, vd,
					diagonalSum)

# Function to calculate diagonal
# sum of given binary tree
def diagonalSum(root) :

	# create a map to store Diagonal Sum
	diagonalSum = dict()
	
	diagonalSumUtil(root, 0, diagonalSum)

	print(""Diagonal sum in a binary tree is - "",
									end = """")
	
	for it in diagonalSum:
		print(diagonalSum[it], end = "" "")
		
# Driver Code
if __name__ == '__main__':
	root = newNode(1)
	root.left = newNode(2)
	root.right = newNode(3)
	root.left.left = newNode(9)
	root.left.right = newNode(6)
	root.right.left = newNode(4)
	root.right.right = newNode(5)
	root.right.left.right = newNode(7)
	root.right.left.left = newNode(12)
	root.left.right.left = newNode(11)
	root.left.left.right = newNode(10)

	diagonalSum(root)

# This code is contributed
# by SHUBHAMSINGH10
<|endoftext|>"
447,"<|endoftext|>Given a binary tree and two nodes, the task is to Print all the nodes that are common for 2 given nodes in a binary tree.:# Python3 Program to find common
# nodes for given two nodes
 
# Utility class to create a new tree Node
class newNode:
    def __init__(self, key):
        self.key = key
        self.left = self.right = None
     
# Utility function to find the LCA of
# two given values n1 and n2.
def findLCA(root, n1, n2):
     
    # Base case
    if (root == None):
        return None
 
    # If either n1 or n2 matches with root's key,
    # report the presence by returning root (Note
    # that if a key is ancestor of other, then the
    # ancestor key becomes LCA
    if (root.key == n1 or root.key == n2):
        return root
 
    # Look for keys in left and right subtrees
    left_lca = findLCA(root.left, n1, n2)
    right_lca = findLCA(root.right, n1, n2)
 
    # If both of the above calls return Non-None,
    # then one key is present in once subtree and
    # other is present in other, So this node is the LCA
    if (left_lca and right_lca):
        return root
 
    # Otherwise check if left subtree or
    # right subtree is LCA
    if (left_lca != None):
        return left_lca
    else:
        return right_lca
 
# Utility Function to print all ancestors of LCA
def printAncestors(root, target):
     
    # base cases
    if (root == None):
        return False
 
    if (root.key == target):
        print(root.key, end = "" "")
        return True
 
    # If target is present in either left or right
    # subtree of this node, then print this node
    if (printAncestors(root.left, target) or
        printAncestors(root.right, target)):
            print(root.key, end = "" "")
            return True
 
    # Else return False
    return False
 
# Function to find nodes common to given two nodes
def findCommonNodes(root, first, second):
    LCA = findLCA(root, first, second)
    if (LCA == None):
        return False
 
    printAncestors(root, LCA.key)
 
# Driver Code
if __name__ == '__main__':
 
    # Let us create binary tree given
    # in the above example
    root = newNode(1)
    root.left = newNode(2)
    root.right = newNode(3)
    root.left.left = newNode(4)
    root.left.right = newNode(5)
    root.right.left = newNode(6)
    root.right.right = newNode(7)
    root.left.left.left = newNode(8)
    root.right.left.left = newNode(9)
    root.right.left.right = newNode(10)
 
    if (findCommonNodes(root, 9, 7) == False):
        print(""No Common nodes"")
 
# This code is contributed by PranchalK
<|endoftext|>"
448,"<|endoftext|>Write a function that returns True if all the strings in a list can be formed by using only the characters from the longest string.
Examples
can_form([""mast"", ""manifest"", ""met"", ""fan""]) ➞ True

can_form([""may"", ""master"", ""same"", ""reams""]) ➞ False

can_form([""may"", ""same"", ""reams"", ""mastery""]) ➞ True
Notes
There will only be one unique longest string.:def can_form(lst):
  longest = max(lst, key=len)
  return all(longest.count(i) >= word.count(i) for word in lst for i in set(word))<|endoftext|>"
449,"<|endoftext|>The math.frexp() method returns the mantissa and the exponent of a specified number, as a pair (m,e).

The mathematical formula for this method is: number = m * 2**e.:#Import math Library
import math

#Return mantissa and exponent of numbers
print(math.frexp(4))
print(math.frexp(-4))
print(math.frexp(7))<|endoftext|>"
450,"<|endoftext|>Gradio is an open-source python library which allows you to quickly create easy to use, customizable UI components for your ML model, any API, or any arbitrary function in just a few lines of code. You can integrate the GUI directly into your Python notebook, or you can share the link to anyone.:
def factorial(integer):
    """""" Returns factorial of the given integer""""""
    n = int(integer)
    if n<=1:
        return 1
    fact=1
    for i in range(1, n+1):
        fact*=i
    return fact
import gradio
gradio.Interface(factorial, inputs=""text"", outputs=""text"").launch(share=True)
# imported necessary libraries
import gradio as gr
import tensorflow as tf
import numpy as np
import requests
 
# loading the model
inception_net = tf.keras.applications.InceptionV3()
 
# Download human-readable labels.
response = requests.get(""https://git.io/JJkYN"")
labels = response.text.split(""\n"")
 
def classify_image(image):
    """""" Returns a dictionary with key as label and values
    as the predicted confidence for that label""""""
    # reshaping the image
    image = image.reshape((-1, 299, 299, 3))
    # preprocessing the image for inception_v3
    image = tf.keras.applications.inception_v3.preprocess_input(image)
    # predicting the output
    prediction = inception_net.predict(image).flatten()
    return {labels[i]: float(prediction[i]) for i in range(1000)}
 
# initializing the input component
image = gr.inputs.Image(shape = (299, 299, 3))
# initializing the output component
label = gr.outputs.Label(num_top_classes = 3)
 
# launching the interface
gr.Interface(fn = classify_image, inputs = image,
             outputs = label, capture_session = True).launch()<|endoftext|>"
451,"<|endoftext|>NetworkX is a Python language software package for the creation, manipulation, and study of the structure, dynamics, and function of complex networks. It is used to study large complex networks represented in form of graphs with nodes and edges. Using networkx we can load and store complex networks. We can generate many types of random and classic networks, analyze network structure, build network models, design new network algorithms and draw networks. :# Python program to create an undirected 
# graph and add nodes and edges to a graph
  
# To import package
import networkx
   
# To create an empty undirected graph
G = networkx.Graph()
   
# To add a node
G.add_node(1)
G.add_node(2)
G.add_node(3)
G.add_node(4)
G.add_node(7)
G.add_node(9)
   
# To add an edge
# Note graph is undirected
# Hence order of nodes in edge doesn't matter
G.add_edge(1,2)
G.add_edge(3,1)
G.add_edge(2,4)
G.add_edge(4,1)
G.add_edge(9,1)
G.add_edge(1,7)
G.add_edge(2,9)
   
# To get all the nodes of a graph
node_list = G.nodes()
print(""#1"")
print(node_list)
   
# To get all the edges of a graph
edge_list = G.edges()
print(""#2"")
print(edge_list)
   
# To remove a node of a graph
G.remove_node(3)
node_list = G.nodes()
print(""#3"")
print(node_list)
   
# To remove an edge of a graph
G.remove_edge(1,2)
edge_list = G.edges()
print(""#4"")
print(edge_list)
   
# To find number of nodes
n = G.number_of_nodes()
print(""#5"")
print(n)
   
# To find number of edges
m = G.number_of_edges()
print(""#6"")
print(m)
   
# To find degree of a node
# d will store degree of node 2
d = G.degree(2)
print(""#7"")
print(d)
  
# To find all the neighbor of a node
neighbor_list = G.neighbors(2)
print(""#8"")
print(neighbor_list)
  
#To delete all the nodes and edges
G.clear()
<|endoftext|>"
452,"<|endoftext|>Stack is a linear data structure that follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out).

Mainly the following three basic operations are performed in the stack: Push: Adds an item in the stack. If the stack is full, then it is said to be an Overflow condition.
Pop: Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.
Peek or Top: Returns the top element of the stack.
isEmpty: Returns true if the stack is empty, else false. How to understand a stack practically? 
There are many real-life examples of a stack. Consider the simple example of plates stacked over one another in a canteen. The plate which is at the top is the first one to be removed, i.e. the plate which has been placed at the bottommost position remains in the stack for the longest period of time. So, it can be simply seen to follow the LIFO/FILO order.

Time Complexities of operations on stack:

push(), pop(), isEmpty() and peek() all take O(1) time. We do not run any loop in any of these operations.:# Python program for linked list implementation of stack

# Class to represent a node


class StackNode:

	# Constructor to initialize a node
	def __init__(self, data):
		self.data = data
		self.next = None


class Stack:

	# Constructor to initialize the root of linked list
	def __init__(self):
		self.root = None

	def isEmpty(self):
		return True if self.root is None else False

	def push(self, data):
		newNode = StackNode(data)
		newNode.next = self.root
		self.root = newNode
		print (""% d pushed to stack"" % (data))

	def pop(self):
		if (self.isEmpty()):
			return float(""-inf"")
		temp = self.root
		self.root = self.root.next
		popped = temp.data
		return popped

	def peek(self):
		if self.isEmpty():
			return float(""-inf"")
		return self.root.data


# Driver code
stack = Stack()
stack.push(10)
stack.push(20)
stack.push(30)

print (""% d popped from stack"" % (stack.pop()))
print (""Top element is % d "" % (stack.peek()))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)<|endoftext|>"
453,"<|endoftext|>Given a string s, return the longest palindromic substring in s.

 

Example 1:

Input: s = ""babad""
Output: ""bab""
Explanation: ""aba"" is also a valid answer.
Example 2:

Input: s = ""cbbd""
Output: ""bb""
 

Constraints:

1 <= s.length <= 1000
s consist of only digits and English letters.:def longestPalindrome(self, s):
    res = """"
    for i in xrange(len(s)):
        # odd case, like ""aba""
        tmp = self.helper(s, i, i)
        if len(tmp) > len(res):
            res = tmp
        # even case, like ""abba""
        tmp = self.helper(s, i, i+1)
        if len(tmp) > len(res):
            res = tmp
    return res
 
# get the longest palindrome, l, r are the middle indexes   
# from inner to outer
def helper(self, s, l, r):
    while l >= 0 and r < len(s) and s[l] == s[r]:
        l -= 1; r += 1
    return s[l+1:r]<|endoftext|>"
454,"<|endoftext|>You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| <= k and nums[j] == key.

Return a list of all k-distant indices sorted in increasing order.
:class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        
        length = len(nums)
        end = 0   
        output = []
        
        for i in range(length):
            if nums[i] == key:
                start = max(end, i - k)
                end = min(length - 1, i + k) + 1
                output += [index for index in range(start, end)]
                
        return output<|endoftext|>"
455,"<|endoftext|>In the previous article, we have discussed Python Program to Print Series 2, 4, 7, 2, 21, … N
 Given a number N and the task is to print the series (1, 3, 7, 15, 31 … N) till the given number N in Python.
 Examples:
 Example1:
 Input:
 Given Number (Limit) = 5
 Output:
 The above series till the given number{ 5 } is :
 
 1 3 7 15 31
 Example2:
 Input:
 Given Number (Limit) = 9
 Output:
 The above series till the given number{ 9 } is :
 
 1 3 7 15 31 63 127 255 511:# Give the number N as static input and store it in a variable.
 
 gvn_numb = 5
 
 # Take a variable to say itr and initialize its value to 1.
 
 itr = 1
 
 # Take another variable say previous_val and initialize its value to 0.
 
 previous_val = 0
 
 print(""The above series till the given number{"", gvn_numb, ""} is :"")
 
 # Loop until the above-declared variable itr value is less than or equal to the
 
 # given number using the while loop.
 
 while itr &lt;= gvn_numb:
 
  # Inside the loop, Multiply the variable previous_val with 2 and add 1 to the result.
 
  # Store it in the same variable previous_val.
 
  previous_val = (previous_val * 2) + 1
 
  # Print the value of the above previous_val separated by spaces.
 
  print(previous_val, end="" "")
 
  # Increment the above itr value by 1.
 
  itr += 1
 
 </pre><|endoftext|>"
456,"<|endoftext|>Given the number of rows of the diamond pattern, the task is to print the Hollow diamond star pattern in C, C++, and Python

Examples:

Example1:

Input:

given number of rows of diamond =6
Output:

  *
  *  *
  *  *
  *  *
 *  *
*  *
 *  *
  *  *
  *  *
  *  *
  *
Example2:

Input:

given number of rows of diamond =10
given character to print ='^'
Output:

  ^
  ^ ^
  ^  ^
  ^  ^
  ^  ^
  ^  ^
  ^  ^
  ^  ^
 ^  ^
^  ^
 ^  ^
  ^  ^
  ^  ^
  ^  ^
  ^  ^
  ^  ^
  ^  ^
  ^ ^
  ^:# Give the number of rows  as static input and store it in a variable.
diamondrows = 6
# Loop from 1 to the number of rows using For Loop.
for m in range(1, diamondrows+1):
  # Loop from 1 to the number of rows -iterator value of the parent
  # For loop using another For loop(Nested For loop).
  for n in range(1, diamondrows - m + 1):
  # Print the space character in the inner For loop.
  print(end=' ')
  # Loop from 1 to the 2* iterator value of the parent For loop
  # using another For loop(Nested For loop).
  for l in range(1, (2 * m)):
  # If the value of the iterator is equal to 1 or 2* iterator value
  # of the parent loop -1 then print star character.
  if l == 1 or l == m * 2 - 1:
  print('*', end='')
  # Else print space character.
  else:
  print(' ', end='')
  # After the end of the inner for Loops print the Newline Character.
  print()
# loop from number of rows -1 to 0 in decreasing order using For loop.
for m in range(diamondrows - 1, 0, -1):
  # Loop from 1 to number of rows- iterator value
  # of the parent loop using another For loop(Nested For loop)
  for n in range(1, diamondrows - m + 1):
  # Print the space character in the inner For loop.
  print(end=' ')
  # Loop from 1 to the 2* iterator value of the parent For loop
  # using another For loop(Nested For loop).
  for l in range(1, (2 * m)):
  # If the value of the iterator is equal to 1 or 2* iterator value
  # of the parent loop -1 then print star character.
  if l == 1 or l == m * 2 - 1:
  print('*', end='')
  # Else print space character.
  else:
  print(' ', end='')
  # After the end of the inner for Loops print the Newline Character.
  print(<|endoftext|>"
457,"<|endoftext|>In the diamond star pattern program, we will discuss how to print two types of pyramid star pattern programs, first normal pyramid, and second downward pyramid.:# Python program to print diamond star pattern using for loop # take input n = 4 # printing pyramid for i in range(n): for j in range(n-i-1): # print spaces print("""", end="" "") for j in range(2*i+1): # print stars print(""*"", end="""") print() # printing downward pyramid for i in range(n-1): for j in range(i+1): # print spaces print("""", end="" "") for j in range(2*(n-i-1)-1): # print stars print(""*"", end="""") print()<|endoftext|>"
458,"<|endoftext|>Write a SortedMerge() function that takes two lists, each of which is sorted in increasing order, and merges the two together into one list which is in increasing order. SortedMerge() should return the new list. The new list should be made by splicing together the nodes of the first two lists.:"""""" Python program to merge two
sorted linked lists """"""
  
  
# Linked List Node
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
  
  
# Create & Handle List operations
class LinkedList:
    def __init__(self):
        self.head = None
  
    # Method to display the list
    def printList(self):
        temp = self.head
        while temp:
            print(temp.data, end="" "")
            temp = temp.next
  
    # Method to add element to list
    def addToList(self, newData):
        newNode = Node(newData)
        if self.head is None:
            self.head = newNode
            return
  
        last = self.head
        while last.next:
            last = last.next
  
        last.next = newNode
  
  
# Function to merge the lists
# Takes two lists which are sorted
# joins them to get a single sorted list
def mergeLists(headA, headB):
  
    # A dummy node to store the result
    dummyNode = Node(0)
  
    # Tail stores the last node
    tail = dummyNode
    while True:
  
        # If any of the list gets completely empty
        # directly join all the elements of the other list
        if headA is None:
            tail.next = headB
            break
        if headB is None:
            tail.next = headA
            break
  
        # Compare the data of the lists and whichever is smaller is
        # appended to the last of the merged list and the head is changed
        if headA.data <= headB.data:
            tail.next = headA
            headA = headA.next
        else:
            tail.next = headB
            headB = headB.next
  
        # Advance the tail
        tail = tail.next
  
    # Returns the head of the merged list
    return dummyNode.next<|endoftext|>"
459,"<|endoftext|>Mubashir is getting old but he wants to celebrate his 20th or 21st birthday only. It is possible with some basic maths skills. He just needs to select the correct number base with your help!
For example, if his current age is 22, that's exactly 20 - in base 11. Similarly, 65 is exactly 21 - in base 32 and so on.
Create a function that takes his current age and returns the given age 20 (or 21) years, with number base in the format specified in the below examples.
Examples
happy_birthday(22) ➞ ""Mubashir is just 20, in base 11!""

happy_birthday(65) ➞ ""Mubashir is just 21, in base 32!""

happy_birthday(83) ➞ ""Mubashir is just 21, in base 41!""
Notes
Given age will always be greater than 21.:def happy_birthday(age):
  return ""Mubashir is just {}, in base {}!"".format(20 + age%2, age//2)<|endoftext|>"
460,"<|endoftext|>A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time.
Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. time[i] * satisfaction[i].
Return the maximum sum of like-time coefficient that the chef can obtain after dishes preparation.
Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.
 
Example 1:

Input: satisfaction = [-1,-8,0,5,-9]
Output: 14
Explanation: After Removing the second and last dish, the maximum total like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14).
Each dish is prepared in one unit of time.
Example 2:

Input: satisfaction = [4,3,2]
Output: 20
Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)

Example 3:

Input: satisfaction = [-1,-4,-5]
Output: 0
Explanation: People do not like the dishes. No dish is prepared.

 
Constraints:

n == satisfaction.length
1 <= n <= 500
-1000 <= satisfaction[i] <= 1000:def maxSatisfaction(self, A):
  res = total = 0
  A.sort()
  while A and A[-1] + total > 0:
  total += A.pop()
  res += total
  return res<|endoftext|>"
461,"<|endoftext|>There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:

In each step, you will choose any 3 piles of coins (not necessarily consecutive).
Of your choice, Alice will pick the pile with the maximum number of coins.
You will pick the next pile with the maximum number of coins.
Your friend Bob will pick the last pile.
Repeat until there are no more piles of coins.

Given an array of integers piles where piles[i] is the number of coins in the ith pile.
Return the maximum number of coins that you can have.
 
Example 1:

Input: piles = [2,4,1,2,7,8]
Output: 9
Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.
Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.
The maximum number of coins which you can have are: 7 + 2 = 9.
On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.

Example 2:

Input: piles = [2,4,5]
Output: 4

Example 3:

Input: piles = [9,8,7,6,5,1,2,3,4]
Output: 18

 
Constraints:

3 <= piles.length <= 105
piles.length % 3 == 0
1 <= piles[i] <= 104:def maxCoins(self, A):
  return sum(sorted(A)[len(A) / 3::2])<|endoftext|>"
462,"<|endoftext|>Given two binary trees original and cloned and given a reference to a node target in the original tree.

The cloned tree is a copy of the original tree.

Return a reference to the same node in the cloned tree.

Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.

 

Example 1:


Input: tree = [7,4,3,null,null,6,19], target = 3
Output: 3
Explanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.
Example 2:


Input: tree = [7], target =  7
Output: 7
Example 3:


Input: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
Output: 4
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
The values of the nodes of the tree are unique.
target node is a node from the original tree and is not null.:class Solution:
  def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
  def it(node):
  if node:
  yield node
  yield from it(node.left)
  yield from it(node.right)
  
  for n1, n2 in zip(it(original), it(cloned)):
  if n1 == target:
  return n2<|endoftext|>"
463,"<|endoftext|>In Set 1, unweighted graph is discussed. In this post, weighted graph representation using STL is discussed. The implementation is for adjacency list representation of weighted graph. We use two STL containers to represent graph: 

vector : A sequence container. Here we use it to store adjacency lists of all vertices. We use vertex number as index in this vector.
pair : A simple container to store pair of elements. Here we use it to store adjacent vertex number and weight of edge connecting to the adjacent.:# Python3 program to represent undirected 
# and weighted graph. The program basically 
# prints adjacency list representation of graph
  
# To add an edge
def addEdge(adj, u, v, wt):
      
    adj[u].append([v, wt])
    adj[v].append([u, wt])
    return adj
  
# Print adjacency list representation ot graph
def printGraph(adj, V):
      
    v, w = 0, 0
    for u in range(V):
        print(""Node"", u, ""makes an edge with"")
  
        for it in adj[u]:
            v = it[0]
            w = it[1]
            print(""\tNode"", v, ""with edge weight ="", w)
              
        print()
  
# Driver code
if __name__ == '__main__':
      
    V = 5
    adj = [[] for i in range(V)]
  
    adj = addEdge(adj, 0, 1, 10)
    adj = addEdge(adj, 0, 4, 20)
    adj = addEdge(adj, 1, 2, 30)
    adj = addEdge(adj, 1, 3, 40)
    adj = addEdge(adj, 1, 4, 50)
    adj = addEdge(adj, 2, 3, 60)
    adj = addEdge(adj, 3, 4, 70)
  
    printGraph(adj, V)
  
# This code is contributed by mohit kumar 29
<|endoftext|>"
464,"<|endoftext|>Output Variables:x = ""Python is awesome""
print(x)<|endoftext|>"
465,"<|endoftext|>Swap all Odd and Even Bits of a Number (Static Input):# Give the number as static input and store it in a variable.
numb = 185
# To extract the odd bits from the number,
# use a bitwise AND operation with hexadecimal 55555555.
oddbitsnumb = numb & 0x55555555
# To extract the even bits from the number,
# use a bitwise AND operation with hexadecimal AAAAAAAA.
evenbitsnumb = numb & 0xAAAAAAAA
# Perform a left shift << by 1 position to move odd bits to even positions.
oddbitsnumb = oddbitsnumb << 1
# Perform a right shift >> by 1 place to move even bits to odd positions.
evenbitsnumb = evenbitsnumb >> 1
# Finally, using the bitwise OR operator, to combine both bits.
modifdnumb = oddbitsnumb | evenbitsnumb
# Print the modified Number after swapping odd and even bits of the given number.
print('The original given number is =', numb)
print('The modified number after swapping bits is =', modifdnumb)<|endoftext|>"
466,"<|endoftext|>The name of this searching algorithm may be misleading as it works in O(Log n) time. The name comes from the way it searches an element.

Given a sorted array, and an element x to be 
searched, find position of x in the array.

Input:  arr[] = {10, 20, 40, 45, 55}
        x = 45
Output: Element found at index 3

Input:  arr[] = {10, 15, 25, 45, 55}
        x = 15
Output: Element found at index 1:# Python program to find an element x
# in a sorted array using Exponential Search

# A recursive binary search function returns
# location of x in given array arr[l..r] is
# present, otherwise -1
def binarySearch( arr, l, r, x):
	if r >= l:
		mid = l + ( r-l ) // 2
		
		# If the element is present at
		# the middle itself
		if arr[mid] == x:
			return mid
		
		# If the element is smaller than mid,
		# then it can only be present in the
		# left subarray
		if arr[mid] > x:
			return binarySearch(arr, l,
								mid - 1, x)
		
		# Else he element can only be
		# present in the right
		return binarySearch(arr, mid + 1, r, x)
		
	# We reach here if the element is not present
	return -1

# Returns the position of first
# occurrence of x in array
def exponentialSearch(arr, n, x):
	# IF x is present at first
	# location itself
	if arr[0] == x:
		return 0
		
	# Find range for binary search
	# j by repeated doubling
	i = 1
	while i < n and arr[i] <= x:
		i = i * 2
	
	# Call binary search for the found range
	return binarySearch( arr, i // 2,
						min(i, n-1), x)
	

# Driver Code
arr = [2, 3, 4, 10, 40]
n = len(arr)
x = 10
result = exponentialSearch(arr, n, x)
if result == -1:
	print (""Element not found in the array"")
else:
	print (""Element is present at index %d"" %(result))

# This code is contributed by Harshit Agrawal<|endoftext|>"
467,"<|endoftext|>Given a character array s, reverse the order of the words.

A word is defined as a sequence of non-space characters. The words in s will be separated by a single space.

Your code must solve the problem in-place, i.e. without allocating extra space.

 

Example 1:

Input: s = [""t"",""h"",""e"","" "",""s"",""k"",""y"","" "",""i"",""s"","" "",""b"",""l"",""u"",""e""]
Output: [""b"",""l"",""u"",""e"","" "",""i"",""s"","" "",""s"",""k"",""y"","" "",""t"",""h"",""e""]
Example 2:

Input: s = [""a""]
Output: [""a""]:class Solution:
    def reverse(self, l: list, left: int, right: int) -> None:
        while left < right:
            l[left], l[right] = l[right], l[left]
            left, right = left + 1, right - 1
            
    def reverse_each_word(self, l: list) -> None:
        n = len(l)
        start = end = 0
        
        while start < n:
            # go to the end of the word
            while end < n and l[end] != ' ':
                end += 1
            # reverse the word
            self.reverse(l, start, end - 1)
            # move to the next word
            start = end + 1
            end += 1
            
    def reverseWords(self, s: List[str]) -> None:
        """"""
        Do not return anything, modify s in-place instead.
        """"""
        # reverse the whole string
        self.reverse(s, 0, len(s) - 1)
        
        # reverse each word
        self.reverse_each_word(s)<|endoftext|>"
468,"<|endoftext|>Find Numbers Divisible by 7 and Multiple of 5 in Given Range Using for loop (User input):# Scan lower limit range as user input
lowerlimit = int(input(""Enter some random lower limit =""))
# Scan upper limit range as user  input
upperlimit = int(input(""Enter some random lower limit =""))
# Then using if conditional statement check whether the given
# iterator value is divisible by 7 and a multiple of 5.
print(""The number which is divisible by 7 and multiple of 5 :"")
for numb in range(lowerlimit, upperlimit+1):
  # If the if condition statement is true then print it.
    if(numb % 7 == 0 and numb % 5 == 0):
        print('Number =', numb)<|endoftext|>"
469,"<|endoftext|>Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The cost of each insertion is the minimum of the following:

The number of elements currently in nums that are strictly less than instructions[i].
The number of elements currently in nums that are strictly greater than instructions[i].

For example, if inserting element 3 into nums = [1,2,3,5], the cost of insertion is min(2, 1) (elements 1 and 2 are less than 3, element 5 is greater than 3) and nums will become [1,2,3,3,5].
Return the total cost to insert all elements from instructions into nums. Since the answer may be large, return it modulo 109 + 7
 
Example 1:

Input: instructions = [1,5,6,2]
Output: 1
Explanation: Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 5 with cost min(1, 0) = 0, now nums = [1,5].
Insert 6 with cost min(2, 0) = 0, now nums = [1,5,6].
Insert 2 with cost min(1, 2) = 1, now nums = [1,2,5,6].
The total cost is 0 + 0 + 0 + 1 = 1.
Example 2:

Input: instructions = [1,2,3,6,5,4]
Output: 3
Explanation: Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 2 with cost min(1, 0) = 0, now nums = [1,2].
Insert 3 with cost min(2, 0) = 0, now nums = [1,2,3].
Insert 6 with cost min(3, 0) = 0, now nums = [1,2,3,6].
Insert 5 with cost min(3, 1) = 1, now nums = [1,2,3,5,6].
Insert 4 with cost min(3, 2) = 2, now nums = [1,2,3,4,5,6].
The total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3.

Example 3:

Input: instructions = [1,3,3,3,2,4,2,1,2]
Output: 4
Explanation: Begin with nums = [].
Insert 1 with cost min(0, 0) = 0, now nums = [1].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3].
Insert 3 with cost min(1, 0) = 0, now nums = [1,3,3,3].
Insert 2 with cost min(1, 3) = 1, now nums = [1,2,3,3,3].
Insert 4 with cost min(5, 0) = 0, now nums = [1,2,3,3,3,4].
​​​​​​​Insert 2 with cost min(1, 4) = 1, now nums = [1,2,2,3,3,3,4].
​​​​​​​Insert 1 with cost min(0, 6) = 0, now nums = [1,1,2,2,3,3,3,4].
​​​​​​​Insert 2 with cost min(2, 4) = 2, now nums = [1,1,2,2,2,3,3,3,4].
The total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4.

 
Constraints:

1 <= instructions.length <= 105
1 <= instructions[i] <= 105:def createSortedArray(self, A):
  m = max(A)
  c = [0] * (m + 1)

  def update(x):
  while (x <= m):
  c[x] += 1
  x += x & -x

  def get(x):
  res = 0
  while (x > 0):
  res += c[x]
  x -= x & -x
  return res

  res = 0
  for i, a in enumerate(A):
  res += min(get(a - 1), i - get(a))
  update(a)
  return res % (10**9 + 7)<|endoftext|>"
470,"<|endoftext|>We will develop a Python program to concatenate string and int using the native method, str() function, format(), and % operator. If the string is “Know Program” and the number is 100. Then, after concatenation string will be “Know Program 100”.:# Python program to concatenate string and int # take integer string = 'Know Program' # take integer integer = 100 # concatenate string and int print(string, integer)<|endoftext|>"
471,"<|endoftext|>If you are new to Java and want to learn the java coding skills too fast. Try practicing the core java programs with the help of the Java basic programs list available.

We’ll look at how to make a countdown timer in Python. The code will accept the user’s input on the length of the countdown in seconds. Following that, a countdown in the format ‘minutes: seconds’ will commence on the screen. Here, we’ll make use of the time module.:# Import the time module using the import statement.
import time

# creating a function time which counts the time


def countdownTime(tim):
    # A while loop is used in this function until the time reaches zero.
    while (tim):
       # To calculate the number of minutes and seconds, use divmod(). 
        timemins, timesecs = divmod(tim, 60)
    # Now, using the variable timeformat, output the minutes and seconds on the screen.
        timercount = '{:02d}:{:02d}'.format(timemins, timesecs)
    # By using end = '\n', we force the cursor to return to the
    # beginning of the screen (carriage return),
    # causing the following line written to overwrite the preceding one.
        print(timercount, end=""\n"")
    # The time. sleep() function is used to make the program wait one second.
        time.sleep(1)
    # Now decrement time so that the while loop can reach a finish.
        tim -= 1
    # After the loop is completed, we will print ""The Given time is completed"" to indicate the conclusion of the countdown.
    print('The Given time is completed')


# Then in seconds, Give the length of the countdown as static input and store it in a variable.
tim = 5

# Passing the given time as argument to the countdownTime() function
countdownTime(tim)<|endoftext|>"
472,"<|endoftext|>Create a function that takes a number and returns a string like square.
Examples
create_square(-1) ➞ """"

create_square(0) ➞ """"

create_square(1) ➞ ""#""

create_square(2) ➞ ""##\n##""

create_square(3) ➞ ""###\n# #\n###""

create_square(4) ➞ ""####\n#  #\n#  #\n####""
""####
#  #
#  #
####""
Notes
N/A:def create_square(n):
  if not n or n < 1:
    return ''
  elif n == 1:
    return '#'
  else:
    top = ['#'*n]
    bot = ['#'*n]
    mid = ['#' + ' '*(n-2) + '#'] * (n-2)
    return '\n'.join(top+mid+bot)<|endoftext|>"
473,"<|endoftext|>Create a function that takes two integers, num and n, and returns an integer which is divisible by n and is the closest to num. If there are two numbers equidistant from num and divisible by n, select the larger one.
Examples
round_number(33, 25) ➞ 25

round_number(46, 7) ➞ 49

round_number(133, 14) ➞ 140
Notes
n will always be a positive number.:def round_number(num, n):
  down, up = num%n, -num%n
  return num - down if down < up else num + up<|endoftext|>"
474,"<|endoftext|>Given a Binary Tree, find the maximum(or minimum) element in it. For example, maximum in the following Binary Tree is 9.


 :# Python3 program to find maximum
# and minimum in a Binary Tree
 
# A class to create a new node
 
 
class newNode:
    def __init__(self, data):
        self.data = data
        self.left = self.right = None
 
# Returns maximum value in a
# given Binary Tree
 
 
def findMax(root):
 
    # Base case
    if (root == None):
        return float('-inf')
 
    # Return maximum of 3 values:
    # 1) Root's data 2) Max in Left Subtree
    # 3) Max in right subtree
    res = root.data
    lres = findMax(root.left)
    rres = findMax(root.right)
    if (lres > res):
        res = lres
    if (rres > res):
        res = rres
    return res
 
 
# Driver Code
if __name__ == '__main__':
    root = newNode(2)
    root.left = newNode(7)
    root.right = newNode(5)
    root.left.right = newNode(6)
    root.left.right.left = newNode(1)
    root.left.right.right = newNode(11)
    root.right.right = newNode(9)
    root.right.right.left = newNode(4)
 
    # Function call
    print(""Maximum element is"",
          findMax(root))
 
# This code is contributed by PranchalK
<|endoftext|>"
475,"<|endoftext|>You might get text that looks like it's all English characters but it very well may not be: pànts != pants
To ensure that you only get the characters you want in a string you will need to use the character classes that accept hexadecimal digits.
Write a regular expression that will match the word ""edabit"". Use the hexadecimal character classes \x or \u in your expression.
You are not allowed to use any of the following characters: \w, \W, \d, \D, \t, \T, \S, \c, ., [, ] as well as any of the letters in the word edabit.
Example
txt = ""edabit""
pattern = ""yourregularexpressionhere""

bool(re.match(""^{}$"".format(pattern), txt)) ➞ True
Notes
You don't need to write a function, just the pattern.
Do not remove import re from the code.
You might want to use a raw string for this challenge.
Find more info on RegEx and character classes in Resources.
You can find all the challenges of this series in my Basic RegEx collection.:import re
pattern = ''.join('\\x'+'{:x}'.format(ord(c)) for c in 'edabit')<|endoftext|>"
476,"<|endoftext|>A string r is a substring or subword of a string s if r is contained within s. A string r is a common substring of s and t if r is a substring of both s and t. A string r is a longest common substring or subword (LCW) of s and t if there is no string that is longer than r and is a common substring of s and t. The problem is to find an LCW of two given strings.:def lcw(u, v):
    """"""Return length of an LCW of strings u and v and its starting indexes.
 
    (l, i, j) is returned where l is the length of an LCW of the strings u, v
    where the LCW starts at index i in u and index j in v.
    """"""
    # c[i][j] will contain the length of the LCW at the start of u[i:] and
    # v[j:].
    c = [[-1]*(len(v) + 1) for _ in range(len(u) + 1)]
 
    for i in range(len(u) + 1):
        c[i][len(v)] = 0
    for j in range(len(v)):
        c[len(u)][j] = 0
 
    lcw_i = lcw_j = -1
    length_lcw = 0
    for i in range(len(u) - 1, -1, -1):
        for j in range(len(v)):
            if u[i] != v[j]:
                c[i][j] = 0
            else:
                c[i][j] = 1 + c[i + 1][j + 1]
                if length_lcw < c[i][j]:
                    length_lcw = c[i][j]
                    lcw_i = i
                    lcw_j = j
 
    return length_lcw, lcw_i, lcw_j
 
 
u = input('Enter first string: ')
v = input('Enter second string: ')
length_lcw, lcw_i, lcw_j = lcw(u, v)
print('Longest Common Subword: ', end='')
if length_lcw > 0:
    print(u[lcw_i:lcw_i + length_lcw])<|endoftext|>"
477,"<|endoftext|>Given two numbers base value and the exponential value, the task is to find the power of base and exponent modular 10^9+7:# Take a variable to say numb and initialize its value with 1000000007(10^9+7).
numb = 1000000007

# Create a function to say exponentl_squaring() which takes the given two base and
# exponential values as the arguments and returns the value of the power of base and
# exponent modular 10^9+7.


def exponentl_squaring(gvn_baseval, gvn_exponentlval):
  # Inside the function, take a variable say p, and initialize its value to 1.
    p = 1
    # Loop until the given exponential value is greater than 0 using the while loop.
    while(gvn_exponentlval > 0):
           # Check if the given exponential value is odd using the if conditional statement.
        if (gvn_exponentlval % 2 != 0):
            # If it is true, multiply p with the given base value and store it in another
            # variable.
            k = p * gvn_baseval
            # Calculate the value of the above result modulus numb(10^9+7) and store it in the
            # same variable p.
            p = k % numb
      # Multiply the given base value with itself and apply the modulus operator with
      # 10^9+7(numb).
      # Store it in the same variable given base value.
        gvn_baseval = (gvn_baseval * gvn_baseval) % numb
        # Divide the given exponential value by 2 and convert it to an integer using the
        # int() function.
        # Store it in the same variable given exponential value.
        gvn_exponentlval = int(gvn_exponentlval / 2)
   # Return the value of p modulus 10^9+7.
    return p % numb

# Give the base value as user input using the int(input()) function and store it in a variable.
gvn_baseval = int(input(""Enter some random number = ""))
# Give the exponential value as user input using the int(input()) function and 
# store it in another variable.
gvn_exponentlval = int(input(""Enter some random number = ""))
# Pass the given base and exponential values as the arguments to the exponentl_squaring()
# function and store it in a variable.
rslt = exponentl_squaring(gvn_baseval, gvn_exponentlval)
# Print the value of the power of base and exponent modular 10^9+7.
print(""The value of the power of base and exponent modular 10^9+7 = "", rslt)<|endoftext|>"
478,"<|endoftext|>Your goal is to create a function that returns a list with a string for each of the 108 tiles in the following format:
""rank suit""
Where rank is a number from 1 to 9 and suit is one of the three suits (tong, tiao, wan), both written in the pinyin transcription of Mandarin Chinese (for numbers see table below).
Number Character Pinyin
1 一 yi
2 二 er
3 三 san
4 四 si
5 五 wu
6 六 liu
7 七 qi
8 八 ba
9 九 jiu
Three of the tiles have special names. Each of the 4 copies of these tiles should be represented by their names only (no suit, no rank):
One of tong is called bing gan (饼干, cookie)
Two of tong is called yan jing (眼镜, glasses)
One of tiao is called ji (鸡, chicken)
Examples of tiles
Five of tong ➞ ""wu tong""

Seven of wan ➞ ""qi wan""

One of tiao ➞ ""ji""

Three of tiao ➞ ""san tiao""
Notes
Don't forget to include 4 copies of each tile.
Don't forget to substitute the tiles with special names.
You can return the tiles in any order.:def gen_tiles():
  suits = ['tong', 'tiao', 'wan']
  ranks = ['yi', 'er', 'san', 'si', 'wu', 'liu', 'qi', 'ba', 'jiu']
  special = {'yi tong': 'bing gan', 'er tong': 'yan jing', 'yi tiao': 'ji'}
  tiles = ['{} {}'.format(r, s) for s in suits for r in ranks] * 4
  return [special[i] if i in special else i for i in tiles]<|endoftext|>"
479,"<|endoftext|>Write a function that returns the number of users in a chatroom based on the following rules:
If there is no one, return ""no one online"".
If there is 1 person, return ""user1 online"".
If there are 2 people, return ""user1 and user2 online"".
If there are n>2 people, return the first two names and add ""and n-2 more online"".
For example, if there are 5 users, return:
""user1, user2 and 3 more online""
Examples
chatroom_status([]) ➞ ""no one online""

chatroom_status([""paRIE_to""]) ➞ ""paRIE_to online""

chatroom_status([""s234f"", ""mailbox2""]) ➞ ""s234f and mailbox2 online""

chatroom_status([""pap_ier44"", ""townieBOY"", ""panda321"", ""motor_bike5"", ""sandwichmaker833"", ""violinist91""])
➞ ""pap_ier44, townieBOY and 4 more online""
Notes
N/A:def chatroom_status(users):
  if len(users)>2:
    return ', '.join(u for u in users[:2])+' and '+str(len(users)-2)+' more online'
  return ' and '.join([u for u in users])+' online' if users else 'no one online'<|endoftext|>"
480,"<|endoftext|>Here, we will develop a Python program to remove character from string. If the string was “KnowProgram” then remove a specific character from the string and the new string will be like “Knowrogram”, “KnoProgram”, “nowProgram”, “Knowprogra”, etc. We will discuss how to remove characters from the given string using native methods, replace(), Regular Expression, translate(), join() method, and slice operator.:# Python program to remove character from string # take input string = ""Python"" # print original string print (""Original string:"", string) # remove character from string out_string = """" for i in range(0, len(string)): if i != 4: out_string = out_string + string[i] # print string after removal print (""New string:"", out_string)<|endoftext|>"
481,"<|endoftext|>Exercise 8: Rename key of a dictionary:sample_dict = {
    ""name"": ""Kelly"",
    ""age"": 25,
    ""salary"": 8000,
    ""city"": ""New york""
}

sample_dict['location'] = sample_dict.pop('city')
print(sample_dict)<|endoftext|>"
482,"<|endoftext|>Method #1: Using For Loop (Static Input)
Approach:

Give the number of rows as static input and store it in a variable.
Take a variable and initialize it with 2*double the number of rows say lastnumb.
Take another variable and initialize it with the lastnumb say evennumb.
Loop from 1 to the number of rows using For loop.
Initialize the evennumb with the lastnumb.
Loop from 0 to the iterator value of the parent For loop using another for loop(Nested For loop).
Print the evennumb.
Reduce the evennumb by 2.
Print the Newline character after the end of the inner loop.
The Exit of the Program.:# Give the number of rows as static input and store it in a variable.
numberOfRows = 10
# Take a variable and initialize it with 2*double the number of rows say lastnumb.
lastnumb = 2*numberOfRows
# Take another variable and initialize it with the lastnumb say evennumb.
evennumb = lastnumb
# Loop from 1 to the number of rows using For loop.
for m in range(1, numberOfRows+1):
    # Initialize the evennumb with the lastnumb.
    evennumb = lastnumb
    # Loop from 0 to the iterator value of the parent For loop using
    # another for loop(Nested For loop).
    for n in range(0, m):
        # Print the evennumb.
        print(evennumb, end=' ')
        # Reduce the evennumb by 2.
        evennumb = evennumb-2

    # Print the Newline character after the end of the inner loop.
    print()<|endoftext|>"
483,"<|endoftext|>Given a binary number and the task is to get the respective decimal number using the while loop.

Examples:

Example1:

Input:

Given Binary Number = 1000
Output:

The Decimal value of the given binary number { 1000 } is: 
8
Example2:

Input:

Given Binary Number = 1100
Output:

The Decimal value of the given binary number { 1100 } is: 
12:# Give the binary number as static input and store it in a variable.
 gvn_binry_num = 1000
 # Take a variable say 'a 'and initialize its value with 0.
 a = 0
 # Take another variable say deciml_num and initialize its value with 0.
 deciml_num = 0
 print(
  ""The Decimal value of the given binary number {"", gvn_binry_num, ""} is: "")
 # Loop till the given number is not equal to zero using the while loop.
 while (gvn_binry_num != 0):
  # Inside the loop, calculate the value of the given binary number modulus 10
  # (to get the last digit) and store it in a variable say rem.
  rem = gvn_binry_num % 10
  # Calculate the value of the given binary number divided by 10.
 # Store it in the same variable gvn_binry_num.
  gvn_binry_num = gvn_binry_num // 10
  # Multiply rem with the 2 power a using the pow() function and store it in
 # another variable say 'b'.
  b = rem*pow(2, a)
  # Add b with the above deciml_num and store it in the same variable deciml_num.
  deciml_num = deciml_num + b
  # Increment the value a by 1 and store it in the same variable 'a'.
  a = a+1
 # Print the deciml_num to get the decimal value of the given binary number.
 print(deciml_num)<|endoftext|>"
484,"<|endoftext|>In this challenge, you must think about words as elastics. What happens when do you tend an elastic applying a constant traction force at both ends? Every part (or letter, in this case) of the elastic will expand, with the minimum expansion at the ends, and the maximum expansion in the center.
If the word has an odd length, the effective central character of the word will be the pivot that splits the word into two halves.
""ABC"" -> Left = ""A"" | Center = ""B"" | Right = ""C""
If the word has an even length, you will consider two parts of equal length, with the last character of the left half and the first character of the right half being the center.
""ABCD"" -> Left = ""AB"" | Right = ""CD""
You will represent the expansion of a letter repeating it as many times as its numeric position (so counting the indexes from/to 1, and not from 0 as usual) in its half, with a crescent order in the left half and a decrescent order in the right half.
Word = ""ANNA"" 

Left = ""AN""
Right = ""NA""

Left = ""A"" * 1 + ""N"" * 2 = ""ANN""
Right = ""N"" * 2 + ""A"" * 1 = ""NNA""

Word = Left + Right = ""ANNNNA""
If the word has an odd length, the pivot (the central character) will be the peak (as to say, the highest value) that delimits the two halves of the word.
Word = ""KAYAK""

Left = ""K"" * 1 + ""A"" * 2 = ""KAA""
Pivot = ""Y"" * 3 = ""YYY""
Right = ""A"" * 2 + ""K"" * 1 = ""AAK""

Word = Left + Pivot + Right = ""KAAYYYAAK""
Given a word, implement a function that returns the elasticized version of the word as a string.
Examples
elasticize(""ANNA"") ➞ ""ANNNNA""

elasticize(""KAYAK"") ➞ ""KAAYYYAAK""

elasticize(""X"") ➞ ""X""
Notes
For words with less than three characters, the function must return the same word (no traction appliable).
Remember, into the left part characters are counted from 1 to the end, and, in reverse order until 1 is reached, into the right.:def elasticize(word):
    return ''.join(c*(i+1 if i < len(word)/2 else len(word)-i)\
        for i, c in enumerate(word))<|endoftext|>"
485,"<|endoftext|>Exercise 1: Convert two lists into a dictionary:keys = ['Ten', 'Twenty', 'Thirty']
values = [10, 20, 30]

res_dict = dict(zip(keys, values))
print(res_dict)<|endoftext|>"
486,"<|endoftext|>Creating a strong password is essential in everyone’s life nowadays in order to keep your accounts safe and secure. Passwords that are simple and easy to guess can be readily hacked. To avoid this problem, we’ll show you how to create your own safe and secure password using simple Python code.:# Take a variable(say secpassword) and create some random characters as tuple
# (('s', '$'), ('and', '&'), ('a', '@'), ('o', '0'), ('i', '1'), ('I', '|')).
secpassword = (('s', '$'), ('and', '&'),
               ('a', '@'), ('o', '0'), ('i', '1'),
               ('I', '|'))
# Create a function createSecurePassword() which accepts the given password
# as an argument and returns the secure password.


def createSecurePassword(givenpassword):
    # Loop using two variables in the secpassword using For loop.
    for m, n in secpassword:
      # Replace the password with the two variables.
        givenpassword = givenpassword.replace(m, n)
    # Return the modified Password.
    return givenpassword


# Give the password as static input and store it in a variable.
givenpassword = 'Italian'
print('The original Password = ', givenpassword)
# Pass the given password as an argument to createSecurePassword() function.
modifiedpassword = createSecurePassword(givenpassword)
# Print the New Modified Password.

print('The new modified password = ', modifiedpassword)<|endoftext|>"
487,"<|endoftext|>Instructions
Given a string of digits, output all the contiguous substrings of length n in that string in the order that they appear.

For example, the string ""49142"" has the following 3-digit series:

""491""
""914""
""142""
And the following 4-digit series:

""4914""
""9142""
And if you ask for a 6-digit series from a 5-digit string, you deserve whatever you get.

Note that these series are only required to occupy adjacent positions in the input; the digits need not be numerically consecutive.

Exception messages
Sometimes it is necessary to raise an exception. When you do this, you should always include a meaningful error message to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the built in error types, but should still include a meaningful message.

This particular exercise requires that you use the raise statement to ""throw"" a ValueError if the series and/or length parameters input into the slice() function are empty or out of range. The tests will only pass if you both raise the exception and include a message with it.

To raise a ValueError with a message, write the message as an argument to the exception type:

# if the slice length is zero.
raise ValueError(""slice length cannot be zero"")

# if the slice length is negative.
raise ValueError(""slice length cannot be negative"")

# if the series provided is empty.
raise ValueError(""series cannot be empty"")

# if the slice length is longer than the series.
raise ValueError(""slice length cannot be greater than series length""):from typing import List
def slices(digits: str, length: int) -> List[str]:
    if length <= 0:
        raise ValueError('slice length cannot be %s' % ('zero' if length == 0 else 'negative'))
    if not digits:
        raise ValueError('series cannot be empty')
    if len(digits) < length:
        raise ValueError('slice length cannot be greater than series length')
    number_of_series = len(digits) - length + 1
    return [digits[n:n + length] for n in range(number_of_series)]<|endoftext|>"
488,"<|endoftext|>You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location.
Return the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1.
The Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2).
 
Example 1:

Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]
Output: 2
Explanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.
Example 2:

Input: x = 3, y = 4, points = [[3,4]]
Output: 0
Explanation: The answer is allowed to be on the same location as your current location.
Example 3:

Input: x = 3, y = 4, points = [[2,3]]
Output: -1
Explanation: There are no valid points.
 
Constraints:

1 <= points.length <= 104
points[i].length == 2
1 <= x, y, ai, bi <= 104:def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
  index, smallest = -1, math.inf
  for i, (r, c) in enumerate(points):
  dx, dy = x - r, y - c
  if dx * dy == 0 and abs(dx + dy) < smallest:
  smallest = abs(dx + dy)
  index = i
  return index<|endoftext|>"
489,"<|endoftext|>Given the root of a binary tree, return the postorder traversal of its nodes' values.

 

Example 1:


Input: root = [1,null,2,3]
Output: [3,2,1]
Example 2:

Input: root = []
Output: []
Example 3:

Input: root = [1]
Output: [1]:class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def postorderTraversal(self, root):
        traversal, stack = [], [(root, False)]
        while stack:
            node, visited = stack.pop()
            if node:
                if visited:
                    # add to result if visited
                    traversal.append(node.val)
                else:
                    # post-order
                    stack.append((node, True))
                    stack.append((node.right, False))
                    stack.append((node.left, False))

        return traversal<|endoftext|>"
490,"<|endoftext|>If you are new to Java and want to learn the java coding skills too fast. Try practicing the core java programs with the help of the Java basic programs list available.

We’ll look at how to make a countdown timer in Python. The code will accept the user’s input on the length of the countdown in seconds. Following that, a countdown in the format ‘minutes: seconds’ will commence on the screen. Here, we’ll make use of the time module.:# Import the time module using the import statement.
import time

# creating a function time which counts the time


def countdownTime(tim):
    # A while loop is used in this function until the time reaches zero.
    while (tim):
       # To calculate the number of minutes and seconds, use divmod(). 
        timemins, timesecs = divmod(tim, 60)
    # Now, using the variable timeformat, output the minutes and seconds on the screen.
        timercount = '{:02d}:{:02d}'.format(timemins, timesecs)
    # By using end = '\n', we force the cursor to return to the
    # beginning of the screen (carriage return),
    # causing the following line written to overwrite the preceding one.
        print(timercount, end=""\n"")
    # The time. sleep() function is used to make the program wait one second.
        time.sleep(1)
    # Now decrement time so that the while loop can reach a finish.
        tim -= 1
    # After the loop is completed, we will print ""The Given time is completed"" to indicate the conclusion of the countdown.
    print('The Given time is completed')


# Then in seconds, Give the length of the countdown as static input and store it in a variable.
tim = 5

# Passing the given time as argument to the countdownTime() function
countdownTime(tim)<|endoftext|>"
491,"<|endoftext|>Print First k Digits of 1/N where N is a Positive Integer (User Input):# GIve the numbers n and k as user input using map(),int(),split() functions.
# Store them in two separate variables.
numb, k = map(int, input(
    'Enter some random values of numb and k separated by spaces = ').split())
# Calculate the value of 1/n and store it in a variable say divval.
divval = 1/numb
# Calculate the value of 10 power k using the ** operator
# and store it in a variable say powerval.
powerval = 10**k
# Calculate the integer value of the product of divval and powerval
# and store it in another variable say resval.
resval = int(divval*powerval)
# Check if the value of n is equal to 1 or not
# using the If conditional Statement.
if(numb == 1):
        # Convert the resval to string using the str() function
    # and store it in the same variable.
    resval = str(resval)
    # Print the resval in reverse order using slicing.
    print(""The first [""+str(k)+""] digits in the given number [ "" +
          str(numb)+"" ] is :""+str(resval[::-1]))
# If the ""IF"" conditional statement is false then print the value of resval.
else:
    print(""The first [""+str(k)+""] digits in the given number [ "" +
          str(numb)+"" ] is :""+str(resval))<|endoftext|>"
492,"<|endoftext|>The Latin Alphabet Cipher Encryption Technique is one of the quickest and most straightforward methods of encoding data. It’s essentially a replacement cipher method, in which each letter of a given input is replaced by its matching number as represented alphabetically.:# Give the string as user input(which consists of only alphabets and spaces)
# using input() and store it in a variable.
givenstring = input('Enter some random string = ')
print('The encrypted message of the given string{', givenstring, '}is :')
# Iterate through the characters of the string using For loop.
# We can calculate the ASCII value of the character using the ord() function.
for m in givenstring:
    # Now, transform each input string character to its ASCII value
    # and subtract it from the ASCII
    # value of alphabet A for uppercase characters and 'a' for lowercase ones.
    if (m >= ""A"" and m <= ""Z""):
      # The operation is written as ord(givenstring[i])-ord(“A”)+1 for uppercase letters.
        print(ord(m)-ord(""A"")+1, end="" "")
    elif (m >= ""a"" and m <= 'z'):
        # ord(givenstring[i])-ord(“a”)+1 for lowercase letters.
        print(ord(m)-ord(""a"")+1, end="" "")
    # If the character is space then print it(That is printing
    # space character without endl which makes it to print in next line)
    if m == ("" ""):
        print(m)<|endoftext|>"
493,"<|endoftext|>In the previous article, we have discussed Python Program to Convert Binary to Octal using While Loop
 Given a number N the task is to find the sum of the given series 1^2+2^2+3^2…+N^2 for the given number in Python.
 Examples:
 Example1:
 Input:
 Given Number =3
 Output:
 The sum of the series till the given number { 3 } is : 14
 Example2:
 Input:
 Given Number =5
 Output:
 The sum of the series till the given number { 6 } is : 55:# Give the number N as static input and store it in a variable.
 
 gvnNumbr = 5
 
 # Take a variable say resltsum which gives the sum of
 
 # the given series till N and initialize its value to 0.
 
 resltsum = 0
 
 # Loop from 1 to given number using the For loop.
 
 for k in range(1, gvnNumbr+1):
 
  # Inside the For loop,
 
  # Calculate the value of iterator value * iterator value and store it in a variable.
 
  squarevalu = k*k
 
  # Add the above variable to the resltsum
 
  resltsum = resltsum+squarevalu
 
 
 
 # Print the resltsum value which is the result of the series till the given Number N.
 
 print(
 
  'The sum of the series till the given number {', gvnNumbr, '} is :', resltsum)
 
 </pre><|endoftext|>"
494,"<|endoftext|>Create a function that takes any non-negative number as an argument and returns it with its digits in descending order. Descending order is when you sort from highest to lowest.
Examples
sort_descending(123) ➞ 321

sort_descending(1254859723) ➞ 9875543221

sort_descending(73065) ➞ 76530
Notes
You can expect non-negative numbers for all test cases.:def sort_descending(num):
  return int(''.join(sorted(str(num), reverse = True)))<|endoftext|>"
495,"<|endoftext|>The string ""PAYPALISHIRING"" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: ""PAHNAPLSIIGYIR""

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
 

Example 1:

Input: s = ""PAYPALISHIRING"", numRows = 3
Output: ""PAHNAPLSIIGYIR""
Example 2:

Input: s = ""PAYPALISHIRING"", numRows = 4
Output: ""PINALSIGYAHRPI""
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I
Example 3:

Input: s = ""A"", numRows = 1
Output: ""A""
 

Constraints:

1 <= s.length <= 1000
s consists of English letters (lower-case and upper-case), ',' and '.'.
1 <= numRows <= 1000:class Solution(object):
    def convert(self, s, numRows):
        """"""
        :type s: str
        :type numRows: int
        :rtype: str
        """"""
        if numRows == 1 or numRows >= len(s):
            return s

        L = [''] * numRows
        index, step = 0, 1

        for x in s:
            L[index] += x
            if index == 0:
                step = 1
            elif index == numRows -1:
                step = -1
            index += step

        return ''.join(L)<|endoftext|>"
496,"<|endoftext|>Write a program that unsets the rightmost set bit of an integer. :# unsets the rightmost set bit
# of n and returns the result
def fun(n):

	return n & (n-1)

# Driver code

n = 7
print(""The number after unsetting the rightmost set bit"", fun(n))

# This code is contributed
# by Anant Agarwal.
<|endoftext|>"
497,"<|endoftext|>List in Python :
 The list data type is one of the most often used data types in Python. The square brackets [ ] easily identify a Python List. Lists are used to store data items, with each item separated by a comma (,). A Python List can include data elements of any data type, including integers and Booleans.
 One of the primary reasons that lists are so popular is that they are mutable. Any data item in a List can be replaced by any other data item if it is mutable. This distinguishes Lists from Tuples, which are likewise used to store data elements but are immutable.
 Given a list, the task is to sort the list according to the length of the elements in the given list
 Example:
 Input:
 given list = [""hello"", ""this"", ""is"", ""BTechGeeks"", ""online"", ""platform"", ""for"", ""Python"", ""and"", ""many"", ""Programming"", ""languages""]
 Output:
 printing the given list before sorting according to length : 
 
 ['hello', 'this', 'is', 'BTechGeeks', 'online', 'platform', 'for', 'Python', 'and', 'many', 'Programming', 'languages']
 
 printing the given list after sorting according to length : 
 
 ['is', 'for', 'and', 'this', 'many', 'hello', 'online', 'Python', 'platform', 'languages', 'BTechGeeks', 'Programming']:def lengthSort(given_list):
 
  # sorting the given list by length of elements of the given list
 
  given_list.sort(key=len)
 
  # return the list
 
  return given_list
 
 
 
 
 
 # given list
 
 given_list = [""hello"", ""this"", ""is"", ""BTechGeeks"", ""online"", ""platform"",
 
  ""for"", ""Python"", ""and"", ""many"", ""Programming"", ""languages""]
 
 # printing the given list before sorting according to length
 
 print(""printing the given list before sorting according to length : "")
 
 print(given_list)
 
 # passing the given_list to lengthSort function to sort
 
 # the list according to the length of the elements of the given list
 
 # printing the given list before sorting according to length
 
 print(""printing the given list after sorting according to length : "")
 
 print(lengthSort(given_list))<|endoftext|>"
498,"<|endoftext|>Given a number, return a string of the word ""Boom"", which varies in the following ways:

The string should include n number of ""o""s, unless n is below 2 (in that case, return ""boom"").
If n is evenly divisible by 2, add an exclamation mark to the end.
If n is evenly divisible by 5, return the string in ALL CAPS.
The example below should help clarify these instructions.

Examples
boom_intensity(4) ➞ ""Boooom!""
# There are 4 ""o""s and 4 is divisible by 2 (exclamation mark included)

boom_intensity(1) ➞ ""boom""
# 1 is lower than 2, so we return ""boom""

boom_intensity(5) ➞ ""BOOOOOM""
# There are 5 ""o""s and 5 is divisible by 5 (all caps)

boom_intensity(10) ➞ ""BOOOOOOOOOOM!""
# There are 10 ""o""s and 10 is divisible by 2 and 5 (all caps and exclamation mark included):def boom_intensity(n):
	if n < 2:
		return 'boom'
	return 'B' + ('oO'[n%5==0])*n + 'mM'[n%5==0] + '!'*(1-n%2)<|endoftext|>"
499,"<|endoftext|>In this program, we will create a doubly linked list and remove the duplicate, if present, by traversing through the list.
:#Represent a node of doubly linked list    
class Node:    
    def __init__(self,data):    
        self.data = data;    
        self.previous = None;    
        self.next = None;    
            
class RemoveDuplicate:    
    #Represent the head and tail of the doubly linked list    
    def __init__(self):    
        self.head = None;    
        self.tail = None;    
            
    #addNode() will add a node to the list    
    def addNode(self, data):    
        #Create a new node    
        newNode = Node(data);    
            
        #If list is empty    
        if(self.head == None):    
            #Both head and tail will point to newNode    
            self.head = self.tail = newNode;    
            #head's previous will point to None    
            self.head.previous = None;    
            #tail's next will point to None, as it is the last node of the list    
            self.tail.next = None;    
        else:    
            #newNode will be added after tail such that tail's next will point to newNode    
            self.tail.next = newNode;    
            #newNode's previous will point to tail    
            newNode.previous = self.tail;    
            #newNode will become new tail    
            self.tail = newNode;    
            #As it is last node, tail's next will point to None    
            self.tail.next = None;    
                
    #removeDuplicateNode() will remove duplicate nodes from the list    
    def removeDuplicateNode(self):    
            
        #Checks whether list is empty    
        if(self.head == None):    
            return;    
        else:    
            #Initially, current will point to head node    
            current = self.head;    
            while(current != None):    
                #index will point to node next to current    
                index = current.next    
                while(index != None):    
                    if(current.data == index.data):    
                        #Store the duplicate node in temp    
                        temp = index;    
                        #index's previous node will point to node next to index thus, removes the duplicate node    
                        index.previous.next = index.next;    
                        if(index.next != None):    
                            index.next.previous = index.previous;    
                        #Delete duplicate node by making temp to None    
                        temp = None;    
                    index = index.next;    
                current = current.next;    
                            
    #display() will print out the nodes of the list    
    def display(self):    
        #Node current will point to head    
        current = self.head;    
        if(self.head == None):    
            print(""List is empty"");    
            return;    
        while(current != None):    
            #Prints each node by incrementing pointer.    
            print(current.data),    
            current = current.next;    
        print();    
            
dList = RemoveDuplicate();    
#Add nodes to the list    
dList.addNode(1);    
dList.addNode(2);    
dList.addNode(3);    
dList.addNode(2);    
dList.addNode(2);    
dList.addNode(4);    
dList.addNode(5);    
dList.addNode(3);    
     
print(""Originals list: "");    
dList.display();    
     
#Removes duplicate nodes    
dList.removeDuplicateNode();    
     
print(""List after removing duplicates: "");    
dList.display();    <|endoftext|>"
500,"<|endoftext|>Given a list of scrabble tiles (as dictionaries), create a function that outputs the maximum possible score a player can achieve by summing up the total number of points for all the tiles in their hand. Each hand contains 7 scrabble tiles.
Here's an example hand:
[
  { ""tile"": ""N"", ""score"": 1 },
  { ""tile"": ""K"", ""score"": 5 },
  { ""tile"": ""Z"", ""score"": 10 },
  { ""tile"": ""X"", ""score"": 8 },
  { ""tile"": ""D"", ""score"": 2 },
  { ""tile"": ""A"", ""score"": 1 },
  { ""tile"": ""E"", ""score"": 1 }
]
The player's maximum_score from playing all these tiles would be 1 + 5 + 10 + 8 + 2 + 1 + 1, or 28.
Examples
maximum_score([
  { ""tile"": ""N"", ""score"": 1 },
  { ""tile"": ""K"", ""score"": 5 },
  { ""tile"": ""Z"", ""score"": 10 },
  { ""tile"": ""X"", ""score"": 8 },
  { ""tile"": ""D"", ""score"": 2 },
  { ""tile"": ""A"", ""score"": 1 },
  { ""tile"": ""E"", ""score"": 1 }
]) ➞ 28

maximum_score([
  { ""tile"": ""B"", ""score"": 2 },
  { ""tile"": ""V"", ""score"": 4 },
  { ""tile"": ""F"", ""score"": 4 },
  { ""tile"": ""U"", ""score"": 1 },
  { ""tile"": ""D"", ""score"": 2 },
  { ""tile"": ""O"", ""score"": 1 },
  { ""tile"": ""U"", ""score"": 1 }
]) ➞ 15
Notes
Here, each tile is represented as an dictionary with two keys: tile and score.:def maximum_score(tile_hand):
  return sum([i['score'] for i in tile_hand])<|endoftext|>"
501,"<|endoftext|>Given a string, which contains duplicate characters the task is to remove the adjacent duplicate characters from the given string.:# Function to remove adjacent duplicates characters from a string
def remAdj(givenstrng):
    # convert the given string to list using list() function
    charslist = list(givenstrng)
    prevele = None
    p = 0
    # Traverse the given string
    for chars in givenstrng:
        if prevele != chars:
            charslist[p] = chars
            prevele = chars
            p = p + 1
    # join the list which contains characters to string using join function and return it
    return ''.join(charslist[:p])


# Driver code
# Give the string as user input using the input() function.
# Store it in a variable.
givenstrng = input('Enter some random string = ')
# printing the given string before removing adjacent duplicate characters
print('given string before removing adjacent duplicate characters = ', givenstrng)
# Pass the given string to the remAdj function which accepts
# the given string as the argument
# and returns the modified string with no adjacent duplicates.
modistring = remAdj(givenstrng)
# printing the given string after removing adjacent duplicate characters
print('given string without after adjacent duplicate characters = ', modistring)<|endoftext|>"
502,"<|endoftext|>Given three corner points of a triangle, and one more point P. Write a function to check whether P lies within the triangle or not.
For example, consider the following program, the function should return true for P(10, 15) and false for P'(30, 15) 

              B(10,30)
                / \
               /   \
              /     \
             /   P   \      P'
            /         \
     A(0,0) ----------- C(20,0) 
Solution: 
Let the coordinates of three corners be (x1, y1), (x2, y2) and (x3, y3). And coordinates of the given point P be (x, y)
1) Calculate area of the given triangle, i.e., area of the triangle ABC in the above diagram. Area A = [ x1(y2 – y3) + x2(y3 – y1) + x3(y1-y2)]/2 
2) Calculate area of the triangle PAB. We can use the same formula for this. Let this area be A1. 
3) Calculate area of the triangle PBC. Let this area be A2. 
4) Calculate area of the triangle PAC. Let this area be A3. 
5) If P lies inside the triangle, then A1 + A2 + A3 must be equal to A. :# A utility function to calculate area
# of triangle formed by (x1, y1),
# (x2, y2) and (x3, y3)

def area(x1, y1, x2, y2, x3, y3):

	return abs((x1 * (y2 - y3) + x2 * (y3 - y1)
				+ x3 * (y1 - y2)) / 2.0)


# A function to check whether point P(x, y)
# lies inside the triangle formed by
# A(x1, y1), B(x2, y2) and C(x3, y3)
def isInside(x1, y1, x2, y2, x3, y3, x, y):

	# Calculate area of triangle ABC
	A = area (x1, y1, x2, y2, x3, y3)

	# Calculate area of triangle PBC
	A1 = area (x, y, x2, y2, x3, y3)
	
	# Calculate area of triangle PAC
	A2 = area (x1, y1, x, y, x3, y3)
	
	# Calculate area of triangle PAB
	A3 = area (x1, y1, x2, y2, x, y)
	
	# Check if sum of A1, A2 and A3
	# is same as A
	if(A == A1 + A2 + A3):
		return True
	else:
		return False

# Driver program to test above function
# Let us check whether the point P(10, 15)
# lies inside the triangle formed by
# A(0, 0), B(20, 0) and C(10, 30)
if (isInside(0, 0, 20, 0, 10, 30, 10, 15)):
	print('Inside')
else:
	print('Not Inside')

# This code is contributed by Danish Raza<|endoftext|>"
503,"<|endoftext|>Trimorphic Number:

Cube the number you’ve been given. If the given number appears in the cube number in the last means, it is referred to as a trimorphic number.

For example:

Let the given number =25

The cube of the number = 25*25*25= 15625

The Given number 25 is present at the end.

Therefore, 25 is a Trimorphic Number.

The examples of the first few Trimorphic Numbers are 1, 4, 5, 6, 9, 24, 25, 49, 51, 75, 76, 99, 125, 249, 251, 375, 376, 499, and so on.

Given the number and the task is to check whether the given number is a Trimorphic Number or not.

Examples:

Example1:

Input:

Given Number = 75
Output:

The given number { 75 } is a Trimorphic number:# Give the number as static input and store it in a variable.
gvn_numb = 75
# Calculate the cube root of the given number and convert it into the string using the str() function.
# Store it in another variable.
cube_numb = str(gvn_numb**3)
# Convert the given number to a string using the str() function and store it in
# another variable.
str_numb = str(gvn_numb)
# Calculate the length of the above-obtained string number using the len() function
# and store it in another variable.
len_str = len(str_numb)
# Check if the cube_root[-len_string:](negative slicing)  is equal to the string number using the
# if conditional statement and slicing.
if(cube_numb[-len_str:] == str_numb):
  # If the statement is true, then print ""The given number is a Trimorphic Number"".
    print(""The given number {"", gvn_numb, ""} is a Trimorphic number"")
else:
  # If it is false, then print ""The given number is Not a Trimorphic Number"".
    print(""The given number {"", gvn_numb, ""} is Not a Trimorphic number"")<|endoftext|>"
504,"<|endoftext|>Create a function that takes a positive integer number (one of base2, base8, or base16) and converts the integer into the given base and returns a string using recursion.
Examples
integer_to_string(10 , 2) ➞ ""1010""
# Base = 2

integer_to_string(1642 , 8) ➞ ""3152""
# Base = 8

integer_to_string(212 , 16) ➞ ""d4""
# Base = 16
Notes
Input is a positive integer and base = 2, 8, or 16.
Please use recursion to solve this.:def integer_to_string(number, base):
    change = ""0123456789abcdef""
    if number < base:
        return change[number]
    else:
        return integer_to_string(number // base, base) + change[number % base]<|endoftext|>"
505,"<|endoftext|>Create a function that takes a list of strings and return the number of smiley faces contained within it. These are the components that make up a valid smiley:
A smiley has eyes. Eyes can be : or ;.
A smiley has a nose but it doesn't have to. A nose can be - or ~.
A smiley has a mouth which can be ) or D.
No other characters are allowed except for those mentioned above.
Examples
count_smileys(["":)"", "";("", "";}"", "":-D""]) ➞ 2

count_smileys(["";D"", "":-("", "":-)"", "";~)""]) ➞ 3

count_smileys(["";]"", "":["", "";*"", "":$"", "";-D""]) ➞ 1
Notes
You will always be given a list as input.
An empty list should return 0.
The order of each facial element will always be the same.
Noses are optional (e.g. :) and :-) are both valid).:import re
def count_smileys(lst):
    return len(re.findall(r'[:;][-~]?[)D]', ''.join(lst)))<|endoftext|>"
506,"<|endoftext|>Given a binary tree and a key(node) value, find the floor and ceil value for that particular key value.

Floor Value Node: Node with the greatest data lesser than or equal to the key value. 
Ceil Value Node: Node with the smallest data larger than or equal to the key value.

For example, Let’s consider the Binary Tree below – 

          8
        /   \    
      4      12
    /  \    /  \
   2    6  10   14

Key: 11  Floor: 10  Ceil: 12
Key: 1   Floor: -1  Ceil: 2
Key: 6   Floor: 6   Ceil: 6
Key: 15  Floor: 14  Ceil: -1:# Python3 program to find floor and
# ceil of a given key in BST

# A binary tree node has key,
#. left child and right child
class Node:
	
	def __init__(self, x):
		
		self.data = x
		self.left = None
		self.right = None

# Helper function to find floor and
# ceil of a given key in BST
def floorCeilBSTHelper(root, key):
	
	global floor, ceil

	while (root):
		if (root.data == key):
			ceil = root.data
			floor = root.data
			return
		if (key > root.data):
			floor = root.data
			root = root.right
		else:
			ceil = root.data
			root = root.left

# Display the floor and ceil of a given
# key in BST. If key is less than the min
# key in BST, floor will be -1; If key is
# more than the max key in BST, ceil will be -1;
def floorCeilBST(root, key):
	
	global floor, ceil

	# Variables 'floor' and 'ceil'
	# are passed by reference
	floor = -1
	ceil = -1

	floorCeilBSTHelper(root, key)

	print(key, floor, ceil)

# Driver code
if __name__ == '__main__':
	
	floor, ceil = -1, -1
	
	root = Node(8)
	root.left = Node(4)
	root.right = Node(12)
	root.left.left = Node(2)
	root.left.right = Node(6)
	root.right.left = Node(10)
	root.right.right = Node(14)

	for i in range(16):
		floorCeilBST(root, i)

# This code is contributed by mohit kumar 29<|endoftext|>"
507,"<|endoftext|>Files in Python:

Python File handling is a method that allows you to save the program’s output to a file or read data from a file. In the programming world, file handling is a critical notion. File management is employed in practically every type of project. For example, suppose you’re developing an inventory management system. You have data connected to sales and purchases in the inventory management system, thus you must save that data somewhere. You can save that data to a file using Python file management. If you want to undertake data analysis, you must be given data in the form of a comma-separated file or a Microsoft Excel file. You can read data from a file and also store output back into it using file handling.

Given a file, the task is to count the entire number of lines within the given file in Python.:# Take a variable that stores the count of a number of lines in a given file and initialize it to 0.
linecount = 0
# Enter the file name of the  file using the input() function and store it in a variable.
filename = input(""Enter the file name = "")
# In read mode, open the file with the entered file name.
with open(filename, 'r') as givenfile:
    # Using for loop, Traverse the lines in the file.
    # Increment the value of line count by 1.
    for line in givenfile:
        linecount = linecount+1
# Print the line count.
print('The total number of lines in the given file = ', linecount)<|endoftext|>"
508,"<|endoftext|>Given two lists list1 and list2 containing m and n items respectively. Each item is associated with two fields: name and price. The problem is to count items that are in both the lists but with different prices.

Examples: 

Input : list1[] = {{""apple"", 60}, {""bread"", 20}, 
                   {""wheat"", 50}, {""oil"", 30}}
    list2[] = {{""milk"", 20}, {""bread"", 15}, 
                   {""wheat"", 40}, {""apple"", 60}}
Output : 2
bread and wheat are the two items common to both the
lists but with different prices.:# Python implementation to
# count items common to both
# the lists but with different
# prices

# function to count items
# common to both
# the lists but with different prices
def countItems(list1, list2):
	count = 0
	
	# for each item of 'list1'
	# check if it is in 'list2'
	# but with a different price
	for i in list1:
		for j in list2:

			if i[0] == j[0] and i[1] != j[1]:
				count += 1
	
	# required count of items
	return count

# Driver program to test above
list1 = [(""apple"", 60), (""bread"", 20),
			(""wheat"", 50), (""oil"", 30)]
list2 = [(""milk"", 20), (""bread"", 15),
			(""wheat"", 40), (""apple"", 60)]
	
print(""Count = "", countItems(list1, list2))
	
# This code is contributed by Ansu Kumari.<|endoftext|>"
509,"<|endoftext|>Create a function that takes a single character as an argument and returns the char code of its lowercased / uppercased counterpart.
Examples
Given that:
  - ""A"" char code is: 65
  - ""a"" char code is: 97

counterpartCharCode(""A"") ➞ 97

counterpartCharCode(""a"") ➞ 65
Notes
The argument will always be a single character.
Not all inputs will have a counterpart (e.g. numbers), in which case return the input's char code.:def counterpartCharCode(char):
  return ord(char.swapcase())<|endoftext|>"
510,"<|endoftext|>How hashing works:
For insertion of a key(K) – value(V) pair into a hash map, 2 steps are required: 
 

K is converted into a small integer (called its hash code) using a hash function.
The hash code is used to find an index (hashCode % arrSize) and the entire linked list at that index(Separate chaining) is first searched for the presence of the K already.
If found, it’s value is updated and if not, the K-V pair is stored as a new node in the list.
 

Complexity and Load Factor
 

For the first step, time taken depends on the K and the hash function. 
For example, if the key is a string “abcd”, then it’s hash function may depend on the length of the string. But for very large values of n, the number of entries into the map, length of the keys is almost negligible in comparison to n so hash computation can be considered to take place in constant time, i.e, O(1).
For the second step, traversal of the list of K-V pairs present at that index needs to be done. For this, the worst case may be that all the n entries are at the same index. So, time complexity would be O(n). But, enough research has been done to make hash functions uniformly distribute the keys in the array so this almost never happens.
So, on an average, if there are n entries and b is the size of the array there would be n/b entries on each index. This value n/b is called the load factor that represents the load that is there on our map.
This Load Factor needs to be kept low, so that number of entries at one index is less and so is the complexity almost constant, i.e., O(1).
 

Rehashing:
As the name suggests, rehashing means hashing again. Basically, when the load factor increases to more than its pre-defined value (default value of load factor is 0.75), the complexity increases. So to overcome this, the size of the array is increased (doubled) and all the values are hashed again and stored in the new double sized array to maintain a low load factor and low complexity.
 

Why rehashing?

Rehashing is done because whenever key value pairs are inserted into the map, the load factor increases, which implies that the time complexity also increases as explained above. This might not give the required time complexity of O(1). 
Hence, rehash must be done, increasing the size of the bucketArray so as to reduce the load factor and the time complexity.
 

How Rehashing is done?

Rehashing can be done as follows:
 

For each addition of a new entry to the map, check the load factor.
If it’s greater than its pre-defined value (or default value of 0.75 if not given), then Rehash.
For Rehash, make a new array of double the previous size and make it the new bucketarray.
Then traverse to each element in the old bucketArray and call the insert() for each so as to insert it into the new larger bucket array.
:# Python3 program to implement Rehashing

class Map:

	class MapNode:
		def __init__(self,key,value):
			self.key=key
			self.value=value
			self.next=None

	# The bucket array where
	# the nodes containing K-V pairs are stored
	buckets=list()

	# No. of pairs stored - n
	size=0

	# Size of the bucketArray - b
	numBuckets=0

	# Default loadFactor
	DEFAULT_LOAD_FACTOR = 0.75

	def __init__(self):
		Map.numBuckets = 5

		Map.buckets = [None]*Map.numBuckets

		print(""HashMap created"")
		print(""Number of pairs in the Map: "" + str(Map.size))
		print(""Size of Map: "" + str(Map.numBuckets))
		print(""Default Load Factor : "" + str(Map.DEFAULT_LOAD_FACTOR) + ""\n"")

	def getBucketInd(self,key):

		# Using the inbuilt function from the object class
		hashCode = hash(key)

		# array index = hashCode%numBuckets
		return (hashCode % Map.numBuckets)

	def insert(self,key,value):

		# Getting the index at which it needs to be inserted
		bucketInd = self.getBucketInd(key)

		# The first node at that index
		head = Map.buckets[bucketInd]

		# First, loop through all the nodes present at that index
		# to check if the key already exists
		while (head != None):

			# If already present the value is updated
			if (head.key==key):
				head.value = value
				return
			head = head.next

		# new node with the K and V
		newElementNode = Map.MapNode(key, value)

		# The head node at the index
		head = Map.buckets[bucketInd]

		# the new node is inserted
		# by making it the head
		# and it's next is the previous head
		newElementNode.next = head

		Map.buckets[bucketInd]= newElementNode

		print(""Pair(\"" {} \"", \"" {} \"") inserted successfully."".format(key,value))

		# Incrementing size
		# as new K-V pair is added to the map
		Map.size+=1

		# Load factor calculated
		loadFactor = (1* Map.size) / Map.numBuckets

		print(""Current Load factor = "" + str(loadFactor))

		# If the load factor is > 0.75, rehashing is done
		if (loadFactor > Map.DEFAULT_LOAD_FACTOR):
			print(str(loadFactor) + "" is greater than "" + str(Map.DEFAULT_LOAD_FACTOR))
			print(""Therefore Rehashing will be done."")

			# Rehash
			self.rehash()

			print(""New Size of Map: "" + str(Map.numBuckets))

		print(""Number of pairs in the Map: "" + str(Map.size))
		print(""Size of Map: "" + str(Map.numBuckets))

	def rehash(self):

		print(""\n***Rehashing Started***\n"")

		# The present bucket list is made temp
		temp = Map.buckets

		# New bucketList of double the old size is created
		buckets =(2 * Map.numBuckets)

		for i in range(2 * Map.numBuckets):
			# Initialised to null
			Map.buckets.append(None)

		# Now size is made zero
		# and we loop through all the nodes in the original bucket list(temp)
		# and insert it into the new list
		Map.size = 0
		Map.numBuckets *= 2

		for i in range(len(temp)):

			# head of the chain at that index
			head = temp[i]

			while (head != None):
				key = head.key
				val = head.value

				# calling the insert function for each node in temp
				# as the new list is now the bucketArray
				self.insert(key, val)
				head = head.next

		print(""\n***Rehashing Ended***"")

	def printMap(self):

		# The present bucket list is made temp
		temp = Map.buckets

		print(""Current HashMap:"")
		# loop through all the nodes and print them
		for i in range(len(temp)):

			# head of the chain at that index
			head = temp[i]

			while (head != None):
				print(""key = \"" {} \"", val = {}"" .format(head.key,head.value))

				head = head.next
		print()


if __name__ == '__main__':
	# Creating the Map
	map = Map()

	# Inserting elements
	map.insert(1, ""Geeks"")
	map.printMap()

	map.insert(2, ""forGeeks"")
	map.printMap()

	map.insert(3, ""A"")
	map.printMap()

	map.insert(4, ""Computer"")
	map.printMap()

	map.insert(5, ""Portal"")
	map.printMap()

# This code is contributed by Amartya Ghosh<|endoftext|>"
511,"<|endoftext|>Given two integers as arguments, create a function that finds the largest prime within the range of the two integers.
Examples
fat_prime(2, 10) ➞ 7
# range [2, 3, 4, 5, 6, 7, 8, 9, 10] and the largest prime is 7.

fat_prime(10, 2) ➞ 7
# [10, 9, 8, 7, 6, 5, 4, 3, 2] and the largest prime is 7.

fat_prime(4, 24) ➞ 23
# range [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24] the largest prime is 23.
Notes
All numbers will be positive integers.:def fat_prime(a, b):
  s, e = min(a,b), max(a,b)
  return max(i for i in range(s,e+1) if all(i%j for j in range(2,int(i**0.5)+1)))<|endoftext|>"
512,"<|endoftext|>You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.
Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.
 
Example 1:

Input: nums = [1,1,4,2,3], x = 5
Output: 2
Explanation: The optimal solution is to remove the last two elements to reduce x to zero.

Example 2:

Input: nums = [5,6,7,8,9], x = 4
Output: -1

Example 3:

Input: nums = [3,2,20,1,1,3], x = 10
Output: 5
Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.

 
Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 104
1 <= x <= 109:class Solution:
  def minOperations(self, nums, x) :
  cumsum = [0] + list(accumulate(nums))
  dic = {c:i for i,c in enumerate(cumsum)}
  goal = cumsum[-1] - x
  ans = -float(""inf"")

  if goal < 0: return -1

  for num in dic:
  if num + goal in dic:
  ans = max(ans, dic[num + goal] - dic[num])

  return len(nums) - ans if ans != -float(""inf"") else -1<|endoftext|>"
513,"<|endoftext|>Strings in Python:
 “String is a character collection or array”
 Well in Python too, for the string data type, we say the same definition. The string is a sequenced character array and is written within single, double, or three quotes. Also, Python does not have the data type character, thus it is used as a string of length 1 if we write ‘s’.
 Given a hyphen-separated sequence of strings, the task is to sort the strings and print them as hyphen-separated strings in Python.
 Examples:
 Example1:
 Input:
 given hyphen-separated string =hello-this-is-btechgeeks
 Output:
 The string before modification = hello-this-is-btechgeeks
 
 The string after modification = btechgeeks-hello-is-this
 Example2:
 Input:
 given hyphen-separated string =good-morning-codechef
 Output:
 The string before modification = good-morning-codechef
 
 The string after modification = codechef-good-morning
 Examples3:
 Input:
 given hyphen-separated string =btechgeeks-online-platform-fror-coding-students
 Output:
 The string before modification = btechgeeks-online-platform-fror-coding-students
 
 The string after modification = btechgeeks-coding-fror-online-platform-students:# Give the string as static input and store it in a variable.
 
 givn_strng = 'hello-this-is-btechgeeks'
 
 # print the string before modification
 
 print('The string before modification = ', givn_strng)
 
 # Split the hyphen-separated strings into a list of strings using the split()
 
 # function and store it in a variable.
 
 wordsLis = givn_strng.split('-')
 
 # sort the given list using the sort() function.
 
 wordsLis.sort()
 
 # Print the sorted sequence by joining the words in the list with a hyphen.
 
 resultwords = '-'.join(wordsLis)
 
 # print the resultwords
 
 print('The string after modification = ', resultwords)
 
 </pre><|endoftext|>"
514,"<|endoftext|>Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.

In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:


 

Example 1:

Input: rowIndex = 3
Output: [1,3,3,1]
Example 2:

Input: rowIndex = 0
Output: [1]
Example 3:

Input: rowIndex = 1
Output: [1,1]
 

Constraints:

0 <= rowIndex <= 33:class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        row = [1]
        for i in range(rowIndex):
            for j in range(i, 0, -1):
                row[j] = row[j] + row[j-1]
            row.append(1)
        return row<|endoftext|>"
515,"<|endoftext|>Given a string s, return the maximum number of unique substrings that the given string can be split into.
You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique.
A substring is a contiguous sequence of characters within a string.
 
Example 1:

Input: s = ""ababccc""
Output: 5
Explanation: One way to split maximally is ['a', 'b', 'ab', 'c', 'cc']. Splitting like ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid as you have 'a' and 'b' multiple times.

Example 2:

Input: s = ""aba""
Output: 2
Explanation: One way to split maximally is ['a', 'ba'].

Example 3:

Input: s = ""aa""
Output: 1
Explanation: It is impossible to split the string any further.

 
Constraints:


1 <= s.length <= 16


s contains only lower case English letters.:def maxUniqueSplit(self, s: str) -> int:
seen = set()
return self.helper(s, seen)

def helper(self, s, seen):
ans = 0
if s:
for i in range(1, len(s) + 1):
candidate = s[:i]
if candidate not in seen:
seen.add(candidate)
ans = max(ans, 1 + self.helper(s[i:], seen))
seen.remove(candidate)
return ans<|endoftext|>"
516,"<|endoftext|>Hermione has come up with a precise formula for determining whether or not a phrase was ssspoken by a parssseltongue (a reference from the Harry Potter universe; the language of ssserpents and those who can converse with them).
Each word in a sssentence must contain either:
Two or more consecutive instances of the letter ""s"" (i.e. must be together ss..), or...
Zero instances of the letter ""s"" by itself.
Examples
is_parsel_tongue(""Sshe ssselects to eat that apple. "") ➞ True

is_parsel_tongue(""She ssselects to eat that apple. "") ➞ False
# ""She"" only contains one ""s"".

is_parsel_tongue(""Beatrice samples lemonade"") ➞ False
# While ""samples"" has 2 instances of ""s"", they are not together.

is_parsel_tongue(""You ssseldom sssspeak sso boldly, ssso messmerizingly."") ➞ True
Notes
N/A:def is_parsel_tongue(sentence):
  return all('ss' in word or 's' not in word for word in sentence.lower().split())<|endoftext|>"
517,"<|endoftext|>Given a string, reverse it using stack. For example “GeeksQuiz” should be converted to “ziuQskeeG”.:# Python program to reverse a string using stack
 
# Function to create an empty stack.
# It initializes size of stack as 0
def createStack():
    stack=[]
    return stack
 
# Function to determine the size of the stack
def size(stack):
    return len(stack)
 
# Stack is empty if the size is 0
def isEmpty(stack):
    if size(stack) == 0:
        return true
 
# Function to add an item to stack .
# It increases size by 1
def push(stack,item):
    stack.append(item)
 
#Function to remove an item from stack.
# It decreases size by 1
def pop(stack):
    if isEmpty(stack): return
    return stack.pop()
 
# A stack based function to reverse a string
def reverse(string):
    n = len(string)
     
    # Create a empty stack
    stack = createStack()
 
    # Push all characters of string to stack
    for i in range(0,n,1):
        push(stack,string[i])
 
    # Making the string empty since all
    #characters are saved in stack
    string=""""
 
    # Pop all characters of string and
    # put them back to string
    for i in range(0,n,1):
        string+=pop(stack)
         
    return string
     
# Driver program to test above functions
string=""GeeksQuiz""
string = reverse(string)
print(""Reversed string is "" + string)
 
# This code is contributed by Sunny Karira
<|endoftext|>"
518,"<|endoftext|>Given an array of n elements, where each element is at most k away from its target position, devise an algorithm that sorts in O(n log k) time. For example, let us consider k is 2, an element at index 7 in the sorted array, can be at indexes 5, 6, 7, 8, 9 in the given array.

Examples: 

Input : arr[] = {6, 5, 3, 2, 8, 10, 9}
            k = 3 
Output : arr[] = {2, 3, 5, 6, 8, 9, 10}

Input : arr[] = {10, 9, 8, 7, 4, 70, 60, 50}
         k = 4
Output : arr[] = {4, 7, 8, 9, 10, 50, 60, 70}:# A Python3 program to sort a
# nearly sorted array.

from heapq import heappop, heappush, heapify


# A utility function to print
# array elements
def print_array(arr: list):
	for elem in arr:
		print(elem, end=' ')

# Given an array of size n, where every
# element is k away from its target
# position, sorts the array in O(nLogk) time.


def sort_k(arr: list, n: int, k: int):
	""""""
	:param arr: input array
	:param n: length of the array
	:param k: max distance, which every
	element is away from its target position.
	:return: None
	""""""
	# List of first k+1 items
	heap = arr[:k + 1]

	# using heapify to convert list
	# into heap(or min heap)
	heapify(heap)

	# ""rem_elmnts_index"" is index for remaining
	# elements in arr and ""target_index"" is
	# target index of for current minimum element
	# in Min Heap ""heap"".
	target_index = 0
	for rem_elmnts_index in range(k + 1, n):
		arr[target_index] = heappop(heap)
		heappush(heap, arr[rem_elmnts_index])
		target_index += 1

	while heap:
		arr[target_index] = heappop(heap)
		target_index += 1


# Driver Code
k = 3
arr = [2, 6, 3, 12, 56, 8]
n = len(arr)
sort_k(arr, n, k)

print('Following is sorted array')
print_array(arr)

# This code is contributed by
# Veerat Beri(viratberi)<|endoftext|>"
519,"<|endoftext|>Dictionaries in Python:
 Dictionary is a mutable built-in Python Data Structure. It is conceptually related to List, Set, and Tuples. It is, however, indexed by keys rather than a sequence of numbers and can be thought of as associative arrays. On a high level, it consists of a key and its associated value. The Dictionary class in Python represents a hash-table implementation.
 Examples:
 Example1:
 Input:
 given string =""hello this is hello BTechGeeks BTechGeeks BTechGeeks this python programming python language""
 Output:
 {'hello': 2, 'this': 2, 'is': 1, 'BTechGeeks': 3, 'python': 2, 'programming': 1, 'language': 1}
 Example2:
 Input:
 given string =""good morning this is good this python python BTechGeeks good good python online coding platform""
 Output:
 {'good': 4, 'morning': 1, 'this': 2, 'is': 1, 'python': 3, 'BTechGeeks': 1, 'online': 1, 'coding': 1, 'platform': 1}:# given string
 
 given_string = ""hello this is hello BTechGeeks BTechGeeks BTechGeeks this python programming python language""
 
 # Split the given string into words using split() function
 
 # Convert this into list using list() function.
 
 listString = given_string.split()
 
 # Count the frequency of each term using count() function and
 
 # save the results in a separate list using list Comprehension.
 
 freqWords = [listString.count(k) for k in listString]
 
 # Merge the lists containing the terms and the word counts
 
 # into a dictionary using the zip() function.
 
 resultdict = dict(zip(listString, freqWords))
 
 # Print the resultant dictionary
 
 print(resultdict)<|endoftext|>"
520,"<|endoftext|>Static Input: Find the Sum of Series 1^2+2^2+3^2…+N^2 using Math Formula:# Give the number N as static input and store it in a variable.
gvnNumbr = 5
# Calculate the sum of the given series using the above mathematical formula
# and store it in a variable to say resltsum
resltsum = (gvnNumbr*(gvnNumbr+1)*((2*gvnNumbr)+1))//6

# Print the resltsum value which is the result of the series till the given Number N.
print(
    'The sum of the series till the given number {', gvnNumbr, '} is :', resltsum)<|endoftext|>"
521,"<|endoftext|>We have discussed Knight’s tour and Rat in a Maze problems in Set 1 and Set 2 respectively. Let us discuss N Queen as another example problem that can be solved using Backtracking. 
The N Queen is the problem of placing N chess queens on an N×N chessboard so that no two queens attack each other. For example, following is a solution for 4 Queen problem.:# Python3 program to solve N Queen
# Problem using backtracking
global N
N = 4
 
def printSolution(board):
    for i in range(N):
        for j in range(N):
            print (board[i][j], end = "" "")
        print()
 
# A utility function to check if a queen can
# be placed on board[row][col]. Note that this
# function is called when ""col"" queens are
# already placed in columns from 0 to col -1.
# So we need to check only left side for
# attacking queens
def isSafe(board, row, col):
 
    # Check this row on left side
    for i in range(col):
        if board[row][i] == 1:
            return False
 
    # Check upper diagonal on left side
    for i, j in zip(range(row, -1, -1),
                    range(col, -1, -1)):
        if board[i][j] == 1:
            return False
 
    # Check lower diagonal on left side
    for i, j in zip(range(row, N, 1),
                    range(col, -1, -1)):
        if board[i][j] == 1:
            return False
 
    return True
 
def solveNQUtil(board, col):
     
    # base case: If all queens are placed
    # then return true
    if col >= N:
        return True
 
    # Consider this column and try placing
    # this queen in all rows one by one
    for i in range(N):
 
        if isSafe(board, i, col):
             
            # Place this queen in board[i][col]
            board[i][col] = 1
 
            # recur to place rest of the queens
            if solveNQUtil(board, col + 1) == True:
                return True
 
            # If placing queen in board[i][col
            # doesn't lead to a solution, then
            # queen from board[i][col]
            board[i][col] = 0
 
    # if the queen can not be placed in any row in
    # this column col then return false
    return False
 
# This function solves the N Queen problem using
# Backtracking. It mainly uses solveNQUtil() to
# solve the problem. It returns false if queens
# cannot be placed, otherwise return true and
# placement of queens in the form of 1s.
# note that there may be more than one
# solutions, this function prints one of the
# feasible solutions.
def solveNQ():
    board = [ [0, 0, 0, 0],
              [0, 0, 0, 0],
              [0, 0, 0, 0],
              [0, 0, 0, 0] ]
 
    if solveNQUtil(board, 0) == False:
        print (""Solution does not exist"")
        return False
 
    printSolution(board)
    return True
 
# Driver Code
solveNQ()
 
# This code is contributed by Divyanshu Mehta
<|endoftext|>"
522,"<|endoftext|>Given a Binary Tree, convert it into Doubly Linked List where the nodes are represented Spirally. The left pointer of the binary tree node should act as a previous node for created DLL and right pointer should act as next node. 
The solution should not allocate extra memory for DLL nodes. It should use binary tree nodes for creating DLL i.e. only change of pointers is allowed :# Python3 program to convert Binary Tree
# into Doubly Linked List where the nodes
# are represented spirally.
	
# Binary tree node
class newNode:

	# Constructor to create a newNode
	def __init__(self, data):
		self.data = data
		self.left = None
		self.right = None
		
"""""" Given a reference to the head of a list
	and a node, inserts the node on the front
	of the list. """"""
def push(head_ref, node):

	# Make right of given node as
	# head and left as None
	node.right = (head_ref)
	node.left = None

	# change left of head node to
	# given node
	if ((head_ref) != None):
		(head_ref).left = node

	# move the head to point to
	# the given node
	(head_ref) = node

# Function to prints contents of DLL
def printList(node):
	i = 0
	while (i < len(node)):
	
		print(node[i].data, end = "" "")
		i += 1
	
"""""" Function to print corner node at each level """"""
def spiralLevelOrder(root):

	# Base Case
	if (root == None):
		return

	# Create an empty deque for doing spiral
	# level order traversal and enqueue root
	q = []
	q.append(root)

	# create a stack to store Binary
	# Tree nodes to insert into DLL later
	stk = []

	level = 0
	while (len(q)):
	
		# nodeCount indicates number of
		# Nodes at current level.
		nodeCount = len(q)
		
		# Dequeue all Nodes of current level
		# and Enqueue all Nodes of next level
		if (level&1): # odd level
			while (nodeCount > 0):
			
				# dequeue node from front &
				# push it to stack
				node = q[0]
				q.pop(0)
				stk.append(node)

				# insert its left and right children
				# in the back of the deque
				if (node.left != None):
					q.append(node.left)
				if (node.right != None):
					q.append(node.right)

				nodeCount -= 1
			
		else:	 # even level
		
			while (nodeCount > 0):
			
				# dequeue node from the back &
				# push it to stack
				node = q[-1]
				q.pop(-1)
				stk.append(node)

				# inserts its right and left
				# children in the front of
				# the deque
				if (node.right != None):
					q.insert(0, node.right)
				if (node.left != None):
					q.insert(0, node.left)
				nodeCount -= 1
		level += 1
		
	# head pointer for DLL
	head = []
	
	# pop all nodes from stack and push
	# them in the beginning of the list
	while (len(stk)):
	
		head.append(stk[0])
		stk.pop(0)

	print(""Created DLL is:"")
	printList(head)

# Driver Code
if __name__ == '__main__':
	
	""""""Let us create Binary Tree as
	shown in above example """"""

	root = newNode(1)
	root.left = newNode(2)
	root.right = newNode(3)
	root.left.left = newNode(4)
	root.left.right = newNode(5)
	root.right.left = newNode(6)
	root.right.right = newNode(7)

	root.left.left.left = newNode(8)
	root.left.left.right = newNode(9)
	root.left.right.left = newNode(10)
	root.left.right.right = newNode(11)
	#root.right.left.left = newNode(12)
	root.right.left.right = newNode(13)
	root.right.right.left = newNode(14)
	#root.right.right.right = newNode(15)

	spiralLevelOrder(root)

# This code is contributed
# by SHUBHAMSINGH10
<|endoftext|>"
523,"<|endoftext|>You are given an integer array nums of even length n and an integer limit. In one move, you can replace any integer from nums with another integer between 1 and limit, inclusive.
The array nums is complementary if for all indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number. For example, the array [1,2,3,4] is complementary because for all indices i, nums[i] + nums[n - 1 - i] = 5.
Return the minimum number of moves required to make nums complementary.
 
Example 1:

Input: nums = [1,2,4,3], limit = 4
Output: 1
Explanation: In 1 move, you can change nums to [1,2,2,3] (underlined elements are changed).
nums[0] + nums[3] = 1 + 3 = 4.
nums[1] + nums[2] = 2 + 2 = 4.
nums[2] + nums[1] = 2 + 2 = 4.
nums[3] + nums[0] = 3 + 1 = 4.
Therefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary.

Example 2:

Input: nums = [1,2,2,1], limit = 2
Output: 2
Explanation: In 2 moves, you can change nums to [2,2,2,2]. You cannot change any number to 3 since 3 > limit.

Example 3:

Input: nums = [1,2,1,2], limit = 2
Output: 0
Explanation: nums is already complementary.

 
Constraints:

n == nums.length
2 <= n <= 105
1 <= nums[i] <= limit <= 105
n is even.:class Solution:
  def minMoves(self, nums: List[int], limit: int) -> int:
  delta = collections.Counter()
  n = len(nums)
  for i in range(n // 2):
  a, b = nums[i], nums[n - 1 - i]
  delta[2] += 2
  delta[min(a, b) + 1] -= 1
  delta[a + b] -= 1
  delta[a + b + 1] += 1
  delta[max(a, b) + limit + 1] += 1
  
  curr = 0  
  res = math.inf
  for i in range(2, 2 * limit + 1):
  curr += delta[i]
  res = min(res, curr)
  return res<|endoftext|>"
524,"<|endoftext|>In the previous article, we have discussed Python Program to Print Series 0, 2, 8, 14, 24, 34 …N
 Given a number N and the task is to print the series (1 9 17 33 49 73 97 …N) till the given number N in Python.
 Examples:
 Example1:
 Input:
 Given Number = 8
 Output:
 The above series till the given number{ 8 } is :
 
 1 9 17 33 49 73 97 129
 Example2:
 Input:
 Given Number = 4
 Output:
 The above series till the given number{ 4 } is :
 
 1 9 17 33:# Give the number N as static input and store it in a variable.
 
 gvn_numb = 8
 
 # Take a variable to say itr and initialize its value to 1.
 
 itr = 1
 
 # Take another variable say previous_val and initialize its value to 0.
 
 previous_val = 0
 
 # Loop until the above-declared variable itr value is less than or equal to the
 
 # given number using the while loop.
 
 print(""The above series till the given number{"", gvn_numb, ""} is :"")
 
 while itr &lt;= gvn_numb:
 
  # Inside the loop, check if the above itr value is even or not using the if
 
  # conditional statement.
 
  if(itr % 2 == 0):
 
  # If it is true, calculate the value of 2 multiplied with the above itr value raised
 
  # to the power 2 using the pow() function. 
 
  # Store it in a variable.
 
  k = 2*pow(itr, 2)
 
  # Add 1 to the above result and store it in the same variable previous_val.
 
  previous_val = k+1
 
  # Print the value of the above previous_val separated by spaces.
 
  print(previous_val, end="" "")
 
  else:
 
  # If it is false, calculate the value of 2 multiplied with the above itr value raised
 
  # to the power 2 using the pow() function. 
 
  # Store it in another variable.
 
  l = 2*pow(itr, 2)
 
  # Subtract 1 from the above result and store it in the same variable previous_val.
 
  previous_val = l - 1
 
  # Print the value of the above previous_val separated by spaces.
 
  print(previous_val, end="" "")
 
  # Increment the above itr value by 1.
 
  itr += 1
 
 </pre><|endoftext|>"
525,"<|endoftext|>In the previous article, we have discussed Python Program to Find the Sum of all Diagonal Elements of a Matrix
 
 Given a matrix and the task is to display the lower triangular matrix of the given matrix in Python.
 
 What is a matrix:
 
 A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.
 
 Example:
 
 
 
 Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.
 
 In this order, the dimensions of a matrix indicate the number of rows and columns.
 
 
 
 Here as there are 5 rows and 4 columns it is called a 5*4 matrix.
 
 Lower Triangular Matrix:
 
 A lower triangular matrix is one that has all of its upper triangular elements equal to zero. In other words, all non-zero elements are on the main diagonal or in the lower triangle.
 
 Examples:
 
 Example1:
 
 Input:
 
 Given Matrix :
 5 3 2
 6 1 5
 4 8 2
 Output:
 
 The Lower Triangular matrix of the given matrix is :
 5 0 0 
 6 1 0 
 4 8 2
 Example2:
 
 Input:
 
 Given Matrix :
 1 2 3
 6 5 4
 7 8 9
 Output:
 
 The Lower Triangular matrix of the given matrix is :
 1 0 0 
 6 5 0 
 7 8 9:# Give the matrix as static input and store it in a variable.
 mtrx = [[5, 3, 2], [6, 1, 5], [4, 8, 2]]
 # Calculate the number of rows of the given matrix by
 # calculating the length of the nested list using the len() function
 # and store it in a variable mtrxrows.
 mtrxrows = len(mtrx)
 # Calculate the number of columns of the given matrix by
 # calculating the length of the first list in the nested list
 # using the len() function and store it in a variable mtrxcols.
 mtrxcols = len(mtrx[0])
 print(""The Lower Triangular matrix of the given matrix is :"")
 # To print all the elements of the given matrix.
 # Loop till the given number of rows using the For loop.
 for n in range(mtrxrows):
  # Inside the For loop, Iterate till the given number of columns using another
  # Nested For loop(Inner For loop).
  for m in range(mtrxcols):
  # Check if the condition n is less than m using the if conditional statement where n
  # is the iterator value of the parent For loop and m is the iterator value of the
  # inner For loop.
  if n < m:
  # If the statement is true, then print 0.
  print(""0 "", end="""")
  else:
  # Else Print the element of the matrix by printing gvnmatrix[n][m] value.
  print(mtrx[n][m], end="" "")
  print()<|endoftext|>"
526,"<|endoftext|>The program creates a queue using stacks and allows the user to perform enqueue and dequeue operations on it.:class Queue:
    def __init__(self):
        self.inbox = Stack()
        self.outbox = Stack()
 
    def is_empty(self):
        return (self.inbox.is_empty() and self.outbox.is_empty())
 
    def enqueue(self, data):
        self.inbox.push(data)
 
    def dequeue(self):
        if self.outbox.is_empty():
            while not self.inbox.is_empty():
                popped = self.inbox.pop()
                self.outbox.push(popped)
        return self.outbox.pop()
 
 
class Stack:
    def __init__(self):
        self.items = []
 
    def is_empty(self):
        return self.items == []
 
    def push(self, data):
        self.items.append(data)
 
    def pop(self):
        return self.items.pop()
 
 
a_queue = Queue()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    do = input('What would you like to do? ').split()
 
    operation = do[0].strip().lower()
    if operation == 'enqueue':
        a_queue.enqueue(int(do[1]))
    elif operation == 'dequeue':
        if a_queue.is_empty():
            print('Queue is empty.')
        else:
            dequeued = a_queue.dequeue()
            print('Dequeued element: ', int(dequeued))
    elif operation == 'quit':
        break<|endoftext|>"
527,"<|endoftext|>You are given two integer arrays nums and multipliers of size n and m respectively, where n >= m. The arrays are 1-indexed.
You begin with a score of 0. You want to perform exactly m operations. On the ith operation (1-indexed), you will:

Choose one integer x from either the start or the end of the array nums.
Add multipliers[i] * x to your score.
Remove x from the array nums.

Return the maximum score after performing m operations.
 
Example 1:

Input: nums = [1,2,3], multipliers = [3,2,1]
Output: 14
Explanation: An optimal solution is as follows:
- Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.
- Choose from the end, [1,2], adding 2 * 2 = 4 to the score.
- Choose from the end, [1], adding 1 * 1 = 1 to the score.
The total score is 9 + 4 + 1 = 14.
Example 2:

Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
Output: 102
Explanation: An optimal solution is as follows:
- Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.
- Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.
- Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.
- Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.
- Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. 
The total score is 50 + 15 - 9 + 4 + 42 = 102.

 
Constraints:

n == nums.length
m == multipliers.length
1 <= m <= 103
m <= n <= 105 
-1000 <= nums[i], multipliers[i] <= 1000:class Solution:
  def maximumScore(self, nums: List[int], muls: List[int]) -> int:
  n, m = len(nums), len(muls)
  
  @lru_cache(2000)
  def dp(l, i):
  if i == m: return 0
  pickLeft = dp(l+1, i+1) + nums[l] * muls[i] # Pick the left side
  pickRight = dp(l, i+1) + nums[n-(i-l)-1] * muls[i] # Pick the right side
  return max(pickLeft, pickRight)
  
  return dp(0, 0)<|endoftext|>"
528,"<|endoftext|>The recursive function for this challenge should return the factorial of an inputted integer. If anyone needs a refresher, factorials in mathematics are represented by an exclamation point placed to the right of a number:def factorial(num):
  return 1 if num == 1 else num * factorial(num - 1)<|endoftext|>"
529,"<|endoftext|>Files in Python:

Python File handling is a method that allows you to save the program’s output to a file or read data from a file. In the programming world, file handling is a critical notion. File management is employed in practically every type of project. For example, suppose you’re developing an inventory management system. You have data connected to sales and purchases in the inventory management system, thus you must save that data somewhere. You can save that data to a file using Python file management. If you want to undertake data analysis, you must be given data in the form of a comma-separated file or a Microsoft Excel file. You can read data from a file and also store output back into it using file handling.

Given the file, the task is to count the number of blank spaces in a Text File.:# Take a variable say blankCount that stores the calculate the
# total number of blank spaces in a given file and initialize it to 0.
blankCount = 0
# Enter the file name of the file using the input() function and store it in a variable.
filename = input(""Enter the file name = "")
# In read mode, open the file with the entered file name.
with open(filename, 'r') as givenfile:
  # Using for loop, go over the lines in the first file.
  for fileline in givenfile:
  # Split the line into words using the split() function.
  wordslist = fileline.split()
  # To traverse the words in the list, use a for loop, then another
  # for loop to traverse the letters in the word.
  for words in wordslist:
  for char in words:
  # Check to see if the letter is a space using isspace,
  # and if so, increase the blank count by 1.
  if(char.isspace):
  blankCount = blankCount+1
print('The total count of the blank spaces in the given file = ', blankCount)<|endoftext|>"
530,"<|endoftext|>Given a string, find its rank among all its permutations sorted lexicographically. For example, rank of “abc” is 1, rank of “acb” is 2, and rank of “cba” is 6. 

Examples:  



Input : str[] = ""acb""
Output : Rank = 2

Input : str[] = ""string""
Output : Rank = 598

Input : str[] = ""cba""
Output : Rank = 6:# Python program to find lexicographic
# rank of a string

# A utility function to find factorial
# of n
def fact(n) :
	f = 1
	while n >= 1 :
		f = f * n
		n = n - 1
	return f
	
# A utility function to count smaller
# characters on right of arr[low]
def findSmallerInRight(st, low, high) :
	
	countRight = 0
	i = low + 1
	while i <= high :
		if st[i] < st[low] :
			countRight = countRight + 1
		i = i + 1

	return countRight
	
# A function to find rank of a string
# in all permutations of characters
def findRank (st) :
	ln = len(st)
	mul = fact(ln)
	rank = 1
	i = 0

	while i < ln :
		
		mul = mul // (ln - i)
		
		# count number of chars smaller
		# than str[i] from str[i + 1] to
		# str[len-1]
		countRight = findSmallerInRight(st, i, ln-1)

		rank = rank + countRight * mul
		i = i + 1
		
	return rank
	
	
# Driver program to test above function
st = ""string""
print (findRank(st))

# This code is contributed by Nikita Tiwari.<|endoftext|>"
531,"<|endoftext|>In this example, you will learn to check if a Python list is empty.:my_list = []
if not my_list:
    print(""the list is empty"")
my_list = []
if not len(my_list):
    print(""the list is empty"")
my_list = []
if my_list == []:
    print(""The list is empty"")<|endoftext|>"
532,"<|endoftext|>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.

 

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
Example 2:

Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
Example 3:

Input: numCourses = 1, prerequisites = []
Output: [0]:from collections import defaultdict
class Solution:

    WHITE = 1
    GRAY = 2
    BLACK = 3

    def findOrder(self, numCourses, prerequisites):
        """"""
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: List[int]
        """"""

        # Create the adjacency list representation of the graph
        adj_list = defaultdict(list)

        # A pair [a, b] in the input represents edge from b --> a
        for dest, src in prerequisites:
            adj_list[src].append(dest)

        topological_sorted_order = []
        is_possible = True

        # By default all vertces are WHITE
        color = {k: Solution.WHITE for k in range(numCourses)}
        def dfs(node):
            nonlocal is_possible

            # Don't recurse further if we found a cycle already
            if not is_possible:
                return

            # Start the recursion
            color[node] = Solution.GRAY

            # Traverse on neighboring vertices
            if node in adj_list:
                for neighbor in adj_list[node]:
                    if color[neighbor] == Solution.WHITE:
                        dfs(neighbor)
                    elif color[neighbor] == Solution.GRAY:
                         # An edge to a GRAY vertex represents a cycle
                        is_possible = False

            # Recursion ends. We mark it as black
            color[node] = Solution.BLACK
            topological_sorted_order.append(node)

        for vertex in range(numCourses):
            # If the node is unprocessed, then call dfs on it.
            if color[vertex] == Solution.WHITE:
                dfs(vertex)

        return topological_sorted_order[::-1] if is_possible else []<|endoftext|>"
533,"<|endoftext|>You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value. In one operation, you can:

Select two distinct indices i and j such that the value stored at one of the leaves of trees[i] is equal to the root value of trees[j].
Replace the leaf node in trees[i] with trees[j].
Remove trees[j] from trees.
Return the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST.

A BST (binary search tree) is a binary tree where each node satisfies the following property:

Every node in the node's left subtree has a value strictly less than the node's value.
Every node in the node's right subtree has a value strictly greater than the node's value.
A leaf is a node that has no children.

 :# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.roots = {}
        self.leaves = {}
        
    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:
        for tree in trees:
            self.generate_roots_and_leaves(tree)
        start = set(self.roots.keys()) - set(self.leaves.keys())
                
                # Check only 1 starting root else disjointed
        if len(start) != 1:
            return None
                        
        start = self.roots[next(iter(start))]
        root = self.dfs(start)
        return root if len(self.roots) == 1 and self.is_valid_tree(root, float(""inf""), float(""-inf"")) else None

    def is_valid_tree(self, node, max_left, min_right):
        if node:
            if node.val < max_left and node.val > min_right:
                return all([self.is_valid_tree(node.left, min(node.val, max_left), min_right), self.is_valid_tree(node.right, max_left, max(min_right, node.val))])
            else:
                return False
        return True
           
    def generate_roots_and_leaves(self, tree):
        self.roots[tree.val] = tree

        if tree.left:
            self.leaves[tree.left.val] = tree.left
        if tree.right:
            self.leaves[tree.right.val] = tree.right
            
    def dfs(self, tree):
        if tree:
            if tree.left and tree.left.val in self.roots:
                tree.left = self.roots[tree.left.val]
                del(self.roots[tree.left.val])
                self.dfs(tree.left)

            if tree.right and tree.right.val in self.roots:
                tree.right = self.roots[tree.right.val]
                del(self.roots[tree.right.val])
                self.dfs(tree.right)

        return tree<|endoftext|>"
534,"<|endoftext|>The program allows the user to determine whether a directed graph contains a cycle.:class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}
 
    def add_vertex(self, key):
        """"""Add a vertex with the given key to the graph.""""""
        vertex = Vertex(key)
        self.vertices[key] = vertex
 
    def get_vertex(self, key):
        """"""Return vertex object with the corresponding key.""""""
        return self.vertices[key]
 
    def __contains__(self, key):
        return key in self.vertices
 
    def add_edge(self, src_key, dest_key, weight=1):
        """"""Add edge from src_key to dest_key with given weight.""""""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)
 
    def does_edge_exist(self, src_key, dest_key):
        """"""Return True if there is an edge from src_key to dest_key.""""""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])
 
    def __iter__(self):
        return iter(self.vertices.values())
 
 
class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}
 
    def get_key(self):
        """"""Return key corresponding to this vertex object.""""""
        return self.key
 
    def add_neighbour(self, dest, weight):
        """"""Make this vertex point to dest with given edge weight.""""""
        self.points_to[dest] = weight
 
    def get_neighbours(self):
        """"""Return all vertices pointed to by this vertex.""""""
        return self.points_to.keys()
 
    def get_weight(self, dest):
        """"""Get weight of edge from this vertex to dest.""""""
        return self.points_to[dest]
 
    def does_it_point_to(self, dest):
        """"""Return True if this vertex points to dest.""""""
        return dest in self.points_to
 
 
def is_cycle_present(graph):
    """"""Return True if cycle is present in the graph.""""""
    on_stack = set()
    visited = set()
    for v in graph:
        if v not in visited:
            if is_cycle_present_helper(v, visited, on_stack):
                return True
    return False
 
 
def is_cycle_present_helper(v, visited, on_stack):
    """"""Return True if the DFS traversal starting at vertex v detects a
    cycle. Uses set visited to keep track of nodes that have been visited. Uses
    set on_stack to keep track of nodes that are 'on the stack' of the recursive
    calls.""""""
    if v in on_stack:
        return True
    on_stack.add(v)
    for dest in v.get_neighbours():
        if dest not in visited:
            if is_cycle_present_helper(dest, visited, on_stack):
                return True
    on_stack.remove(v)
    visited.add(v)
    return False
 
 
g = Graph()
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('cycle')
print('display')
print('quit')
 
while True:
    do = input('What would you like to do? ').split()
 
    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_edge_exist(v1, v2):
                    g.add_edge(v1, v2)
                else:
                    print('Edge already exists.')
 
    elif operation == 'cycle':
        if is_cycle_present(g):
            print('Cycle present.')
        else:
            print('Cycle not present.')
 
    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()
 
        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()
 
    elif operation == 'quit':
        break<|endoftext|>"
535,"<|endoftext|>Write a function that converts a dictionary into a list of keys-values tuples.
Examples
dict_to_list({
  ""D"": 1,
  ""B"": 2,
  ""C"": 3
}) ➞ [(""B"", 2), (""C"", 3), (""D"", 1)]

dict_to_list({
  ""likes"": 2,
  ""dislikes"": 3,
  ""followers"": 10
}) ➞ [(""dislikes"", 3), (""followers"", 10), (""likes"", 2)]
Notes
Return the elements in the list in alphabetical order.:def dict_to_list(d):
  return sorted(d.items())<|endoftext|>"
536,"<|endoftext|>Given a partially filled 9×9 2D array ‘grid[9][9]’, the goal is to assign digits (from 1 to 9) to the empty cells so that every row, column, and subgrid of size 3×3 contains exactly one instance of the digits from 1 to 9. 





Example: 

Input:
grid = { {3, 0, 6, 5, 0, 8, 4, 0, 0}, 
         {5, 2, 0, 0, 0, 0, 0, 0, 0}, 
         {0, 8, 7, 0, 0, 0, 0, 3, 1}, 
         {0, 0, 3, 0, 1, 0, 0, 8, 0}, 
         {9, 0, 0, 8, 6, 3, 0, 0, 5}, 
         {0, 5, 0, 0, 9, 0, 6, 0, 0}, 
         {1, 3, 0, 0, 0, 0, 2, 5, 0}, 
         {0, 0, 0, 0, 0, 0, 0, 7, 4}, 
         {0, 0, 5, 2, 0, 6, 3, 0, 0} }
Output:
          3 1 6 5 7 8 4 9 2
          5 2 9 1 3 4 7 6 8
          4 8 7 6 2 9 5 3 1
          2 6 3 4 1 5 9 8 7
          9 7 4 8 6 3 1 2 5
          8 5 1 7 9 2 6 4 3
          1 3 8 9 4 7 2 5 6
          6 9 2 3 5 1 8 7 4
          7 4 5 2 8 6 3 1 9
Explanation: Each row, column and 3*3 box of 
the output matrix contains unique numbers.

Input:    
grid = { { 3, 1, 6, 5, 7, 8, 4, 9, 2 },
         { 5, 2, 9, 1, 3, 4, 7, 6, 8 },
         { 4, 8, 7, 6, 2, 9, 5, 3, 1 },
         { 2, 6, 3, 0, 1, 5, 9, 8, 7 },
         { 9, 7, 4, 8, 6, 0, 1, 2, 5 },
         { 8, 5, 1, 7, 9, 2, 6, 4, 3 },
         { 1, 3, 8, 0, 4, 7, 2, 0, 6 },
         { 6, 9, 2, 3, 5, 1, 8, 7, 4 },
         { 7, 4, 5, 0, 8, 6, 3, 1, 0 } };
Output:
           3 1 6 5 7 8 4 9 2 
           5 2 9 1 3 4 7 6 8 
           4 8 7 6 2 9 5 3 1 
           2 6 3 4 1 5 9 8 7 
           9 7 4 8 6 3 1 2 5 
           8 5 1 7 9 2 6 4 3 
           1 3 8 9 4 7 2 5 6 
           6 9 2 3 5 1 8 7 4 
           7 4 5 2 8 6 3 1 9 
Explanation: Each row, column and 3*3 box of 
the output matrix contains unique numbers.:# A Backtracking program
# in Python to solve Sudoku problem

# A Utility Function to print the Grid
def print_grid(arr):
	for i in range(9):
		for j in range(9):
			print arr[i][j],
		print ('n')

		
# Function to Find the entry in
# the Grid that is still not used
# Searches the grid to find an
# entry that is still unassigned. If
# found, the reference parameters
# row, col will be set the location
# that is unassigned, and true is
# returned. If no unassigned entries
# remains, false is returned.
# 'l' is a list variable that has
# been passed from the solve_sudoku function
# to keep track of incrementation
# of Rows and Columns
def find_empty_location(arr, l):
	for row in range(9):
		for col in range(9):
			if(arr[row][col]== 0):
				l[0]= row
				l[1]= col
				return True
	return False

# Returns a boolean which indicates
# whether any assigned entry
# in the specified row matches
# the given number.
def used_in_row(arr, row, num):
	for i in range(9):
		if(arr[row][i] == num):
			return True
	return False

# Returns a boolean which indicates
# whether any assigned entry
# in the specified column matches
# the given number.
def used_in_col(arr, col, num):
	for i in range(9):
		if(arr[i][col] == num):
			return True
	return False

# Returns a boolean which indicates
# whether any assigned entry
# within the specified 3x3 box
# matches the given number
def used_in_box(arr, row, col, num):
	for i in range(3):
		for j in range(3):
			if(arr[i + row][j + col] == num):
				return True
	return False

# Checks whether it will be legal
# to assign num to the given row, col
# Returns a boolean which indicates
# whether it will be legal to assign
# num to the given row, col location.
def check_location_is_safe(arr, row, col, num):
	
	# Check if 'num' is not already
	# placed in current row,
	# current column and current 3x3 box
	return not used_in_row(arr, row, num) and
		not used_in_col(arr, col, num) and
		not used_in_box(arr, row - row % 3,
						col - col % 3, num)

# Takes a partially filled-in grid
# and attempts to assign values to
# all unassigned locations in such a
# way to meet the requirements
# for Sudoku solution (non-duplication
# across rows, columns, and boxes)
def solve_sudoku(arr):
	
	# 'l' is a list variable that keeps the
	# record of row and col in
	# find_empty_location Function
	l =[0, 0]
	
	# If there is no unassigned
	# location, we are done
	if(not find_empty_location(arr, l)):
		return True
	
	# Assigning list values to row and col
	# that we got from the above Function
	row = l[0]
	col = l[1]
	
	# consider digits 1 to 9
	for num in range(1, 10):
		
		# if looks promising
		if(check_location_is_safe(arr,
						row, col, num)):
			
			# make tentative assignment
			arr[row][col]= num

			# return, if success,
			# ya !
			if(solve_sudoku(arr)):
				return True

			# failure, unmake & try again
			arr[row][col] = 0
			
	# this triggers backtracking	
	return False

# Driver main function to test above functions
if __name__==""__main__"":
	
	# creating a 2D array for the grid
	grid =[[0 for x in range(9)]for y in range(9)]
	
	# assigning values to the grid
	grid =[[3, 0, 6, 5, 0, 8, 4, 0, 0],
		[5, 2, 0, 0, 0, 0, 0, 0, 0],
		[0, 8, 7, 0, 0, 0, 0, 3, 1],
		[0, 0, 3, 0, 1, 0, 0, 8, 0],
		[9, 0, 0, 8, 6, 3, 0, 0, 5],
		[0, 5, 0, 0, 9, 0, 6, 0, 0],
		[1, 3, 0, 0, 0, 0, 2, 5, 0],
		[0, 0, 0, 0, 0, 0, 0, 7, 4],
		[0, 0, 5, 2, 0, 6, 3, 0, 0]]
	
	# if success print the grid
	if(solve_sudoku(grid)):
		print_grid(grid)
	else:
		print ""No solution exists""

# The above code has been contributed by Harshit Sidhwa.<|endoftext|>"
537,"<|endoftext|>A list is special if every even index contains an even number and every odd index contains an odd number. Create a function that returns True if an array is special, and False otherwise.:def is_special_array(lst):
        return all(lst[i]%2==i%2 for i in range(len(lst)))<|endoftext|>"
538,"<|endoftext|>Print all Numbers in a Range Divisible by a Given Number Using for loop(Static Input):# given lower limit
lower_limit = 17
# given upper limit
upper_limit = 263
# given number
numb = 5
print(""The numbers which are divisible by"", numb,
      ""from"", lower_limit, ""to"", upper_limit, ""are:"")
# Using for loop, loop from lower limit to upper limit
for val in range(lower_limit, upper_limit):
    # Using an if conditional statement, determine whether
    # the iterator value is divisible by the given number.
    if(val % numb == 0):
        print(val, end="" "")<|endoftext|>"
539,"<|endoftext|>There has been a masterdata issue which affected the prices of the products. Check if each product has a valid price (integer or float, and greater than or equal to zero). Products with a price of 0 are free and count as a valid price.
The return value should be a Boolean.
Examples
has_valid_price({ ""product"": ""Milk"", ""price"": 1.50 }) ➞ True

has_valid_price({ ""product"": ""Cheese"", ""price"": -1 }) ➞ False

has_valid_price({ ""product"": ""Eggs"", ""price"": 0 }) ➞ True

has_valid_price({ ""product"": ""Cereals"", ""price"": ""3.0"" }) ➞ False

has_valid_price(None) ➞ False
Notes
Type of the price should be an integer/float. If it's anything else, you should return False.:def has_valid_price(product):
  try:
    return product['price'] >= 0
  except:
    return False<|endoftext|>"
540,"<|endoftext|>Multiplication Table in Python | In this post, We will discuss how to print multiplication tables in python. In mathematics, a multiplication table is a mathematical table used to define a multiplication operation for an algebraic system. We will also develop a Python program to print multiplication tables from 1 to 10.:# Python program to print multiplication table # take inputs num = int(input('Display multiplication table of: ')) # print multiplication table for i in range(1, 11): print (""%d * %d = %d"" % (num, i, num * i))<|endoftext|>"
541,"<|endoftext|>The math.erf() method returns the error function of a number.

This method accepts a value between - inf and + inf, and returns a value between - 1 to + 1.:# Import math Library
import math

# Print error function for different numbers
print (math.erf(0.67))
print (math.erf(1.34))
print (math.erf(-6))<|endoftext|>"
542,"<|endoftext|>Perfect square in python | In this post, we will develop a Python program to check whether the given number is a perfect square or not.:# Python program to check number is perfect square or not import math #importing math-module def PerfectSquare(x): #user-defined function root = math.sqrt(x) # check number is perfecct square if int(root + 0.5) ** 2 == x: print(x, 'is a perfect square') else: print(x, 'is not a perfect square') return root # take inputs num = int(input('Enter number: ')) # calling function PerfectSquare(num)<|endoftext|>"
543,"<|endoftext|>Given an Undirected simple graph, We need to find how many triangles it can have. 

Let A[][] be the adjacency matrix representation of the graph. If we calculate A3, then the number of triangles in Undirected Graph is equal to trace(A3) / 6. Where trace(A) is the sum of the elements on the main diagonal of matrix A. 
 

Trace of a graph represented as adjacency matrix A[V][V] is,
trace(A[V][V]) = A[0][0] + A[1][1] + .... + A[V-1][V-1]

Count of triangles = trace(A3) / 6


 :# A Python3 program for finding number of
# triangles in an Undirected Graph. The
# program is for adjacency matrix
# representation of the graph
 
# Utility function for matrix
# multiplication
def multiply(A, B, C):
    global V
    for i in range(V):
        for j in range(V):
            C[i][j] = 0
            for k in range(V):
                C[i][j] += A[i][k] * B[k][j]
 
# Utility function to calculate
# trace of a matrix (sum of
# diagonal elements)
def getTrace(graph):
    global V
    trace = 0
    for i in range(V):
        trace += graph[i][i]
    return trace
 
# Utility function for calculating
# number of triangles in graph
def triangleInGraph(graph):
    global V
     
    # To Store graph^2
    aux2 = [[None] * V for i in range(V)]
 
    # To Store graph^3
    aux3 = [[None] * V for i in range(V)]
 
    # Initialising aux
    # matrices with 0
    for i in range(V):
        for j in range(V):
            aux2[i][j] = aux3[i][j] = 0
 
    # aux2 is graph^2 now printMatrix(aux2)
    multiply(graph, graph, aux2)
 
    # after this multiplication aux3 is
    # graph^3 printMatrix(aux3)
    multiply(graph, aux2, aux3)
 
    trace = getTrace(aux3)
    return trace // 6
 
# Driver Code
 
# Number of vertices in the graph
V = 4
graph = [[0, 1, 1, 0],
         [1, 0, 1, 1],
         [1, 1, 0, 1],
         [0, 1, 1, 0]]
 
print(""Total number of Triangle in Graph :"",
                    triangleInGraph(graph))
 
# This code is contributed by PranchalK
<|endoftext|>"
544,"<|endoftext|>Print unique rows in a given binary ,atrix:# Given a binary matrix of M X N of
# integers, you need to return only
# unique rows of binary array
ROW = 4
COL = 5
 
# The main function that prints
# all unique rows in a given matrix.
def findUniqueRows(M):
     
    # Traverse through the matrix
    for i in range(ROW):
        flag = 0
 
        # Check if there is similar column
        # is already printed, i.e if i and
        # jth column match.
        for j in range(i):
            flag = 1
 
            for k in range(COL):
                if (M[i][k] != M[j][k]):
                    flag = 0
 
            if (flag == 1):
                break
 
        # If no row is similar
        if (flag == 0):
             
            # Print the row
            for j in range(COL):
                print(M[i][j], end = "" "")
                 
            print()   
 
# Driver Code
if __name__ == '__main__':
     
    M = [ [ 0, 1, 0, 0, 1 ],
          [ 1, 0, 1, 1, 0 ],
          [ 0, 1, 0, 0, 1 ],
          [ 1, 0, 1, 0, 0 ] ]
 
    findUniqueRows(M)
 
# This code is contributed by mohit kumar 29<|endoftext|>"
545,"<|endoftext|>We will develop a program on how to find the average of n numbers in Python. The average is defined as the mean value which is equal to the ratio of the sum of the number of a given set of values to the total number of values present in the set. Here, we will calculate the average of n numbers using various methods.:# Python program to find the average of n numbers # total number you want to enter n = int(input('How many numbers: ')) # denotes total sum of n numbers total_sum = 0 for i in range (n): # take inputs num = float(input('Enter number: ')) # calculate total sum of numbers total_sum += num # calculate average of numbers avg = total_sum / n # print average value print('The average value of numbers = %0.2f' %avg)<|endoftext|>"
546,"<|endoftext|>Linear Search works in much the same way as we search for a random list of objects.

If we need to find a word on a specific page, we will begin at the top and go through each word one by one before we find the word we are searching for.

Linear Search:

Linear search is a method for locating elements in a sequence. It’s also known as a sequential scan. It is the most basic searching algorithm since it searches for the desired element sequentially.

It compares each element to the value that we are looking for. If both match, the element is found, and the algorithm returns the index position of the key.:# function which return index if element is present else return -1
def linearSearch(given_list, key):
    # Traverse the list
    for index in range(len(given_list)):
        # if the element is equal to key then return index
        if(given_list[index] == key):
            return index
    # if no index is returned then the element is not found in list
    # return -1
    return -1


# given_list
given_list = [2, 7, 3, 4, 9, 15]
# given key
key = 9
# passing the given_list and key to linearSearch function
res = linearSearch(given_list, key)
# if result is equal to -1 then element is not present in list
if(res == -1):
    print(""Given element(key) is not found in list"")
else:
    print(""Element"", key, ""is found at index"", res)<|endoftext|>"
547,"<|endoftext|>Write a Python Program to Print Right Triangle Number Pattern using For Loop:# Python Program to Print Right Triangle Number Pattern
 
rows = int(input(""Please Enter the total Number of Rows  : ""))

print(""Right Triangle Pattern of Numbers"") 
 
for i in range(1, rows + 1):
    for j in range(1, i + 1):        
        print('%d' %i, end = '  ')
    print()<|endoftext|>"
548,"<|endoftext|>In Python, we can display the calendar of any month of any year by importing the calendar module.
:# First import the calendar module  
import calendar  
# ask of month and year  
yy = int(input(""Enter year: ""))  
mm = int(input(""Enter month: ""))  
# display the calendar  
print(calendar.month(yy,mm))  <|endoftext|>"
549,"<|endoftext|>Sunny Number:

A number is said to be a sunny number if the number next to it is a perfect square. In other words, if N+1 is a perfect square, then N is a sunny number.

Example :

Let Given number(N) = 3

Then N+1= 3+1 = 4 # which is a perfect square.

Therefore ,the Given number “3” is a Sunny Number.

some of the examples are 3,8 ,15, 24, 35 ,48 ,63, 80 ,99, 120 etc.

Given a number, the task is to check whether the given number is a Sunny Number or not.

Examples:

Example1:

Input:

Given number = 3
Output:

The given number{ 3 } is Sunny Number:# Import the math module using import keyword.
import math
# Give the number as static input and store it in a variable.
numb = 3
# Add '1' to the above given number and store it in another variable say
# ""incremented number"".
incremnt_num = numb + 1
# Calculate the Square root of the above obtained number using math.sqrt()
# built-in function and store it in another variable.
sqrt_numb = math.sqrt(incremnt_num)
# Multiply the above obtained Square root value with itself and
# store it in another variable say ""square_number"".
square_number = sqrt_numb * sqrt_numb
# Check if the value of ""square_number "" is equal the ""incremented number""
# using if conditional statement.
if(square_number == incremnt_num):
  # If the statement is True ,Print ""The given number is Strong Number""
    print(""The given number{"", numb, ""} is Sunny Number"")
else:
  # Else if the statement is False, print ""The given number is Not a Strong Number"" .
    print(""The given number{"", numb, ""} is not a Sunny Number"")<|endoftext|>"
550,"<|endoftext|>We will develop a Python program to convert Celsius to Kelvin. Celsius is currently a derived unit for temperature in the SI system, Kelvin being the base unit. The unit and the actual Celsius scale were first presented by a Swede Andreas Celsius in 1742. Celsius is also known as centigrade. It is an SI-derived unit used by most countries worldwide.:# Python program to convert Celsius to Kelvin # take inputs cel = 10 # find temprature in Kelvin kelvin = cel + 273.15 # print temperature in Kelvin print('%0.1f degrees Celsius is equivalent to %0.1f Kelvin' %(cel, kelvin))<|endoftext|>"
551,"<|endoftext|>You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.

Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).

The island doesn't have ""lakes"", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.:class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        
        
        def dfs(i,j):
            nonlocal res
            if (i,j) in visited:
                return
            if i<0 or j<0 or i>=m or j>=n or grid[i][j]==0:
                res+=1
                return
            visited.add((i,j))
            
            dfs(i-1,j)
            dfs(i+1,j)
            dfs(i,j-1)
            dfs(i,j+1)
            
        res=0
        m=len(grid)
        n=len(grid[0])
        visited=set()
        for i in range(m):
            for j in range(n):
                if grid[i][j]==1:
                    dfs(i,j)
                    return res
        <|endoftext|>"
552,"<|endoftext|>We will be given a binary number and the python program to convert the given binary number into an equivalent decimal number.:# Python program to convert Binary to Decimal using while loop def BinaryDecimal(n): #user-defined function num, dec, base = n, 0, 1 temp = num while(temp): digit = temp % 10 temp = int(temp / 10) dec += digit * base base = base * 2 return dec # take inputs num = int(input('Enter a binary number: ')) # display result print('The decimal value is =', BinaryDecimal(num))<|endoftext|>"
553,"<|endoftext|>You are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that text contains at least one word.
Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text.
Return the string after rearranging the spaces.
 
Example 1:

Input: text = ""  this  is  a sentence ""
Output: ""this  is  a  sentence""
Explanation: There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces.

Example 2:

Input: text = "" practice  makes  perfect""
Output: ""practice  makes  perfect ""
Explanation: There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string.

 
Constraints:

1 <= text.length <= 100
text consists of lowercase English letters and ' '.
text contains at least one word.:def reorderSpaces(self, text: str) -> str:
  words = text.split() # split(sep=None) will discard empty strings.
  cnt = len(words)
  spaces = text.count(' ')
  gap = 0 if cnt == 1 else spaces // (cnt - 1)
  # trailing_spaces = spaces if gap == 0 else spaces % (cnt - 1)
  trailing_spaces = spaces - gap * (cnt - 1) # credit to @madno
  return (' ' * gap).join(words) + ' ' * trailing_spaces<|endoftext|>"
554,"<|endoftext|>Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.

A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).:def minFallingPathSum(self, matrix: List[List[int]]) -> int:
    for i in range(1, len(matrix)):
        for j in range(len(matrix[0])):
            matrix[i][j] += min(matrix[i - 1][max(0, j - 1):j + 2])
    return min(matrix[-1])<|endoftext|>"
555,"<|endoftext|>Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i.

Each plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:

Alice waters the plants in order from left to right, starting from the 0th plant. Bob waters the plants in order from right to left, starting from the (n - 1)th plant. They begin watering the plants simultaneously.
It takes the same amount of time to water each plant regardless of how much water it needs.
Alice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.
In case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.
Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, return the number of times they have to refill to water all the plants.:class Solution:
    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:
        n= len(plants) 
        req_refill = 0
        capA = capacityA
        capB = capacityB
        for i in range(n//2):
            
            if (capA < plants[i]):
                    capA =  capacityA
                    req_refill += 1
            if (capB < plants[n-i-1]):
                    capB =  capacityB
                    req_refill += 1
            capA -= plants[i]
            capB -= plants[n-i-1]
        if n!=1 and n%2 :
            mid =n//2
            if capB>capA and capB>=plants[mid]:
                capB -= plants[mid]
            elif capA>=plants[mid]:
                capA -= plants[mid]
            else:
                req_refill +=1 
        return req_refill<|endoftext|>"
556,"<|endoftext|>Find the Size of a Tuple : Using len() function:# Give the tuple as static input and store it in a variable.
gvntuple = (9, 11, 24, 19, 11, 23, 29, 23, 31)
# Finding the size or length of a tuple is a rather simple task.
# The number of objects in a tuple is represented by its size.
# The syntax for determining the size is len ().
# The number of elements/objects in the tuple is returned by this function.
# Calculate the len() using len() function and store it in a variable.
tuplelength = len(gvntuple)
# Print the length of the tuple.
print('The length of the given tuple', gvntuple, 'is [', tuplelength, ']')<|endoftext|>"
557,"<|endoftext|>Check if Two Numbers are Equal Without using Arithmetic and Comparison Operators Using Xor(^) Operator (Static Input):# Create a function isEqualNumbers()
# which takes the given two numbers as arguments and
# returns true if they are equal
# else returns false if they are not equal.


def isEqualNumbers(first_numb, second_numb):
        # Inside the isEqualNumbers() function.
        # Apply xor to the first number and second number and
    # store it in a variable say xor_result.
    xor_result = first_numb ^ second_numb
    # Check if the value of xor_result is not equal to 0
    # using the if conditional statement.
    if(xor_result != 0):
        # If it is true then return False
        return False
    # Else return True.
    return True


# Inside the main code.
# Give the first number as static input and store it in a variable.
firstnumb = 10
# Give the second number as static input and store it in another variable.
secondnumb = 10
# Pass the given two numbers as the arguments to isEqualNumbers() function
# and store the result in a variable Reslt.
Reslt = isEqualNumbers(firstnumb, secondnumb)
# Check if the Value of Reslt using the If conditional statement.
if(Reslt):
        # If it is true then print the given two numbers are Equal.
    print('The given two numbers {', firstnumb,
          ',', secondnumb, '} are Equal')
# Else print the given two numbers are Not Equal.
else:
    print('The given two numbers {', firstnumb,
          ',', secondnumb, '} are Not equal')<|endoftext|>"
558,"<|endoftext|>The task is to write a python program using classes that perform simple calculator operations.:# class
class calculator():
  # use a parameterized constructor to initialize its values.
    def __init__(self, number1, number2):
        self.number1 = number1
        self.number2 = number2
 # function which calculates the sum of the given two numbers

    def addNumbers(self):
        return self.number1+self.number2
 # function which calculates the product of the given two numbers

    def mulNumbers(self):
        return self.number1*self.number2
 # function which divides the given two numbers

    def divNumbers(self):
        return self.number1/self.number2
 # function which calculates the difference of the given two numbers

    def subNumbers(self):
        return self.number1-self.number2


# Give the two numbers as static input and store them in two variables.
number1 = 28
number2 = 11
# Create an object to represent the class.
calobj = calculator(number1, number2)
option = 1
# using while loop
while option != 0:
    print(""0. For Exit"")
    print(""1. For Addition of given two numbers"", number1, ',', number2)
    print(""2. For Subtraction of given two numbers"", number1, ',', number2)
    print(""3. For Multiplication of given two numbers"", number1, ',', number2)
    print(""4. For Division of given two numbers"", number1, ',', number2)
    option = int(input(""Enter the option/choice you want = ""))
    if option == 1:
        print(""The additon of given numbers"", number1,
              ',', number2, '=', calobj.addNumbers())
    elif option == 2:
        print(""The difference of given numbers"", number1,
              ',', number2, '=', calobj.subNumbers())
    elif option == 3:
        print(""The product of given numbers"", number1,
              ',', number2, '=', calobj.mulNumbers())
    elif option == 4:
        print(""The division of two numbers"", number1,
              ',', number2, '=', calobj.divNumbers())
    elif option == 0:
        print(""Exit of program"")
    else:
        print(""Enter the choice again"")
    print()<|endoftext|>"
559,"<|endoftext|>Create a function which simplifies a given fraction into its simplest ratio. Return the fraction as a string.
Examples
simplify_frac(""2/4"") ➞ ""1/2""

simplify_frac(""15/25"") ➞ ""3/5""

simplify_frac(""4/9"") ➞ ""4/9""
Notes
Fractions are given as strings.
Return the same fraction if it is already in its simplified ratio (see example #3).:from fractions import gcd
def simplify_frac(f):
  n,d = [int(i) for i in f.split('/')]
  return '/'.join(str(i//gcd(n,d)) for i in (n,d))<|endoftext|>"
560,"<|endoftext|>In this program, you'll learn to shuffle a deck of cards using random module.:# Python program to shuffle a deck of card

# importing modules
import itertools, random

# make a deck of cards
deck = list(itertools.product(range(1,14),['Spade','Heart','Diamond','Club']))

# shuffle the cards
random.shuffle(deck)

# draw five cards
print(""You got:"")
for i in range(5):
   print(deck[i][0], ""of"", deck[i][1])<|endoftext|>"
561,"<|endoftext|>A string s can be partitioned into groups of size k using the following procedure:

The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group.
For the last group, if the string does not have k characters remaining, a character fill is used to complete the group.
Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.

Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.

 :class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        i, v = 0, []
        while i < len(s):
            if i+k < len(s):
                v.append(s[i:i+k])
            else:
                v.append((s[i:] + fill *(k - len(s)%k))[:k])
            i += k
        return v<|endoftext|>"
562,"<|endoftext|>Python is a popular, general-purpose programming language and has straightforward syntax. Python also provides many built-in functions. In this tutorial, we will learn how to start with Python programming.

This is the most basic Python program. It specifies how to print any statement in Python.

In old Python (up to Python 2.7.0), the print command is not written in parenthesis, but in new python software (Python 3.4.3), it is mandatory to add parenthesis to print a statement.:print ('Hello Python')  <|endoftext|>"
563,"<|endoftext|>Write a Python program to print right arrow alphabets pattern using for loop.

:rows = int(input(""Enter Right Arrow Alphabets Pattern Rows = ""))

print(""====The Right Arrow Alphabets Pattern===="")
alphabet = 65

for i in range(rows):
    for j in range(i):
        print(end = ' ')
    for k in range(i, rows):
        print('%c' %(alphabet + k), end = '')
    print()

for i in range(rows - 2, -1, -1):
    for j in range(i):
        print(end = ' ')
    for k in range(i, rows):
        print('%c' %(alphabet + k), end = '')
    print()<|endoftext|>"
564,"<|endoftext|>In a game of RisiKo! (the Italian version of the popular board game Risk!), the players throw six-sided dice to conquer territories around a World map.
When two players contend a territory there is a battle, and they throw from 1 up to 3 dice, with each die being an army sent to fight. To establish who loses armies after the battle, the dice are compared starting from the highest value, and proceeding with the comparisons in descending order (eliminating the dice in excess if the amount of thrown dice among the two players is different).
When the rolls are compared, for each comparison the die of the attacking player must have a greater value than the defender's die to win the fight. In the case of a tie, the defender wins the single fight. The loser only loses 1 army per comparison.
Given two arrays attacker (rolls of the attacker) and defender (rolls of the defender), implement a function that returns the armies lost by the defender as an integer.
Examples
risiko([3, 6, 4], [2, 5, 3]) ➞ 3
# Comparison 1:
# ATT(6) vs. DEF(5): DEF loses an army
# Comparison 2:
# ATT(4) vs. DEF(3): DEF loses an army
# Comparison 3:
# ATT(3) vs. DEF(2): DEF loses an army

risiko([3, 6], [6, 4, 4]) ➞ 0
# Comparison 1:
# ATT(6) vs. DEF(6): ATT loses an army
# Comparison 2:
# ATT(3) vs. DEF(4): ATT loses an army

risiko([3, 1], [1]) ➞ 1
# Comparison 1:
# ATT(3) vs. DEF(1): DEF loses an army
Notes
When two compared dice have the same value, the player who defends wins the fight (see example #2).
When the number of rolls is different between the two players, the number of comparisons to do is equal to the lowest amount of rolled dice (see examples #2 and #3).
You can expect only valid inputs: each array will have at least a die, and no more than three dice, with values in the range from 1 to 6.:def risiko(attacker, defender):
  attacker.sort(reverse=True)
  defender.sort(reverse=True)
  return sum(a > d for a, d in zip(attacker, defender))<|endoftext|>"
565,"<|endoftext|>Given a character and a value between 0 and 100, return a string that represents a simple progress bar.

The value represents a percentage.
The bar should begin and end with ""|""
Repeat the character to fill the bar, with each character equivalent to 10%
Use spaces to pad the bar to a length of 10 characters.
A single space comes after the bar, then a message with the % of completion (e.g. ""Progress: 60%"")
If the value is 100, the message should be ""Completed!"".
Examples
progress_bar(""#"", 0) ➞ ""|          | Progress: 0%""

progress_bar(""="", 40) ➞ ""|====      | Progress: 40%""

progress_bar(""#"", 60) ➞ ""|######    | Progress: 60%""

progress_bar("">"", 100) ➞ ""|>>>>>>>>>>| Completed!"":def progress_bar(bar, progress):
	chart = ""|{:10}| Progress: {}%"".format(bar*(progress//10), progress)
	return chart.replace(""Progress: 100%"", ""Completed!"")<|endoftext|>"
566,"<|endoftext|>Given a binary matrix of N x M, containing at least a value 1. The task is to find the distance of nearest 1 in the matrix for each cell. The distance is calculated as |i1 – i2| + |j1 – j2|, where i1, j1 are the row number and column number of the current cell and i2, j2 are the row number and column number of the nearest cell having value 1.

Examples: 

Input : N = 3, M = 4
        mat[][] = { 0, 0, 0, 1,
                    0, 0, 1, 1,
                    0, 1, 1, 0 }
Output : 3 2 1 0
         2 1 0 0
         1 0 0 1
Explanation:
For cell at (0, 0), nearest 1 is at (0, 3),
so distance = (0 - 0) + (3 - 0) = 3.
Similarly, all the distance can be calculated.

Input : N = 3, M = 3
        mat[][] = { 1, 0, 0, 
            0, 0, 1, 
            0, 1, 1 }
Output :
       0 1 1 
       1 1 0 
       1 0 0 
Explanation:
For cell at (0, 1), nearest 1 is at (0, 0), so distance
is 1. Similarly, all the distance can be calculated.:# Python3 program to find distance of
# nearest cell having 1 in a binary matrix.

# Print distance of nearest cell
# having 1 for each cell.
def printDistance(mat):
	global N, M
	ans = [[None] * M for i in range(N)]

	# Initialize the answer matrix
	# with INT_MAX.
	for i in range(N):
		for j in range(M):
			ans[i][j] = 999999999999

	# For each cell
	for i in range(N):
		for j in range(M):
			
			# Traversing the whole matrix
			# to find the minimum distance.
			for k in range(N):
				for l in range(M):
					
					# If cell contain 1, check
					# for minimum distance.
					if (mat[k][l] == 1):
						ans[i][j] = min(ans[i][j],
									abs(i - k) + abs(j - l))

	# Printing the answer.
	for i in range(N):
		for j in range(M):
			print(ans[i][j], end = "" "")
		print()

# Driver Code
N = 3
M = 4
mat = [[0, 0, 0, 1],
	[0, 0, 1, 1],
	[0, 1, 1, 0]]

printDistance(mat)

# This code is contributed by PranchalK
<|endoftext|>"
567,"<|endoftext|>Given a decimal number and the task is to get the respective binary number for a given number.:# Give the number as user input using the int(input()) function and store it in a variable.
gvn_numb = int(input(""Enter some random Number = ""))
# Take a variable say 'a 'and initialize its value with 1.
a = 1
# Take another variable say binry_num and initialize its value with 0.
binry_num = 0
print(""The Binary value of the given decimal number {"", gvn_numb, ""} is: "")
# Loop till the given number is not equal to zero using the while loop.
while (gvn_numb != 0):
  # Inside the loop, calculate the value of the given number modulus 2 and
    # store it in a variable remdr.
    remdr = gvn_numb % 2
  # Divide the given number by 2 and store it in the same variable gvn_numb.
    gvn_numb = gvn_numb // 2
    # Multiply a with the remdr and store it in another variable b
    b = (remdr * a)
    # Add b to the binry_num and convert to int using the int() function.
    # Store it in the same variable binry_num.
    binry_num = int(binry_num + b)
    # Multiply a with 10 and Store it in the same variable 'a'.
    a = int(a * 10)
 # Print the binry_num to get the binary value of the given decimal number.
print(binry_num)<|endoftext|>"
568,"<|endoftext|>A cinema has n rows of seats, numbered from 1 to n and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above.

Given the array reservedSeats containing the numbers of seats already reserved, for example, reservedSeats[i] = [3,8] means the seat located in row 3 and labelled with 8 is already reserved.

Return the maximum number of four-person groups you can assign on the cinema seats. A four-person group occupies four adjacent seats in one single row. Seats across an aisle (such as [3,3] and [3,4]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a four-person group, in that case, the aisle split a four-person group in the middle, which means to have two people on each side.

 

Example 1:



Input: n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]
Output: 4
Explanation: The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.
Example 2:

Input: n = 2, reservedSeats = [[2,1],[1,8],[2,6]]
Output: 2
Example 3:

Input: n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]
Output: 4
 

Constraints:

1 <= n <= 10^9
1 <= reservedSeats.length <= min(10*n, 10^4)
reservedSeats[i].length == 2
1 <= reservedSeats[i][0] <= n
1 <= reservedSeats[i][1] <= 10
All reservedSeats[i] are distinct.:class Solution:
def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
seats = collections.defaultdict(set)

for i,j in reservedSeats:
if j in [2,3,4,5]:
seats[i].add(0)
if j in [4,5,6,7]:
seats[i].add(1)
if j in [6,7,8,9]:
seats[i].add(2)
res = 2*n
for i in seats:
if len(seats[i]) == 3:
res -= 2
else:
res -= 1

return res<|endoftext|>"
569,"<|endoftext|>Given a String and the task is to enter ‘*’ between two identical characters.

Example :

Given string = btechgeeks

Output: btechge*eks

Explanation: Since both the e’s are identical and next to each other. so, we enter a ‘*’ in between them.

Examples:

Example1:

Input:

Given string = ""good morning btechgeekss""
Output:

The given string after entering '*' between two identical characters= go*od morning btechge*eks*
Example 2:

Input:

Given string = ""aabcddeefghii""
Output:

The given string after entering '*' between two identical characters= a*abcd*de*efghi*:# Give the string as static input and store it in a variable.
gvn_str = ""good morning btechgeekss""
# Take a new empty string say 'new_str'and store it in another variable.
new_str = """"
# Take a variable and initialize its value with '0' and store it in another variable.
itr = 0
# Loop from '0' to the length of the given string -1 using for loop and len() function.
for itr in range(0, len(gvn_str)-1):
  # Concat the new_str with the iterator value of the given string and
  # store it in the same variable 'new_str'
  new_str = new_str + gvn_str[itr]
# Check if the iterator value of the given input string is equal to the iterator+1 value
# of the given input string using the if conditional statement.
  if(gvn_str[itr] == gvn_str[itr+1]):
  # If the statement is true, concat the 'new_str' with the '*' symbol and
  # store it in the same variable 'new_str'.
  new_str += '*'
# Print the variable 'new_str' to enter '*' between two identical characters in a
# given String.
print(""The given string after entering '*' between two identical characters="", new_str)<|endoftext|>"
570,"<|endoftext|>You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].

You may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).

Return a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.

A substring is a contiguous sequence of characters within the string.

 :class Solution:
    def maximumNumber(self, num: str, change: List[int]) -> str:
        l = r = 0
        n = len(num)
        result = ''
        while r<n:
            curr_digit = int(num[r])
            new_digit = change[curr_digit]
            if curr_digit >= new_digit and l == r:
                result += num[r]
                l += 1
                r += 1
                continue

            if l < r and new_digit < curr_digit:
                break
            
            result += str(change[curr_digit])
            r += 1

        while r<n:
            result += num[r]
            r += 1
        
        return result<|endoftext|>"
571,"<|endoftext|>Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.

The test cases are generated so that the answer will fit in a 32-bit integer.

A subarray is a contiguous subsequence of the array.

 :class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0

        result = nums[0]

        for i in range(len(nums)):
            accu = 1
            for j in range(i, len(nums)):
                accu *= nums[j]
                result = max(result, accu)

        return result<|endoftext|>"
572,"<|endoftext|>Exercise 4: Pick a random character from a given String:import random

name = 'pynative'
char = random.choice(name)
print(""random char is "", char)<|endoftext|>"
573,"<|endoftext|>We all know that Machine Learning is basically mathematics and statistics. Theano is a popular python library that is used to define, evaluate and optimize mathematical expressions involving multi-dimensional arrays in an efficient manner. It is achieved by optimizing the utilization of CPU and GPU. It is extensively used for unit-testing and self-verification to detect and diagnose different types of errors. Theano is a very powerful library that has been used in large-scale computationally intensive scientific projects for a long time but is simple and approachable enough to be used by individuals for their own projects. :# Python program using Theano
# for computing a Logistic
# Function
 
import theano
import theano.tensor as T
x = T.dmatrix('x')
s = 1 / (1 + T.exp(-x))
logistic = theano.function([x], s)
logistic([[0, 1], [-1, -2]])<|endoftext|>"
574,"<|endoftext|>Generative Adversarial Networks (GANs) are a powerful class of neural networks that are used for unsupervised learning. It was developed and introduced by Ian J. Goodfellow in 2014. GANs are basically made up of a system of two competing neural network models which compete with each other and are able to analyze, capture and copy the variations within a dataset.:
# importing the necessary libraries and the MNIST dataset
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.examples.tutorials.mnist import input_data
  
mnist = input_data.read_data_sets(""MNIST_data"")
  
# defining functions for the two networks.
# Both the networks have two hidden layers
# and an output layer which are densely or 
# fully connected layers defining the 
# Generator network function
def generator(z, reuse = None):
    with tf.variable_scope('gen', reuse = reuse):
        hidden1 = tf.layers.dense(inputs = z, units = 128, 
                            activation = tf.nn.leaky_relu)
                              
        hidden2 = tf.layers.dense(inputs = hidden1,
           units = 128, activation = tf.nn.leaky_relu)
             
        output = tf.layers.dense(inputs = hidden2, 
             units = 784, activation = tf.nn.tanh)
          
        return output
  
# defining the Discriminator network function 
def discriminator(X, reuse = None):
    with tf.variable_scope('dis', reuse = reuse):
        hidden1 = tf.layers.dense(inputs = X, units = 128,
                            activation = tf.nn.leaky_relu)
                              
        hidden2 = tf.layers.dense(inputs = hidden1,
               units = 128, activation = tf.nn.leaky_relu)
                 
        logits = tf.layers.dense(hidden2, units = 1)
        output = tf.sigmoid(logits)
          
        return output, logits
  
# creating placeholders for the outputs
tf.reset_default_graph()
  
real_images = tf.placeholder(tf.float32, shape =[None, 784])
z = tf.placeholder(tf.float32, shape =[None, 100])
  
G = generator(z)
D_output_real, D_logits_real = discriminator(real_images)
D_output_fake, D_logits_fake = discriminator(G, reuse = True)
  
# defining the loss function
def loss_func(logits_in, labels_in):
    return tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(
                          logits = logits_in, labels = labels_in))
  
 # Smoothing for generalization
D_real_loss = loss_func(D_logits_real, tf.ones_like(D_logits_real)*0.9)
D_fake_loss = loss_func(D_logits_fake, tf.zeros_like(D_logits_real))
D_loss = D_real_loss + D_fake_loss
  
G_loss = loss_func(D_logits_fake, tf.ones_like(D_logits_fake))
  
# defining the learning rate, batch size,
# number of epochs and using the Adam optimizer
lr = 0.001 # learning rate
  
# Do this when multiple networks
# interact with each other
  
# returns all variables created(the two
# variable scopes) and makes trainable true
tvars = tf.trainable_variables() 
d_vars =[var for var in tvars if 'dis' in var.name]
g_vars =[var for var in tvars if 'gen' in var.name]
  
D_trainer = tf.train.AdamOptimizer(lr).minimize(D_loss, var_list = d_vars)
G_trainer = tf.train.AdamOptimizer(lr).minimize(G_loss, var_list = g_vars)
  
batch_size = 100 # batch size
epochs = 500 # number of epochs. The higher the better the result
init = tf.global_variables_initializer()
  
# creating a session to train the networks
samples =[] # generator examples
  
with tf.Session() as sess:
    sess.run(init)
    for epoch in range(epochs):
        num_batches = mnist.train.num_examples//batch_size
          
        for i in range(num_batches):
            batch = mnist.train.next_batch(batch_size)
            batch_images = batch[0].reshape((batch_size, 784))
            batch_images = batch_images * 2-1
            batch_z = np.random.uniform(-1, 1, size =(batch_size, 100))
            _= sess.run(D_trainer, feed_dict ={real_images:batch_images, z:batch_z})
            _= sess.run(G_trainer, feed_dict ={z:batch_z})
              
        print(""on epoch{}"".format(epoch))
          
        sample_z = np.random.uniform(-1, 1, size =(1, 100))
        gen_sample = sess.run(generator(z, reuse = True),
                                 feed_dict ={z:sample_z})
          
        samples.append(gen_sample)
  
# result after 0th epoch
plt.imshow(samples[0].reshape(28, 28))
  
# result after 499th epoch
plt.imshow(samples[49].reshape(28, 28))<|endoftext|>"
575,"<|endoftext|>Create a function that takes a string and determine if it's a valid sequence by either returning True or False. The string will be composed of + and = symbols with several characters between them (e.g. ""++d+===+c++==a"") and for the string to be True, each letter must be surrounded by a + symbol. So the string to the left would be False.
Examples
simple_symbols(""f++d+"") ➞ False

simple_symbols(""+d+=3=+s+"") ➞ True

simple_symbols(""==+p+++++++++====8+z++++"") ➞ True
Notes
The given string will not be empty and will have at least one letter.:import re
def simple_symbols(txt):
  return len(re.findall(r'\+[a-z]\+', txt)) == len(re.findall('[a-z]', txt))<|endoftext|>"
576,"<|endoftext|>The current article would deal with the concepts surrounding the complex networks using the python library Networkx. It is a Python language software package for the creation, manipulation, and study of the structure, dynamics, and function of complex networks. With NetworkX you can load and store networks in standard and nonstandard data formats, generate many types of random and classic networks, analyze network structure, build network models, design new network algorithms, draw networks, and much more.

The current article would deal with the algorithm for generating random scale free networks for using preferential attachment model. The reason of interest behind this model dates back to the 1990s when Albert Lazlo Barabasi and Reka Albert came out with the path breaking research describing the model followed by the scale free networks around the world. They suggested that several natural and human-made systems, including the Internet, the World Wide Web, citation networks, and some social networks are thought to be approximately scale-free networks.
A scale-free network is a network whose degree distribution follows a power law, at least asymptotically. That is, the fraction P (k) of nodes in the network having k connections to other nodes goes for large values of k as

P(k)=ck^{-\gamma }
Where \gamma is a parameter whose value is typically in the range 2 < \gamma < 3, although occasionally it may lie outside these bounds and c is a proportionality constant.

The Barabási–Albert model is one of several proposed models that generate scale-free networks. It incorporates two important general concepts: growth and preferential attachment. Both growth and preferential attachment exist widely in real networks. Growth means that the number of nodes in the network increases over time.
Preferential attachment means that the more connected a node is, the more likely it is to receive new links. Nodes with higher degree have stronger ability to grab links added to the network. Intuitively, the preferential attachment can be understood if we think in terms of social networks connecting people. Here a link from A to B means that person A ""knows"" or ""is acquainted with"" person B. Heavily linked nodes represent well-known people with lots of relations. When a newcomer enters the community, s/he is more likely to become acquainted with one of those more visible people rather than with a relative unknown. The BA model was proposed by assuming that in the World Wide Web, new pages link preferentially to hubs, i.e. very well-known sites such as Google, rather than to pages that hardly anyone knows. If someone selects a new page to link to by randomly choosing an existing link, the probability of selecting a particular page would be proportional to its degree.:def barabasi_albert_graph(n, m, seed=None):
    """"""Returns a random graph according to the Barabási–Albert preferential
    Attachment model.
  
    A graph of ``n`` nodes is grown by attaching new nodes each with ``m``
    Edges that are preferentially attached to existing nodes with high degree.
  
    Parameters
    ----------
    n : int
        Number of nodes
    m : int
        Number of edges to attach from a new node to existing nodes
    seed : int, optional
        Seed for random number generator (default=None).
  
    Returns
    -------
    G : Graph
  
    Raises
    ------
    NetworkXError
        If ``m`` does not satisfy ``1 <= m < n``.
  
      
    if m < 1 or  m >=n:
        raise nx.NetworkXError(""Barabási–Albert network must have m >= 1""
                               "" and m < n, m = %d, n = %d"" % (m, n))
    if seed is not None:
        random.seed(seed)
  
    # Add m initial nodes (m0 in barabasi-speak)
    G=empty_graph(m)
    G.name=""barabasi_albert_graph(%s,%s)""%(n,m)
    # Target nodes for new edges
    targets=list(range(m))
    # List of existing nodes, with nodes repeated once for each adjacent edge
    repeated_nodes=[]
    # Start adding the other n-m nodes. The first node is m.
    source=m
    while source<n:
        # Add edges to m nodes from the source.
        G.add_edges_from(zip(*m,targets))
        # Add one node to the list for each new edge just created.
        repeated_nodes.extend(targets)
        # And the new node ""source"" has m edges to add to the list.
        repeated_nodes.extend(*m)
        # Now choose m unique nodes from the existing nodes
        # Pick uniformly from repeated_nodes (preferential attachement)
        targets = _random_subset(repeated_nodes,m)
        source += 1
    return G<|endoftext|>"
577,"<|endoftext|>Using Stack is the obvious way to traverse tree without recursion. Below is an algorithm for traversing binary tree using stack. See this for step wise step execution of the algorithm. :# Python program to do inorder traversal without recursion
 
# A binary tree node
class Node:
     
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
 
# Iterative function for inorder tree traversal
def inOrder(root):
     
    # Set current to root of binary tree
    current = root
    stack = [] # initialize stack
     
    while True:
         
        # Reach the left most Node of the current Node
        if current is not None:
             
            # Place pointer to a tree node on the stack
            # before traversing the node's left subtree
            stack.append(current)
         
            current = current.left
 
         
        # BackTrack from the empty subtree and visit the Node
        # at the top of the stack; however, if the stack is
        # empty you are done
        elif(stack):
            current = stack.pop()
            print(current.data, end="" "") # Python 3 printing
         
            # We have visited the node and its left
            # subtree. Now, it's right subtree's turn
            current = current.right
 
        else:
            break
      
    print()
 
# Driver program to test above function
 
"""""" Constructed binary tree is
            1
          /   \
         2     3
       /  \
      4    5   """"""
 
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
 
inOrder(root)
 
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)<|endoftext|>"
578,"<|endoftext|>Given a number the task is to print the multiplication table of the given number from 1 to 10.

Prerequisite:

1)For Loop in python

2)While Loop in python

Explore more instances related to python concepts from Python Programming Examples Guide and get promoted from beginner to professional programmer level in Python Programming Language.

Examples:

Example 1:

Input:

number=8
Output:

8 * 1 = 8
8 * 2 = 16
8 * 3 = 24
8 * 4 = 32
8 * 5 = 40
8 * 6 = 48
8 * 7 = 56
8 * 8 = 64
8 * 9 = 72
8 * 10 = 80
Example 2:

Input:

number=34
Output:

34 * 1 = 34
34 * 2 = 68
34 * 3 = 102
34 * 4 = 136
34 * 5 = 170
34 * 6 = 204
34 * 7 = 238
34 * 8 = 272
34 * 9 = 306
34 * 10 = 340:# given number
 number = 8
 # using for loop with range
 for i in range(1, 11):
  print(number, ""*"", i, ""="", number*i)<|endoftext|>"
579,"<|endoftext|>Write a function that returns the lexicographically first and lexicographically last rearrangements of a lowercase string. Output the results in the following manner:
first_and_last(string) ➞ [first, last]
Examples
first_and_last(""marmite"") ➞ [""aeimmrt"", ""trmmiea""]

first_and_last(""bench"") ➞ [""bcehn"", ""nhecb""]

first_and_last(""scoop"") ➞ [""coops"", ""spooc""]
Notes
Lexicographically first: the permutation of the string that would appear first in the English dictionary (if the word existed).
Lexicographically last: the permutation of the string that would appear last in the English dictionary (if the word existed).:def first_and_last(s):
  x = ''.join(sorted(list(s)))
  return [x, x[::-1]]<|endoftext|>"
580,"<|endoftext|>A CSV file, which stands for Comma Separated Values file, is a simple text file that maintains a list of data. CSV files are commonly used to exchange data between different applications. Contact Managers and Databases, for example, typically support CSV files.

These CSV files are also known as Comma Separated Values or Comma Delimited Files. These files primarily use the comma character to delimit or segregate data. However, other characters, such as semicolons, are sometimes used. The plan is to export complex data from one program to a CSV file and then import the data from the CSV file into another program.

A Comma Separated Values (CSV) file has a simple structure that contains some data that is listed and separated by commas. CSV files are constructed in such a way that they may simply import and export data from other applications. The resulting data is easily readable by humans and may be seen using a text editor like Notepad or a spreadsheet program like Microsoft Excel or Google Sheets.

What do you mean by JSON Array?

JSON (JavaScript Object Notation) is a dictionary-like notation that may be utilized in Python by importing the JSON module. Every record (or row) is preserved as its own dictionary, with the column names serving as the dictionary’s Keys. To make up the whole dataset, all of these records are kept as dictionaries in a nested dictionary. It is saved together with the extension. geeksforgeeks.json

JSON format was actually based on a subset of JavaScript. It is, nevertheless, referred to as a language-independent format, and it is supported by a wide range of programming APIs. In most cases, JSON is used in Ajax Web Application Programming. Over the last few years, the popularity of JSON as an alternative to XML has gradually increased.:# Import csv module using the import keyword.
import csv  
# Import json module using the import keyword.
import json  
# Open some random JSON file in read-only mode using the open() function 
# and store it in a variable
gvn_jsonfile =open('samplefile.json','r')
# Open an empty CSV file in write mode using the open() function 
# and store it in another variable
gvn_csvfile=open('demo.csv','w')

# Pass the above given json file to the load() function of the json module
# to convert the json file data into a dictionary
dictionary =json.load(gvn_jsonfile)
# Pass the above given csv file to writer() function of the csv module to 
# pass the given csv to writer() function of csv file and store it in a variable to write content/data to csv file
write=csv.writer(gvn_csvfile)
# Write all the key values of the json file using writerow() function and 
# apply it on the above writing object 
write.writerow(dictionary.keys())
# Write all the dictionary values of the json file using writerow() function and 
# apply it on the above writing object 
write.writerow(dictionary.values())

# Close the given JSON file using the close() function
gvn_jsonfile.close()
# Close the given CSV file using the close() function
gvn_csvfile.close()<|endoftext|>"
581,"<|endoftext|>Given a matrix M of size m x n ( 1 <= m,n <= 1000 ). It is initially filled with integers from 1 to m x n sequentially in a row major order. The task is to process a list of queries manipulating M such that every query is one of the following three. 


 :# Python3 implementation of program
 
# Fills initial values in rows[] and cols[]
def preprocessMatrix(rows, cols, m, n):
 
    # Fill rows with 1 to m-1
    for i in range(m):
        rows[i] = i;
 
    # Fill columns with 1 to n-1
    for i in range(n):
        cols[i] = i;
 
# Function to perform queries on matrix
# m --> number of rows
# n --> number of columns
# ch --> type of query
# x --> number of row for query
# y --> number of column for query
def queryMatrix(rows, cols, m, n, ch, x, y):
 
    # perform queries
    tmp = 0;
     
    if ch == 'R':
 
        # swap row x with y
        rows[x-1], rows[y-1] = rows[y-1], rows[x-1];
 
    elif ch == 'C':
 
        # swap column x with y
        cols[x-1], cols[y-1] = cols[y-1],cols[x-1];
 
    elif ch == 'P':
 
        # Print value at (x, y)
        print('value at (',x,',',y,') = ',rows[x-1]*n + cols[y-1]+1, sep='');
         
    return ;
 
# Driver program to run the case
m = 1234
n = 5678;
 
# row[] is array for rows and cols[]
# is array for columns
rows = [0 for i in range(m)]
cols = [0 for i in range(n)];
 
# Fill initial values in rows[] and cols[]
preprocessMatrix(rows, cols, m, n);
 
queryMatrix(rows, cols, m, n, 'R', 1, 2);
queryMatrix(rows, cols, m, n, 'P', 1, 1);
queryMatrix(rows, cols, m, n, 'P', 2, 1);
queryMatrix(rows, cols, m, n, 'C', 1, 2);
queryMatrix(rows, cols, m, n, 'P', 1, 1);
queryMatrix(rows, cols, m, n, 'P', 2, 1);
 
# This code is contributed by rutvik_56.
<|endoftext|>"
582,"<|endoftext|>Lemmatization is the process of grouping together the different inflected forms of a word so they can be analyzed as a single item. Lemmatization is similar to stemming but it brings context to the words. So it links words with similar meanings to one word.
Text preprocessing includes both Stemming as well as Lemmatization. Many times people find these two terms confusing. Some treat these two as the same. Actually, lemmatization is preferred over Stemming because lemmatization does morphological analysis of the words.
Applications of lemmatization are: 
 

Used in comprehensive retrieval systems like search engines.
Used in compact indexing.:# from textblob lib import Word method
from textblob import Word
 
# create a Word object.
u = Word(""rocks"")
 
# apply lemmatization.
print(""rocks :"", u.lemmatize())
 
# create a Word object.
v = Word(""corpora"")
 
# apply lemmatization.
print(""corpora :"", v.lemmatize())
 
# create a Word object.
w = Word(""better"")
  
# apply lemmatization with
# parameter ""a"", ""a"" denotes adjective.
print(""better :"", w.lemmatize(""a""))<|endoftext|>"
583,"<|endoftext|>Given a fraction as a string, return whether or not it is greater than 1 when evaluated.

Examples
greater_than_one(""1/2"") ➞ False

greater_than_one(""7/4"") ➞ True

greater_than_one(""10/10"") ➞ False
Notes
Fractions must be strictly greater than 1 (see example #3).:def greaterThanOne(frac):
	return eval(frac) > 1<|endoftext|>"
584,"<|endoftext|>You are given two balanced binary search trees e.g., AVL or Red-Black Tree. Write a function that merges the two given balanced BSTs into a balanced binary search tree. Let there be m elements in the first tree and n elements in the other tree. Your merge function should take O(m+n) time.
1) Do inorder traversal of first tree and store the traversal in one temp array arr1[]. This step takes O(m) time. 
2) Do inorder traversal of second tree and store the traversal in another temp array arr2[]. This step takes O(n) time. 
3) The arrays created in step 1 and 2 are sorted arrays. Merge the two sorted arrays into one array of size m + n. This step takes O(m+n) time. 
4) Construct a balanced tree from the merged array using the technique discussed in this post. This step takes O(m+n) time.
Time complexity of this method is O(m+n) which is better than method 1. This method takes O(m+n) time even if the input BSTs are not balanced. 
Following is implementation of this method.:# A binary tree node has data, pointer to left child 
# and a pointer to right child
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
 
# A utility function to merge two sorted arrays into one
# Time Complexity of below function: O(m + n)
# Space Complexity of below function: O(m + n)
def merge_sorted_arr(arr1, arr2):
    arr = []
    i = j = 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] <= arr2[j]:
            arr.append(arr1[i])
            i += 1
        else:
            arr.append(arr2[j])
            j += 1
    while i < len(arr1):
        arr.append(arr1[i])
        i += 1
    while i < len(arr2):
        arr.append(arr2[j])
        j += 1
    return arr
 
# A helper function that stores inorder
# traversal of a tree in arr
def inorder(root, arr = []):
    if root:
        inorder(root.left, arr)
        arr.append(root.val)
        inorder(root.right, arr)
 
# A utility function to insert the values
# in the individual Tree
def insert(root, val):
    if not root:
        return Node(val)
    if root.val == val:
        return root
    elif root.val > val:
        root.left = insert(root.left, val)
    else:
        root.right = insert(root.right, val)
    return root
 
# Converts the merged array to a balanced BST
# Explanation of the below code:
# https://www.geeksforgeeks.org/sorted-array-to-balanced-bst/
def arr_to_bst(arr):
    if not arr:
        return None
    mid = len(arr) // 2
    root = Node(arr[mid])
    root.left = arr_to_bst(arr[:mid])
    root.right = arr_to_bst(arr[mid + 1:])
    return root
 
if __name__=='__main__':
    root1 = root2 = None
     
    # Inserting values in first tree
    root1 = insert(root1, 100)
    root1 = insert(root1, 50)
    root1 = insert(root1, 300)
    root1 = insert(root1, 20)
    root1 = insert(root1, 70)
     
    # Inserting values in second tree
    root2 = insert(root2, 80)
    root2 = insert(root2, 40)
    root2 = insert(root2, 120)
    arr1 = []
    inorder(root1, arr1)
    arr2 = []
    inorder(root2, arr2)
    arr = merge_sorted_arr(arr1, arr2)
    root = arr_to_bst(arr)
    res = []
    inorder(root, res)
    print('Following is Inorder traversal of the merged tree')
    for i in res:
      print(i, end = ' ')
       
# This code is contributed by Flarow4<|endoftext|>"
585,"<|endoftext|>Given a n x n matrix. The problem is to find all the distinct elements common to all rows of the matrix. The elements can be printed in any order.:# Python3 program to find distinct elements
# common to all rows of a matrix
MAX = 100

# function to individually sort
# each row in increasing order
def findAndPrintCommonElements(mat, n):
	us = dict()

	# map elements of first row
	# into 'us'
	for i in range(n):
		us[mat[0][i]] = 1

	for i in range(1, n):
		temp = dict()
		
		# mapping elements of current row
		# in 'temp'
		for j in range(n):
			temp[mat[i][j]] = 1

		# iterate through all the elements
		# of 'us'
		for itr in list(us):

			# if an element of 'us' is not present
			# into 'temp', then erase that element
			# from 'us'
			if itr not in temp:
				del us[itr]

		# if size of 'us' becomes 0,
		# then there are no common elements
		if (len(us) == 0):
			break

	# print common elements
	for itr in list(us)[::-1]:
		print(itr, end = "" "")

# Driver Code
mat = [[2, 1, 4, 3],
	[1, 2, 3, 2],
	[3, 6, 2, 3],
	[5, 2, 5, 3]]
n = 4
findAndPrintCommonElements(mat, n)

# This code is contributed by Mohit Kumar<|endoftext|>"
586,"<|endoftext|>Deque or Double Ended Queue is a generalized version of Queue data structure that allows insert and delete at both ends.In previous post we had discussed introduction of deque. Now in this post we see how we implement deque Using circular array. 

Operations on Deque: 

Mainly the following four basic operations are performed on queue: 

insertFront(): Adds an item at the front of Deque. 

insertRear(): Adds an item at the rear of Deque. 

deleteFront(): Deletes an item from front of Deque. 

deleteRear(): Deletes an item from rear of Deque.

In addition to above operations, following operations are also supported 

getFront(): Gets the front item from queue. 

getRear(): Gets the last item from queue. 

isEmpty(): Checks whether Deque is empty or not. 

isFull(): Checks whether Deque is full or not. :
# Python implementation of De-queue using circular
# array
   
# A structure to represent a Deque
MAX = 100;
 
class Deque:
    def __init__(self, size):
        self.arr = [0] * MAX
        self.front = -1;
        self.rear = 0;
        self.size = size;
     
     
    ''' Operations on Deque:
    void  insertfront(int key);
    void  insertrear(int key);
    void  deletefront();
    void  deleterear();
    bool  isFull();
    bool  isEmpty();
    int  getFront();
    int  getRear(); '''
   
    # Checks whether Deque is full or not.
    def isFull(self):
        return ((self.front == 0 and self.rear == self.size-1) or self.front == self.rear + 1)
     
     
    # Checks whether Deque is empty or not.
    def isEmpty (self):
        return (self.front == -1);
     
    # Inserts an element at front
    def insertfront(self, key):
 
        # check whether Deque if  full or not
        if (self.isFull()):
            print(""Overflow"");
            return;
         
   
        # If queue is initially empty
        if (self.front == -1):
            self.front = 0;
            self.rear = 0;
         
          
        # front is at first position of queue
        elif (self.front == 0):
            self.front = self.size - 1 ;
   
        else: # decrement front end by '1'
            self.front = self.front-1;
   
        # insert current element into Deque
        self.arr[self.front] = key ;
     
     
    # function to inset element at rear end
    # of Deque.
    def insertrear(self, key):
        if (self.isFull()):
            print("" Overflow"");
            return;
         
   
        # If queue is initially empty
        if (self.front == -1):
            self.front = 0;
            self.rear = 0;
         
   
        # rear is at last position of queue
        elif (self.rear == self.size-1):
            self.rear = 0;
   
        # increment rear end by '1'
        else:
            self.rear = self.rear+1;
          
        # insert current element into Deque
        self.arr[self.rear] = key ;
     
     
    # Deletes element at front end of Deque
    def deletefront(self):
        # check whether Deque is empty or not
        if (self.isEmpty()):
            print(""Queue Underflow"");
            return ;
         
   
        # Deque has only one element
        if (self.front == self.rear):
            self.front = -1;
            self.rear = -1;
         
        else:
            # back to initial position
            if (self.front == self.size -1):
                self.front = 0;
   
            else: # increment front by '1' to remove current
                # front value from Deque
                self.front = self.front+1;
     
     
    # Delete element at rear end of Deque
    def deleterear(self):
        if (self.isEmpty()):
            print("" Underflow"");
            return ;
         
   
        # Deque has only one element
        if (self.front == self.rear):
            self.front = -1;
            self.rear = -1;
         
        elif (self.rear == 0):
            self.rear = self.size-1;
        else:
            self.rear = self.rear-1;
     
     
    # Returns front element of Deque
    def getFront(self):
        # check whether Deque is empty or not
        if (self.isEmpty()):
            print("" Underflow"");
            return -1 ;
         
        return self.arr[self.front];
     
     
    # function return rear element of Deque
    def getRear(self):
        # check whether Deque is empty or not
        if(self.isEmpty() or self.rear < 0):
            print("" Underflow"");
            return -1 ;
         
        return self.arr[self.rear];
     
     
 
 
# Driver program to test above function
dq = Deque(5);
           
print(""Insert element at rear end  : 5 "");
dq.insertrear(5);
 
print(""insert element at rear end : 10 "");
dq.insertrear(10);
 
print(f""get rear element : {dq.getRear()}"");
 
dq.deleterear();
print(f""After delete rear element new rear become : {dq.getRear()}"");
 
print(""inserting element at front end"");
dq.insertfront(15);
 
print(f""get front element: {dq.getFront()}"");
 
dq.deletefront();
 
print(f""After delete front element new front become : {dq.getFront()}"");
 
# This code is contributed by _saurabh_jaiswal


<|endoftext|>"
587,"<|endoftext|>Mubashir has started his journey from home. Given a string of directions (N=North, W=West, S=South, E=East), he will walk for one minute in each direction. Determine whether a set of directions will lead him back to the starting position or not.
Examples
back_to_home(""EEWE"") ➞ False

back_to_home(""NENESSWW"") ➞ True

back_to_home(""NEESSW"") ➞ False
Notes
N/A:def back_to_home(d):
  return d.count('N') == d.count('S') and d.count('E') == d.count('W')<|endoftext|>"
588,"<|endoftext|>In this article, we will learn how to print happy numbers within a specific range in Python. You will learn what a happy number is, how to check whether a given number is a happy number, and how to write Python code that outputs all the happy numbers within the user-specified range.
 Happy Number :
 If the repeating sum of the digits squared equals one, the number is said to be a Happy Number. If we continue this method and get outcome 1, we have a happy number. If the outcome is 4, it enters an infinite loop and is not a happy number. Let’s look at an example to help you grasp it better.
 Given Number = 320
 Square of the digits = 32 + 22 + 02 = 13
 Square of the digits = 12 + 32 = 10
 Square of the digits = 12 + 02 = 1
 Other Examples of happy numbers =7, 28, 100 etc.
 Examples:
 Example1:
 Input:
 Given upper limit range =19
 
 Given lower limit range =145
 Output:
 The happy numbers in the given range 19 and 145 are:
 
 19 23 28 31 32 44 49 68 70 79 82 86 91 94 97 100 103 109 129 130 133 139
 Example2:
 Input:
 Given upper limit range =333
 
 Given lower limit range =444
 Output:
 The happy numbers in the given range 333 and 444 are:
 
 338 356 362 365 367 368 376 379 383 386 391 392 397 404 409 440:# Create a function digitSquareSum() that accepts the given number
 
 # as an argument and returns the sum of squares of digits.
 
 
 
 
 
 def digitSquareSum(resltnumber):
 
  # Inside the digitSquareSum() function.
 
  # Convert the given argument to string using the str() function.
 
  strnumbe = str(resltnumber)
 
  # Convert the given argument into list of digits using list(),map(),int() functions.
 
  # Store it in a variable.
 
  numbrlistdigits = list(map(int, strnumbe))
 
  # Take a variable sumsquaredigits and initialize its value to 0.
 
  sumsquaredigits = 0
 
  # Loop in this digits list using For loop.
 
  for digitvalu in numbrlistdigits:
 
  # Increment the value of sumsquaredigits by the square
 
  # of the digit(iterator value).
 
  sumsquaredigits = sumsquaredigits+(digitvalu**2)
 
  # Return the sumsquaredigits value
 
  return sumsquaredigits
 
 
 
 # Create a function checkhapppynumb() which accepts the number as an argument
 
 # and returns true if it is happy number else returns False.
 
 
 
 
 
 def checkhapppynumb(numb):
 
  # Take a variable rest and initialize its value to the given argument.
 
  rest = numb
 
  # Loop till the rest is not equal to 1 or 4 using while loop.
 
  while(rest != 1 and rest != 4):
 
  # Inside the loop pass the reslt value to digitSquareSum()
 
  # and store it in the same variable reslt.
 
  rest = digitSquareSum(rest)
 
  # After the end of the while loop,
 
  # Check whether rest value is 1 or not using the If statement.
 
  if(rest == 1):
 
  # If it is true then the given number is a happy number so return True
 
  return True
 
  else:
 
  # Else it is not a happy number so return False.
 
  return False
 
 
 
 
 
 # Give the lower limit range as static input and store it in a variable.
 
 lowlimrange = 19
 
 # Give the upper limit range as static input and store it in another variable.
 
 upplimrange = 145
 
 print('The happy numbers in the given range',
 
  lowlimrange, 'and', upplimrange, 'are:')
 
 # Loop from lower limit range to upper limit range using For loop.
 
 for l in range(lowlimrange, upplimrange+1):
 
  # IInside the for loop pass the iterator value to checkhapppynumb() function.
 
  if(checkhapppynumb(l)):
 
  # If it returns true then print the iterator value.
 
  print(l, end=' ')
 
 </pre><|endoftext|>"
589,"<|endoftext|>Design a data structure that supports the following operations in Θ(1) time.
insert(x): Inserts an item x to the data structure if not already present.
remove(x): Removes item x from the data structure if present. 
search(x): Searches an item x in the data structure.
getRandom(): Returns a random element from current set of elements 
:''
Python program to design a DS that
supports following operations
in Theta(n) time:
a) Insert
b) Delete
c) Search
d) getRandom
'''
import random

# Class to represent the required
# data structure
class MyDS:

        # Constructor (creates a list and a hash)
        def __init__(self):
                
                # A resizable array
                self.arr = []

                # A hash where keys are lists elements
                # and values are indexes of the list
                self.hashd = {}

        # A Theta(1) function to add an element
        # to MyDS data structure
        def add(self, x):
                
                # If element is already present,
                # then nothing has to be done
                if x in self.hashd:
                        return

                # Else put element at
                # the end of the list
                s = len(self.arr)
                self.arr.append(x)

                # Also put it into hash
                self.hashd[x] = s

        # A Theta(1) function to remove an element
        # from MyDS data structure
        def remove(self, x):
                
                # Check if element is present
                index = self.hashd.get(x, None)
                if index == None:
                        return

                # If present, then remove
                # element from hash
                del self.hashd[x]

                # Swap element with last element
                # so that removal from the list
                # can be done in O(1) time
                size = len(self.arr)
                last = self.arr[size - 1]
                self.arr[index], \
                self.arr[size - 1] = self.arr[size - 1], \
                                                        self.arr[index]

                # Remove last element (This is O(1))
                del self.arr[-1]

                # Update hash table for
                # new index of last element
                self.hashd[last] = index

        # Returns a random element from MyDS
        def getRandom(self):
                
                
                # Find a random index from 0 to size - 1
                index = random.randrange(0, len(self.arr))

                # Return element at randomly picked index
                return self.arr[index]

        # Returns index of element
        # if element is present,
        # otherwise none
        def search(self, x):
                return self.hashd.get(x, None)

# Driver Code
if __name__==""__main__"":
        ds = MyDS()
        ds.add(10)
        ds.add(20)
        ds.add(30)
        ds.add(40)
        print(ds.search(30))
        ds.remove(20)
        ds.add(50)
        print(ds.search(50))
        print(ds.getRandom())

# This code is contributed
# by Saurabh Singh
<|endoftext|>"
590,"<|endoftext|>An anagram is a word, x, formed by rearranging the letters that make up another word, y, and using up all the letters in y at the same frequency. For example, ""dear"" is an anagram of ""read"" and ""plead"" is an anagram of ""paled"".
The Hamming distance between two strings is the number of positions at which they differ. Hamming distances can only be calculated for strings of equal length.
s1 = ""eleven""

s2 = ""twelve""
They only have the third position (index 2) in common, giving them a Hamming distance of 5.
As anagrams are of identical length, the Hamming distance between them can be calculated.
s1 = ""read""

s2 = ""dear""
These strings differ at the first and last positions, giving them a Hamming distance of 2. ""Plead"" and ""paled"" have a Hamming distance of 3.
Create a function that takes two strings, and returns:
True if they are anagrams of each other and their Hamming distance is equal to their length (i.e. no letters in the same positions).
False if they aren't anagrams, or
Their Hamming distance if they are anagrams with >=1 letter at the same index.
Examples
max_ham(""dear"", ""read"") ➞ 2

max_ham(""dare"", ""read"") ➞ True

max_ham(""solemn"", ""molest"") ➞ False
Notes
N/A:def max_ham(s1, s2):
  if sorted(list(s1)) != sorted(list(s2)):
    return False
    d = sum(1 for i in range(len(s1)) if s1[i] != s2[i])
  return d if d != len(s1) else True<|endoftext|>"
591,"<|endoftext|>Given a list, the task is to find Kth’s Smallest and largest element in the given Unsorted list in Python.:# Give the list as static input and store it in a variable.
gvnlst = [19, 24, 25, 36, 81, 144, 600, 900,
          225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]
print('The given list before sorting is', gvnlst)
# Give the value of K as static input and store it in a variable.
kth = 6
# Sort the given list using the sort() function
# which sorts the given list in ascending order.
gvnlst.sort()
print('The given list after sorting is', gvnlst)
# We can get the Kth smallest element in the given list
# by printing the k-1 index element in this sorted list.
print('The', kth,
      'th smallest element in the given list is [', gvnlst[kth-1], ']')
# We can get the Kth largest element in the given list
# by printing the -k index element in this sorted list
# ( '-' refers to negative indexing).
print('The', kth,
      'th largest element in the given list is [', gvnlst[-kth], ']')<|endoftext|>"
592,"<|endoftext|>You are given a phone number as a string number. number consists of digits, spaces ' ', and/or dashes '-'.
You would like to reformat the phone number in a certain manner. Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits. The final digits are then grouped as follows:

2 digits: A single block of length 2.
3 digits: A single block of length 3.
4 digits: Two blocks of length 2 each.

The blocks are then joined by dashes. Notice that the reformatting process should never produce any blocks of length 1 and produce at most two blocks of length 2.
Return the phone number after formatting.
 
Example 1:

Input: number = ""1-23-45 6""
Output: ""123-456""
Explanation: The digits are ""123456"".
Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is ""123"".
Step 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is ""456"".
Joining the blocks gives ""123-456"".

Example 2:

Input: number = ""123 4-567""
Output: ""123-45-67""
Explanation: The digits are ""1234567"".
Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is ""123"".
Step 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are ""45"" and ""67"".
Joining the blocks gives ""123-45-67"".

Example 3:

Input: number = ""123 4-5678""
Output: ""123-456-78""
Explanation: The digits are ""12345678"".
Step 1: The 1st block is ""123"".
Step 2: The 2nd block is ""456"".
Step 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is ""78"".
Joining the blocks gives ""123-456-78"".

 
Constraints:

2 <= number.length <= 100
number consists of digits and the characters '-' and ' '.
There are at least two digits in number.:def reformatNumber(self, number: str) -> str:
  return re.sub('(...?(?=..))', r'\1-', re.sub('\D', '', number))<|endoftext|>"
593,"<|endoftext|>The math.lgamma() method returns the natural logarithm gamma value of a number.

Tip: We can find also find the log gamma value by using the math.gamma() method to find the gamma value, and then use the math.log() method to calculate the log of that value.

Tip: The gamma value is equal to factorial(x-1).:# Import math Library
import math

# Return the log gamma value of different numbers
print (math.lgamma(7))
print (math.lgamma(-4.2))<|endoftext|>"
594,"<|endoftext|>Given a Binary Tree, find the sum of all left leaves in it. For example, sum of all left leaves in below Binary Tree is 5+1=6.

:# Python program to find sum of all left leaves

# A Binary tree node
class Node:
	# Constructor to create a new Node
	def __init__(self, key):
		self.key = key
		self.left = None
		self.right = None

# A utility function to check if a given node is leaf or not
def isLeaf(node):
	if node is None:
		return False
	if node.left is None and node.right is None:
		return True
	return False

# This function return sum of all left leaves in a
# given binary tree
def leftLeavesSum(root):

	# Initialize result
	res = 0
	
	# Update result if root is not None
	if root is not None:

		# If left of root is None, then add key of
		# left child
		if isLeaf(root.left):
			res += root.left.key
		else:
			# Else recur for left child of root
			res += leftLeavesSum(root.left)

		# Recur for right child of root and update res
		res += leftLeavesSum(root.right)
	return res

# Driver program to test above function

# Let us construct the Binary Tree shown in the above function
root = Node(20)
root.left = Node(9)
root.right = Node(49)
root.right.left = Node(23)	
root.right.right = Node(52)
root.right.right.left = Node(50)
root.left.left = Node(5)
root.left.right = Node(12)
root.left.right.right = Node(12)
print (""Sum of left leaves is"", leftLeavesSum(root))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
<|endoftext|>"
595,"<|endoftext|>Static Input: Print Leonardo Number Series:# function which finds the Leonardo sequence recursively
def LeonardoRecursion(numb):
  # The base condition is defined as a value that is less than or equal to 1.
    if(numb <= 1):
        # If the base condition is true, then return 1.
        return 1
    else:
      # Otherwise, call the function recursively with the argument as the number minus 1 plus the function that was called
      # recursively with the parameter as the number minus 2 and add 1 to it.
        return(LeonardoRecursion(numb-1) + LeonardoRecursion(numb-2)+1)


# The user must give the number as static input and store it in a variable.
numb = 10
print(""The Leonardo Number Sequence till the given number"", numb, ' = ')
# Looping from 1 to given number using for loop
for n in range(numb):
  # passing the iterter value as argument to the recursive function LeonardoRecursion
    print(LeonardoRecursion(n))<|endoftext|>"
596,"<|endoftext|>Create a method in the Person class which returns how another person's age compares. Given the objects p1, p2 and p3, which will be initialised with the attributes name and age, return a sentence in the following format:
{other_person} is {older than / younger than / the same age as} me.
Examples
p1 = Person(""Samuel"", 24)
p2 = Person(""Joel"", 36)
p3 = Person(""Lily"", 24)
p1.compare_age(p2) ➞ ""Joel is older than me.""

p2.compare_age(p1) ➞ ""Samuel is younger than me.""

p1.compare_age(p3) ➞ ""Lily is the same age as me.""
Notes
Check out the Resources tab for some helpful tutorials on Python classes!
If you're really stuck, check out the Solutions tab for answers.:class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age
      def compare_age(self, other):
    if other.age < self.age:
      s = 'younger than'
    elif other.age > self.age:
      s = 'older than'
    elif other.age == self.age:
      s = 'the same age as'
    return '{} is {} me.'.format(other.name,s)<|endoftext|>"
597,"<|endoftext|>Now in this post, we will print vowels in a string in python using for loop and list comprehension. Also, develop a Python program to print vowels and consonants in a string. The alphabets ‘A’, ‘E’, ‘I’, ‘O’, ‘U’ (in uppercase) and ‘a’, ‘e’, ‘i’, ‘o’, ‘u’ are vowels, and remaining alphabets are called consonants.:# Python program to print vowels in a string def printVowels(string): # to print the vowels for char in string: if char in ""aeiouAEIOU"": print(char, end=', ') return char # take input string = input('Enter any string: ') # calling function printVowels(string)<|endoftext|>"
598,"<|endoftext|>Given a moment, determine the moment that would be after a gigasecond has passed.

A gigasecond is 10^9 (1,000,000,000) seconds.:from datetime import datetime, timedelta
GIGASECOND = timedelta(seconds=10**9)
def add(moment: datetime) -> datetime:
    return moment + GIGASECOND<|endoftext|>"
599,"<|endoftext|>If a person traveled up a hill for 18mins at 20mph and then traveled back down the same path at 60mph then their average speed traveled was 30mph.
Write a function that returns the average speed traveled given an uphill time, uphill rate and a downhill rate. Uphill time is given in minutes. Return the rate as an integer (mph). No rounding is necessary.
Examples
ave_spd(18, 20, 60) ➞ 30

ave_spd(30, 10, 30) ➞ 15

ave_spd(30, 8, 24) ➞ 12
Notes
The solution is not dividing the sum of the speeds by 2.
Check the Resources tab if your stuck.:def ave_spd(_, up, down):
  return 2*up*down/(up+down)<|endoftext|>"
600,"<|endoftext|>Write a function that stutters a word as if someone is struggling to read it. The first two letters are repeated twice with an ellipsis ... and space after each, and then the word is pronounced with a question mark ?.
Examples
stutter(""incredible"") ➞ ""in... in... incredible?""

stutter(""enthusiastic"") ➞ ""en... en... enthusiastic?""

stutter(""outstanding"") ➞ ""ou... ou... outstanding?""
Notes
Assume all input is in lower case and at least two characters long.:def stutter(word):
    return '{0}... {0}... {1}?'.format(word[:2], word)<|endoftext|>"
601,"<|endoftext|>Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.
Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.
 
Example 1:


Input: path = ""NES""
Output: false 
Explanation: Notice that the path doesn't cross any point more than once.

Example 2:


Input: path = ""NESWW""
Output: true
Explanation: Notice that the path visits the origin twice.
 
Constraints:

1 <= path.length <= 104
path[i] is either 'N', 'S', 'E', or 'W'.:def isPathCrossing(self, path: str) -> bool:
  cur = (0, 0)
  seen = {cur}
  dir = {'N': (0, 1), 'S': (0, -1), 'E': (1, 0), 'W': (-1, 0)}
  for char in path:
  cur = tuple(map(operator.add, cur, dir[char]))
  if cur in seen:
  return True
  seen.add(cur)
  return False<|endoftext|>"
602,"<|endoftext|>Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.

As the answer can be very large, return it modulo 109 + 7.:class Solution(object):
    def threeSumMulti(self, A, target):
        MOD = 10**9 + 7
        count = collections.Counter(A)
        keys = sorted(count)

        ans = 0

        # Now, let's do a 3sum on ""keys"", for i <= j <= k.
        # We will use count to add the correct contribution to ans.
        for i, x in enumerate(keys):
            T = target - x
            j, k = i, len(keys) - 1
            while j <= k:
                y, z = keys[j], keys[k]
                if y + z < T:
                    j += 1
                elif y + z > T:
                    k -= 1
                else: # x+y+z == T, now calculate the size of the contribution
                    if i < j < k:
                        ans += count[x] * count[y] * count[z]
                    elif i == j < k:
                        ans += count[x] * (count[x] - 1) / 2 * count[z]
                    elif i < j == k:
                        ans += count[x] * count[y] * (count[y] - 1) / 2
                    else:  # i == j == k
                        ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6

                    j += 1
                    k -= 1

        return ans % MOD<|endoftext|>"
603,"<|endoftext|>A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.
Given the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.
 
Example 1:

Input: s = ""1000"", k = 10000
Output: 1
Explanation: The only possible array is [1000]

Example 2:

Input: s = ""1000"", k = 10
Output: 0
Explanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.

Example 3:

Input: s = ""1317"", k = 2000
Output: 8
Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]

 
Constraints:

1 <= s.length <= 105
s consists of only digits and does not contain leading zeros.
1 <= k <= 109:class Solution:
  def numberOfArrays(self, s: str, k: int) -> int:
  n = len(s)
  s = [*map(int, s)] + [math.inf] # for easier implementation
  dp = [0] * n + [1]
  for i in range(n - 1, -1, -1):
  num, j = s[i], i + 1
  while 1 <= num <= k and j < n + 1:
  dp[i] = (dp[i] + dp[j]) % 1000000007
  num = 10 * num + s[j]
  j += 1
  return dp[0]<|endoftext|>"
604,"<|endoftext|>Files in Python:

Python file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python’s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.

Given a file, the task is to write a list content into the given File.:# Give the list as static input and store it in a variable.
gvn_lst = ['hello', 'this', 'is', 'Btechgeeks', 'good morning']
# Make a single variable to store the path of the file. This is a constant value. 
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in write mode. In this case, we're writing the contents into the file.
with open(givenFilename, 'w') as givenfilecontent:
  # Iterate in the above given list using the for loop
  for itr in gvn_lst:
  # Write the iterator value(list elements) into the file using the write() function
  givenfilecontent.write(""%s\n"" % itr)
# Open the file in read-only mode. In this case, we're simply reading the contents of the file.
filecontent = open(""samplefile.txt"")
# Read the above file using the read() function(get the content) and print it.
print(filecontent.read())<|endoftext|>"
605,"<|endoftext|>Given a number N, the task is to calculate the value of 1/N!:# Give the number as user input using the int(input()) function and store it in a variable.
gven_nval = int(input(""Enter some random Number = ""))
# Take a variable, initialize it with the value '1', and store it in another variable say
# 'factorl'.
factorl = 1
# Loop from 1 to the given number using the for loop.
for itr in range(1, gven_nval+1):
  # Inside the loop, calculate the factorial of a given number by multiplying the value of
    # the above variable ""factorl"" with the iterator value.
    # Store it in the same variable 'factorl'.
    factorl *= itr
# Calculate the value of 1/factorl and store it in another variable.
fnl_reslt = 1.0/factorl
# Print the value of 1/N! for the given number.
print(""The value of 1/n! with given n value{"", gven_nval, ""} ="", fnl_reslt)<|endoftext|>"
606,"<|endoftext|>The Fibonacci sequence is a classic use case for recursive functions since the value of the sequence at a given index is dependent on the sum of the last two values. However, the recursion tree created by solving the Fibonacci sequence recursively can grow quite fast. Therefore it can be important to think about the implications of running a function recursively. Depending on the size of n needed and the capabilities of the system in question you might want to take a different approach.
Write a non-recursive function that takes an integer n and returns the Fibonacci sequence's value at index n.
Examples
fib(6) ➞ 8
# 0 + 1 = 1, 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8

fib(1) ➞ 1

fib(2) ➞ 1
Notes
Inputs will be whole numbers >= 0:def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a<|endoftext|>"
607,"<|endoftext|>If n be the total number of buckets we decided to fill initially say 10 and let’s say 7 of them got filled now, so the load factor is 7/10=0.7. 

In our implementation whenever we add a key-value pair to the Hash Table we check the load factor if it is greater than 0.7 we double the size of our hash table.:// Java program to demonstrate implementation of our
// own hash table with chaining for collision detection
import java.util.ArrayList;
import java.util.Objects;

// A node of chains
class HashNode<K, V> {
        K key;
        V value;
        final int hashCode;

        // Reference to next node
        HashNode<K, V> next;

        // Constructor
        public HashNode(K key, V value, int hashCode)
        {
                this.key = key;
                this.value = value;
                this.hashCode = hashCode;
        }
}

// Class to represent entire hash table
class Map<K, V> {
        // bucketArray is used to store array of chains
        private ArrayList<HashNode<K, V> > bucketArray;

        // Current capacity of array list
        private int numBuckets;

        // Current size of array list
        private int size;

        // Constructor (Initializes capacity, size and
        // empty chains.
        public Map()
        {
                bucketArray = new ArrayList<>();
                numBuckets = 10;
                size = 0;

                // Create empty chains
                for (int i = 0; i < numBuckets; i++)
                        bucketArray.add(null);
        }

        public int size() { return size; }
        public boolean isEmpty() { return size() == 0; }
        
        private final int hashCode (K key) {
                return Objects.hashCode(key);
        }

        // This implements hash function to find index
        // for a key
        private int getBucketIndex(K key)
        {
                int hashCode = hashCode(key);
                int index = hashCode % numBuckets;
                // key.hashCode() could be negative.
                index = index < 0 ? index * -1 : index;
                return index;
        }

        // Method to remove a given key
        public V remove(K key)
        {
                // Apply hash function to find index for given key
                int bucketIndex = getBucketIndex(key);
                int hashCode = hashCode(key);
                // Get head of chain
                HashNode<K, V> head = bucketArray.get(bucketIndex);

                // Search for key in its chain
                HashNode<K, V> prev = null;
                while (head != null) {
                        // If Key found
                        if (head.key.equals(key) && hashCode == head.hashCode)
                                break;

                        // Else keep moving in chain
                        prev = head;
                        head = head.next;
                }

                // If key was not there
                if (head == null)
                        return null;

                // Reduce size
                size--;

                // Remove key
                if (prev != null)
                        prev.next = head.next;
                else
                        bucketArray.set(bucketIndex, head.next);

                return head.value;
        }

        // Returns value for a key
        public V get(K key)
        {
                // Find head of chain for given key
                int bucketIndex = getBucketIndex(key);
                int hashCode = hashCode(key);
        
                HashNode<K, V> head = bucketArray.get(bucketIndex);

                // Search key in chain
                while (head != null) {
                        if (head.key.equals(key) && head.hashCode == hashCode)
                                return head.value;
                        head = head.next;
                }

                // If key not found
                return null;
        }

        // Adds a key value pair to hash
        public void add(K key, V value)
        {
                // Find head of chain for given key
                int bucketIndex = getBucketIndex(key);
                int hashCode = hashCode(key);
                HashNode<K, V> head = bucketArray.get(bucketIndex);

                // Check if key is already present
                while (head != null) {
                        if (head.key.equals(key) && head.hashCode == hashCode) {
                                head.value = value;
                                return;
                        }
                        head = head.next;
                }

                // Insert key in chain
                size++;
                head = bucketArray.get(bucketIndex);
                HashNode<K, V> newNode
                        = new HashNode<K, V>(key, value, hashCode);
                newNode.next = head;
                bucketArray.set(bucketIndex, newNode);

                // If load factor goes beyond threshold, then
                // double hash table size
                if ((1.0 * size) / numBuckets >= 0.7) {
                        ArrayList<HashNode<K, V> > temp = bucketArray;
                        bucketArray = new ArrayList<>();
                        numBuckets = 2 * numBuckets;
                        size = 0;
                        for (int i = 0; i < numBuckets; i++)
                                bucketArray.add(null);

                        for (HashNode<K, V> headNode : temp) {
                                while (headNode != null) {
                                        add(headNode.key, headNode.value);
                                        headNode = headNode.next;
                                }
                        }
                }
        }

        // Driver method to test Map class
        public static void main(String[] args)
        {
                Map<String, Integer> map = new Map<>();
                map.add(""this"", 1);
                map.add(""coder"", 2);
                map.add(""this"", 4);
                map.add(""hi"", 5);
                System.out.println(map.size());
                System.out.println(map.remove(""this""));
                System.out.println(map.remove(""this""));
                System.out.println(map.size());
                System.out.println(map.isEmpty());
        }
}
<|endoftext|>"
608,"<|endoftext|>Create a function that takes a string and returns the first character of every word if the length of the word is even and the middle character if the length of the word is odd.
Examples
stmid(""Alexa have to paid"") ➞ ""ehtp""
# ""e"" is the middle character of ""Alexa""
# ""h"" is the first character of ""have""

stmid(""Th3 0n3 4nd 0n1y"") ➞ ""hnn0""

stmid(""who is the winner"") ➞ ""hihw""
Notes
N/A:def stmid(s):
  return ''.join(w[[0, len(w) // 2][len(w) % 2]] for w in s.split())<|endoftext|>"
609,"<|endoftext|>Method #1: Using For Loop(Star Character)
Approach:

Give the number of rows of the Hollow Inverted Right Triangle as static input and store it in a variable.
Loop from the given number of rows to 0 using For loop and take iterator value as m.
Loop from the iterator value of the first loop to 0 using another nested For loop.
If m equals zero, rows, n, or n equals one value, the if statement prints stars.
Else print space character.
Print the newline character after inner for loop.
The Exit of the Program.:# Give the number of rows of the Hollow Inverted Right Triangle as static input and store it in a variable.
triNumRows = 7
# Loop from the given number of rows to 0 using For loop and take iterator value as m.
for m in range(triNumRows, 0, -1):
    # Loop from the  iterator value of the first loop to 0 using another nested For loop.
    for n in range(m, 0, -1):
        # If m equals zero, rows, n, or n equals one value, the if statement prints stars.
        if m == 1 or m == triNumRows or n == 1 or n == m:
            print('*', end='')
        else:
            print(' ', end='')
    # Print the newline character after inner for loop.
    print()<|endoftext|>"
610,"<|endoftext|>OOP Exercise 1:  Write a Python program to create a Vehicle class with max_speed and mileage instance attributes.:class Vehicle:
    def __init__(self, max_speed, mileage):
        self.max_speed = max_speed
        self.mileage = mileage

modelX = Vehicle(240, 18)
print(modelX.max_speed, modelX.mileage)<|endoftext|>"
611,"<|endoftext|>Given a square matrix, the task is that we turn it by 180 degrees in an anti-clockwise direction without using any extra space. 

Examples : 

Input :  1  2  3
         4  5  6
         7  8  9
Output : 9 8 7 
         6 5 4 
         3 2 1

Input :  1 2 3 4 
         5 6 7 8 
         9 0 1 2 
         3 4 5 6 
Output : 6 5 4 3 
         2 1 0 9 
         8 7 6 5 
         4 3 2 1:# Python3 program to check if all rows
# of a matrix are rotations of each other
 
MAX = 1000
 
# Returns true if all rows of mat[0..n-1][0..n-1]
# are rotations of each other.
def isPermutedMatrix(mat, n) :
     
    # Creating a string that contains
    # elements of first row.
    str_cat = """"
    for i in range(n) :
        str_cat = str_cat + ""-"" + str(mat[0][i])
 
    # Concatenating the string with itself
    # so that substring search operations
    # can be performed on this
    str_cat = str_cat + str_cat
 
    # Start traversing remaining rows
    for i in range(1, n) :
         
        # Store the matrix into vector
        # in the form of strings
        curr_str = """"
         
        for j in range(n) :
            curr_str = curr_str + ""-"" + str(mat[i][j])
 
        # Check if the current string is present
        # in the concatenated string or not
        if (str_cat.find(curr_str)) :
            return True
             
    return False
 
# Driver code
if __name__ == ""__main__"" :
    n = 4
    mat = [[1, 2, 3, 4],
           [4, 1, 2, 3],
           [3, 4, 1, 2],
           [2, 3, 4, 1]]
     
    if (isPermutedMatrix(mat, n)):
        print(""Yes"")
    else :
        print(""No"")
         
# This code is contributed by Ryuga
<|endoftext|>"
612,"<|endoftext|>Given a string s, return true if s is a good string, or false otherwise.

A string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency).

 :```class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        
        save = []
        
        news = list([str(x) for x in s])  # change s from string to a list  
        
        for i in set(news): # save the count of occurrances in save
            save.append(news.count(i))
        
        for i in save: # if any number is not the same like save[0], return False
            if i != save[0]:
                return False
            
        return True<|endoftext|>"
613,"<|endoftext|>Mubashir needs your help in a simple task of multiplication of elements in a given list.
Create a function which takes a list of integers lst and a positive integer k and returns the minimum and maximum possible product of k elements taken from the list. If enough elements are not available in the list, return None.
Examples
product_pair([1, -2, -3, 4, 6, 7], 1) ➞ (-3, 7)

product_pair([1, -2, -3, 4, 6, 7], 2) ➞ (-21, 42)
# -3*7, 6*7

product_pair([1, -2, -3, 4, 6, 7], 3) ➞ (-126, 168)
# -3*6*7, 4*6*7

product_pair([1, -2, -3, 4, 6, 7], 7) ➞ None
# There are only 6 elements in the list
Notes
N/A:from itertools import*
def product_pair(l,k):
  if len(l)>=k:
    r=[]
    for x in combinations(l,k):
      p=1
      for i in x:p*=i
      r.append(p)
    return min(r),max(r)<|endoftext|>"
614,"<|endoftext|>You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.
You are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.
You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.
Return the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.
 
Example 1:


Input: customers = [8,3], boardingCost = 5, runningCost = 6
Output: 3
Explanation: The numbers written on the gondolas are the number of people currently there.
1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.
2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.
3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.
The highest profit was $37 after rotating the wheel 3 times.

Example 2:

Input: customers = [10,9,6], boardingCost = 6, runningCost = 4
Output: 7
Explanation:
1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.
2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.
3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.
4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.
5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.
6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.
7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.
The highest profit was $122 after rotating the wheel 7 times.

Example 3:

Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92
Output: -1
Explanation:
1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.
2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.
3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.
4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.
5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.
The profit was never positive, so return -1.

 
Constraints:

n == customers.length
1 <= n <= 105
0 <= customers[i] <= 50
1 <= boardingCost, runningCost <= 100:import sys
MIN_INT = -sys.maxsize-1
class Solution:
  def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
  maxx = MIN_INT
  rotate = total =  ans = money = num = i = 0
  for i in range(len(customers)):
  total += customers[i]
  rotate = i+1
  if total >= 4:
  num += 4
  total -= 4
  else: 
  num += total
  total = 0
  money = num * boardingCost - rotate * runningCost
  if maxx < money:
  maxx = money
  ans = rotate
  i+=1
  while(total > 0):
  rotate = i+1
  if total >= 4:
  num += 4
  total -= 4
  else: 
  num += total
  total = 0
  money = num * boardingCost - rotate * runningCost
  if maxx < money:
  maxx = money
  ans = rotate
  i+=1
  if maxx < 0: return -1
  return ans<|endoftext|>"
615,"<|endoftext|>You're in the midst of creating a typing game.
Create a function that takes in two lists: the list of user-typed words, and the list of correctly-typed words and outputs a list containing 1s (correctly-typed words) and -1s (incorrectly-typed words).
# Inputs:
User-typed: [""cat"", ""blue"", ""skt"", ""umbrells"", ""paddy""]
Correct: [""cat"", ""blue"", ""sky"", ""umbrella"", ""paddy""]

# Output: [1, 1, -1, -1, 1]
Examples
correct_stream(
  [""it"", ""is"", ""find""],
  [""it"", ""is"", ""fine""]
) ➞ [1, 1, -1]

correct_stream(
  [""april"", ""showrs"", ""bring"", ""may"", ""flowers""],
  [""april"", ""showers"", ""bring"", ""may"", ""flowers""]
) ➞ [1, -1, 1, 1, 1]
Notes
The input list lengths will always be the same.:def correct_stream(user, correct):
  return [1 if user[i] == correct[i] else -1 for i in range(len(user))]<|endoftext|>"
616,"<|endoftext|>Parallel Lines :

If two lines remain the same distance apart along their entire length, they are said to be parallel. They will not meet no matter how far you stretch them. These lines are denoted by the equations ax+by=c.



The line equation is ax+by=c, where an is the x coefficient and b is the y coefficient. If the slopes of two lines are equal, we say they are parallel. As a result, we must determine the slope, which is “rise over run.”

The straight-line equation is y=mx+c, where m is the slope. Take a1,b1,c1 and a2,b2,c2 from the user and see if they are parallel.

Given the values of equations of two lines, and the task is to check if the given two lines are parallel or not.

Examples:

Example 1:

Input:

a1=4, b1=8, c1=13
a2=2, b2=4, c2=7
Output:

The given lines are parallel to each other
Example 2:

Input:

a1=8, b1=0, c1=9
a2=8, b2=0, c2=11
Output:

The given lines are parallel to each other:#Create a function checkParallel() which accepts the 6 parameters
 #(First and second line x,y,z coordinates)
 #We can Check if the slopes of the given two lines are equal by formula (a1/b1 == a2/b2).
 def checkParallel(a1,b1,c1,a2,b2,c2):
  #Inside the checkParallel() function.
  #Check if both lines y coordinates are not equal to 0 
  #using the If conditional Statement.
  if(b1!=0 and b2!=0):
  #If it is true then check a1/b1 is equal to a2/b2 
  #using another Nested If conditional Statement.
  if(a1/b1==a2/b2):
  #If it is true then return True
  return True
  else:
  #Else return False.
  return False
  #If parent If conditional statement is false then inside the else statement 
  else:
  #check if first line and second line x and y coordinates are equal
  #or not using the nested If conditional statement.
  if(a1==a2 and b1==b2):
  #If it is true then return True else return False.
  return True
  else:
  return False
 #Give the values of a1,b1,c1 as static input 
 #and store it in three separate variables.
 a1,b1,c1=4,8,13
 #Give the values of a2,b2,c2 as static input 
 #and store it in three separate variables.
 a2,b2,c2=2,4,7
 #Pass the a1,b1,c1,a2,b2,c2 as the arguments to checkParallel() function
 #inside the if Conditional statement.
 if(checkParallel(a1,b1,c1,a2,b2,c2)):
  #If it is true then print those lines are parallel.
  print('The given lines are parallel to each other')
 else:
  #Else they are not parallel.
  print('The given lines are not parallel to each other')<|endoftext|>"
617,"<|endoftext|>Create a function that takes a list with numbers and return a list with the elements multiplied by two.
Examples
get_multiplied_list([2, 5, 3]) ➞ [4, 10, 6]

get_multiplied_list([1, 86, -5]) ➞ [2, 172, -10]

get_multiplied_list([5, 382, 0]) ➞ [10, 764, 0]
Notes
N/A:def get_multiplied_list(lst):
  return [i*2 for i in lst]<|endoftext|>"
618,"<|endoftext|>Given an array, find the difference between highest occurrence and least occurrence of any number in an array
Examples: 
 

Input  : arr[] = [7, 8, 4, 5, 4, 1, 1, 7, 7, 2, 5]
Output : 2
Lowest occurring element (5) occurs once.
Highest occurring element (1 or 7) occurs 3 times:# Python code to find the difference between highest
# and least frequencies

from collections import defaultdict
def findDiff(arr,n):

        # Put all elements in a hash map
        mp = defaultdict(lambda:0)
        for i in range(n):
                mp[arr[i]]+=1

        # Find counts of maximum and minimum
        # frequent elements
        max_count=0;min_count=n
        for key,values in mp.items():
                max_count= max(max_count,values)
                min_count = min(min_count,values)

        return max_count-min_count


# Driver code
arr = [ 7, 8, 4, 5, 4, 1, 1, 7, 7, 2, 5]
n = len(arr)
print(findDiff(arr,n))

# This code is contributed by Shrikant13
<|endoftext|>"
619,"<|endoftext|>Remove a List Item
There are several methods to remove items from a list::thislist = [""apple"", ""banana"", ""cherry""]
thislist.remove(""banana"")
print(thislist)<|endoftext|>"
620,"<|endoftext|>Given an array arr[0..n-1] of positive and negative numbers we need to find if there is a cycle in array with given rules of movements. If a number at an i index is positive, then move arr[i]%n forward steps, i.e., next index to visit is (i + arr[i])%n. Conversely, if it’s negative, move backward arr[i]%n steps i.e., next index to visit is (i – arr[i])%n. Here n is size of array. If value of arr[i]%n is zero, then it means no move from index i.

The idea is to form a directed graph of array elements using given set of rules. While forming the graph we don’t make self loops as value arr[i]%n equals to 0 means no moves. Finally our task reduces to detecting cycle in a directed graph. For detecting cycle, we use DFS and in DFS if reach a node which is visited and recursion call stack, we say there is a cycle.
 :# Python3 program to check if a
# given array is cyclic or not
 
# A simple Graph DFS based recursive
# function to check if there is cycle
# in graph with vertex v as root of DFS.
# Refer below article for details.
# https:#www.geeksforgeeks.org/detect-cycle-in-a-graph/
def isCycleRec(v, adj, visited, recur):
    visited[v] = True
    recur[v] = True
    for i in range(len(adj[v])):
        if (visited[adj[v][i]] == False):
            if (isCycleRec(adj[v][i], adj,
                               visited, recur)):
                return True
 
        # There is a cycle if an adjacent is visited
        # and present in recursion call stack recur[]
        else if (visited[adj[v][i]] == True and
                recur[adj[v][i]] == True):
            return True
 
    recur[v] = False
    return False
 
# Returns true if arr[] has cycle
def isCycle(arr, n):
     
    # Create a graph using given
    # moves in arr[]
    adj = [[] for i in range(n)]
    for i in range(n):
        if (i != (i + arr[i] + n) % n):
            adj[i].append((i + arr[i] + n) % n)
 
    # Do DFS traversal of graph
    # to detect cycle  
    visited = [False] * n
    recur = [False] * n
    for i in range(n):
        if (visited[i] == False):
            if (isCycleRec(i, adj,
                           visited, recur)):
                return True
    return True
 
# Driver code
if __name__ == '__main__':
 
    arr = [2, -1, 1, 2, 2]
    n = len(arr)
    if (isCycle(arr, n)):
        print(""Yes"")
    else:
        print(""No"")
 
# This code is contributed by PranchalK
<|endoftext|>"
621,"<|endoftext|>Convert Decimal number to octal using print() output formatting:num = 8
print('%o' % num)<|endoftext|>"
622,"<|endoftext|>You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.

You are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time.

Return the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 109 + 7.:class Solution:
        def countPaths(self, n: int, roads: List[List[int]]) -> int:
                # using dijsktra algorithm-> minimum time/shortest path along a weighted graph
                # Time O(elogv), Space O(v)
                graph = defaultdict(list)
                mod = 10**9 + 7
                for u,v,t in roads:
                        graph[u].append((v,t))
                        graph[v].append((u,t))

                times = [sys.maxsize] * n
                ways = [0] *n
                times[0] = 0
                ways[0] = 1

                hp = [[0,0]] #shortest time, node

                while hp:
                        cur_time, cur_node = heappop(hp)

                        for v,t in graph[cur_node]:
                                if cur_time+t < times[v]:
                                        times[v] = cur_time+t
                                        heappush(hp, [cur_time+t, v])
                                        ways[v] = ways[cur_node]
                                elif cur_time+t == times[v]:
                                        ways[v] += ways[cur_node]

                return ways[-1] % mod<|endoftext|>"
623,"<|endoftext|>Write you own Power without using multiplication(*) and division(/) operator:# Python 3 code for power
# function

# Works only if a >= 0 and b >= 0
def pow(a,b):
	if(b==0):
		return 1
		
	answer=a
	increment=a
	
	for i in range(1,b):
		for j in range (1,a):
			answer+=increment
		increment=answer
	return answer

# driver code
print(pow(5,3))

# this code is contributed
# by Sam007
<|endoftext|>"
624,"<|endoftext|>OOP Exercise 7: Check type of an object:class Vehicle:
    def __init__(self, name, mileage, capacity):
        self.name = name
        self.mileage = mileage
        self.capacity = capacity

class Bus(Vehicle):
    pass

School_bus = Bus(""School Volvo"", 12, 50)

# Python's built-in type()
print(type(School_bus))<|endoftext|>"
625,"<|endoftext|>Given a list, the task is to find the majority element of the given list.

Majority Element:

A majority element appears more than n/2 times, where n is the size of the array. The Boyer–Moore majority vote algorithm uses linear time and constant space to determine the majority of a series of elements.:# Function to find the majority element present in a given list
def majoElement(given_list):
    # majo stores the majority element (if present in the given list)
    majo = -1
    # initializing counter index with 0
    ind = 0
    # do for each element `A[j]` in the list
    for j in range(len(given_list)):
        # check if the counter index is zero or not.
        if ind == 0:
            # set the current candidate of the given list to givenlist[j]
            majo = given_list[j]
            # change the counter index to 1.
            ind = 1
        # Otherwise, if givenlist[j] is a current candidate, increment the counter.
        elif majo == given_list[j]:
            ind = ind + 1
        # Otherwise, if givenlist[j] is a current candidate, decrement the counter.
        else:
            ind = ind - 1
    # return the majority element
    return majo


# Driver Code
# Give the list as user input using map(), int, split(), and list() functions.

# store it in a variable.
given_list = list(map(int,
    input('Enter some random elements of the given list separated by spaces = ').split()))
# Pass the given list to the majoElement function which accepts
# the given list as an argument
# and implement the Boyer–Moore majority vote algorithm.

print(""The majority element present in the givenlist"",
      given_list, '=', majoElement(given_list))<|endoftext|>"
626,"<|endoftext|>Below is an example of a repeating cycle.
is_repeating_cycle([1, 2, 3, 1, 2], 3) ➞ True
# Since the first two elements of [1, 2, 3] equals [1, 2]
Below is an example of a non-repeating cycle.
is_repeating_cycle([1, 2, 3, 1, 3], 3) ➞ False
# Since [1, 2, 3] != [1, 3]
You are tasked with writing a function that takes in two inputs:
A list of integers.
The length of each cycle.
Return the boolean value True if the list is a repeating cycle, and False if the list is a non-repeating cycle.
Examples
is_repeating_cycle([1, 2, 3, 1, 2, 3, 1], 3) ➞ True

is_repeating_cycle([1, 2, 3, 4, 2, 3, 1], 4) ➞ False

is_repeating_cycle([1, 2, 1, 2, 2], 2) ➞ False

is_repeating_cycle([1, 1, 1, 1], 3) ➞ True
Notes
All cycles begin with the first element of the list.
Return True if the cycle length is greater than the list length.:def is_repeating_cycle(lst, length):
  return (lst[:length] * len(lst))[:len(lst)] == lst<|endoftext|>"
627,"<|endoftext|>Functions can Return a Boolean
You can create functions that returns a Boolean Value::def myFunction() :
  return True

if myFunction():
  print(""YES!"")
else:
  print(""NO!"")<|endoftext|>"
628,"<|endoftext|>Given a decimal number and the task is to get the respective octal number using the while loop in Python.

Examples:

Example1:

Input:

Given Number = 15
Output:

The Octal value of the given decimal number { 15 } is: 
17
Example2:

Input:

Given Number = 25
Output:

The Octal value of the given decimal number { 25 } is: 
31:# Give the number as static input and store it in a variable.
 gvn_numb = 15
 # Take a variable say 'a 'and initialize its value with 1.
 a = 1
 print(
  ""The Octal value of the given decimal number {"", gvn_numb, ""} is: "")
 # Take another variable say octl_num and initialize its value with 0.
 octl_num = 0
 # Loop till the given number not equals to zero using the while loop.
 while(gvn_numb != 0):
  # Multiply 'a' with the given number modulus 8 and store it in a variable say 'b'.
  b = (gvn_numb % 8)*a
  # Add the above-got b to the octl_num and store it in the same variable octl_num.
  octl_num = octl_num+b
  # Calculate the value of the given number divided by 8.
  # Store it in the same variable gvn_numb.
  gvn_numb = gvn_numb//8
  # Multiply a with 10 and Store it in the same variable 'a'.
  a = int(a*10)
  # Print the octl_num to get the octal value of the given decimal number.
 print(octl_num)<|endoftext|>"
629,"<|endoftext|>Given an array of n numbers. Your task is to read numbers from the array and keep at-most K numbers at the top (According to their decreasing frequency) every time a new number is read. We basically need to print top k numbers sorted by frequency when input stream has included k distinct elements, else need to print all distinct elements sorted by frequency.
Examples: 
 

Input : arr[] = {5, 2, 1, 3, 2} 
k = 4 
Output : 5 2 5 1 2 5 1 2 3 5 2 1 3 5 
Explanation: 
 

After reading 5, there is only one element 5 whose frequency is max till now. 
so print 5.
After reading 2, we will have two elements 2 and 5 with the same frequency. 
As 2, is smaller than 5 but their frequency is the same so we will print 2 5.
After reading 1, we will have 3 elements 1, 2 and 5 with the same frequency, 
so print 1 2 5.
Similarly after reading 3, print 1 2 3 5
After reading last element 2 since 2 has already occurred so we have now a 
frequency of 2 as 2. So we keep 2 at the top and then rest of the element 
with the same frequency in sorted order. So print, 2 1 3 5.
Input : arr[] = {5, 2, 1, 3, 4} 
k = 4 
Output : 5 2 5 1 2 5 1 2 3 5 1 2 3 4 
Explanation:

After reading 5, there is only one element 5 whose frequency is max till now. 
so print 5.
After reading 2, we will have two elements 2 and 5 with the same frequency. 
As 2, is smaller than 5 but their frequency is the same so we will print 2 5.
After reading 1, we will have 3 elements 1, 2 and 5 with the same frequency, 
so print 1 2 5. 
Similarly after reading 3, print 1 2 3 5
After reading last element 4, All the elements have same frequency 
So print, 1 2 3 4.:# Python program to find top k elements in a stream

# Function to print top k numbers
def kTop(a, n, k):

	# list of size k + 1 to store elements
	top = [0 for i in range(k + 1)]

	# dictionary to keep track of frequency
	freq = {i:0 for i in range(k + 1)}

	# iterate till the end of stream
	for m in range(n):

		# increase the frequency
		if a[m] in freq.keys():
			freq[a[m]] += 1
		else:
			freq[a[m]] = 1

		# store that element in top vector
		top[k] = a[m]

		i = top.index(a[m])
		i -= 1
		
		while i >= 0:

			# compare the frequency and swap if higher
			# frequency element is stored next to it
			if (freq[top[i]] < freq[top[i + 1]]):
				t = top[i]
				top[i] = top[i + 1]
				top[i + 1] = t
			
			# if frequency is same compare the elements
			# and swap if next element is high
			else if ((freq[top[i]] == freq[top[i + 1]]) and (top[i] > top[i + 1])):
				t = top[i]
				top[i] = top[i + 1]
				top[i + 1] = t
			else:
				break
			i -= 1
		
		# print top k elements
		i = 0
		while i < k and top[i] != 0:
			print(top[i],end="" "")
			i += 1
	print()

# Driver program to test above function
k = 4
arr = [ 5, 2, 1, 3, 2 ]
n = len(arr)
kTop(arr, n, k)

# This code is contributed by Sachin Bisht<|endoftext|>"
630,"<|endoftext|>Create a function that takes a list of ""mostly"" numbers, counts the amount of missing numbers and returns their sum. Watch out for strings!
Examples
count_missing_nums([""1"", ""3"", ""5"", ""7"", ""9""]) ➞ 4
# 1+1+1+1

count_missing_nums([""7"", ""3"", ""1"", ""9"", ""5""]) ➞ 4

count_missing_nums([""1"", ""5"", ""B"", ""9"", ""z""]) ➞ 6
Notes
The data might be dirty! Clean out any filthy strings.:def sum_of_missing_nums(lst):
  lst = [int(i) for i in lst if i.isdigit()]
  return max(lst) - min(lst) + 1 - len(lst)<|endoftext|>"
631,"<|endoftext|>You are an ant tasked with adding n new rooms numbered 0 to n-1 to your colony. You are given the expansion plan as a 0-indexed integer array of length n, prevRoom, where prevRoom[i] indicates that you must build room prevRoom[i] before building room i, and these two rooms must be connected directly. Room 0 is already built, so prevRoom[0] = -1. The expansion plan is given such that once all the rooms are built, every room will be reachable from room 0.

You can only build one room at a time, and you can travel freely between rooms you have already built only if they are connected. You can choose to build any room as long as its previous room is already built.

Return the number of different orders you can build all the rooms in. Since the answer may be large, return it modulo 109 + 7.:class Solution:
    def waysToBuildRooms(self, arr: List[int]) -> int:
        MOD = 10**9 + 7
        g = collections.defaultdict(list)
        for cur, pre in enumerate(arr):
            g[pre].append(cur)
            
        def dfs(cur):
            if not g[cur]:
                return 1, 1
            ans, l = 1, 0
            for nxt in g[cur]:
                tmp, r = dfs(nxt)
                ans = (ans * tmp * math.comb(l+r, r)) % MOD
                l += r
            return ans, l + 1
            
        return dfs(0)[0]<|endoftext|>"
632,"<|endoftext|>Arrays
Arrays are used to store multiple values in one single variable::cars = [""Ford"", ""Volvo"", ""BMW""]<|endoftext|>"
633,"<|endoftext|>Create a function that is a Hashtag Generator by using the following rules:
The output must start with a hashtag (#).
Each word in the output must have its first letter capitalized.
If the final result, a single string, is longer than 140 characters, the function should return false.
If either the input (str) or the result is an empty string, the function should return false.
Examples
generate_hashtag(""    Hello     World   "" ) ➞ ""#HelloWorld""

generate_hashtag("""") ➞ false, ""Expected an empty string to return false""

generate_hashtag(""Edabit Is Great"") ➞ ""#EdabitIsGreat"", ""Should remove spaces.""
Notes
N/A:def generate_hashtag(txt):
  txt = txt.title().replace("" "", """")
  return '#' + txt if 0 < len(txt) < 140 else False<|endoftext|>"
634,"<|endoftext|>A tree consisting of n nodes is given, we need to print its DFS.


 :# Python3 code to perform DFS of given tree :
 
# DFS on tree
def dfs(List, node, arrival):
     
    # Printing traversed node
    print(node)
 
    # Traversing adjacent edges
    for i in range(len(List[node])):
 
        # Not traversing the parent node
        if (List[node][i] != arrival):
            dfs(List, List[node][i], node)
 
# Driver Code
if __name__ == '__main__':
 
    # Number of nodes
    nodes = 5
 
    # Adjacency List
    List = [[] for i in range(10000)]
 
    # Designing the tree
    List[1].append(2)
    List[2].append(1)
 
    List[1].append(3)
    List[3].append(1)
 
    List[2].append(4)
    List[4].append(2)
 
    List[3].append(5)
    List[5].append(3)
 
    # Function call
    dfs(List, 1, 0)
 
# This code is contributed by PranchalK
<|endoftext|>"
635,"<|endoftext|>Create a function which returns the word in the string, but with all the fog letters removed. However, if the string is clear from fog, return ""It's a clear day!"".
Examples
clear_fog(""sky"") ➞ ""It's a clear day!""

clear_fog(""fogfogFFfoooofftogffreogffesGgfOogfog"") ➞ ""trees""

clear_fog(""fogFogFogffoObirdsanffodthebffoeffoesGGGfOgFog"") ➞ ""birdsandthebees""
Notes
Hidden words won't include the letters f, o or g.
Hidden words are always in lowercase.:def clear_fog(txt):
  if 'fog' in txt:
    return txt.strip('fog')
  else:
    return 'It\'s a clear day!'<|endoftext|>"
636,"<|endoftext|>Create a function that takes an lst and returns the sum of the numbers between two ""1""s.
Examples
space_apart([1, 0, 1, ""1"", 4, 3, 2, 3, 2, ""1""]) ➞ 14

space_apart([""1"", 9, 20, 38, ""1""]) ➞ 67

space_apart([3, 2, 9, ""1"", 0, 0, -1, ""1""]) ➞ ""invalid""
Notes
Return ""invalid"" if:
A negative number exists inside lst.
The number of ""1""s does not equal 2.
Ignore any other string inside lst.
Note that ""1"" is not 1.:def space_apart(lst):
    count1 = spaces = 0
    for x in lst:
        if x == ""1"":
            count1 += 1
        elif count1 == 1 and type(x) == int and x > 0:
            spaces += x
        elif count1 == 1 and type(x) == int and x < 0:
            break
    return spaces if count1 == 2 else ""invalid""<|endoftext|>"
637,"<|endoftext|>Method #1: Using For Loop (Static Input)
Approach:

Give the number of rows as static input and store it in a variable.
Loop from 1 to the number of rows using For loop.
Loop from 1 to m-1 using another For loop(Nested For loop) where m is the iterator value of the parent For loop.
Print the inner loop iterator value with space.
Loop from m-1 to 0 in decreasing order using another For loop(Nested For loop) where m is the iterator value of the parent For loop.
Print the inner loop iterator value with space.
Print the Newline character after the end of the inner loop.
The Exit of the Program.:# Give the number of rows as static input and store it in a variable.
numberOfRows = 8
# Loop from 1 to the number of rows using For loop.
for m in range(1, numberOfRows + 1):
    # Loop from 1 to m-1 using another For loop(Nested For loop)
    # where m is the iterator value of the parent For loop.
    for n in range(1, m - 1):
      # Print the inner loop iterator value with space.
        print(n, end="" "")
    # Loop from m-1 to 0 in decreasing order using another For loop(Nested For loop)
    # where m is the iterator value of the parent For loop.
    for n in range(m - 1, 0, -1):
      # Print the inner loop iterator value with space.
        print(n, end="" "")
    # Print the Newline character after the end of the inner loop.
    print()<|endoftext|>"
638,"<|endoftext|>You are given a 0-indexed integer array nums consisting of 3 * n elements.

You are allowed to remove any subsequence of elements of size exactly n from nums. The remaining 2 * n elements will be divided into two equal parts:

The first n elements belonging to the first part and their sum is sumfirst.
The next n elements belonging to the second part and their sum is sumsecond.
The difference in sums of the two parts is denoted as sumfirst - sumsecond.

For example, if sumfirst = 3 and sumsecond = 2, their difference is 1.
Similarly, if sumfirst = 2 and sumsecond = 3, their difference is -1.
Return the minimum difference possible between the sums of the two parts after the removal of n elements.:class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums) // 3
        
        maxHeap = [-i for i in nums[:n]]
        heapq.heapify(maxHeap)
        sum1 = [sum(nums[:n])]
        for i in range(n, 2*n):
            heapq.heappush(maxHeap, -nums[i])
            delete = -heapq.heappop(maxHeap)
            sum1.append(sum1[-1] + nums[i] - delete)
        
        minHeap = nums[2*n:]
        heapq.heapify(minHeap)
        sum2 = [sum(minHeap)]
        for i in range(2*n-1, n-1, -1):
            heapq.heappush(minHeap, nums[i])
            delete = heapq.heappop(minHeap)
            sum2.insert(0, sum2[0] + nums[i] - delete)
                
        return min(sum1[i] - sum2[i] for i in range(n+1))<|endoftext|>"
639,"<|endoftext|>Given a positive integer n. Consider a matrix of n rows and n columns, in which each element contain absolute difference of its row number and numbers. The task is to calculate sum of each element of the matrix.

 :# Python3 program to find sum of matrix
# in which each element is absolute
# difference of its corresponding
# row and column number row.
 
# Return the sum of matrix in which each
# element is absolute difference of its
# corresponding row and column number row
def findSum(n):
 
    # Generate matrix
    arr = [[0 for x in range(n)]
              for y in range (n)]
    for i in range (n):
        for j in range (n):
            arr[i][j] = abs(i - j)
 
    # Compute sum
    sum = 0
    for i in range (n):
        for j in range(n):
            sum += arr[i][j]
 
    return sum
 
# Driver Code
if __name__ == ""__main__"":
 
    n = 3
    print (findSum(n))
     
# This code is contributed by ita_c
<|endoftext|>"
640,"<|endoftext|>In this example, you will learn to get the last element of this list.:my_list = ['a', 'b', 'c', 'd', 'e']

# print the last element
print(my_list[-1])<|endoftext|>"
641,"<|endoftext|>In the previous article, we have discussed Python Program to Find GCD of Elements in a Given Range
 Given a number and the task is to find the given number’s second-largest digit.
 sort() method in Python:
 By default, the sort() method sorts the list in ascending order.
 Examples:
 Example1:
 Input:
 Given Number = 1732981
 Output:
 The given number's { 1732981 } second largest digit = 8
 Example2:
 Input:
 Given Number = 76542316
 Output:
 The given number's { 76542316 } second largest digit = 6:# Give the number as static input and store it in a variable.
 
 numb = 1732981
 
 # Convert the given number to string using the str() function and store it in another variable
 
 stringnum = str(numb)
 
 # Create a list of digits say ""digtslst"" using map(),list(),int functions.
 
 # Store it in another variable.
 
 digtslst = list(map(int, stringnum))
 
 # Sort the above-obtained list of digits using the sort() function.
 
 digtslst.sort()
 
 # Calculate the length of the list of digits of a given number using the len() function
 
 # and store it in another variable.
 
 len_digtslst = len(digtslst)
 
 # Calculate the digit at the index length of the digitlist-2 to get the second-largest
 
 # digit of a given number.
 
 # Store it in another variable.
 
 scnd_largst_digtt = digtslst[len_digtslst-2]
 
 # Print the second-largest digit of a given Number.
 
 print(""The given number's {"", numb,
 
  ""} second largest digit ="", scnd_largst_digtt)<|endoftext|>"
642,"<|endoftext|>Create a function that finds each number in the given list that is greater than every number that comes after it. Your solution should return a list of the number(s) that meet these criteria.
Examples
leader([2, 3, 20, 15, 8, 3]) ➞ [20, 15, 8, 3]
# Note that 20 is greater than all the elements to it's
# right side, similarly 15 and so on.

leader([2, 3, 20, 15, 8, 25, 3]) ➞ [25, 3]
# Note that 20 cannot be added because it is not greater than 25.

leader([1, 2, 3, 4, 5]) ➞ [5]
# 5 is technically greater than the (zero) remaining items.

leader([8, 7, 1, 2, 10, 3, 5]) ➞ [10, 5]
# 10 is greater than all items to the right of it, so include.
# 3 is not greater than all items to the right of it, so exclude.
# 5 is greater than the remaining items, so include.
Notes
Add elements in the new list in the same order they occur in the input list.:def leader(arr):
  return [arr[i] for i in range(len(arr)) if max(arr[i:])==arr[i]]<|endoftext|>"
643,"<|endoftext|>
Given a number, the task is to print the previous Armstrong number in Python.:# Import the count from the itertools module using the import and from keyword.
from itertools import count
# Give the number n as user input using the int(input()) function and store it in a variable.
gvnnumb = int(input('Enter some random number = '))
# Loop till the given number in decreasing order using the For loop
# and the count() function.
for m in count(gvnnumb, -1):
        # Convert the given number to the string using the str() function
    # and store it in a variable say strngnumb.
    strngnumb = str(m)
    # Take a variable say cuntsum and initialize its value to 0.
    cuntsum = 0
    # Calculate the length of the string using the len() function
    # and store it in a variable to say
    strnglengt = len(strngnumb)
    # Loop in the strngnumb using the nested For loop(Inner For loop).
    for dgtval in strngnumb:
                # Convert the inner loop iterator value to an integer using the int() function
        # and store it as a new variable say intitr.
        intitr = int(dgtval)
        # Inside the for loop, increment the value of cuntsum with intitr**strnglengt(where ** is power operator).
        cuntsum += intitr**strnglengt
        # After the end of For loop check if cuntsum is equal to the iterator value
    # of the inner for loop using the if conditional statement.

    if(cuntsum == m):
                # If it is true then print the value of cuntsum.
        print('The previous armstrong number of {', gvnnumb, '} is :', cuntsum)
        # Break the parent for loop using the break keyword.
        break<|endoftext|>"
644,"<|endoftext|>n this post, we will discuss how to delete objects using the del operator. In Python everything is an object, so the del keyword can also be used to delete user-defined objects, variables, lists, or parts of a list, etc. The del statement works by unbinding the name, removing it from the set of names known to the Python interpreter. If this variable was the last remaining reference to an object, the object will be removed from memory. If, on the other hand, other variables still refer to this object, the object won’t be deleted.:# Python program to delete user-defined object # user-defined object class My_Project: x = 5 def func(self): print('Know Program') # Output print(My_Project) # deleting My_Project del My_Project # check if class exists print(My_Project)<|endoftext|>"
645,"<|endoftext|>Instructions
In this exercise, we'll develop a simple control system for a nuclear reactor.

For a reactor to produce the power it must be in a state of criticality. If the reactor is in a state less than criticality, it can become damaged. If the reactor state goes beyond criticality, it can overload and result in a meltdown. We want to mitigate the chances of meltdown and correctly manage reactor state.

The following three tasks are all related to writing code for maintaining ideal reactor state.

1. Check for criticality
The first thing a control system has to do is check if the reactor is balanced in criticality. A reactor is said to be critical if it satisfies the following conditions:

The temperature is less than 800 K.
The number of neutrons emitted per second is greater than 500.
The product of temperature and neutrons emitted per second is less than 500000.
Implement the function is_criticality_balanced() that takes temperature measured in kelvin and neutrons_emitted as parameters, and returns True if the criticality conditions are met, False if not.

>>> is_criticality_balanced(750, 600)
True
2. Determine the Power output range
Once the reactor has started producing power its efficiency needs to be determined. Efficiency can be grouped into 4 bands:

green -> efficiency of 80% or more,
orange -> efficiency of less than 80% but at least 60%,
red -> efficiency below 60%, but still 30% or more,
black -> less than 30% efficient.
The percentage value can be calculated as (generated_power/theoretical_max_power)*100 where generated_power = voltage * current. Note that the percentage value is usually not an integer number, so make sure to consider the proper use of the < and <= comparisons.

Implement the function reactor_efficiency(<voltage>, <current>, <theoretical_max_power>), with three parameters: voltage, current, and theoretical_max_power. This function should return the efficiency band of the reactor : 'green', 'orange', 'red', or 'black'.

>>> reactor_efficiency(200,50,15000)
'orange'
3. Fail Safe Mechanism
Your final task involves creating a fail-safe mechanism to avoid overload and meltdown. This mechanism will determine if the reactor is below, at, or above the ideal criticality threshold. Criticality can then be increased, decreased, or stopped by inserting (or removing) control rods into the reactor.

Implement the function called fail_safe(), which takes 3 parameters: temperature measured in kelvin, neutrons_produced_per_second, and threshold, and outputs a status code for the reactor.

If temperature * neutrons_produced_per_second < 90% of threshold, output a status code of 'LOW' indicating that control rods must be removed to produce power.

If temperature * neutrons_produced_per_second are within plus or minus 10% of the threshold the reactor is in criticality and the status code of 'NORMAL' should be output, indicating that the reactor is in optimum condition and control rods are in an ideal position.

If temperature * neutrons_produced_per_second is not in the above-stated ranges, the reactor is going into meltdown and a status code of 'DANGER' must be passed to immediately shut down the reactor.

>>> fail_safe(temperature=1000, neutrons_produced_per_second=30, threshold=5000)
'DANGER':"""""" Meltdown Mitigation exercise """"""
from typing import Union
def is_criticality_balanced(
    temperature: Union[int, float], neutrons_emitted: Union[int, float]
) -> bool:
    """"""Verify criticality is balanced.
 
    :param temperature: temperature value (integer or float)
    :param neutrons_emitted: number of neutrons emitted per second (integer or float)
    :return:  boolean True if conditions met, False if not
 
    A reactor is said to be critical if it satisfies the following conditions:
    - The temperature is less than 800.
    - The number of neutrons emitted per second is greater than 500.
    - The product of temperature and neutrons emitted per second is less than 500000.
    """"""
    return (
        temperature < 800
        and neutrons_emitted > 500
        and (temperature * neutrons_emitted) < 500000
    )
def reactor_efficiency( 
    voltage: Union[int, float],
    current: Union[int, float],
    theoretical_max_power: Union[int, float],
 ) -> str:
    """"""Assess reactor efficiency zone.
 
    :param voltage: voltage value (integer or float)
    :param current: current value (integer or float)
    :param theoretical_max_power: power that corresponds to a 100% efficiency (integer or float)
    :return: str one of 'green', 'orange', 'red', or 'black'
 
    Efficiency can be grouped into 4 bands:
 
    1. green -> efficiency of 80% or more,
    2. orange -> efficiency of less than 80% but at least 60%,
    3. red -> efficiency below 60%, but still 30% or more,
    4. black ->  less than 30% efficient.
 
    The percentage value is calculated as
    (generated power/ theoretical max power)*100
    where generated power = voltage * current
    """"""
    efficiency = 100 * voltage * current / theoretical_max_power
    if efficiency >= 80:
        return ""green""
    elif efficiency >= 60:
        return ""orange""
    elif efficiency >= 30:
        return ""red""
    else:
        return ""black""
def fail_safe( 
    temperature: Union[int, float],
    neutrons_produced_per_second: Union[int, float],
    threshold: Union[int, float],
 ) -> str:
    """"""Assess and return status code for the reactor.
 
    :param temperature: value of the temperature (integer or float)
    :param neutrons_produced_per_second: neutron flux (integer or float)
    :param threshold: threshold (integer or float)
    :return: str one of: 'LOW', 'NORMAL', 'DANGER'
 
    - `temperature * neutrons per second` < 90% of `threshold` == 'LOW'
    - `temperature * neutrons per second` +/- 10% of `threshold` == 'NORMAL'
    - `temperature * neutrons per second` is not in the above-stated ranges ==  'DANGER'
    """"""
    val = temperature * neutrons_produced_per_second
    ratio = val / threshold
    if ratio < 0.9:
        return ""LOW""
    elif ratio <= 1.1:
        return ""NORMAL""
    else:
        return ""DANGER""<|endoftext|>"
646,"<|endoftext|>Given a list, the task is to find the sum of the maximum frequency elements of a given list.

Examples:

Example1:

Input:

Given List = [4, 5, 5, 2, 4, 2, 2, 3, 3, 4, 9, 8, 5, 1, 1]
Output:

The sum of elements in the given list [4, 5, 5, 2, 4, 2, 2, 3, 3, 4, 9, 8, 5, 1, 1] which are having maximum frequency are :
11:# Take a dictionary and initialize it to empty
# using the {} or dict() say freqncyDictionary.
freqncyDictionary = {}
# Give the list as static input and store it in a variable.
gvnlst = [4, 5, 5, 2, 4, 2, 2, 3, 3, 4, 9, 8, 5, 1, 1]
# Loop in the given list using the For loop.
for i in gvnlst:
        # Inside the For loop,
    # Check if the list element is present in the dictionary
    # or not using the if conditional statement and 'in' keyword.
    if i in freqncyDictionary.keys():
                # If it is true then increment the count of the list element
        # in the dictionary by 1.
        freqncyDictionary[i] = freqncyDictionary[i]+1
    # Else initialize the dictionary with the list element as key and value as 1.
    else:
        freqncyDictionary[i] = 1
# Take a variable which stores sum of all the most occuring elements in the given list
# and initialize its value to 0
summaxfreqelemnts = 0
# find the maximum frequency in the freqncyDictionary
# We can find it by converting freqncyDictionary values to list(using list and values() functions)
# and using max() function
maxfrqncy = max(freqncyDictionary.values())
print('The sum of elements in the given list', gvnlst,
      'which are having maximum frequency are :')
# loop in the freqncyDictionary using the For loop
for key in freqncyDictionary:
    # check if any element value having frequency equal to max frequency using the if conditional statement.
    if(freqncyDictionary[key] == maxfrqncy):
        # if it is true then increment the count by the key(list element)
        summaxfreqelemnts = summaxfreqelemnts+key
print(summaxfreqelemnts)<|endoftext|>"
647,"<|endoftext|>Given two integer arrays of same size, “arr[]” and “index[]”, reorder elements in “arr[]” according to given index array. It is not allowed to given array arr’s length.

Example: 



Input:  arr[]   = [10, 11, 12];
        index[] = [1, 0, 2];
Output: arr[]   = [11, 10, 12]
        index[] = [0,  1,  2] 

Input:  arr[]   = [50, 40, 70, 60, 90]
        index[] = [3,  0,  4,  1,  2]
Output: arr[]   = [40, 60, 90, 50, 70]
        index[] = [0,  1,  2,  3,   4]:# Python3 program to sort
# an array according to given
# indexes

# Function to reorder
# elements of arr[] according
# to index[]
def reorder(arr,index, n):

	temp = [0] * n;

	# arr[i] should be
		# present at index[i] index
	for i in range(0,n):
		temp[index[i]] = arr[i]

	# Copy temp[] to arr[]
	for i in range(0,n):
		arr[i] = temp[i]
		index[i] = i
	
# Driver program
arr = [50, 40, 70, 60, 90]
index = [3, 0, 4, 1, 2]
n = len(arr)

reorder(arr, index, n)

print(""Reordered array is:"")
for i in range(0,n):
	print(arr[i],end = "" "")

print(""\nModified Index array is:"")
for i in range(0,n):
	print(index[i],end = "" "")

# This code is contributed by
# Smitha Dinesh Semwal<|endoftext|>"
648,"<|endoftext|>The List is the container that contains the elements of different datatypes whereas a String is a sequence of characters it contains only similar elements. Python provides functionality to convert a list to a string.:def Main(s): string = "" "" return (string.join(s)) s = ['Know', 'Program'] print(Main(s))<|endoftext|>"
649,"<|endoftext|>Given a list of contacts containing the username, email and phone number in any order. Identify the same contacts (i.e., the same person having many contacts) and output the same contacts together. 

Notes: 
1) A contact can store its three fields in any order, i.e., a phone number can appear before username or username can appear before the phone number.
2) Two contacts are the same if they have either the same username or email or phone number. 
We strongly recommend you to minimize your browser and try this yourself first. 
Input is basically an array of structures. A structure contains three fields such that any field can represent any detail about a contact.

The idea is to first create a graph of contacts using given array. In the graph, there is an edge between vertex i to vertex j if they both have either same username or same email or same phone number. Once the graph is constructed, the task reduces to finding connected components in an undirected graph. We can find connected components either by doing DFS or BFS starting from every unvisited vertex. In below code, DFS is used.
:# A Python3 program to find same contacts
# in a list of contacts

# Structure for storing contact details.
class contact:
	def __init__(self, field1,
					field2, field3):
		self.field1 = field1
		self.field2 = field2
		self.field3 = field3

# A utility function to fill entries in
# adjacency matrix representation of graph
def buildGraph(arr, n, mat):
	
	# Initialize the adjacency matrix
	for i in range(n):
		for j in range(n):
			mat[i][j] = 0

	# Traverse through all contacts
	for i in range(n):

		# Add mat from i to j and vice versa,
		# if possible. Since length of each
		# contact field is at max some constant.
		# (say 30) so body execution of this for
		# loop takes constant time.
		for j in range(i + 1, n):
			if (arr[i].field1 == arr[j].field1 or
				arr[i].field1 == arr[j].field2 or
				arr[i].field1 == arr[j].field3 or
				arr[i].field2 == arr[j].field1 or
				arr[i].field2 == arr[j].field2 or
				arr[i].field2 == arr[j].field3 or
				arr[i].field3 == arr[j].field1 or
				arr[i].field3 == arr[j].field2 or
				arr[i].field3 == arr[j].field3):
				mat[i][j] = 1
				mat[j][i] = 1
				break

# A recursive function to perform DFS
# with vertex i as source
def DFSvisit(i, mat, visited, sol, n):
	visited[i] = True
	sol.append(i)

	for j in range(n):
		if (mat[i][j] and not visited[j]):
			DFSvisit(j, mat, visited, sol, n)

# Finds similar contacts in an
# array of contacts
def findSameContacts(arr, n):
	
	# vector for storing the solution
	sol = []

	# Declare 2D adjacency matrix for mats
	mat = [[None] * n for i in range(n)]

	# visited array to keep track
	# of visited nodes
	visited = [0] * n

	# Fill adjacency matrix
	buildGraph(arr, n, mat)

	# Since, we made a graph with contacts
	# as nodes with fields as links. Two
	# nodes are linked if they represent
	# the same person. So, total number of
	# connected components and nodes in each
	# component will be our answer.
	for i in range(n):
		if (not visited[i]):
			DFSvisit(i, mat, visited, sol, n)

			# Add delimiter to separate nodes
			# of one component from other.
			sol.append(-1)

	# Print the solution
	for i in range(len(sol)):
		if (sol[i] == -1):
			print()
		else:
			print(sol[i], end = "" "")

# Driver Code
if __name__ == '__main__':
	arr = [contact(""Gaurav"", ""gaurav@gmail.com"", ""gaurav@gfgQA.com""),
		contact(""Lucky"", ""lucky@gmail.com"", ""+1234567""),
		contact(""gaurav123"", ""+5412312"", ""gaurav123@skype.com""),
		contact(""gaurav1993"", ""+5412312"", ""gaurav@gfgQA.com""),
		contact(""raja"", ""+2231210"", ""raja@gfg.com""),
		contact(""bahubali"", ""+878312"", ""raja"")]

	n = len(arr)
	findSameContacts(arr, n)

# This code is contributed by PranchalK
<|endoftext|>"
650,"<|endoftext|>Print the elements of an array in the decreasing frequency if 2 numbers have same frequency then print the one which came first. 

Examples:  



Input:  arr[] = {2, 5, 2, 8, 5, 6, 8, 8}
Output: arr[] = {8, 8, 8, 2, 2, 5, 5, 6}

Input: arr[] = {2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8}
Output: arr[] = {8, 8, 8, 2, 2, 5, 5, 6, -1, 9999999}:# Python program for above approach

from collections import defaultdict

# Sort by Frequency


def sortByFreq(arr, n):
	# arr -> Array to be sorted
	# n -> Length of Array

	# d is a hashmap(referred as dictionary in python)
	d = defaultdict(lambda: 0)
	for i in range(n):
		d[arr[i]] += 1

	# Sorting the array 'arr' where key
	# is the function based on which
	# the array is sorted
	# While sorting we want to give
	# first priority to Frequency
	# Then to value of item
	arr.sort(key=lambda x: (-d[x], x))

	return (arr)


# Driver Function
if __name__ == ""__main__"":
	arr = [2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8]
	n = len(arr)
	solution = sortByFreq(arr, n)
	print(*solution)<|endoftext|>"
651,"<|endoftext|>Given an array of n elements. Our task is to write a program to rearrange the array such that elements at even positions are greater than all elements before it and elements at odd positions are less than all elements before it.
Examples: 
 

Input : arr[] = {1, 2, 3, 4, 5, 6, 7}
Output : 4 5 3 6 2 7 1

Input : arr[] = {1, 2, 1, 4, 5, 6, 8, 8} 
Output : 4 5 2 6 1 8 1 8:# Python3 code to rearrange the array
# as per the given condition
import array as a
import numpy as np

# function to rearrange the array
def rearrangeArr(arr, n):
	
	# total even positions
	evenPos = int(n / 2)

	# total odd positions
	oddPos = n - evenPos

	# initialising empty array in python
	tempArr = np.empty(n, dtype = object)

	# copy original array in an
	# auxiliary array
	for i in range(0, n):
		
		tempArr[i] = arr[i]

	# sort the auxiliary array
	tempArr.sort()

	j = oddPos - 1

	# fill up odd position in original
	# array
	for i in range(0, n, 2):

		arr[i] = tempArr[j]
		j = j - 1
	
	j = oddPos

	# fill up even positions in original
	# array
	for i in range(1, n, 2):
		arr[i] = tempArr[j]
		j = j + 1
	
	# display array
	for i in range(0, n):
		print (arr[i], end = ' ')

# Driver code
arr = a.array('i', [ 1, 2, 3, 4, 5, 6, 7 ])
rearrangeArr(arr, 7)

# This code is contributed by saloni1297<|endoftext|>"
652,"<|endoftext|>Write a function that sorts the positive numbers in ascending order, and keeps the negative numbers untouched.
Examples
pos_neg_sort([6, 3, -2, 5, -8, 2, -2]) ➞ [2, 3, -2, 5, -8, 6, -2]

pos_neg_sort([6, 5, 4, -1, 3, 2, -1, 1]) ➞ [1, 2, 3, -1, 4, 5, -1, 6]

pos_neg_sort([-5, -5, -5, -5, 7, -5]) ➞ [-5, -5, -5, -5, 7, -5]

pos_neg_sort([]) ➞ []
Notes
If given an empty list, you should return an empty list.
Integers will always be either positive or negative (0 isn't included in the tests).:def pos_neg_sort(lst):
  pos = sorted([i for i in lst if i>0],reverse=True)
  return [pos.pop() if j>0 else j for j in lst]<|endoftext|>"
653,"<|endoftext|>Given multiple strings separated by spaces, the task is to print even-length words in the given string in Python.
:# Give the string as user input using the input() function and store it in a variable.
gvnstrng = input('Enter some random string = ')
print('Even length words in the given string [', gvnstrng, '] are:')
# Convert this string into a list of words and
# split them with spaces using split() and list() functions.
strngwordslist = list(gvnstrng.split())
# Loop in the words list using For loop.
for strngword in strngwordslist:
        # Calculate the length of the word using the len() function.
    wordleng = len(strngword)
    # Check if the length of the word is even or not
    # using the If conditional Statement.
    if(wordleng % 2 == 0):
        # If it is true then print the word.
        print(strngword)<|endoftext|>"
654,"<|endoftext|>User Input: Find the Sum of Series 1^2+2^2+3^2…+N^2 Using For loop and ** operator:# Give the number N as user input using the int(input()) function
# and store it in a variable.
gvnNumbr = int(input('Enter some random number N = '))
# Calculate the sum of the given series using the above mathematical formula
# and store it in a variable to say resltsum
resltsum = (gvnNumbr*(gvnNumbr+1)*((2*gvnNumbr)+1))//6

# Print the resltsum value which is the result of the series till the given Number N.
print(
    'The sum of the series till the given number {', gvnNumbr, '} is :', resltsum)<|endoftext|>"
655,"<|endoftext|>Given the radius and the task is to find the volume and surface area of the given sphere.

Surface Area of the sphere:

A sphere resembles a basketball or the three-dimensional view of a circle. If we know the radius of the Sphere,

we can use the following formula to calculate the Surface Area of the Sphere:

The Surface Area of a Sphere = 4πr²

r= radius of the given sphere

The Volume of the sphere:

Volume is the amount of space inside the sphere. If we know the radius of the sphere, we can use the following formula to calculate the volume of the sphere:

The volume of a Sphere = 4πr³

Examples:

Example 1:

Input:

Given radius = 7.5
Output:

The Surface area of the given Sphere with the radius [ 7.5 ]= 706.500
The volume of the given Sphere with the radius [ 7.5 ]= 1766.250
Example 2:

Input:

Given radius = 3
Output:

The Surface area of the given Sphere with the radius [ 3 ]= 113.040
The volume of the given Sphere with the radius [ 3 ]= 113.040:# Give the radius of a sphere as static input and store it in a variable.
 gvn_radis = 7.5
 # Take a variable and initialize it with the ""pi"" value i.e. 3.14 and
 # store it in another variable.
 standard_pi_val = 3.14
 # Calculate the surface area of the given sphere using the above mathematical formula
 # and store it in another variable.
 surf_area = 4 * standard_pi_val * gvn_radis * gvn_radis
 # Calculate the volume of the given sphere using the above mathematical formula and
 # store it in another variable.
 sphre_volm = (4 / 3) * standard_pi_val * gvn_radis * gvn_radis * gvn_radis
 # Print the surface area of the given sphere.
 print(
  ""The Surface area of the given Sphere with the radius ["", gvn_radis, ""]= %.3f"" % surf_area)
 # Print the volume of the given sphere.
 print(
  ""The volume of the given Sphere with the radius ["", gvn_radis, ""]= %.3f"" % sphre_volm)<|endoftext|>"
656,"<|endoftext|>There are two singly linked lists in a system. By some programming error, the end node of one of the linked list got linked to the second list, forming an inverted Y shaped list. Write a program to get the point where two linked list merge. 
:# defining a node for LinkedList
class Node:
def __init__(self,data):
	self.data=data
	self.next=None
	


def getIntersectionNode(head1,head2):

#finding the total number of elements in head1 LinkedList
	c1=getCount(head1)

#finding the total number of elements in head2 LinkedList
	c2=getCount(head2)

#Traverse the bigger node by 'd' so that from that node onwards, both LinkedList
#would be having same number of nodes and we can traverse them together.
	if c1 > c2:
		d=c1-c2
		return _getIntersectionNode(d,head1,head2)
	else:
		d=c2-c1
		return _getIntersectionNode(d,head2,head1)


def _getIntersectionNode(d,head1,head2):
	
	
	current1=head1
	current2=head2
	
	
	for i in range(d):
		if current1 is None:
			return -1
		current1=current1.next
	
	while current1 is not None and current2 is not None:
	
	# Instead of values, we need to check if there addresses are same
	# because there can be a case where value is same but that value is
	#not an intersecting point.
		if current1 is current2:
			return current1.data # or current2.data ( the value would be same)
	
		current1=current1.next
		current2=current2.next

# Incase, we are not able to find our intersecting point.
	return -1

#Function to get the count of a LinkedList
def getCount(node):
	cur=node
	count=0
	while cur is not None:
		count+=1
		cur=cur.next
	return count
	

if __name__ == '__main__':
# Creating two LinkedList
# 1st one: 3->6->9->15->30
# 2nd one: 10->15->30
# We can see that 15 would be our intersection point

# Defining the common node

common=Node(15)

#Defining first LinkedList

head1=Node(3)
head1.next=Node(6)
head1.next.next=Node(9)
head1.next.next.next=common
head1.next.next.next.next=Node(30)

# Defining second LinkedList

head2=Node(10)
head2.next=common
head2.next.next=Node(30)

print(""The node of intersection is "",getIntersectionNode(head1,head2))

# The code is contributed by Ansh Gupta.<|endoftext|>"
657,"<|endoftext|>Given an array of positive numbers and a number k, find the number of subarrays having product exactly equal to k. We may assume that there is no overflow.:# Python3 program to find number of subarrays
# having product exactly equal to k.

# Function to find number of subarrays
# having product equal to 1.
def countOne(arr, n) :
	i = 0
	
	# To store number of ones in
	# current segment of all 1s.
	Len = 0
	
	# To store number of subarrays
	# having product equal to 1.
	ans = 0
	
	while(i < n) :
		
		# If current element is 1, then
		# find length of segment of 1s
		# starting from current element.
		if(arr[i] == 1) :
			Len = 0
			while(i < n and arr[i] == 1) :
				i += 1
				Len += 1
			
			# add number of possible
			# subarrays of 1 to result.
			ans += (Len*(Len+1)) // 2
		i += 1
	
	return ans

# Function to find number of subarrays having
# product exactly equal to k.
def findSubarrayCount(arr, n, k) :

	start, endval, p, countOnes, res = 0, 0, 1, 0, 0

	while (endval < n) :
	
		p = p * (arr[endval])

		# If product is greater than k then we need to decrease
		# it. This could be done by shifting starting point of
		# sliding window one place to right at a time and update
		# product accordingly.
		if(p > k) :
		
			while(start <= endval and p > k) :
			
				p = p // arr[start]
				start += 1
				
		if(p == k) :
		
			# Count number of succeeding ones.
			countOnes = 0
			while endval + 1 < n and arr[endval + 1] == 1 :
			
				countOnes += 1
				endval += 1

			# Update result by adding both new subarray
			# and effect of succeeding ones.
			res += (countOnes + 1)

			# Update sliding window and result according
			# to change in sliding window. Here preceding
			# 1s have same effect on subarray as succeeding
			# 1s, so simply add.
			while(start <= endval and arr[start] == 1 and k!=1) :
			
				res += (countOnes + 1)
				start += 1

			# Move start to correct position to find new
			# subarray and update product accordingly.
			p = p // arr[start]
			start += 1

		endval += 1

	return res

arr1 = [ 2, 1, 1, 1, 3, 1, 1, 4 ]
n1 = len(arr1)
k = 1

if(k != 1) :
	print(findSubarrayCount(arr1, n1, k))
else :
	print(countOne(arr1, n1))

arr2 = [ 2, 1, 1, 1, 4, 5]
n2 = len(arr2)
k = 4

if(k != 1) :
	print(findSubarrayCount(arr2, n2, k))
else :
	print(countOne(arr2, n2))

	# This code is contributed by divyesh072019
<|endoftext|>"
658,"<|endoftext|>You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.
A route's effort is the maximum absolute difference in heights between two consecutive cells of the route.
Return the minimum effort required to travel from the top-left cell to the bottom-right cell.
 
Example 1:


Input: heights = [[1,2,2],[3,8,2],[5,3,5]]
Output: 2
Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.
This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.

Example 2:


Input: heights = [[1,2,3],[3,8,4],[5,3,5]]
Output: 1
Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].

Example 3:


Input: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
Output: 0
Explanation: This route does not require any effort.

 
Constraints:

rows == heights.length
columns == heights[i].length
1 <= rows, columns <= 100
1 <= heights[i][j] <= 106:class Solution(object):
  def minimumEffortPath(self, heights):
  m, n = len(heights), len(heights[0])
  DIR = [0, 1, 0, -1, 0]
  
  def dfs(r, c, visited, threadshold):
  if r == m-1 and c == n-1: return True # Reach destination
  visited[r][c] = True
  for i in range(4):
  nr, nc = r+DIR[i], c+DIR[i+1]
  if nr < 0 or nr == m or nc < 0 or nc == n or visited[nr][nc]: continue
  if abs(heights[nr][nc]-heights[r][c]) <= threadshold and dfs(nr, nc, visited, threadshold): return True
  return False
  
  def canReachDestination(threadshold):
  visited = [[False] * n for _ in range(m)]
  return dfs(0, 0, visited, threadshold)
  
  left = 0
  ans = right = 10**6
  while left <= right:
  mid = left + (right-left)/2
  if canReachDestination(mid):
  right = mid - 1 # Try to find better result on the left side
  ans = mid
  else:
  left = mid + 1
  return ans<|endoftext|>"
659,"<|endoftext|>Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.:class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        newS = (s+s)[1:-1]
        return s in newS<|endoftext|>"
660,"<|endoftext|>The mode of a group of numbers is the value (or values) that occur most often (values have to occur more than once). Given a sorted list of numbers, return a list of all modes in ascending order.
Examples
mode([4, 5, 6, 6, 6, 7, 7, 9, 10]) ➞ [6] 

mode([4, 5, 5, 6, 7, 8, 8, 9, 9]) ➞ [5, 8, 9]

mode([1, 2, 2, 3, 6, 6, 7, 9]) ➞ [2, 6] 
Notes
In this challenge, all group of numbers will have at least one mode.:def mode(nums):
  m = max(nums.count(i) for i in nums)
  return [i for i in sorted(set(nums)) if nums.count(i)==m]<|endoftext|>"
661,"<|endoftext|>Count Minimum Bits to Flip such that XOR of A and B Equal to C Using For Loop (Static Input):# Create a function to say Flips_Count which takes the given three sequence
# strings and the given number as the arguments and returns the count of minimum bits
# to Flip in such a way that the XOR of A and B equals C.


def Flips_Count(fst_seqnce, scnd_seqnce, third_seqnce, numb):
    # Take a variable say totl_cnt and initialize its value to 0.
    totl_cnt = 0
    # Loop till the given number using the for loop.
    for itr in range(numb):
        # Check if the fst_seqnce[itr] == scnd_seqnce[itr] and third_seqnce[itr] == '1'
        # using the if conditional statement.
        if fst_seqnce[itr] == scnd_seqnce[itr] and third_seqnce[itr] == '1':
          # If the statement is true, then increment the value of above totl_cnt by 1.
          # Store it in the same variable.
            totl_cnt = totl_cnt+1

        # Check if the fst_seqnce[itr] != scnd_seqnce[itr] and third_seqnce[itr] == '0' using
        # the elif conditional statement.
        elif fst_seqnce[itr] != scnd_seqnce[itr] and third_seqnce[itr] == '0':
          # If the statement is true, then increment the value of above totl_cnt by 1.
          # Store it in the same variable.
            totl_cnt = totl_cnt+1
    # Return the value of totl_cnt.
    return totl_cnt


# Give the number (which is the count of bits) as static input and store it in a variable.
numb = 5
# Give the first binary sequence string as static input and store it in another variable.
fst_seqnce = ""11011""
# Give the second binary sequence string as static input and store it in another variable.
scnd_seqnce = ""11001""
# Give the third binary sequence string as static input and store it in another variable.
third_seqnce = ""11100""
# Pass the given three sequence strings and the given number as the arguments to the
# Flips_Count function.
# Print the count of minimum bits to Flip in such a way that the XOR of A and B equals C.
print(""The count of minimum bits to Flip in such a way that the XOR of A and B equals C = "",
      Flips_Count(fst_seqnce, scnd_seqnce, third_seqnce, numb))<|endoftext|>"
662,"<|endoftext|>Given a string s of lower and upper case English letters.
A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:

0 <= i <= s.length - 2
s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.

To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.
Return the string after making it good. The answer is guaranteed to be unique under the given constraints.
Notice that an empty string is also good.
 
Example 1:

Input: s = ""leEeetcode""
Output: ""leetcode""
Explanation: In the first step, either you choose i = 1 or i = 2, both will result ""leEeetcode"" to be reduced to ""leetcode"".

Example 2:

Input: s = ""abBAcC""
Output: """"
Explanation: We have many possible scenarios, and all lead to the same answer. For example:
""abBAcC"" --> ""aAcC"" --> ""cC"" --> """"
""abBAcC"" --> ""abBA"" --> ""aA"" --> """"

Example 3:

Input: s = ""s""
Output: ""s""

 
Constraints:

1 <= s.length <= 100
s contains only lower and upper case English letters.:class Solution:
  def makeGood(self, s: str) -> str:
  result = []
  for c in s:
  if not result:
  result.append(c)
  elif result[-1].isupper() and result[-1].lower() == c:
  result.pop()
  elif result[-1].islower() and result[-1].upper() == c:
  result.pop()
  else:
  result.append(c)
  return ''.join(result)<|endoftext|>"
663,"<|endoftext|>Given an array of random numbers, Push all the zero’s of a given array to the end of the array. For example, if the given arrays is {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0}, it should be changed to {1, 9, 8, 4, 2, 7, 6, 0, 0, 0, 0}. The order of all other elements should be same. Expected time complexity is O(n) and extra space is O(1).
Example: 
 

Input :  arr[] = {1, 2, 0, 4, 3, 0, 5, 0};
Output : arr[] = {1, 2, 4, 3, 5, 0, 0, 0};

Input : arr[]  = {1, 2, 0, 0, 0, 3, 6};
Output : arr[] = {1, 2, 3, 6, 0, 0, 0};:# Python3 code to move all zeroes
# at the end of array

# Function which pushes all
# zeros to end of an array.
def pushZerosToEnd(arr, n):
	count = 0 # Count of non-zero elements
	
	# Traverse the array. If element
	# encountered is non-zero, then
	# replace the element at index
	# 'count' with this element
	for i in range(n):
		if arr[i] != 0:
			
			# here count is incremented
			arr[count] = arr[i]
			count+=1
	
	# Now all non-zero elements have been
	# shifted to front and 'count' is set
	# as index of first 0. Make all
	# elements 0 from count to end.
	while count < n:
		arr[count] = 0
		count += 1
		
# Driver code
arr = [1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9]
n = len(arr)
pushZerosToEnd(arr, n)
print(""Array after pushing all zeros to end of array:"")
print(arr)

# This code is contributed by ""Abhishek Sharma 44""<|endoftext|>"
664,"<|endoftext|>A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two.
You can pick any two different foods to make a good meal.
Given an array of integers deliciousness where deliciousness[i] is the deliciousness of the i​​​​​​th​​​​​​​​ item of food, return the number of different good meals you can make from this list modulo 109 + 7.
Note that items with different indices are considered different even if they have the same deliciousness value.
 
Example 1:

Input: deliciousness = [1,3,5,7,9]
Output: 4
Explanation: The good meals are (1,3), (1,7), (3,5) and, (7,9).
Their respective sums are 4, 8, 8, and 16, all of which are powers of 2.

Example 2:

Input: deliciousness = [1,1,1,3,3,3,7]
Output: 15
Explanation: The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways.
 
Constraints:

1 <= deliciousness.length <= 105
0 <= deliciousness[i] <= 220:class Solution:
  def countPairs(self, deliciousness: List[int]) -> int:
  freq = defaultdict(int)
  for x in deliciousness: freq[x] += 1
  
  ans = 0
  for x in freq: 
  for k in range(22): 
  if 2**k - x <= x and 2**k - x in freq: 
  ans += freq[x]*(freq[x]-1)//2 if 2**k - x == x else freq[x]*freq[2**k-x]
  return ans % 1_000_000_007<|endoftext|>"
665,"<|endoftext|>Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed:

Find the leftmost occurrence of the substring part and remove it from s.
Return s after removing all occurrences of part.

A substring is a contiguous sequence of characters in a string.:class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        
        while part in s:
            
            s = s.replace(part, """", 1)
            
        return s<|endoftext|>"
666,"<|endoftext|>Python will interpret empty values (e.g. 0, (), {}, [], """") as the boolean False. For example, the code ""cat"" if () else ""dog"" returns ""dog"", since () is False.
On the other hand, non-empty values are interpreted as True. For example, ""cat"" if (3, 2) else ""dog"" returns ""cat"" since (3, 2) is True.
Write a function that, given a list of values, returns the list of the values that are False.
Examples
find_the_falsehoods([0, 1, 2, 3]) ➞ [0]

find_the_falsehoods(["""", ""a"", ""ab""]) ➞ [""""]

find_the_falsehoods([None, 1, [], [0], 0]) ➞ [None, [], 0]

find_the_falsehoods([]) ➞ []

find_the_falsehoods([[]]) ➞ [[]]

find_the_falsehoods([[[]]]) ➞ []
Notes
N/A:def find_the_falsehoods(lst):
  return [e for e in lst if not e]<|endoftext|>"
667,"<|endoftext|>Write a sorting function that takes in a list of names and sorts them by last name either alphabetically (ASC) or reverse-alphabetically (DESC).
Examples
sort_contacts([
  ""John Locke"",
  ""Thomas Aquinas"",
  ""David Hume"",
  ""Rene Descartes""
], ""ASC"") ➞ [
  ""Thomas Aquinas"",
  ""Rene Descartes"",
  ""David Hume"",
  ""John Locke""
]

# Aquinas (A) < Descartes (D) < Hume (H) < Locke (L)

sort_contacts([
  ""Paul Erdos"",
  ""Leonhard Euler"",
  ""Carl Gauss""
], ""DESC"") ➞ [
  ""Carl Gauss"",
  ""Leonhard Euler"",
  ""Paul Erdos""
]

# Gauss (G) > Erdos (ER) > Euler (EU)

sort_contacts([], ""DESC"") ➞ []

sort_contacts(None, ""DESC"") ➞ []
Notes
A list with a single name should be trivially returned.
An empty list, or an input of None should return an empty list.:def sort_contacts(names, sort):
    return sorted(names or [], key=lambda x:x.split()[1], reverse=sort!='ASC')<|endoftext|>"
668,"<|endoftext|>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.

 

Example 1:

Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
Example 2:

Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 

Constraints:

1 <= nums.length <= 8
-10 <= nums[i] <= 10:class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        results = []
        def backtrack(comb, counter):
            if len(comb) == len(nums):
                # make a deep copy of the resulting permutation,
                # since the permutation would be backtracked later.
                results.append(list(comb))
                return

            for num in counter:
                if counter[num] > 0:
                    # add this number into the current combination
                    comb.append(num)
                    counter[num] -= 1
                    # continue the exploration
                    backtrack(comb, counter)
                    # revert the choice for the next exploration
                    comb.pop()
                    counter[num] += 1

        backtrack([], Counter(nums))

        return results<|endoftext|>"
669,"<|endoftext|>This article demonstrates an illustration of K-means clustering on a sample random data using open-cv library.:# importing required tools
import numpy as np
from matplotlib import pyplot as plt
  
# creating two test data
X = np.random.randint(10,35,(25,2))
Y = np.random.randint(55,70,(25,2))
Z = np.vstack((X,Y))
Z = Z.reshape((50,2))
  
# convert to np.float32
Z = np.float32(Z)
  
plt.xlabel('Test Data')
plt.ylabel('Z samples')
  
plt.hist(Z,256,[0,256])
  
plt.show()<|endoftext|>"
670,"<|endoftext|>Mubashir and his friend Matt found some gold piles. They decided to follow simple rules to distribute the gold among them.
Gold will be divided into n piles.
Each person will choose bigger gold pile either from far left or far right.
If the weight of both piles is equal then the person will choose left pile.
Help them by creating a function that takes an array of gold piles gold and returns a two-element array with [Mubashir's Gold, Matt's Gold].
Examples
gold_distribution([4, 2, 9, 5, 2, 7]) ➞ [14, 15]
# Mubashir will choose 7, Remaining piles = [4, 2, 9, 5, 2]
# Matt will choose 4, Remaining piles = [2, 9, 5, 2]
# Mubashir will choose 2, Remaining piles = [9, 5, 2]
# Matt will choose 9, Remaining piles = [5, 2]
# Mubashir will choose 5, Remaining piles = [2]
# Matt will choose 2
# Mubashir = 7+2+5 = 14, Matt = 4+9+2 = 15

gold_distribution([10, 1000, 2, 1]) ➞ [12, 1001]

gold_distribution([10, 9, 1, 2, 8, 4]) ➞ [16, 18]
Notes
Mubashir gets to pick his gold first!:def gold_distribution(gold):
    g = gold[:]
    turn, total = 0, [0, 0]
    while g:
        total[turn % 2] += g.pop(-(g[0] < g[-1]))
        turn += 1
    return total<|endoftext|>"
671,"<|endoftext|>Instructions
Given two buckets of different size and which bucket to fill first, determine how many actions are required to measure an exact number of liters by strategically transferring fluid between the buckets.

There are some rules that your solution must follow:

You can only do one action at a time.
There are only 3 possible actions:
Pouring one bucket into the other bucket until either: a) the first bucket is empty b) the second bucket is full
Emptying a bucket and doing nothing to the other.
Filling a bucket and doing nothing to the other.
After an action, you may not arrive at a state where the starting bucket is empty and the other bucket is full.
Your program will take as input:

the size of bucket one
the size of bucket two
the desired number of liters to reach
which bucket to fill first, either bucket one or bucket two
Your program should determine:

the total number of actions it should take to reach the desired number of liters, including the first fill of the starting bucket
which bucket should end up with the desired number of liters - either bucket one or bucket two
how many liters are left in the other bucket
Note: any time a change is made to either or both buckets counts as one (1) action.

Example: Bucket one can hold up to 7 liters, and bucket two can hold up to 11 liters. Let's say at a given step, bucket one is holding 7 liters and bucket two is holding 8 liters (7,8). If you empty bucket one and make no change to bucket two, leaving you with 0 liters and 8 liters respectively (0,8), that counts as one action. Instead, if you had poured from bucket one into bucket two until bucket two was full, resulting in 4 liters in bucket one and 11 liters in bucket two (4,11), that would also only count as one action.

Another Example: Bucket one can hold 3 liters, and bucket two can hold up to 5 liters. You are told you must start with bucket one. So your first action is to fill bucket one. You choose to empty bucket one for your second action. For your third action, you may not fill bucket two, because this violates the third rule -- you may not end up in a state after any action where the starting bucket is empty and the other bucket is full.

Written with <3 at Fullstack Academy by Lindsay Levine.

Exception messages
Sometimes it is necessary to raise an exception. When you do this, you should always include a meaningful error message to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the built in error types, but should still include a meaningful message.

This particular exercise requires that you use the raise statement to ""throw"" a ValueError. The tests will only pass if you both raise the exception and include a message with it.

To raise a ValueError with a message, write the message as an argument to the exception type:

raise ValueError(""A meaningful error message here.""):def measure(bucket_one, bucket_two, goal, start_bucket):
    counter = 0
    p_bucket = 0
    s_bucket = 0
    if goal>bucket_two and goal>bucket_one:
        raise ValueError(""Goal bigger than buckets."")
    else:
        while p_bucket != goal and s_bucket!=goal:
            if counter>30:
                raise ValueError(""Not possible to reach the goal."")
    
            elif start_bucket == ""one"":
    
                if p_bucket==0:
                    p_bucket=bucket_one
                    counter = counter + 1
                    #print(p_bucket, s_bucket, counter)
                elif goal==bucket_two:
                    s_bucket=bucket_two
                    counter = counter + 1
    
                elif s_bucket==bucket_two:
                    s_bucket=0
                    counter = counter + 1
                else:
                    if p_bucket + s_bucket <= bucket_two:
                        s_bucket = s_bucket + p_bucket
                        p_bucket = 0
                        counter = counter + 1
                        #print(p_bucket, s_bucket, counter)
                    else:
                        p_bucket = p_bucket - (bucket_two - s_bucket)
                        s_bucket = bucket_two
                        counter = counter + 1
                        #print(p_bucket, s_bucket, counter)
            else:
                
    
                if s_bucket == 0:
                    s_bucket = bucket_two
                    counter = counter + 1
                    #print(p_bucket, s_bucket, counter)
                    
                elif goal==bucket_one:
                    p_bucket=bucket_one
                    counter = counter + 1
    
                elif p_bucket==bucket_one:
                    p_bucket=0
                    counter = counter + 1
                    #print(p_bucket, s_bucket, counter)
                else:
                    if p_bucket + s_bucket <= bucket_one:
                        p_bucket = s_bucket + p_bucket
                        s_bucket = 0
                        counter = counter + 1
                        #print(p_bucket, s_bucket, counter)
                    else:
                        s_bucket = s_bucket - (bucket_one - p_bucket)
                        p_bucket = bucket_one
                        counter = counter + 1
                        #print(p_bucket, s_bucket, counter)
    
        if goal==p_bucket:
            print(counter,""one"",s_bucket)
            return counter, ""one"", s_bucket
    
        else:
            print(counter, ""two"", p_bucket)
            return counter, ""two"", p_bucket<|endoftext|>"
672,"<|endoftext|>Given the number of rows(largest number) the task is to print the Right Triangle Number pattern in C, C++, and Python.

Examples:

Example1:

Input:

given number of rows of the right triangle = 11
Output:

1 
2 2 
3 3 3 
4 4 4 4 
5 5 5 5 5 
6 6 6 6 6 6 
7 7 7 7 7 7 7 
8 8 8 8 8 8 8 8 
9 9 9 9 9 9 9 9 9 
10 10 10 10 10 10 10 10 10 10 
11 11 11 11 11 11 11 11 11 11 11
Example2:

Input:

given number of rows of the right triangle = 9
Output:

1 
2 2 
3 3 3 
4 4 4 4 
5 5 5 5 5 
6 6 6 6 6 6 
7 7 7 7 7 7 7 
8 8 8 8 8 8 8 8 
9 9 9 9 9 9 9 9 9:# Give the number of rows of the right-angled triangle Number pattern
# as static input and store it in a variable.
triangleNum = 11
# Loop from 1 to the number of rows using For loop.
for m in range(1, triangleNum+1):
  # Loop from 1 to first loop iterator value using another Nested For loop.
  for n in range(1, m+1):
  # Print the iterator value of the nested loop with space in the inner For loop.
  # (This prints the same number parent loop number of times)
  print(m, end=' ')
  # Print the newline character after ending of inner For loop.
  print()<|endoftext|>"
673,"<|endoftext|>Write a function that takes in a word and splits the consonants one by one, but keeps the vowels in a cluster.
Examples
split(""beautifully"") ➞ [""b"", ""eau"", ""t"", ""i"", ""f"", ""u"", ""l"", ""l"", ""y""]

split(""spoonful"") ➞ [""s"", ""p"", ""oo"", ""n"", ""f"", ""u"", ""l""]

split(""swimming"") ➞ [""s"", ""w"", ""i"", ""m"", ""m"", ""i"", ""n"", ""g""]
Notes
Vowels are: a, e, i, o, u.
All letters will be in lower case.:import re
def split(word): 
  return re.findall(r'[aeiou]+|[^aeiou]', word)<|endoftext|>"
674,"<|endoftext|>In this program, we have an array of elements to count the occurrence of its each element. One of the approaches to resolve this problem is to maintain one array to store the counts of each element of the array. Loop through the array and count the occurrence of each element as frequency and store it in another array fr.

1    2   8  3   2   2   2   5   1  :#Initialize array     
arr = [1, 2, 8, 3, 2, 2, 2, 5, 1];     
#Array fr will store frequencies of element    
fr = [None] * len(arr);    
visited = -1;    
     
for i in range(0, len(arr)):    
    count = 1;    
    for j in range(i+1, len(arr)):    
        if(arr[i] == arr[j]):    
            count = count + 1;    
            #To avoid counting same element again    
            fr[j] = visited;    
                
    if(fr[i] != visited):    
        fr[i] = count;    
     
#Displays the frequency of each element present in array    
print(""---------------------"");    
print("" Element | Frequency"");    
print(""---------------------"");    
for i in range(0, len(fr)):    
    if(fr[i] != visited):    
        print(""    "" + str(arr[i]) + ""    |    "" + str(fr[i]));    
print(""---------------------"");    <|endoftext|>"
675,"<|endoftext|>Given two arrays that represent preorder and postorder traversals of a full binary tree, construct the binary tree.:# Python3 program for construction of
# full binary tree

# A binary tree node has data, pointer
# to left child and a pointer to right child
class Node:
	
	def __init__(self, data):
		
		self.data = data
		self.left = None
		self.right = None

# A recursive function to construct
# Full from pre[] and post[].
# preIndex is used to keep track
# of index in pre[]. l is low index
# and h is high index for the
# current subarray in post[]
def constructTreeUtil(pre: list, post: list,
						l: int, h: int,
					size: int) -> Node:
	global preIndex
	
	# Base case
	if (preIndex >= size or l > h):
		return None

	# The first node in preorder traversal
	# is root. So take the node at preIndex
	# from preorder and make it root, and
	# increment preIndex
	root = Node(pre[preIndex])
	preIndex += 1

	# If the current subarray has only
	# one element, no need to recur
	if (l == h or preIndex >= size):
		return root

	# Search the next element
	# of pre[] in post[]
	i = l
	while i <= h:
		if (pre[preIndex] == post[i]):
			break
		
		i += 1

	# Use the index of element
	# found in postorder to divide
	# postorder array in two parts.
	# Left subtree and right subtree
	if (i <= h):
		root.left = constructTreeUtil(pre, post,
									l, i, size)
		root.right = constructTreeUtil(pre, post,
									i + 1, h-1,
									size)

	return root

# The main function to construct
# Full Binary Tree from given
# preorder and postorder traversals.
# This function mainly uses constructTreeUtil()
def constructTree(pre: list,
				post: list,
				size: int) -> Node:
					
	global preIndex
	
	return constructTreeUtil(pre, post, 0,
							size - 1, size)

# A utility function to print
# inorder traversal of a Binary Tree
def printInorder(node: Node) -> None:

	if (node is None):
		return
	
	printInorder(node.left)
	print(node.data, end = "" "")
	
	printInorder(node.right)

# Driver code
if __name__ == ""__main__"":
	
	pre = [ 1, 2, 4, 8, 9, 5, 3, 6, 7 ]
	post = [ 8, 9, 4, 5, 2, 6, 7, 3, 1 ]
	size = len(pre)

	preIndex = 0

	root = constructTree(pre, post, size)

	print(""Inorder traversal of ""
		""the constructed tree: "")
		
	printInorder(root)

# This code is contributed by sanjeev2552<|endoftext|>"
676,"<|endoftext|>Create two functions to_camel_case() and to_snake_case() that each take a single string and convert it into either camelCase or snake_case. If you're not sure what these terms mean, check the Resources tab above.
Examples
to_camel_case(""hello_edabit"") ➞ ""helloEdabit""

to_snake_case(""helloEdabit"") ➞ ""hello_edabit""

to_camel_case(""is_modal_open"") ➞ ""isModalOpen""

to_snake_case(""getColor"") ➞ ""get_color""
Notes
Test input will always be appropriately formatted as either camelCase or snake_case, depending on the function being called.:import re
def to_snake_case(txt):
  pattern = re.compile(r""([a-z])([A-Z])"")
  match = pattern.sub(r'\1_\2', txt).lower()
  return match
  def to_camel_case(txt):
  pattern = re.compile(r""(_)([a-z])"")
  match = pattern.sub(lambda x: x.group(2).upper(), txt)
  a = re.sub(r""_"", """", match)
  return a<|endoftext|>"
677,"<|endoftext|>Linear Regression: It is a commonly used type of predictive analysis. It is a statistical approach for modeling the relationship between a dependent variable and a given set of independent variables. 
 

There are two types of linear regression. 

Attention reader! Don’t stop learning now. Get hold of all the important Machine Learning Concepts with the Machine Learning Foundation Course at a student-friendly price and become industry ready.

Simple Linear Regression
Multiple Linear Regression
Let’s discuss Simple Linear regression using R. 

Simple Linear Regression: 
It is a statistical method that allows us to summarize and study relationships between two continuous (quantitative) variables. One variable denoted x is regarded as an independent variable and the other one denoted y is regarded as a dependent variable. It is assumed that the two variables are linearly related. Hence, we try to find a linear function that predicts the response value(y) as accurately as possible as a function of the feature or independent variable(x).

For understanding the concept let’s consider a salary dataset where it is given the value of the dependent variable(salary) for every independent variable(years experienced).
 

Salary dataset:

Years experienced                 Salary

       1.1                       39343.00
       1.3                       46205.00
       1.5                       37731.00
       2.0                       43525.00
       2.2                       39891.00
       2.9                       56642.00
       3.0                       60150.00
       3.2                       54445.00
       3.2                       64445.00
       3.7                       57189.00
For general purpose, we define: 

x as a feature vector, i.e x = [x_1, x_2, …., x_n], 
y as a response vector, i.e y = [y_1, y_2, …., y_n] 
for n observations (in above example, n=10).
 

Scatter plot of given dataset: 



Now, we have to find a line that fits the above scatter plot through which we can predict any value of y or response for any value of x 
The line which best fits is called the Regression line.
 

The equation of regression line is given by: 

y = a + bx   
Where y is the predicted response value, a is the y-intercept, x is the feature value and b is a slope.
To create the model, let’s evaluate the values of regression coefficient a and b. And as soon as the estimation of these coefficients is done, the response model can be predicted. Here we are going to use Least Square Technique.

The principle of least squares is one of the popular methods for finding a curve fitting a given data. Say (x1, y1), (x2, y2)….(xn, yn) be n observations from an experiment. We are interested in finding a curve 
y=f(x) .....(1)  
Closely fitting the given data of size ‘n’. Now at x=x1 while the observed value of y is y1 the expected value of y from curve (1) is f(x1). Then the residual can be defined by… 
e1=y1-f(x1) ...(2)  
Similarly residual for x2, x3…xn are given by …
e2=y2-f(x2) .....(3)  
..........  
en=yn-f(xn) ....(4)  
While evaluating the residual we will find that some residuals are positives and some are negatives. We are looking forward to finding the curve fitting the given data such that residual at any xi is minimum. Since some of the residuals are positive and others are negative and as we would like to give equal importance to all the residuals it is desirable to consider the sum of the squares of these residuals. Thus we consider:
E=\sum_{i=1}^{n} e_{i}^{2}  
and find the best representative curve.
 

Least Square Fit of a Straight Line 

Suppose, given a dataset (x1, y1), (x2, y2), (x3, y3)…..(xn, yn) of n observation from an experiment. And we are interested in fitting a straight line. 
y=a+bx  
to the given data.
Now consider: 
ei=yi-(axi+b) i=1, 2, 3, 4....n  
Now consider the sum of the squares of ei 
\begin{array}{c} E=\sum_{i=1}^{n} e_{i}^{2} \\ =\sum_{i=1}^{n}\left[y_{i}-\left(a x_{i}+b\right)\right]^{2} \end{array}  
 

Note: E is a function of parameters a and b and we need to find a and b such that E is minimum and the necessary condition for E to be minimum is as follows:

\frac{\partial E}{\partial a}=\frac{\partial E}{\partial b}=0  
This condition yields: 
\begin{array}{l} \frac{\partial E}{\partial a}=\sum_{i=1}^{n} 2 x_{i}\left[y_{i}-\left(a x_{i}+b\right)\right]=0 \\ a \sum_{i=1}^{n} x_{i}+n b=\sum_{i=1}^{n} y_{i} \end{array}  
The above two equations are called normal equations which are solved to get the value of a and b.
The Expression for E can be rewritten as: 
E=\left(\sum_{i=1}^{n} y_{i}^{2}-a \sum_{i=1}^{n} x_{i} y_{i}-b \sum_{i=1}^{n} y_{i}\right)  
The basic syntax for a regression analysis in R is 

lm(Y ~ model) 
where Y is the object containing the dependent variable to be predicted and model is the formula for the chosen mathematical model.
The command lm( ) provides the model’s coefficients but no further statistical information.:# Simple Linear Regression
# Importing the dataset
dataset = read.csv('salary.csv')

# Splitting the dataset into the
# Training set and Test set
install.packages('caTools')
library(caTools)
split = sample.split(dataset$Salary, SplitRatio = 0.7)
trainingset = subset(dataset, split == TRUE)
testset = subset(dataset, split == FALSE)

# Fitting Simple Linear Regression to the Training set
lm.r= lm(formula = Salary ~ YearsExperience,
                                                data = trainingset)
coef(lm.r)

# Predicting the Test set results
ypred = predict(lm.r, newdata = testset)

install.packages(""ggplot2"")
library(ggplot2)

# Visualising the Training set results
ggplot() + geom_point(aes(x = trainingset$YearsExperience,
                                y = trainingset$Salary), colour = 'red') +
geom_line(aes(x = trainingset$YearsExperience,
y = predict(lm.r, newdata = trainingset)), colour = 'blue') +
                
ggtitle('Salary vs Experience (Training set)') +
xlab('Years of experience') +
ylab('Salary')

# Visualising the Test set results
ggplot() +
geom_point(aes(x = testset$YearsExperience, y = testset$Salary),
                        colour = 'red') +
geom_line(aes(x = trainingset$YearsExperience,
                        y = predict(lm.r, newdata = trainingset)),
                        colour = 'blue') +
ggtitle('Salary vs Experience (Test set)') +
xlab('Years of experience') +
ylab('Salary')<|endoftext|>"
678,"<|endoftext|>Given the month and year as numbers, return whether that month contains a Friday 13th.
Examples
has_friday_13(3, 2020) ➞ True

has_friday_13(10, 2017) ➞ True

has_friday_13(1, 1985) ➞ False
Notes
January will be given as 1, February as 2, etc ...
Check Resources for some helpful tutorials on Python's datetime module.:import calendar
def has_friday_13(month, year):
    return calendar.weekday(year, month, 13) == 4<|endoftext|>"
679,"<|endoftext|>The main condition of matrix multiplication is that the number of columns of the 1st matrix must equal to the number of rows of the 2nd one.
As a result of multiplication you will get a new matrix that has the same quantity of rows as the 1st one has and the same quantity of columns as the 2nd one.
For example if you multiply a matrix of ""n"" * ""k"" by ""k"" * ""m"" size you""ll get a new one of ""n"" * ""m"" dimensions.
Create a function that takes 2 x 2D lists m1 and m2 as arguments and returns a 2D list (matrix C). C = A*B.
If the number of columns of the 1st matrix isn't equal to the number of rows of the 2nd: return ""ERROR"".
Examples
multiply_matrix([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
], [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]) ➞ [
  [30, 36, 42],
  [66, 81, 96],
  [102, 126, 150]
]
Notes
N/A:import numpy as np
def multiply_matrix(m1, m2):
  try:
    return np.dot(m1, m2).tolist()
  except:
    return ""ERROR""<|endoftext|>"
680,"<|endoftext|>In this program, we need to create a doubly linked list and rotate it by n node. This can be achieved by maintaining a pointer that starts from the head node and traverses the list until current points to the nth node. Move the list from head to the nth node and place it after tail. Now nth node will be the tail of the list and node next to the nth node will be the new head. Here, n should always be greater than 0 but less than the size of the list.:#Represent a node of doubly linked list    
class Node:    
    def __init__(self,data):    
        self.data = data;    
        self.previous = None;    
        self.next = None;    
            
class RotateList:    
    #Represent the head and tail of the doubly linked list    
    def __init__(self):    
        self.head = None;    
        self.tail = None;    
        self.size = 0;    
            
    #addNode() will add a node to the list    
    def addNode(self, data):    
        #Create a new node    
        newNode = Node(data);    
            
        #If list is empty    
        if(self.head == None):    
            #Both head and tail will point to newNode    
            self.head = self.tail = newNode;    
            #head's previous will point to None    
            self.head.previous = None;    
            #tail's next will point to None, as it is the last node of the list    
            self.tail.next = None;    
        else:    
            #newNode will be added after tail such that tail's next will point to newNode    
            self.tail.next = newNode;    
            #newNode's previous will point to tail    
            newNode.previous = self.tail;    
            #newNode will become new tail    
            self.tail = newNode;    
            #As it is last node, tail's next will point to None    
            self.tail.next = None;    
        #Size will count the number of nodes present in the list    
        self.size = self.size + 1;    
            
    #rotateList() will rotate the list by given n nodes    
    def rotateList(self, n):    
        #Initially, current will point to head    
        current = self.head;    
            
        #n should not be 0 or greater than or equal to number of nodes present in the list    
        if(n == 0 or n >= self.size):    
            return;    
        else:    
            #Traverse through the list till current point to nth node    
            #after this loop, current will point to nth node    
            for i in range(1, n):    
                current = current.next;    
                    
            #Now to move entire list from head to nth node and add it after tail    
            self.tail.next = self.head;    
            #Node next to nth node will be new head    
            self.head = current.next;    
            #Previous node to head should be None    
            self.head.previous = None;    
            #nth node will become new tail of the list    
            self.tail = current;    
            #tail's next will point to None    
            self.tail.next = None;    
                
    #display() will print out the nodes of the list    
    def display(self):    
        #Node current will point to head    
        current = self.head;    
        if(self.head == None):    
            print(""List is empty"");    
            return;    
                
        while(current != None):    
            #Prints each node by incrementing pointer.    
            print(current.data),    
            current = current.next;    
        print();    
            
dList = RotateList();    
#Add nodes to the list    
dList.addNode(1);    
dList.addNode(2);    
dList.addNode(3);    
dList.addNode(4);    
dList.addNode(5);    
     
print(""Original List: "");    
dList.display();    
     
#Rotates list by 3 nodes    
dList.rotateList(3);    
     
print(""Updated List: "");    
dList.display();   <|endoftext|>"
681,"<|endoftext|>Given a binary string, the task is to flip the bits in the given binary string in Python.
 Examples:
 Example1:
 Input:
 Given Binary string =1101010001001
 Output:
 The given binary string before flipping bits is [ 1101010001001 ]
 
 The given binary string after flipping bits is [ 0010101110110 ]
 Example2:
 Input:
 Given Binary string =00110011111
 Output:
 The given binary string before flipping bits is [ 00110011111 ]
 
 The given binary string after flipping bits is [ 11001100000 ]:# Give the binary string as static input and store it in a variable.
 
 gvnbinstring = '1101010001001'
 
 # Take an empty string(say flipbinary) which is the result after flipping the bits
 
 # and initialize its value to a null string using """".
 
 flipbinary = """"
 
 # Traverse the given binary string using For loop.
 
 for bitval in gvnbinstring:
 
  # If the bit is 1 then concatenate the flipbinary with 0.
 
  if bitval == '1':
 
  flipbinary += '0'
 
  # Else concatenate the flipbinary with 1.
 
  else:
 
  flipbinary += '1'
 
 # Print the modified binary string after flipping the bits.
 
 print('The given binary string before flipping bits is [', gvnbinstring, ']')
 
 print('The given binary string after flipping bits is [', flipbinary, ']')
 
 </pre><|endoftext|>"
682,"<|endoftext|>Construct the BST (Binary Search Tree) from its given level order traversal.


 :# Python implementation to construct a BST
# from its level order traversal
import math
 
# node of a BST
class Node:
    def __init__(self,data):
        self.data = data
        self.left = None
        self.right = None
 
# function to get a new node
def getNode( data):
     
    # Allocate memory
    newNode = Node(data)
     
    # put in the data
    newNode.data = data
    newNode.left =None
    newNode.right = None
    return newNode
 
# function to construct a BST from
# its level order traversal
def LevelOrder(root , data):
    if(root == None):
        root = getNode(data)
        return root
     
    if(data <= root.data):
        root.left = LevelOrder(root.left, data)
    else:
        root.right = LevelOrder(root.right, data)
    return root    
 
def constructBst(arr, n):
    if(n == 0):
        return None
    root = None
 
    for i in range(0, n):
        root = LevelOrder(root , arr[i])
     
    return root
 
# function to print the inorder traversal
def inorderTraversal( root):
    if (root == None):
        return None
     
    inorderTraversal(root.left)
    print(root.data,end = "" "")
    inorderTraversal(root.right)
 
# Driver program
if __name__=='__main__':
 
    arr = [7, 4, 12, 3, 6, 8, 1, 5, 10]
    n = len(arr)
     
    root = constructBst(arr, n)
     
    print(""Inorder Traversal: "", end = """")
    root = inorderTraversal(root)
         
# This code is contributed by Srathore
<|endoftext|>"
683,"<|endoftext|>Create a function that takes a dictionary of student names and returns a list of student names in alphabetical order.
Examples
get_student_names({
  ""Student 1"" : ""Steve"",
  ""Student 2"" : ""Becky"",
  ""Student 3"" : ""John""
}) ➞ [""Becky"", ""John"", ""Steve""]
Notes
Don't forget to return your result.
If you get stuck on a challenge, find help in the Resources tab.
If you're really stuck, unlock solutions in the Solutions tab.:def get_student_names(students):
  return sorted(students.values())<|endoftext|>"
684,"<|endoftext|>Static Input: Find the Sum of Series 1^2+2^2+3^2…+N^2 using For loop:# Give the number N as static input and store it in a variable.
gvnNumbr = 5
# Take a variable say resltsum which gives the sum of
# the given series till N and initialize its value to 0.
resltsum = 0
# Loop from 1 to given number using the For loop.
for k in range(1, gvnNumbr+1):
    # Inside the For loop,
    # Calculate the value of iterator value * iterator value and store it in a variable.
    squarevalu = k*k
    # Add the above variable to the resltsum
    resltsum = resltsum+squarevalu

# Print the resltsum value which is the result of the series till the given Number N.
print(
    'The sum of the series till the given number {', gvnNumbr, '} is :', resltsum)<|endoftext|>"
685,"<|endoftext|>Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
 

Example 1:


Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
Example 2:


Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-104 <= matrix[i][j], target <= 104:class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m = len(matrix)
        if m == 0:
            return False
        n = len(matrix[0])
        
        # binary search
        left, right = 0, m * n - 1
        while left <= right:
                pivot_idx = (left + right) // 2
                pivot_element = matrix[pivot_idx // n][pivot_idx % n]
                if target == pivot_element:
                    return True
                else:
                    if target < pivot_element:
                        right = pivot_idx - 1
                    else:
                        left = pivot_idx + 1
        return False<|endoftext|>"
686,"<|endoftext|>You are given a 2D integer array, queries. For each queries[i], where queries[i] = [ni, ki], find the number of different ways you can place positive integers into an array of size ni such that the product of the integers is ki. As the number of ways may be too large, the answer to the ith query is the number of ways modulo 109 + 7.
Return an integer array answer where answer.length == queries.length, and answer[i] is the answer to the ith query.
 
Example 1:

Input: queries = [[2,6],[5,1],[73,660]]
Output: [4,1,50734910]
Explanation: Each query is independent.
[2,6]: There are 4 ways to fill an array of size 2 that multiply to 6: [1,6], [2,3], [3,2], [6,1].
[5,1]: There is 1 way to fill an array of size 5 that multiply to 1: [1,1,1,1,1].
[73,660]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 109 + 7 = 50734910.

Example 2:

Input: queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]
Output: [1,2,3,10,5]

 
Constraints:

1 <= queries.length <= 104 
1 <= ni, ki <= 104:primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)
class Solution:
  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
  def nK(n: int, k: int) -> int:
  res = 1
  for p in primes:
  r = 0
  while k % p == 0:
  r += 1
  k /= p
  res *= comb(n - 1 + r, r)
  if (k != 1):
  res *= n  
  return res % 1000000007
  
  return [nK(n, k) for n, k in queries]<|endoftext|>"
687,"<|endoftext|>Given a Binary Tree, print the nodes level-wise, each level on a new line. :# Python3 program to print levels
# line by line
from collections import deque as queue

# A Binary Tree Node
class Node:
	
	def __init__(self, key):
		
		self.data = key
		self.left = None
		self.right = None

# Function to do level order
# traversal line by line
def levelOrder(root):
	
	if (root == None):
		return

	# Create an empty queue for
	# level order traversal
	q = queue()

	# To store front element of
	# queue.
	#node *curr

	# Enqueue Root and None node.
	q.append(root)
	q.append(None)

	while (len(q) > 1):
		curr = q.popleft()
		#q.pop()

		# Condition to check
		# occurrence of next
		# level.
		if (curr == None):
		q.append(None)
		print()

		else:

			# Pushing left child of
			# current node.
			if (curr.left):
				q.append(curr.left)

			# Pushing right child of
			# current node.
			if (curr.right):
				q.append(curr.right)

			print(curr.data, end = "" "")
			
# Driver code
if __name__ == '__main__':
	
	# Let us create binary tree
	# shown above
	root = Node(1)
	root.left = Node(2)
	root.right = Node(3)
	root.left.left = Node(4)
	root.left.right = Node(5)
	root.right.right = Node(6)

	levelOrder(root)

# This code is contributed by mohit kumar 29<|endoftext|>"
688,"<|endoftext|>Noddy has written a mysterious function which takes in a word and returns True if it's passed a specific test. Solve the riddle of what Noddy's function is by having a look at some of the examples below.
Examples
noddy_function(""FANTASTIC"") ➞ True

noddy_function(""wonderful"") ➞ False

noddy_function(""NODDY"") ➞ False
Notes
Check the Tests tab for more examples.
This isn't really a coding challenge, more of a fun riddle ;):def noddy_function(s):
  return not 'd' in s.lower()<|endoftext|>"
689,"<|endoftext|>The following is a simple recursive Binary Search function in C++ taken from here.:# A recursive binary search function. It returns location of x in
# given array arr[l..r] is present, otherwise -1
def binarySearch(arr, l, r, x):
if (r >= l):
		mid = l + (r - l)/2;
		
# If the element is present at the middle itself
if (arr[mid] == x):
		return mid;
	
# If element is smaller than mid, then it can only be present
# in left subarray
	if (arr[mid] > x):
	return binarySearch(arr, l, mid-1, x);

	# Else the element can only be present in right subarray
	return binarySearch(arr, mid+1, r, x);
	
# We reach here when element is not present in array
return -1;

# This code is contributed by umadevi9616<|endoftext|>"
690,"<|endoftext|>Given N elements, write a program that prints the length of the longest increasing subsequence whose adjacent element difference is one. 
Examples: 

Input : a[] = {3, 10, 3, 11, 4, 5, 6, 7, 8, 12} 
Output : 6 
Explanation: 3, 4, 5, 6, 7, 8 is the longest increasing subsequence whose adjacent element differs by one. :# python program to find length of the
# longest increasing subsequence
# whose adjacent element differ by 1

from collections import defaultdict
import sys

# function that returns the length of the
# longest increasing subsequence
# whose adjacent element differ by 1

def longestSubsequence(a, n):
        mp = defaultdict(lambda:0)

        # stores the length of the longest
        # subsequence that ends with a[i]
        dp = [0 for i in range(n)]
        maximum = -sys.maxsize

        # iterate for all element
        for i in range(n):

                # if a[i]-1 is present before i-th index
                if a[i] - 1 in mp:

                        # last index of a[i]-1
                        lastIndex = mp[a[i] - 1] - 1

                        # relation
                        dp[i] = 1 + dp[lastIndex]
                else:
                        dp[i] = 1

                        # stores the index as 1-index as we need to
                        # check for occurrence, hence 0-th index
                        # will not be possible to check
                mp[a[i]] = i + 1

                # stores the longest length
                maximum = max(maximum, dp[i])
        return maximum


# Driver Code
a = [3, 10, 3, 11, 4, 5, 6, 7, 8, 12]
n = len(a)
print(longestSubsequence(a, n))

# This code is contributed by Shrikant13
<|endoftext|>"
691,"<|endoftext|>User Input: Print Leonardo Number Series:# function which finds the Leonardo sequence recursively
def LeonardoRecursion(numb):
  # The base condition is defined as a value that is less than or equal to 1.
  # If the base condition is true, then return 1.
    if(numb <= 1):
        return 1
    else:
      # Otherwise, call the function recursively with the argument as the number minus 1 plus the function that was called
      # recursively with the parameter as the number minus 2 and add 1 to it.
        return(LeonardoRecursion(numb-1) + LeonardoRecursion(numb-2)+1)


# The user must give the number as user input using the
# int(input()) function and store it in a variable.
numb = int(input('Enter some random number = '))
print(""The Leonardo Sequence till the given number"", numb, ' = ')
# Looping from 1 to given number using for loop
for n in range(numb):
  # passing the iterter value as argument to the recursive function LeonardoRecursion
    print(LeonardoRecursion(n))<|endoftext|>"
692,"<|endoftext|>There are three cups on a table, at positions A, B, and C. At the start, there is a ball hidden under the cup at position B.
However, I perform several swaps on the cups, which is notated as two letters. For example, if I swap the cups at positions A and B, I could notate this as AB or BA.
Create a function that returns the letter position that the ball is at, once I finish swapping the cups. The swaps will be given to you as a list.
Worked Example
cup_swapping([""AB"", ""CA"", ""AB""]) ➞ ""C""

# Ball begins at position B.
# Cups A and B swap, so the ball is at position A.
# Cups C and A swap, so the ball is at position C.
# Cups A and B swap, but the ball is at position C, so it doesn't move.
Examples
cup_swapping([""AB"", ""CA""]) ➞ ""C""

cup_swapping([""AC"", ""CA"", ""CA"", ""AC""]) ➞ ""B""

cup_swapping([""BA"", ""AC"", ""CA"", ""BC""]) ➞ ""A""
Notes
A swap could be notated in two different ways, since both ways end up with the same outcome.
All swaps will be notated as capital letters and will be valid.
You cannot swap a cup with itself.:def cup_swapping(swaps):
    ball = ""B""
    for move in swaps:
        if ball in move:
            ball = move[1] if move[0] == ball else move[0]
    return ball<|endoftext|>"
693,"<|endoftext|>You are given an array nums consisting of non-negative integers. You are also given a queries array, where queries[i] = [xi, mi].
The answer to the ith query is the maximum bitwise XOR value of xi and any element of nums that does not exceed mi. In other words, the answer is max(nums[j] XOR xi) for all j such that nums[j] <= mi. If all elements in nums are larger than mi, then the answer is -1.
Return an integer array answer where answer.length == queries.length and answer[i] is the answer to the ith query.
 
Example 1:

Input: nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
Output: [3,3,7]
Explanation:
1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.
2) 1 XOR 2 = 3.
3) 5 XOR 2 = 7.

Example 2:

Input: nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
Output: [15,-1,5]

 
Constraints:

1 <= nums.length, queries.length <= 105
queries[i].length == 2
0 <= nums[j], xi, mi <= 109:class Trie:
  def __init__(self):
  self.root = {}
  
  def insert(self, num):
  p = self.root
  for i in range(31, -1, -1):
  cur = (num >> i) & 1
  if cur not in p:
  p[cur] = {}
  p = p[cur]
  
  def query(self, num):
  if not self.root: 
  return -1
  p, ans = self.root, 0
  for i in range(31, -1, -1):
  cur = (num >> i) & 1
  if 1 - cur in p:
  p = p[1 - cur]
  ans |= (1 << i)
  else:
  p = p[cur]
  return ans

class Solution:
  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
  nums.sort()
  queries = sorted(enumerate(queries), key=lambda x: x[1][1])
  trie = Trie()
  ans = [-1] * len(queries)
  j = 0
  for i, (x, m) in queries:
  while j < len(nums) and nums[j] <= m:
  trie.insert(nums[j])
  j += 1
  ans[i] = trie.query(x)
  return ans<|endoftext|>"
694,"<|endoftext|>You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order.
The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 <= i <= n-1 where source[i] != target[i] (0-indexed).
Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source.
 
Example 1:

Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]
Output: 1
Explanation: source can be transformed the following way:
- Swap indices 0 and 1: source = [2,1,3,4]
- Swap indices 2 and 3: source = [2,1,4,3]
The Hamming distance of source and target is 1 as they differ in 1 position: index 3.

Example 2:

Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []
Output: 2
Explanation: There are no allowed swaps.
The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2.

Example 3:

Input: source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]
Output: 0

 
Constraints:

n == source.length == target.length
1 <= n <= 105
1 <= source[i], target[i] <= 105
0 <= allowedSwaps.length <= 105
allowedSwaps[i].length == 2
0 <= ai, bi <= n - 1
ai != bi:def minimumHammingDistance(self, source, target, edges):
  res = n = len(source)
  G = [set() for i in xrange(n)]
  for i, j in edges:
  G[i].add(j)
  G[j].add(i)
  seen = [0] * n

  def dfs(i):
  seen[i] = 1
  found.append(i)
  for j in G[i]:
  if not seen[j]:
  dfs(j)

  for i in xrange(n):
  if seen[i]: continue
  found = []
  dfs(i)
  count1 = collections.Counter(source[j] for j in found)
  count2 = collections.Counter(target[j] for j in found)
  res -= sum((count1 & count2).values())
  return res<|endoftext|>"
695,"<|endoftext|>Create a customized data structure such that it has functions :- 
GetLastElement(); 
RemoveLastElement(); 
AddElement() 
GetMin()

All the functions should be of O(1):# Program to demonstrate customized data structure
# which supports functions in O(1)
import sys
 
stack = []
Min = sys.maxsize
 
# Utility function for adding a new element
def addElement(x):
     
    global Min, stack
    if (len(stack) == 0 or x < Min):
        Min = x
    pair = [x, Min]
    stack.append(pair)
    print(x, ""inserted successfully"")
 
# Utility function for returning last
# element of stack
def getLastElement():
     
    global Min, stack
     
    if (len(stack) == 0):
        print(""UnderFlow Error"")
        return -1
    else:
        return stack[-1][0]
 
# Utility function for removing last
# element successfully;
def removeLastElement():
     
    global Min, stack
    if (len(stack) == 0):
        print(""UnderFlow Error"")
    elif (len(stack) > 1):
        Min = stack[-2][1]
    else:
        Min = sys.maxsize
    stack.pop()
     
    print(""removed successfully"")
 
# Utility function for returning min
# element till now;
def getMin():
     
    global Min, stack
    if (len(stack) == 0):
        print(""UnderFlow Error"")
        return -1
         
    return stack[-1][1]
 
# Driver code
addElement(5)
addElement(7)
addElement(3)
print(""min element ::"", getMin())
removeLastElement()
addElement(2)
addElement(9)
print(""Last element ::"", getLastElement())
addElement(0)
print(""min element ::"", getMin())
removeLastElement()
addElement(11)
print(""min element ::"", getMin())
 
# This code is contributed by mukesh07
<|endoftext|>"
696,"<|endoftext|>In this tutorial, we will write a Python program to get the transpose of matrix and print the result in output.

Before writing the Python program, let's first look at the overview of the transpose of a matrix.

Transpose of a matrix
If you change the rows of a matrix with the column of the same matrix, it is known as the transpose of a matrix. It is denoted as X'. For example: The element at ith row and jth column in X will be placed at jth row and ith column in X'.

Example: Suppose we have given following matrix A:

A = [[5, 4, 3]  
         [2, 4, 6]  
         [4, 7, 9]  
         [8, 1, 3]]  
At would be the transpose of above given matrix i.e., A[i][j] = At[j][i] and therefore At should be:

At = [5, 2, 4, 8]
        [4, 4, 7, 1]
        [3, 6, 9, 3]
:# Define a matrix A  
A = [[5, 4, 3],  
         [2, 4, 6],  
         [4, 7, 9],  
         [8, 1, 3]]  
# Define an empty matrix of reverse order  
transResult = [[0, 0, 0, 0],    
                             [0, 0, 0, 0],  
                             [0, 0, 0, 0]]  
# Use nested for loop on matrix A  
for a in range(len(A)):    
   for b in range(len(A[0])):    
          transResult[b][a] = A[a][b] # store transpose result on empty matrix          
# Printing result in the output  
print(""The transpose of matrix A is: "")  
for res in transResult:    
   print(res)  <|endoftext|>"
697,"<|endoftext|>Given a Number and the task is to check if the given number is even or odd using the bitwise operator using Bitwise &(and) Operator (User Input):# Give the number as user input using the int(input()) function and 
# store it in a variable.
gvn_numb = int(input(""Enter some random number = ""))
# Apply bitwise & operation for the given number and 1 and store it in another variable
# say evn_or_od.
evn_or_od = gvn_numb & 1
# Pass the above result to the if conditional statement.
if (evn_or_od):
    # If the statement is true, then print ""The Number given is an Odd Number"".
    print(""The Number given is an Odd Number"")
else:
    # Else print ""The Number given is an Even Number"".
    print(""The Number given is an Even Number"")<|endoftext|>"
698,"<|endoftext|>We have briefly discussed sparse table in Range Minimum Query (Square Root Decomposition and Sparse Table)
Sparse table concept is used for fast queries on a set of static data (elements do not change). It does preprocessing so that the queries can be answered efficiently.
 
 

Example Problem 1 : Range Minimum Query



We have an array arr[0 . . . n-1]. We need to efficiently find the minimum value from index L (query start) to R (query end) where 0 <= L <= R <= n-1. Consider a situation when there are many range queries. 
Example: 

Input:  arr[]   = {7, 2, 3, 0, 5, 10, 3, 12, 18};
        query[] = [0, 4], [4, 7], [7, 8]

Output: Minimum of [0, 4] is 0
        Minimum of [4, 7] is 3
        Minimum of [7, 8] is 12:# Python3 program to do range minimum
# query using sparse table
import math

# Fills lookup array lookup[][] in
# bottom up manner.
def buildSparseTable(arr, n):

	# Initialize M for the intervals
	# with length 1
	for i in range(0, n):
		lookup[i][0] = arr[i]
	
	j = 1
	
	# Compute values from smaller to
	# bigger intervals
	while (1 << j) <= n:

		# Compute minimum value for all
		# intervals with size 2^j
		i = 0
		while (i + (1 << j) - 1) < n:

			# For arr[2][10], we compare arr[lookup[0][7]]
			# and arr[lookup[3][10]]
			if (lookup[i][j - 1] <
				lookup[i + (1 << (j - 1))][j - 1]):
				lookup[i][j] = lookup[i][j - 1]
			else:
				lookup[i][j] = \
						lookup[i + (1 << (j - 1))][j - 1]
			
			i += 1
		j += 1	

# Returns minimum of arr[L..R]
def query(L, R):

	# Find highest power of 2 that is smaller
	# than or equal to count of elements in
	# given range. For [2, 10], j = 3
	j = int(math.log2(R - L + 1))

	# Compute minimum of last 2^j elements
	# with first 2^j elements in range.
	# For [2, 10], we compare arr[lookup[0][3]]
	# and arr[lookup[3][3]],
	if lookup[L][j] <= lookup[R - (1 << j) + 1][j]:
		return lookup[L][j]

	else:
		return lookup[R - (1 << j) + 1][j]

# Driver Code
if __name__ == ""__main__"":

	a = [7, 2, 3, 0, 5, 10, 3, 12, 18]
	n = len(a)
	MAX = 500
	
	# lookup[i][j] is going to store minimum
	# value in arr[i..j]. Ideally lookup table
	# size should not be fixed and should be
	# determined using n Log n. It is kept
	# constant to keep code simple.
	lookup = [[0 for i in range(MAX)]
				for j in range(MAX)]

	buildSparseTable(a, n)
	print(query(0, 4))
	print(query(4, 7))
	print(query(7, 8))
	
# This code is contributed by Rituraj Jain<|endoftext|>"
699,"<|endoftext|>Write the regular expression that will match all non-digit characters of a string. Use the character class \D in your expression.:import re

pattern = '\D+'<|endoftext|>"
700,"<|endoftext|>Dictionaries in Python: In Python, a dictionary dict is a one-to-one mapping; it includes a set of (key, value) pairs, with each key mapped to a value. It exemplifies a hash map or hash table (from Computer Science). Each key denotes a value and is separated by a colon (:).



Curly brackets are used to define a dictionary. The value to the left of the colon is known as the key, while the value to the right of the colon is known as the value. A comma separates each (key, value) pair.
Example 1:

Input:

Enter number of elements to be added to the dictionary = 8
Enter the keys : 
Enter the key1 = hello
Enter the key2 = this
Enter the key3 = is
Enter the key4 = btechgeeks
Enter the key5 = online
Enter the key6 = coding
Enter the key7 = python
Enter the key8 = platform
Enter the Values : 
Enter the value1 = 45
Enter the value2 = 82
Enter the value3 = 125
Enter the value4 = 962
Enter the value5 = 712
Enter the value6 = 100
Enter the value7 = 852
Enter the value8 = 965
Output:

The resultant dictionary with keys = ['hello', 'this', 'is', 'btechgeeks', 'online', 'coding', 'python', 'platform'] 
values = [45, 82, 125, 962, 712, 100, 852, 965] :
{'hello': 45, 'this': 82, 'is': 125, 'btechgeeks': 962, 'online': 712, 'coding': 100, 'python': 852, 'platform': 965}:# Declare two empty lists one to store keys and the other to store values.
keyslist = []
valueslist = []
# Scan the number of elements to be added to the dictionary and store it in a variable.
numb = int(input(""Enter number of elements to be added to the dictionary = ""))
print(""Enter the keys : "")
for p in range(numb):
  # scanning the keys
  keyelement = input(""Enter the key""+str(p+1)+"" = "")
  keyslist.append(keyelement)
print(""Enter the Values : "")
for p in range(numb):
  # scanning the values
  valueelement = int(input(""Enter the value""+str(p+1)+"" = ""))
  valueslist.append(valueelement)
# Zip the two lists together and use dict() to turn them into a dictionary.
resultdict = dict(zip(keyslist, valueslist))
# printing the dictionary
print(""The resultant dictionary with keys ="",
  keyslist, ""values ="", valueslist, "":"")
print(resultdict)<|endoftext|>"
701,"<|endoftext|>Adjacency List: 
An array of lists is used. The size of the array is equal to the number of vertices. Let the array be an array[]. An entry array[i] represents the list of vertices adjacent to the ith vertex. This representation can also be used to represent a weighted graph. The weights of edges can be represented as lists of pairs. Following is the adjacency list representation of the above graph. :""""""
A Python program to demonstrate the adjacency
list representation of the graph
""""""

# A class to represent the adjacency list of the node


class AdjNode:
	def __init__(self, data):
		self.vertex = data
		self.next = None


# A class to represent a graph. A graph
# is the list of the adjacency lists.
# Size of the array will be the no. of the
# vertices ""V""
class Graph:
	def __init__(self, vertices):
		self.V = vertices
		self.graph = [None] * self.V

	# Function to add an edge in an undirected graph
	def add_edge(self, src, dest):
		# Adding the node to the source node
		node = AdjNode(dest)
		node.next = self.graph[src]
		self.graph[src] = node

		# Adding the source node to the destination as
		# it is the undirected graph
		node = AdjNode(src)
		node.next = self.graph[dest]
		self.graph[dest] = node

	# Function to print the graph
	def print_graph(self):
		for i in range(self.V):
			print(""Adjacency list of vertex {}\n head"".format(i), end="""")
			temp = self.graph[i]
			while temp:
				print("" -> {}"".format(temp.vertex), end="""")
				temp = temp.next
			print("" \n"")


# Driver program to the above graph class
if __name__ == ""__main__"":
	V = 5
	graph = Graph(V)
	graph.add_edge(0, 1)
	graph.add_edge(0, 4)
	graph.add_edge(1, 2)
	graph.add_edge(1, 3)
	graph.add_edge(1, 4)
	graph.add_edge(2, 3)
	graph.add_edge(3, 4)

	graph.print_graph()

# This code is contributed by Kanav Malhotra
<|endoftext|>"
702,"<|endoftext|>In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.

For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.
The twin sum is defined as the sum of a node and its twin.

Given the head of a linked list with even length, return the maximum twin sum of the linked list.:class Solution:
        def pairSum(self, head: Optional[ListNode]) -> int:
                l=[]
                def recpal(head,l):
                        if head is None:
                                return []
                        else:
                                l.append(head.val)
                                return recpal(head.next,l)

                recpal(head,l)

                s=set()
                for i in range(len(l)//2):
                         s.add(l[i]+l[~i])

                return max(s)<|endoftext|>"
703,"<|endoftext|>Write a program to print Binary representation of a given number. :def binary(num):
	return int(bin(num).split('0b')[1])

if __name__ == ""__main__"" :
	x = 10
	binary_x = binary(x)
	print(binary_x)

# This code is contributed by Rishika Gupta.<|endoftext|>"
704,"<|endoftext|>In this challenge, you have to establish if a given number is self-describing. To be self-describing, a positive number must have an even quantity of digits, because it has to be split into separated pairs of adjacent digits x and y, and each pair can be interpreted as a declaration: among the digits of the number, there are x instances of the digit equal to y.
If we take as an example the self-describing number 10123331, we can see how it has an even quantity of digits and it can be split into four pairs:
[1, 0] ➞ This pair declares that among the digits of the number there is 1 instance of 0
[1, 2] ➞ This pair declares that among the digits of the number there is 1 instance of 2
[3, 3] ➞ This pair declares that among the digits of the number there are 3 instances of 3
[3, 1] ➞ This pair declares that among the digits of the number there are 3 instances of 1
If every ""declaration"" represented by the pairs is true (as in the above example), then the number is self-describing.
Given a non-negative integer num, implement a function that returns True if num is a self-describing number, or False if it's not.
Examples
is_self_describing(10123331) ➞ True
# See the Instructions

is_self_describing(224444) ➞ True
# Pair [2, 2] is True (two times 2 into num)
# Pair [4, 4] is True (four times 4 into num)
# Pair [4, 4] is True (same as previous)

is_self_describing(2211) ➞ False
# Pair [2, 2] is True (two times 2 into num)
# Pair [1, 1] is False! It declares: one time 1 into num...
# ...but 2211 has two instances of 1 among its digits

is_self_describing(333) ➞ False
# Odd quantity of digits, it can't be splitted
Notes
Pairs can be repeated (see example #2), but they have to be true in any case.
Remember to consider the totality of the digits of the number, when checking if a pair represents a true declaration (see example #3).
You can expect always valid non-negative integers as input.:def is_self_describing(n):
    s = str(n)
    if len(s)%2:
        return False
    return all(int(total) == s.count(d) for total, d in zip(s[::2], s[1::2]))<|endoftext|>"
705,"<|endoftext|>There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.
Roads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.
This year, there will be a big event in the capital (city 0), and many people want to travel to this city.
Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.
It's guaranteed that each city can reach city 0 after reorder.
 
Example 1:


Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
Output: 3
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).

Example 2:


Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
Output: 2
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).

Example 3:

Input: n = 3, connections = [[1,0],[2,0]]
Output: 0

 
Constraints:

2 <= n <= 5 * 104
connections.length == n - 1
connections[i].length == 2
0 <= ai, bi <= n - 1
ai != bi:class Solution:
  def minReorder(self, n: int, connections: List[List[int]]) -> int:
  self.res = 0  
  roads = set()
  graph = collections.defaultdict(list)
  for u, v in connections:
  roads.add((u, v))
  graph[v].append(u)
  graph[u].append(v)
  def dfs(u, parent):
  self.res += (parent, u) in roads
  for v in graph[u]:
  if v == parent:
  continue
  dfs(v, u)  
  dfs(0, -1)
  return self.res<|endoftext|>"
706,"<|endoftext|>Instructions
Detect saddle points in a matrix.

So say you have a matrix like so:

    1  2  3
  |---------
1 | 9  8  7
2 | 5  3  2     <--- saddle point at row 2, column 1, with value 5
3 | 6  6  7
It has a saddle point at row 2, column 1.

It's called a ""saddle point"" because it is greater than or equal to every element in its row and less than or equal to every element in its column.

A matrix may have zero or more saddle points.

Your code should be able to provide the (possibly empty) list of all the saddle points for any given matrix.

The matrix can have a different number of rows and columns (Non square).

Note that you may find other definitions of matrix saddle points online, but the tests for this exercise follow the above unambiguous definition.

Exception messages
Sometimes it is necessary to raise an exception. When you do this, you should always include a meaningful error message to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the built in error types, but should still include a meaningful message.

This particular exercise requires that you use the raise statement to ""throw"" a ValueError if the matrix is irregular. The tests will only pass if you both raise the exception and include a message with it.

To raise a ValueError with a message, write the message as an argument to the exception type:

# if the matrix is irregular
raise ValueError(""irregular matrix""):def saddle_points(matrix):
    if any(len(row) != len(matrix[0]) for row in matrix):
        raise ValueError('irregular matrix')
    row_maxima = list(map(max, matrix))
    col_minima = list(map(min, list(zip(*matrix))))
    return [
        {'row': r+1, 'column': c+1}
        for r, row_max in enumerate(row_maxima)
        for c, col_min in enumerate(col_minima)
        if row_max == col_min
    ]
<|endoftext|>"
707,"<|endoftext|>Given a tuple, the task is to find the size of the given tuple in Python.
 Examples:
 Example1:
 Input:
 Given tuple =(9, 11, 24, 19, 11, 23, 29, 23, 31)
 Output:
 The length of the given tuple (9, 11, 24, 19, 11, 23, 29, 23, 31) is [ 9 ]
 Example2:
 Input:
 Given tuple =(11, 19, 45, 13, 23, 32, 46, 18, 49,58, 53, 75, 11, 19, 93, 99, 85, 68, 24)
 Output:
 The length of the given tuple (11, 19, 45, 13, 23, 32, 46, 18, 49, 58, 53, 75, 11, 19, 93, 99, 85, 68, 24) is [ 19 ]:# Give the tuple as static input and store it in a variable.
 
 gvntuple = (9, 11, 24, 19, 11, 23, 29, 23, 31)
 
 # Finding the size or length of a tuple is a rather simple task.
 
 # The number of objects in a tuple is represented by its size.
 
 # The syntax for determining the size is len ().
 
 # The number of elements/objects in the tuple is returned by this function.
 
 # Calculate the len() using len() function and store it in a variable.
 
 tuplelength = len(gvntuple)
 
 # Print the length of the tuple.
 
 print('The length of the given tuple', gvntuple, 'is [', tuplelength, ']')
 
 </pre><|endoftext|>"
708,"<|endoftext|>Given a number N and the task is to print the series (6,11,21,36,56…N) for the given number N in Python.:# Give the number N as static input and store it in a variable.
gvn_numb = 6
# Take a variable to say itr and initialize its value to 1.
itr = 1
# Take another variable to say previos_val and initialize its value to 6.
previos_val = 6
# Take the other variable to say gvn_diffence and initialize its value to 5
# (which is the common difference).
gvn_diffence = 5
print(""The above series till the given number{"", gvn_numb, ""} is :"")
# Loop until the above-declared variable itr value is less than or equal to the
# given number using the while loop.
while itr <= gvn_numb:
    # Inside the while loop, print the value of the above previos_val value
        # separated by spaces.
    print(previos_val, end="" "")
    # Add the given difference to the previous value and store it in the same
    # variable previos_val.
    previos_val = previos_val + gvn_diffence
    # Add 5 to the given difference and store it in the same variable.
    gvn_diffence = gvn_diffence + 5
    # Increment the value of the above itr value by 1 and store it in the
    # same variable.
    itr += 1<|endoftext|>"
709,"<|endoftext|>Check a Binary Number is Divisible by a Number N (Static input):# Give the binary number as static input and store it in a variable.
binry = 1100
# Given the number as static input and store it in another variable.
num = 4
# Convert the given binary number into a decimal number using int(str(binary number),2)
# function and store it in another variable say ""deci"".
deci = int(str(binry), 2)
# Check if the above-obtained decimal number modulus given number is equal to 0 using the if
# conditional statement.
if deci % num == 0:
    # If the statement is true, then print ""The binary number is divisible by the given
    # input number"".
    print(""The given binary number is divisible by{"", num, ""}"")
else:
 # Else print """"The binary number is not divisible by the given input number"".
    print(""The given binary number is not divisible by{"", num, ""}"")<|endoftext|>"
710,"<|endoftext|>Given a decimal number and the task is to get the respective binary number for a given number.

Examples:

Example1:

Input:

Given Number = 7
Output:

The Binary value of the given decimal number { 7 } is: 
111
Example2:

Input:

Given Number = 9
Output:

The Binary value of the given decimal number { 9 } is: 
1001:# Give the number as static input and store it in a variable.
 gvn_numb = 7
 # Take a variable say 'a 'and initialize its value with 1.
 a = 1
 # Take another variable say binry_num and initialize its value with 0.
 binry_num = 0
 print(""The Binary value of the given decimal number {"", gvn_numb, ""} is: "")
 # Loop till the given number is not equal to zero using the while loop.
 while (gvn_numb != 0):
  # Inside the loop, calculate the value of the given number modulus 2 and
  # store it in a variable remdr.
  remdr = gvn_numb % 2
  # Divide the given number by 2 and store it in the same variable gvn_numb.
  gvn_numb = gvn_numb // 2
  # Multiply a with the remdr and store it in another variable b
  b = (remdr * a)
  # Add b to the binry_num and convert to int using the int() function.
  # Store it in the same variable binry_num.
  binry_num = int(binry_num + b)
  # Multiply a with 10 and Store it in the same variable 'a'.
  a = int(a * 10)
  # Print the binry_num to get the binary value of the given decimal number.
 print(binry_num)<|endoftext|>"
711,"<|endoftext|>You are given a list of integers having both negative and positive values, except for one integer which can be negative or positive. Create a function to find out that integer.
Examples
lonely_integer([1, -1, 2, -2, 3]) ➞ 3
# 3 has no matching negative appearance.

lonely_integer([-3, 1, 2, 3, -1, -4, -2]) ➞ -4
# -4 has no matching positive appearance.

lonely_integer([-9, -105, -9, -9, -9, -9, 105]) ➞ -9
Notes
N/A:def lonely_integer(lst):
  return sum(set(lst))<|endoftext|>"
712,"<|endoftext|>Given a dictionary with students and the grades that they made on the tests that they took, determine which student has the best Test Average. The key will be the student's name and the value will be a list of their grades. You will only have to return the student's name. You do not need to return their Test Average.
Examples
get_best_student({
  ""John"": [100, 90, 80],
  ""Bob"": [100, 70, 80]
}) ➞ ""John""

# John's avg = 90
# Bob's avg = 83.33

get_best_student({
  ""Susan"": [67, 84, 75, 63],
  ""Mike"": [87, 98, 64, 71],
  ""Jim"": [90, 58, 73, 86]
}) ➞ ""Mike""
Notes
All students in a dictionary will have the same amount of test scores. So no student will have taken more tests than another.:def get_best_student(grades):
  return max(grades, key=lambda student: sum(grades[student]))<|endoftext|>"
713,"<|endoftext|>A stack permutation is a permutation of objects in the given input queue which is done by transferring elements from input queue to the output queue with the help of a stack and the built-in push and pop functions.

The well defined rules are: 
* Only dequeue from the input queue.
* Use inbuilt push, pop functions in the single stack.
* Stack and input queue must be empty at the end.
* Only enqueue to the output queue.

Given two arrays, both of unique elements. One represents the input queue and the other represents the output queue. Our task is to check if the given output is possible through stack permutation.

 :# Given two arrays, check if one array is
# stack permutation of other.
from queue import Queue
 
# function to check if Input queue
# is permutable to output queue
def checkStackPermutation(ip, op, n):
     
    # Input queue
    Input = Queue()
    for i in range(n):
        Input.put(ip[i])
 
    # output queue
    output = Queue()
    for i in range(n):
        output.put(op[i])
 
    # stack to be used for permutation
    tempStack = []
    while (not Input.empty()):
        ele = Input.queue[0]
        Input.get()
        if (ele == output.queue[0]):
            output.get()
            while (len(tempStack) != 0):
                if (tempStack[-1] == output.queue[0]):
                    tempStack.pop()
                    output.get()
                else:
                    break
        else:
            tempStack.append(ele)
 
    # If after processing, both Input
    # queue and stack are empty then 
    # the Input queue is permutable
    # otherwise not.
    return (Input.empty() and
        len(tempStack) == 0)
 
# Driver Code
if __name__ == '__main__':
 
    # Input Queue
    Input = [1, 2, 3]
 
    # Output Queue
    output = [2, 1, 3]
 
    n = 3
 
    if (checkStackPermutation(Input,
                              output, n)):
        print(""Yes"")
    else:
        print(""Not Possible"")
 
# This code is contributed by PranchalK
<|endoftext|>"
714,"<|endoftext|>Python Math Factorial Function | In Python, math.factorial() method is a library method of the math module, it is used to find the factorial of a number. It accepts a positive integer number and returns the factorial of the number.:# Python program to find the factorial of a number using math function import math #math module # take input num = 5 # find factorial of a number and display result print('The factorial of',num,'is', math.factorial(num))<|endoftext|>"
715,"<|endoftext|>Sort a List in Wave Form Using For loop (User Input):# Give the list as user input using list(),map(),input(),and split() functions.
#Store it in a variable.
gvn_lst = list(map(int, input(
   'Enter some random List Elements separated by spaces = ').split()))
# Sort the above-given list using the sort() function.
gvn_lst.sort()
# Calculate the length of the given list using the len() function and
# store it in another variable.
len_lst = len(gvn_lst)
# Loop from 0 to length of the given list with a step size of 2 using the for loop.
for itr in range(0, len_lst-1, 2):
    # Assign a given list of (iterator +1) values to the given list of iterator and
    # a given list of the iterator to the given list of iterator+1.
    gvn_lst[itr], gvn_lst[itr+1] = gvn_lst[itr+1], gvn_lst[itr]
print(""The above given list after sorted in waveform :"")
# Loop from 0 to length of the given list using the for loop.
for itr in range(0, len(gvn_lst)):
  # Inside the loop, print the given list of iterator values to sort the list in a waveform.
    print(gvn_lst[itr], end=' ')<|endoftext|>"
716,"<|endoftext|>Else
The else keyword catches anything which isn't caught by the preceding conditions.:a = 200
b = 33
if b > a:
  print(""b is greater than a"")
elif a == b:
  print(""a and b are equal"")
else:
  print(""a is greater than b"")<|endoftext|>"
717,"<|endoftext|>In the previous article, we have discussed Python Program to Find Sum of Geometric Progression Series
 Definition of Lucas sequence:
 We’ve all heard of the Fibonacci sequence. It is a sequence in which each term is the sum of the two preceding terms. The Lucas sequence is the same as the previous one, but with different starting values. A Fibonacci sequence starts with 0 and 1, whereas a Lucas sequence starts with 2 and 1. The other terms in the Lucas sequence are 3, 4, 7, 11, and so on.
 Given a number ‘n’ and the task is to print the given nth iteration of Lucas Sequence.
 Examples:
 Example1:
 Input:
 n = 6
 Output:
 The above Given nth iteration of Lucas Sequence = 18
 Example 2:
 Input:
 n = 10
 Output:
 The above Given nth iteration of Lucas Sequence = 123:# Give the First term =2 (since the first term in Lucas Sequence is 2 which is a constant)
 
 # as static input and store it in a variable.
 
 fst_trm = 2
 
 # Give the Second term =1 (since the second term in Lucas Sequence is 1 which is a constant)
 
 # as static input and store it in another variable.
 
 secnd_trm = 1
 
 # Give the number as static input and store it in another variable.
 
 gvn_n_vlue = 6
 
 # Loop from '1' to the above given n+1 value (since doesn't include last term) range
 
 # using For loop.
 
 for i in range(1, gvn_n_vlue+1):
 
  # Inside the loop , get the third term which is the sum of first and the second term
 
  # and store it in a variable.
 
  third_trm = fst_trm+secnd_trm
 
  # Assign the value of second term to the first term.
 
  fst_trm = secnd_trm
 
  # Assign the value of the third term to the second term and come out of For Loop.
 
  secnd_trm = third_trm
 
 # Print the Value of above given nth iteration of Lucas Sequence(i.e. first term).
 
 print(""The above Given nth iteration of Lucas Sequence = "", fst_trm)
 
 </pre><|endoftext|>"
718,"<|endoftext|>In mathematics, Pascal's triangle is an array of the binomial coefficients. Each coefficients can be obtained by summing adjacent elements in preceding rows.

This Python program prints Pascal's Triangle up to n rows given by user.:row = int(input(""Enter number of rows: ""))

space = 36

# empty list containg all 0s
a = [0] * 20 


print(""\n\t\t\t\t*** PASCAL TRIANGLE ***\n"")
for i in range(row):
    
    for spi in range(1,space+1):
        print("" "", end="""")
    
    a[i] = 1
    
    for j in range(i+1):
        print('%6d' %(a[j]), end = """")
    
    for j in range(i,0,-1):
        a[j] = a[j] + a[j-1]
    
    space = space - 3
    
    print()<|endoftext|>"
719,"<|endoftext|>Alice and Bob use Diffie-Hellman key exchange to share secrets. They start with prime numbers, pick private keys, generate and share public keys, and then generate a shared secret key.

Step 0
The test program supplies prime numbers p and g.

Step 1
Alice picks a private key, a, greater than 1 and less than p. Bob does the same to pick a private key b.

Step 2
Alice calculates a public key A.

A = gᵃ mod p
Using the same p and g, Bob similarly calculates a public key B from his private key b.

Step 3
Alice and Bob exchange public keys. Alice calculates secret key s.

s = Bᵃ mod p
Bob calculates

s = Aᵇ mod p
The calculations produce the same result! Alice and Bob now share secret s.

Python, as of version 3.6, includes two different random modules.

The module called random is pseudo-random, meaning it does not generate true randomness, but follows an algorithm that simulates randomness. Since random numbers are generated through a known algorithm, they are not truly random.

The random module is not correctly suited for cryptography and should not be used, precisely because it is pseudo-random.

For this reason, in version 3.6, Python introduced the secrets module, which generates cryptographically strong random numbers that provide the greater security required for cryptography.

Since this is only an exercise, random is fine to use, but note that it would be very insecure if actually used for cryptography.
:import random
def private_key(p):
    return random.randrange(2, p)
def public_key(p, g, private):
    return pow(g, private, p)
def secret(p, public, private):
    return pow(public, private, p)<|endoftext|>"
720,"<|endoftext|>Depth First Traversal (or Search) for a graph is similar to Depth First Traversal (DFS) of a tree. The only catch here is, unlike trees, graphs may contain cycles, so a node might be visited twice. To avoid processing a node more than once, use a boolean visited array. :# An Iterative Python program to do DFS traversal from
# a given source vertex. DFS(int s) traverses vertices
# reachable from s.
 
# This class represents a directed graph using adjacency
# list representation
class Graph:
    def __init__(self,V): # Constructor
        self.V = V        # No. of vertices
        self.adj  = [[] for i in range(V)]  # adjacency lists
 
    def addEdge(self,v, w):     # to add an edge to graph
        self.adj[v].append(w)    # Add w to v’s list.
 
 
    # prints all not yet visited vertices reachable from s
    def DFS(self,s):            # prints all vertices in DFS manner from a given source.
                                # Initially mark all vertices as not visited
        visited = [False for i in range(self.V)]
 
        # Create a stack for DFS
        stack = []
 
        # Push the current source node.
        stack.append(s)
 
        while (len(stack)):
            # Pop a vertex from stack and print it
            s = stack[-1]
            stack.pop()
 
            # Stack may contain same vertex twice. So
            # we need to print the popped item only
            # if it is not visited.
            if (not visited[s]):
                print(s,end=' ')
                visited[s] = True
 
            # Get all adjacent vertices of the popped vertex s
            # If a adjacent has not been visited, then push it
            # to the stack.
            for node in self.adj[s]:
                if (not visited[node]):
                    stack.append(node)
 
 
 
# Driver program to test methods of graph class
 
g = Graph(5); # Total 5 vertices in graph
g.addEdge(1, 0);
g.addEdge(0, 2);
g.addEdge(2, 1);
g.addEdge(0, 3);
g.addEdge(1, 4);
 
print(""Following is Depth First Traversal"")
g.DFS(0)
 
# This code is contributed by ankush_953
<|endoftext|>"
721,"<|endoftext|>Loop Through Set Items
You cannot access items in a set by referring to an index, since sets are unordered the items has no index.

But you can loop through the set items using a for loop, or ask if a specified value is present in a set, by using the in keyword.:thisset = {""apple"", ""banana"", ""cherry""}

for x in thisset:
  print(x)
<|endoftext|>"
722,"<|endoftext|>Write a function that takes a number and returns the perimeter of either a circle or a square. The input will be in the form (letter l, number num) where the letter will be either ""s"" for square, or ""c"" for circle, and the number will be the side of the square or the radius of the circle.
Use the following formulas:
Perimeter of a square: 4 * side.
Perimeter of a circle: 6.28 * radius.
The catch is you can only use arithmetic or comparison operators, which means:
No if... else statements.
No dictionaries.
No lambdas.
No formatting methods, etc.
The goal is to write a short, branch-free piece of code.
Examples
perimeter(""s"", 7) ➞ 28

perimeter(""c"", 4) ➞ 25.12

perimeter(""c"", 9) ➞ 56.52
Notes
No rounding is needed.
Hint: The Boolean True, used with arithmetic operators, counts as 1, while False counts as 0. That means (a>b)+1 will return 1 or 2, depending on the values of a and b.:def perimeter(l, num):
       return ((l==""s"")*4*num) + (l==""c"")*6.28*num<|endoftext|>"
723,"<|endoftext|>Python Program for Dictionary clear() Function. A dictionary is a set of elements that have key-value pairs. The values in the elements are accessed using the element’s keys.:# Give the dictionary by initializing it with some random values and store it
# in a variable.
gvn_dictinry = {'hello': 100, 'this': 200, 'is': 300, 'btechgeeks': 400}
# Print the above-given dictionary before clearing.
print(""The given dictionary before clearing is :"")
# Calculate the length of the given dictionary using the len() function and print it.
print(gvn_dictinry)
print(""The length of the given dictionary before clearing = "", len(gvn_dictinry))
# Apply clear() function to the given dictionary.
gvn_dictinry.clear()
# Print the above-given dictionary after clearing it.
print(""The given dictionary After clearing is :"")
print(gvn_dictinry)
# Calculate the length of the above dictionary after clearing using the len() function
# and print it.
print(""The length of the given dictionary After clearing = "", len(gvn_dictinry))<|endoftext|>"
724,"<|endoftext|>Instructions
You're going to write some code to help you cook a gorgeous lasagna from your favorite cookbook.

You have five tasks, all related to cooking your recipe.

1. Define expected bake time in minutes
Define an EXPECTED_BAKE_TIME constant that returns how many minutes the lasagna should bake in the oven. According to your cookbook, the Lasagna should be in the oven for 40 minutes:

>>> lasagna.EXPECTED_BAKE_TIME
40
2. Calculate remaining bake time in minutes
Implement the bake_time_remaining() function that takes the actual minutes the lasagna has been in the oven as an argument and returns how many minutes the lasagna still needs to bake based on the EXPECTED_BAKE_TIME.

>>> bake_time_remaining(30)
10
3. Calculate preparation time in minutes
Implement the preparation_time_in_minutes() function that takes the number of layers you want to add to the lasagna as an argument and returns how many minutes you would spend making them. Assume each layer takes 2 minutes to prepare.

>>> preparation_time_in_minutes(2)
4
4. Calculate total elapsed cooking time (prep + bake) in minutes
Implement the elapsed_time_in_minutes() function that has two parameters: number_of_layers (the number of layers added to the lasagna) and elapsed_bake_time (the number of minutes the lasagna has been baking in the oven). This function should return the total number of minutes you've been cooking, or the sum of your preparation time and the time the lasagna has already spent baking in the oven.

>>> elapsed_time_in_minutes(3, 20)
26
5. Update the recipe with notes
Go back through the recipe, adding notes and documentation.

def elapsed_time_in_minutes(number_of_layers, elapsed_bake_time):
    """"""
    Return elapsed cooking time.

    This function takes two numbers representing the number of layers & the time already spent 
    baking and calculates the total elapsed minutes spent cooking the lasagna.
    """""":EXPECTED_BAKE_TIME=40
PREPARATION_TIME=5
TIME_PER_LAYER=2
def bake_time_remaining(elapsed_bake_time):
    """"""Calculate the bake time remaining.
 
    :param elapsed_bake_time: int baking time already elapsed.
    :return: int remaining bake time derived from 'EXPECTED_BAKE_TIME'.
 
    Function that takes the actual minutes the lasagna has been in the oven as
    an argument and returns how many minutes the lasagna still needs to bake
    based on the `EXPECTED_BAKE_TIME`.
    """"""
    return EXPECTED_BAKE_TIME - elapsed_bake_time
def preparation_time_in_minutes(layer):
    """"""Calculate the total preparation time.
 
    :param layer: int number of layers.
    :return: int total time of preparation for all layers.
 
    Function that takes a number of lasagna layers, and returns how many minutes
    it needs to be prepared, based on the `TIME_PER_LAYER`.
    """"""
    return layer * TIME_PER_LAYER
def elapsed_time_in_minutes(layer, baking_time):
    """"""Calculate the full time needed (preparation + baking) in minutes.
 
    :param layer: int number of layers.
    :param baking_time: total baking time needed in minutes.
    :return: int total time in minutes to prepare and bake the marvellous lasagna.
 
    Function that takes the preparation and baking times, and return the total in
    minutes.
    """"""
    preparation_time = preparation_time_in_minutes(layer)
    return preparation_time + baking_time<|endoftext|>"
725,"<|endoftext|>Given a string, and the task is to convert the alternate characters to capital letters for a given string in python:# Give the string as user input using the input() function and 
# store it in a variable.
gven_str = input(""Enter some Random String = "")
# Take a variable say k and initialize its value to zero.
k = 0
# Take a new empty string and store it in another variable.
modified_strng = """"
# Calculate the length of the given string using the len() function and store it in
# another variable.
str_lengt = len(gven_str)
# Loop till the length of the given string using the for loop.
for itr in range(str_lengt):
     # Check if the above-initialized k value modulus 2 is equal to zero using the if
     # conditional statement.
    if k % 2 == 1:
      # If the Statement is true, Check if the character which is present at the iterator
      # value of the given string is greater than or equal to 'A' and less than or equal to 'Z' 
      # using the if conditional statement.
        if gven_str[itr] >= 'A' and gven_str[itr] <= 'Z':
           # If it is true, calculate the ASCII value of the character of the given string which is
           # present at the iterator value index using the ord() function, and add 32 to it
           # Find the character of the above ASCII value using the chr() function.
            charctr = chr(ord(gven_str[itr])+32)
    # Concatenate the above character to the modified string.
            modified_strng = modified_strng+charctr
        else:
           # If the statement is False, then concatenate the character which is present at the
           # iterator value of the given string to the modified string.
            modified_strng = modified_strng+gven_str[itr]
    else:
      # Else, check if the character which is present at the iterator value of the given string 
      # is greater than or equal to 'a' and less than or equal to 'z' using the if
      # conditional statement.
        if gven_str[itr] >= 'a' and gven_str[itr] <= 'z':
          # If it is true, calculate the ASCII value of the character of the given string which
          # is present at the iterator value index using the ord() function, and subtract
          # 32 from it.
          # Find the character of the above ASCII value using the chr() function.
            charctr = chr(ord(gven_str[itr])-32)
  # Concatenate the above character to the modified string.
            modified_strng = modified_strng+charctr
        else:
         # If the statement is False, then concatenate the character which is present at the
         # iterator value of the given string to the modified string.
            modified_strng = modified_strng+gven_str[itr]
   # Check if the character present at the iterator value is equal to space using the if
   # conditional statement.

    if gven_str[itr] == ' ':
      # If it is true, then continue.
        continue
    # Increment the value of k by 1 and store it in the same variable k.
    k = k+1
# Print the modified string to get the given string after converting alternate characters
# into capital letters.
print(""The given string after converting alternate characters into capital letters :"")
print(modified_strng)<|endoftext|>"
726,"<|endoftext|>Given a stack, sort it using recursion. Use of any loop constructs like while, for..etc is not allowed. We can only use the following ADT functions on Stack S: 

is_empty(S)  : Tests whether stack is empty or not.
push(S)         : Adds new element to the stack.
pop(S)         : Removes top element from the stack.
top(S)         : Returns value of the top element. Note that this
               function does not remove element from the stack.:# Python program to sort a stack using recursion

# Recursive method to insert element in sorted way


def sortedInsert(s, element):

	# Base case: Either stack is empty or newly inserted
	# item is greater than top (more than all existing)
	if len(s) == 0 or element > s[-1]:
		s.append(element)
		return
	else:

		# Remove the top item and recur
		temp = s.pop()
		sortedInsert(s, element)

		# Put back the top item removed earlier
		s.append(temp)

# Method to sort stack


def sortStack(s):

	# If stack is not empty
	if len(s) != 0:

		# Remove the top item
		temp = s.pop()

		# Sort remaining stack
		sortStack(s)

		# Push the top item back in sorted stack
		sortedInsert(s, temp)

# Printing contents of stack


def printStack(s):
	for i in s[::-1]:
		print(i, end="" "")
	print()


# Driver Code
if __name__ == '__main__':
	s = []
	s.append(30)
	s.append(-5)
	s.append(18)
	s.append(14)
	s.append(-3)

	print(""Stack elements before sorting: "")
	printStack(s)

	sortStack(s)

	print(""\nStack elements after sorting: "")
	printStack(s)

# This code is contributed by Muskan Kalra.<|endoftext|>"
727,"<|endoftext|>Given an array A of n elements. We need to change the array into a permutation of numbers from 1 to n using minimum replacements in the array. 
Examples: 
 

Input : A[] = {2, 2, 3, 3} 
Output : 2 1 3 4
Explanation:
To make it a permutation of 1 to 4, 1 and 4 are
missing from the array. So replace 2, 3 with 
1 and 4.

Input :  A[] = {1, 3, 2}
Output : 1 3 2

Input : A[] = {10, 1, 2}
Output : 3 1 2:# Python3 code to make a permutation
# of numbers from 1 to n using
# minimum changes.

def makePermutation (a, n):

	# Store counts of all elements.
	count = dict()
	for i in range(n):
		if count.get(a[i]):
			count[a[i]] += 1
		else:
			count[a[i]] = 1;
		
	next_missing = 1
	for i in range(n):
		if count[a[i]] != 1 or a[i] > n or a[i] < 1:
			count[a[i]] -= 1
			
			# Find next missing element to put
			# in place of current element.
			while count.get(next_missing):
				next_missing+=1
			
			# Replace with next missing and
			# insert the missing element in hash.
			a[i] = next_missing
			count[next_missing] = 1

# Driver Code
A = [ 2, 2, 3, 3 ]
n = len(A)
makePermutation(A, n)

for i in range(n):
	print(A[i], end = "" "")
	
# This code is contributed by ""Sharad_Bhardwaj"".<|endoftext|>"
728,"<|endoftext|>In the previous article, we have discussed Python Program to Find Vertex, Focus and Directrix of Parabola
 max() function :
 max() is a built-in function that returns the maximum value in a list.
 index() function:
 This function searches the lists. It returns the index where the value is found when we pass it as an argument that matches the value in the list. If no value is found, Value Error is returned.
 Given a list, the task is to Get the position of Max Value in a List.
 Examples:
 Example 1 :
 Input :
 Given List = [1, 5, 9, 2, 7, 3, 8]
 Output:
 Maximum Value in the above Given list = 9
 
 Position of Maximum value of the above Given List = 3
 Example 2 :
 Input : 
 Given List = [4, 3, 7, 1, 2, 8, 9]
 Output:
 Maximum Value in the above Given list = 9
 
 Position of Maximum value of the above Given List = 7:# Give the List as static input and store it in a variable.
 Gvn_lst = [1, 5, 9, 2, 7, 3, 8]
 # Get the maximum value of the given list using the built-in max() function and
 # store it in another variable
 maxim_vle = max(Gvn_lst)
 # Print the maximum value of the above given List.
 print(""Maximum Value in the above Given list = "", maxim_vle)
 # Get the position of the maximum value of the List using the built-in index() function
 # and store it in another variable.
 maxim_positn = Gvn_lst.index(maxim_vle)
 # Print the position of the maximum value of the given List i.e. maximum position+1
 # ( since list index starts from zero).
 print(""Position of Maximum value of the above Given List = "", maxim_positn+1)<|endoftext|>"
729,"<|endoftext|>Are you wondering how to seek help from subject matter experts and learn the Java language? Go with these Basic Java Programming Examples and try to code all of them on your own then check with the exact code provided by expert programmers.
 
 Recursion:
 
 Recursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.
 
 Given a number the task is to calculate the sum of the digits of the given number using recursive approach in Python.
 
 Examples:
 
 Example1:
 
 Input:
 
 Enter some random number = 18627677851
 Output:
 
 The total sum of digits off the given number 18627677851 = 58
 Example2:
 
 Input:
 
 Enter some random number = 7816833887102099
 Output:
 
 The total sum of digits off the given number 7816833887102099 = 80:# take a empty list
 numbList = []
 # function which returns count of all the digits of
 # the given number using recursive approach.
 def sumDigitsRecursion(numb):
  # Put the base condition in the function that says
  # if the number is zero, return the created list.
  if(numb == 0):
  return numbList
  # getting the last digit of the given number using modulus operator
  numdigit = numb % 10
  # appending this digit to numberslist using digit function
  numbList.append(numdigit)
  # passing numb/10 recursively
  sumDigitsRecursion(numb//10)
 # give the number as static input
 numb = 18627677851
 # passing the number to sumDigitsRecursion function to
 # calculate the sum of digits recursively
 sumDigitsRecursion(numb)
 # calculating the sum of list using sum() function.
 print('The total sum of digits off the given number', numb, '=', sum(numbList))<|endoftext|>"
730,"<|endoftext|>In this challenge, you have to convert a weight weighed on a planet of the Solar System to the corresponding weight on another planet.
To convert the weight, you have to divide it by the gravitational force of the planet on which is weighed and multiply the result (the mass) for the gravitational force of the other planet. See the table below for a list of gravitational forces:
weight on planet_a / gravitational force of planet_a * gravitational force of planet_b
Planet m/s²
Mercury 3.7
Venus 8.87
Earth 9.81
Mars 3.711
Jupiter 24.79
Saturn 10.44
Uranus 8.69
Neptune 11.15
Given a weight weighed on planet_a, return the converted value for planet_b rounded to the nearest hundredth.
Examples
space_weights(""Earth"", 1, ""Mars"") ➞ 0.38

space_weights(""Earth"", 1, ""Jupiter"") ➞ 2.53

space_weights(""Earth"", 1, ""Neptune"") ➞ 1.14
Notes
N/A:def space_weights(planet_a, weight, planet_b):
  forces = {
    ""Mercury"":3.7,
    ""Venus"":8.87,
    ""Earth"":9.81,
    ""Mars"":3.711,
    ""Jupiter"":24.79,
    ""Saturn"":10.44,
    ""Uranus"":8.69,
    ""Neptune"":11.15
  }
  return round(weight / forces[planet_a] * forces[planet_b],2)<|endoftext|>"
731,"<|endoftext|>In the previous article, we have discussed Python Program to Find Position of Rightmost Set Bit
 Give two numbers the task is to find the XOR result of the given two numbers in Python.
 Bitwise & Operator:
 If both bits are 1, sets each bit to 1.
 Bitwise or (|) operator:
 If one of two bits is 1, sets each bit to 1.
 Examples:
 Example1:
 Input:
 Given First Number = 4
 
 Given Second Number = 2
 Output:
 The XOR result of the given first and second numbers{ 4 , 2 } = 6
 Example2:
 Input:
 Given First Number = 7
 
 Given Second Number = 9
 Output:
 The XOR result of the given first and second numbers{ 7 , 9 } = 14:# Create a function XOR_result() which accepts the given two numbers as the argument and
 
 # returns the XOR result of the given first and second numbers.
 
 
 
 
 
 def XOR_result(gvnfst_numb, gvnscnd_numb):
 
  # Inside the XOR_result() function.
 
  # Calculate and the value of (gvnfst_numb | gvnscnd_numb) &amp; (~gvnfst_numb | ~gvnscnd_numb)
 
  # which gives the XOR result of the given first and second numbers and store it in a
 
  # variable say xor_rslt.
 
 
 
  xor_rslt = (gvnfst_numb | gvnscnd_numb) &amp; (~gvnfst_numb | ~gvnscnd_numb)
 
  # Return the value of xor_rslt (Which is the XOR result of the given first and
 
  # second numbers).
 
  return(xor_rslt)
 
 
 
 
 
 # Inside the main code.
 
 # Give the first number as static input and store it in a variable.
 
 gvnfst_numb = 4
 
 # Give the second number as static input and store it in another variable.
 
 gvnscnd_numb = 2
 
 # Pass the given first and second numbers as the arguments to XOR_result() function and
 
 # store the result in a variable (xorreslt_val).
 
 xorreslt_val = XOR_result(gvnfst_numb, gvnscnd_numb)
 
 # Print the xorreslt_val value.
 
 print(""The XOR result of the given first and second numbers{"",
 
  gvnfst_numb, "","", gvnscnd_numb, ""} ="", xorreslt_val)
 
 </pre><|endoftext|>"
732,"<|endoftext|>Definition and Usage
The items() method returns a view object. The view object contains the key-value pairs of the dictionary, as tuples in a list.

The view object will reflect any changes done to the dictionary, see example below.:car = {
  ""brand"": ""Ford"",
  ""model"": ""Mustang"",
  ""year"": 1964
}

x = car.items()

print(x)<|endoftext|>"
733,"<|endoftext|>You are given a string s of length n, and an integer k. You are tasked to find the longest subsequence repeated k times in string s.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

A subsequence seq is repeated k times in the string s if seq * k is a subsequence of s, where seq * k represents a string constructed by concatenating seq k times.

For example, ""bba"" is repeated 2 times in the string ""bababcba"", because the string ""bbabba"", constructed by concatenating ""bba"" 2 times, is a subsequence of the string ""bababcba"".
Return the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. If there is no such subsequence, return an empty string.

 :class Solution:
    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        def helper(subString, string):
            n, m = len(subString), len(string)
            i, j = 0, 0
            while i < n and j < m: 
                if subString[i] == string[j]:
                    i += 1
                j += 1
                
            return i == n
            
        counter = defaultdict(lambda: 0)
        
        for char in s: 
            counter[char] += 1
            
        chars = [key for key in counter if counter[key] >= k]
        chars.sort()
        
        ans = """"
        stack = [""""]
        while stack: 
            prefix = stack.pop(0)
            for char in chars:  
                word = prefix + char
                if helper(word*k, s):                     
                    stack.append(word)
                    ans = word
                    
        return ans<|endoftext|>"
734,"<|endoftext|>Given a positive integer n which represents the dimensions of a 4n x 4n matrix with values from 1 to n filled from left to right and top to bottom. Form two coils from the matrix and print the coils.

Examples:  

Input  : n = 1;
Output : Coil 1 : 10 6 2 3 4 8 12 16 
         Coil 2 : 7 11 15 14 13 9 5 1
Explanation : Matrix is 
1  2  3  4 
5  6  7  8 
9  10 11 12 
13 14 15 16

Input  : n = 2;
Output : Coil 1 : 36 28 20 21 22 30 38 46 54 
                  53 52 51 50 42 34 26 18 10 
                  2 3 4 5 6 7 8 16 24 32 40 
                  48 56 64 
        Coil 2 : 29 37 45 44 43 35 27 19 11 12 
                 13 14 15 23 31 39 47 55 63 62 
                 61 60 59 58 57 49 41 33 25 17
                 9 1 :# Python3 program to print 2 coils of a
# 4n x 4n matrix.
 
# Print coils in a matrix of size 4n x 4n
def printCoils(n):
     
    # Number of elements in each coil
    m = 8*n*n
     
    # Let us fill elements in coil 1.
    coil1 = [0]*m
     
    # First element of coil1
    # 4*n*2*n + 2*n
    coil1[0] = 8*n*n + 2*n
     
    curr = coil1[0]
     
    nflg = 1
    step = 2
     
    # Fill remaining m-1 elements in coil1[]
    index = 1
    while (index < m):
         
        # Fill elements of current step from
        # down to up
        for i in range(step):
             
            # Next element from current element
            curr = coil1[index] = (curr - 4*n*nflg)
            index += 1
            if (index >= m):
                break
        if (index >= m):
            break
         
        # Fill elements of current step from
        # up to down.
        for i in range(step):
             
            curr = coil1[index] = curr + nflg
            index += 1
            if (index >= m):
                break
        nflg = nflg*(-1)
        step += 2
     
    #get coil2 from coil1 */
     
    coil2 = [0]*m
    i = 0
    while(i < 8*n*n):
        coil2[i] = 16*n*n + 1 -coil1[i]
        i += 1
    # Print both coils
    print(""Coil 1 :"", end = "" "")
    i = 0
    while(i < 8*n*n):
        print(coil1[i], end = "" "")
        i += 1
    print(""\nCoil 2 :"", end = "" "")
    i = 0
    while(i < 8*n*n):
        print(coil2[i], end = "" "")
        i += 1
 
# Driver code
 
n = 1
printCoils(n)
 
# This code is contributed by shubhamsingh10
<|endoftext|>"
735,"<|endoftext|>Given two sides of an isosceles triangle and the task is to find the area of the given isosceles triangle.:# Import math module using the import keyword.
import math
# Give the length of the first side of an isosceles triangle as user input using the float(input()) 
#function and store it in a variable.
fst_side = float(input(""Enter some random number = ""))
# Give the length of the second side of an isosceles triangle as user input using the float(input())
#function and store it in another variable.
secnd_side =  float(input(""Enter some random number = ""))
# Calculate the length of the given isosceles triangle using math.sqrt() function
# and the above given mathematical formula.
# Store it in another variable.
area_isosce_tringl = (
    secnd_side * math.sqrt((4 * fst_side * fst_side) - (secnd_side * secnd_side)))/4
# Print the area of the given isosceles triangle.
print(""The Given Isosceles Triangle area with sides ["",
      fst_side, "","", secnd_side, ""]= %.3f"" % area_isosce_tringl)<|endoftext|>"
736,"<|endoftext|>Write a function that takes a two-digit number and determines if it's the largest of two possible digit swaps.
To illustrate:
largest_swap(27) ➞ False

largest_swap(43) ➞ True
If 27 is our input, we should return False because swapping the digits gives us 72, and 72 > 27. On the other hand, swapping 43 gives us 34, and 43 > 34.
Examples
largest_swap(14) ➞ False

largest_swap(53) ➞ True

largest_swap(99) ➞ True
Notes
Numbers with two identical digits (third example) should yield True (you can't do better).:def largest_swap(num):
  return num//10 >= num%10<|endoftext|>"
737,"<|endoftext|>Wondering how to find if two numbers given are Amicable or Not? Then, you have come the right way as we will explain what are Amicable Numbers and Python Program to Check if Two Numbers are Amicable Numbers or not. Refer to the Various Methods for Checking if given Numbers are Amicable or Not and use the method you are comfortable with.

Amicable Numbers in Python
First and foremost, what exactly is this Amicable? We say two numbers are Amicable if the sum of their proper divisors is equal to the opposite numbers, that is, the sum of x’s divisors is equal to y and the sum of y’s divisors is equal to x. We can grasp it better by using an example.

Take 234 and 339 as two numbers; now find the divisors of 123 and 456; their sums will be sum1 and sum2, respectively. Then sum2 must equal 123 and sum1 must equal 456.

We should determine all the suitable divisors of x ,y and add them separately before matching them to the opposite numbers; if they match, we claim the two numbers are amicable; otherwise, we say they are not.

sumX=y,

sumY=x

Where sumX is the sum of all proper divisors of the number x.

Where sumY is the sum of all proper divisors of the number y.

Examples:

Example 1:

Input:

given number1 =220 ;       given number2=284
Output:

The given numbers 220 and 284 are amicable numbers:# python program to cheeck whether the given number is Amicable numbers or not

# function which returns true if the given number is
# Amicable numbers else it will return False


def checkAmicableNumb(given_numb1, given_numb2):
    # Taking a variable totalSum1 and initializing it with 1
    totalSum1 = 1
    # Iterating from 2 to n-1
    for i in range(2, given_numb1):
        # if the iterator value is divides the number then add the given
        # number to totalSum1
        if given_numb1 % i == 0:
            totalSum1 += i
    # repeating the same step for number 2
    # Taking a variable totalSum2 and initializing it with 1
    totalSum2 = 1
    # Iterating from 2 to n-1
    for i in range(2, given_numb2):
        # if the iterator value is divides the number then add the given
        # number to totalSum2
        if given_numb2 % i == 0:
            totalSum2 += i

    # if the totalSum1 is equal to the given number2 and
    # totalSum2 is equal to the given number1 then both the numbers are amicable numbers
    # else they are not amicable numbers

    if(totalSum1 == given_numb2 and totalSum2 == given_numb1):
        # if it is true then they are amicable numbers so return true
        return True
    # if nothing is returned then they are not a amicable numbers so return False
    return False


# Given two numbers
# given number1(numb1)
given_numb1 = 220
# given number2(numb2)
given_numb2 = 284
# passing the given two numbers to checkAmicableNumb to check whether it is
# Amicable numbers or not
if(checkAmicableNumb(given_numb1, given_numb2)):
    print(""The given numbers"", given_numb1, ""and"",
          given_numb2, ""are amicable numbers"")
else:
    print(""The given numbers"", given_numb1, ""and"",
          given_numb2, ""are not amicable numbers"")<|endoftext|>"
738,"<|endoftext|>Given N point on a 2D plane as pair of (x, y) co-ordinates, we need to find maximum number of point which lie on the same line.
Examples: 
 

Input : points[] = {-1, 1}, {0, 0}, {1, 1}, 
                    {2, 2}, {3, 3}, {3, 4} 
Output : 4
Then maximum number of point which lie on same
line are 4, those point are {0, 0}, {1, 1}, {2, 2},
{3, 3}:# python3 program to find maximum number of 2D points that lie on the same line.

from collections import defaultdict
from math import gcd
from typing import DefaultDict, List, Tuple

IntPair = Tuple[int, int]


def normalized_slope(a: IntPair, b: IntPair) -> IntPair:
	""""""
	Returns normalized (rise, run) tuple. We won't return the actual rise/run
	result in order to avoid floating point math, which leads to faulty
	comparisons.

	See
	https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems
	""""""
	run = b[0] - a[0]

	# normalize undefined slopes to (1, 0)
	if run == 0:
		return (1, 0)

	# normalize to left-to-right
	if run < 0:
		a, b = b, a
		run = b[0] - a[0]

	rise = b[1] - a[1]
	# Normalize by greatest common divisor.
	# math.gcd only works on positive numbers.
	gcd_ = gcd(abs(rise), run)
	return (
		rise // gcd_,
		run // gcd_,
	)


def maximum_points_on_same_line(points: List[List[int]]) -> int:
	# You need at least 3 points to potentially have non-colinear points.
	# For [0, 2] points, all points are on the same line.
	if len(points) < 3:
		return len(points)

	# Note that every line we find will have at least 2 points.
	# There will be at least one line because len(points) >= 3.
	# Therefore, it's safe to initialize to 0.
	max_val = 0

	for a_index in range(0, len(points) - 1):
		# All lines in this iteration go through point a.
		# Note that lines a-b and a-c cannot be parallel.
		# Therefore, if lines a-b and a-c have the same slope, they're the same
		# line.
		a = tuple(points[a_index])
		# Fresh lines already have a, so default=1
		slope_counts: DefaultDict[IntPair, int] = defaultdict(lambda: 1)

		for b_index in range(a_index + 1, len(points)):
			b = tuple(points[b_index])
			slope_counts[normalized_slope(a, b)] += 1

		max_val = max(
			max_val,
			max(slope_counts.values()),
		)

	return max_val


print(maximum_points_on_same_line([
	[-1, 1],
	[0, 0],
	[1, 1],
	[2, 2],
	[3, 3],
	[3, 4],
]))

# This code is contributed by Jose Alvarado Torre<|endoftext|>"
739,"<|endoftext|>Given an array and an integer K. We need to find the maximum of every segment of length K which has no duplicates in that segment.:# Python3 code to calculate maximum unique
# element of every segment of array
def find_max(A, N, K):
     
    # Storing counts of first K-1 elements
    # Also storing distinct elements.
    Count = dict()
    for i in range(K - 1):
        Count[A[i]] = Count.get(A[i], 0) + 1
 
    Myset = dict()
    for x in Count:
        if (Count[x] == 1):
            Myset[x] = 1
 
    # Before every iteration of this loop,
    # we maintain that K-1 elements of current
    # window are processed.
    for i in range(K - 1, N):
 
        # Process K-th element of current window
        Count[A[i]] = Count.get(A[i], 0) + 1
 
        if (Count[A[i]] == 1):
            Myset[A[i]] = 1
        else:
            del Myset[A[i]]
 
        # If there are no distinct
        # elements in current window
        if (len(Myset) == 0):
            print(""Nothing"")
 
        # Set is ordered and last element
        # of set gives us maximum element.
        else:
            maxm = -10**9
            for i in Myset:
                maxm = max(i, maxm)
            print(maxm)
 
        # Remove first element of current
        # window before next iteration.
        x = A[i - K + 1]
        if x in Count.keys():
            Count[x] -= 1
            if (Count[x] == 1):
                Myset[x] = 1
            if (Count[x] == 0):
                del Myset[x]
 
# Driver code
a = [1, 2, 2, 3, 3 ]
n = len(a)
k = 3
find_max(a, n, k)
 
# This code is contributed
# by mohit kumar
<|endoftext|>"
740,"<|endoftext|>Recursion:

Recursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.

Given a string and a character the task is to count the occurrence of the given letter in the string using recursive approach in Python.

Examples:

Example1:

Input:

Enter some random string= btechgeeks
Enter some random character= e
Output:

Priting the count of e in the given string btechgeeks = 3:# function which returns count of the given character in the string recursively.


def checkCountRecursively(given_string, character):
  # Pass the fundamental constraint that the string is not empty.
    if not given_string:
        return 0
    # If the initial character of the string is the same as the character
    # taken from the user, increment the count.
    elif given_string[0] == character:
        return 1+checkCountRecursively(given_string[1:], character)
    # The string is progressed in either direction, and the number of times
    # the letter appears in the string is printed.
    else:
        return checkCountRecursively(given_string[1:], character)


# given string as static input
given_string = 'btechgeeks'
# given character as static input
given_character = 'e'
# passing the given character and given string to checkCountRecursively function
print('Priting the count of', given_character, 'in the given string',
      given_string, '=', checkCountRecursively(given_string, given_character))<|endoftext|>"
741,"<|endoftext|>Given an integer, return a new integer according to the rules below:
Split the number into groups of two digit numbers. If the number has an odd number of digits, return ""invalid"".
For each group of two digit numbers, concatenate the last digit to a new string the same number of times as the value of the first digit.
Return the result as an integer.
look_and_say(3132) ➞ 111222

# By reading the number digit by digit, you get three ""1"" and three ""2"".
# Therefore, you put three ones and three two's together.
# Remember to return an integer.
Examples
look_and_say(95) ➞ 555555555

look_and_say(1213141516171819) ➞ 23456789

look_and_say(120520) ➞ 200

look_and_say(231) ➞ ""invalid""
Notes
Note that the number 0 can be included (see example #3).
Check the Resources tab for a TED-Ed video for extra clarity.:def look_and_say(n):
  n = str(n)
  if len(n)%2:
    return 'invalid'
  return int(''.join(int(n[i]) * n[i+1] for i in range(0, len(n), 2)))<|endoftext|>"
742,"<|endoftext|>Create a function that takes a positive integer n and returns the nth ""star number"".

A star number is a centered figurate number that represents a centered hexagram (six-pointed star), such as the one that Chinese checkers is played on.

star numbers for 1, 2 and 3

Examples
star_number(2) ➞ 13
# n = 2
# 2nd star number = 13

star_number(3) ➞ 37
# n = 3
# 3rd star number = 37

star_number(5) ➞ 121
# n = 5
# 5th star number = 121
Notes
n will always be a positive integer.
The nth term of a star number can be represented as 6n(n-1) + 1
See Resources for more information.:def star_number(n):
    return 6 * n * (n - 1) + 1<|endoftext|>"
743,"<|endoftext|>Two pairs (a, b) and (c, d) are said to be symmetric if c is equal to b and a is equal to d. For example, (10, 20) and (20, 10) are symmetric. Given an array of pairs find all symmetric pairs in it. 
It may be assumed that the first elements of all pairs are distinct.
Example: 
 

Input: arr[] = {{11, 20}, {30, 40}, {5, 10}, {40, 30}, {10, 5}}
Output: Following pairs have symmetric pairs
        (30, 40)
        (5, 10)  :# A Python3 program to find all symmetric
# pairs in a given array of pairs.

# Print all pairs that have
# a symmetric counterpart
def findSymPairs(arr, row):

	# Creates an empty hashMap hM
	hM = dict()

	# Traverse through the given array
	for i in range(row):
		
		# First and second elements
		# of current pair
		first = arr[i][0]
		sec = arr[i][1]

		# If found and value in hash matches with first
		# element of this pair, we found symmetry
		if (sec in hM.keys() and hM[sec] == first):
			print(""("", sec,"","", first, "")"")

		else: # Else put sec element of
			# this pair in hash
			hM[first] = sec

# Driver Code
if __name__ == '__main__':
	arr = [[0 for i in range(2)]
			for i in range(5)]
	arr[0][0], arr[0][1] = 11, 20
	arr[1][0], arr[1][1] = 30, 40
	arr[2][0], arr[2][1] = 5, 10
	arr[3][0], arr[3][1] = 40, 30
	arr[4][0], arr[4][1] = 10, 5
	findSymPairs(arr, 5)

# This code is contributed by Mohit Kumar<|endoftext|>"
744,"<|endoftext|>In the previous article, we have discussed Python Program to Check if a Pair with Given Product Exists in a Matrix
 
 Given a square matrix and the task is to check whether the given matrix is a diagonally dominant matrix or not.
 
 What is a matrix:
 
 A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.
 
 Example:
 
 
 
 Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.
 
 In this order, the dimensions of a matrix indicate the number of rows and columns.
 
 
 
 Here as there are 5 rows and 4 columns it is called a 5*4 matrix.
 
 Diagonally Dominant Matrix :
 
 A square matrix is said to be diagonally dominating in mathematics if the magnitude of the diagonal entry in a row is greater than or equal to the sum of the magnitudes of all the other (non-diagonal) values in that row for each row of the matrix.
 
 Examples:
 
 Example1:
 
 Input:
 
 Given Matrix : 
 5 1 3
 2 7 1
 4 0 9
 Output:
 
 Yes, the given matrix is a diagonally dominant matrix
 Example2:
 
 Input:
 
 Given Matrix : 
  1 3 5
  2 4 6
  7 8 9
 Output:
 
 No, the given matrix is not a diagonally dominant matrix:# Create a function to say checkdiagnolydominant_matx() which takes the given matrix
 # and the number of rows of the given matrix as the arguments and returns true or false
 def checkdiagnolydominant_matx(mtrx, mtrxrows):
  # Inside the function, Loop till the given number of rows using the For loop.
  for n in range(0, mtrxrows):
  # Take a variable to say rslt_summ and initialize its value to 0.
  rslt_summ = 0
  # Inside the For loop, Iterate till the given number of rows using another
  # Nested For loop(Inner For loop).
  for m in range(0, mtrxrows):
  # Add the absolute of mtrx[n][m] to the above-initialized rslt_summ and store
  # it in the same variable.
  rslt_summ = rslt_summ + abs(mtrx[n][m])
  # Remove the diagonal element by subtracting the abs(mtrx[n][n]) from the rslt_summ and
  # store it in the same variable.
  rslt_summ = rslt_summ - abs(mtrx[n][n])
  # Check if the abs(mtrx[n][n]) (diagonal element) is less than the rslt_summ
  # (Which is the #sum of non diagonal elements) using the if conditional statement.
  if (abs(mtrx[n][n]) < rslt_summ):
  # If it is true, then return False.
  return False
  # Return True.
  return True
 # Give the matrix as static input and store it in a variable.
 mtrx = [[5, 1, 3], [2, 7, 1], [4, 0, 9]]
 # Calculate the number of rows of the given matrix by
 # calculating the length of the nested list using the len() function
 # and store it in a variable mtrxrows.
 mtrxrows = len(mtrx)
 # Calculate the number of columns of the given matrix by
 # calculating the length of the first list in the nested list
 # using the len() function and store it in a variable mtrxcols.
 mtrxcols = len(mtrx[0])
 # Pass the given matrix and the number of rows of the given matrix as the arguments
 # to the checkdiagnolydominant_matx() function and check if returns true or false
 # using the if conditional statement.
 if((checkdiagnolydominant_matx(mtrx, mtrxrows))):
  # If it is true, print ""Yes, the given matrix is a diagonally dominant matrix"".
  print(""Yes, the given matrix is a diagonally dominant matrix"")
 else:
  # Else print ""No, the given matrix is not a diagonally dominant matrix"".
  print(""No, the given matrix is not a diagonally dominant matrix"")<|endoftext|>"
745,"<|endoftext|>Given two strings s and t, your goal is to convert s into t in k moves or less.
During the ith (1 <= i <= k) move you can:

Choose any index j (1-indexed) from s, such that 1 <= j <= s.length and j has not been chosen in any previous move, and shift the character at that index i times.
Do nothing.

Shifting a character means replacing it by the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Shifting a character by i means applying the shift operations i times.
Remember that any index j can be picked at most once.
Return true if it's possible to convert s into t in no more than k moves, otherwise return false.
 
Example 1:

Input: s = ""input"", t = ""ouput"", k = 9
Output: true
Explanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.

Example 2:

Input: s = ""abc"", t = ""bcd"", k = 10
Output: false
Explanation: We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.

Example 3:

Input: s = ""aab"", t = ""bbb"", k = 27
Output: true
Explanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'.

 
Constraints:

1 <= s.length, t.length <= 10^5
0 <= k <= 10^9
s, t contain only lowercase English letters.:def canConvertString(self, s: str, t: str, k: int) -> bool:
  if len(s) != len(t):
  return False
  cnt = [0] * 26
  for cs, ct in zip(s, t):
  diff = (ord(ct) - ord(cs)) % 26
  if diff > 0 and cnt[diff] * 26 + diff > k:
  return False
  cnt[diff] += 1
  return True<|endoftext|>"
746,"<|endoftext|>Given an array of integers, and a number ‘sum’, find the number of pairs of integers in the array whose sum is equal to ‘sum’.

Examples:  

Input  :  arr[] = {1, 5, 7, -1}, 
          sum = 6
Output :  2
Pairs with sum 6 are (1, 5) and (7, -1)

Input  :  arr[] = {1, 5, 7, -1, 5}, 
          sum = 6
Output :  3
Pairs with sum 6 are (1, 5), (7, -1) &
                     (1, 5)         

Input  :  arr[] = {1, 1, 1, 1}, 
          sum = 2
Output :  6
There are 3! pairs with sum 2.

Input  :  arr[] = {10, 12, 10, 15, -1, 7, 6, 
                   5, 4, 2, 1, 1, 1}, 
          sum = 11
Output :  9:# Python 3 implementation of simple method
# to find count of pairs with given sum.
import sys

# Returns number of pairs in arr[0..n-1]
# with sum equal to 'sum'


def getPairsCount(arr, n, sum):

	m = [0] * 1000

	# Store counts of all elements in map m
	for i in range(0, n):
		m[arr[i]] += 1

	twice_count = 0

	# Iterate through each element and increment
	# the count (Notice that every pair is
	# counted twice)
	for i in range(0, n):

		twice_count += m[sum - arr[i]]

		# if (arr[i], arr[i]) pair satisfies the
		# condition, then we need to ensure that
		# the count is decreased by one such
		# that the (arr[i], arr[i]) pair is not
		# considered
		if (sum - arr[i] == arr[i]):
			twice_count -= 1

	# return the half of twice_count
	return int(twice_count / 2)


# Driver function
arr = [1, 5, 7, -1, 5]
n = len(arr)
sum = 6

print(""Count of pairs is"", getPairsCount(arr,
										n, sum))

# This code is contributed by
# Smitha Dinesh Semwal<|endoftext|>"
747,"<|endoftext|>In the previous article, we have discussed Python Program for Given Two Numbers a and b Find all x Such that a % x = b
 Given a string and the task is to remove all the odd occurring characters from the given string.
 Examples:
 Example1:
 Input:
 Given String = ""goodmorning""
 Output:
 The given string { goodmorning } after removing odd frequency elements is : gnng
 Example2:
 Input:
 Given String = ""thisisbtechgeeks""
 Output:
 The given string { thisisbtechgeeks } after removing odd frequency elements is : thiith:# Take a dictionary and initialize it to empty
 
 # using the {} or dict() say freqncyDictionary.
 
 freqncyDictionary = {}
 
 # Give the string as static input and store it in a variable
 
 gvnstrng = ""goodmorning""
 
 # Loop in the given string using the For loop.
 
 for i in gvnstrng:
 
  # Inside the For loop,
 
  # Check if the string character is present in the dictionary
 
  # or not using the if conditional statement and 'in' keyword.
 
  if i in freqncyDictionary.keys():
 
  # If it is true then increment the count of the string character
 
  # in the dictionary by 1.
 
  freqncyDictionary[i] = freqncyDictionary[i]+1
 
  # Else initialize the dictionary with the string character as key and value as 1.
 
  else:
 
  freqncyDictionary[i] = 1
 
 # Take a string which stores all the characters which are not occuring odd number
 
 # of times and initialize it to null string using """" or str()
 
 modifd_string = """"
 
 # loop in the given string using the for loop
 
 for charac in gvnstrng:
 
 
 
  # check if the character has even frequency by checking value of that character in frequency dictionary
 
  # we check using the if conditional statement
 
  if(freqncyDictionary[charac] % 2 == 0):
 
  # if it is true then concatenate this character to modifd_string using string concatenation
 
  modifd_string = modifd_string+charac
 
 
 
 
 
 # print the modifd_string string
 
 print('The given string {', gvnstrng,
 
  '} after removing odd frequency elements is :', modifd_string)<|endoftext|>"
748,"<|endoftext|>In general, the median is the middle value of a sorted list of elements. To find the median, we must first sort the data if it is not already sorted. The middle value can then be extracted and printed. If the number of elements in the list is even, we can calculate the median by taking the average of the list’s two middle values. Else take the middle value.:# Give the list as static input and store it in a variable.
gvn_list = [5, 2, 4, 2, 1]
# sorting the given list using sort() function
gvn_list.sort()
# Calculate the length of the list using the len() function and store it in a variable.
lst_leng = len(gvn_list)
# Find the middle element of the given List by using (total length of list-1)
# divided by 2( zero indexing)and store it in a variable.
mid_vlu = (lst_leng-1)//2
# Check if the given list is even or odd using the If conditional statement.
if(lst_leng % 2 == 0):
    # If the length of given list is even , median is the average of middle two elements.
    res_vlu = (gvn_list[mid_vlu] + gvn_list[mid_vlu+1])/2
else:
    # If the length of given list is odd , Median  is the middle element.
    res_vlu = gvn_list[mid_vlu]
print('The Median of the Given List of Elements =', res_vlu)<|endoftext|>"
749,"<|endoftext|>Create a function double unique_fract(), which should sum all irreducible regular fractions between 0 and 1, in the numerator and denominator of which there are only single-digit numbers: 1/2, 1/3, 1/4, ... 2/3, 2/4, ... 8/9.
Examples
unique_fract() ➞ sum
Notes
Of the fractions 1/2 2/4 3/6 4/8, only 1/2 is included in the sum.
Don't include any values >= 1.
Both the numerator and denominator are single digit.:def unique_fract():
  return sum(a/b for a in range(1,10) for b in range(1,10) if a<b and gcd(a,b)==)
def gcd(a,b):
  while a:
    a,b = b%a,a
  return b<|endoftext|>"
750,"<|endoftext|>Create a function that takes a list and returns a new list containing only prime numbers.
Examples
filter_primes([7, 9, 3, 9, 10, 11, 27]) ➞ [7, 3, 11]

filter_primes([10007, 1009, 1007, 27, 147, 77, 1001, 70]) ➞ [10007, 1009]

filter_primes([1009, 10, 10, 10, 3, 33, 9, 4, 1, 61, 63, 69, 1087, 1091, 1093, 1097]) ➞ [1009, 3, 61, 1087, 1091, 1093, 1097]
Notes
New list must maintain the order of primes as they first appear in the original list.
Check the Resources tab for help.:def filter_primes(num):
  return [n for n in num if n > 1 and all(n%i for i in range(2,int(n**0.5)+1))]<|endoftext|>"
751,"<|endoftext|>Write a program to take three names as input from a user in the single input() function call.:str1, str2, str3 = input(""Enter three string"").split()
print('Name1:', str1)
print('Name2:', str2)
print('Name3:', str3)<|endoftext|>"
752,"<|endoftext|>A Skew Symmetric Matrix or Anti-Symmetric Matrix is a square matrix whose transpose is negative to that of the original matrix. If the entry in the ith row and jth column of a matrix is a[i][j], i.e. if A = (a[i][j]) then the skew symmetric condition is -A = -a[j][i].

Write a program to check if the given matrix is skew matrix or not.


 :# Python 3 program to check
# whether given matrix
# is skew-symmetric or not
ROW=3
COL=3
 
# Utility function to
# create transpose matrix
def transpose(transpose_matrix,matrix):
    for i in range (ROW):
        for j in range(COL):
            transpose_matrix[j][i] = matrix[i][j]
             
# Utility function to
# check skew - symmetric
# matrix condition
def check(transpose_matrix,matrix):
    for i in range(ROW):
        for j in range(COL):
            if (matrix[i][j] != -transpose_matrix[i][j]):
                return False
    return True
     
# Utility function to print a matrix
def printMatrix(matrix):
    for i in range (ROW):
        for j in range(COL):
            print(matrix[i][j],"" "",end="""")
        print()
         
# Driver program to test above functions
matrix= [
            [0, 5, -4],
            [-5, 0, 1],
            [4, -1, 0],
        ]
transpose_matrix=[[0 for i in range(3)] for j in range(3)]
 
# Function create transpose matrix
transpose(transpose_matrix, matrix)
print(""Transpose matrix:"")
printMatrix(transpose_matrix)
 
# Check whether matrix is
# skew-symmetric or not
if (check(transpose_matrix, matrix)):
    print(""Skew Symmetric Matrix"")
else:
    print(""Not Skew Symmetric Matrix"")
 
# This code is contributed
# by Azkia Anam.
<|endoftext|>"
753,"<|endoftext|>At school, we used to play with our calculators and send each other secret messages. The trick was to enter a special number and turn the calculator upside-down. LOL ... I mean 707!
Given a number, create a function that converts it into a word by turning the integer 180 degrees around.
Examples
turn_calc(707) ➞ ""LOL""

turn_calc(5508) ➞ ""BOSS""

turn_calc(3045) ➞ ""SHOE""
number letter
1 I
2 Z
3 E
4 H
5 S
6 G
7 L
8 B
9 -
0 O
Notes
Convert to uppercase words.
Ignore dots.:def turn_calc(num):
  return str(num)[::-1].translate(str.maketrans('01345678', 'OIEHSGLB', '.'))<|endoftext|>"
754,"<|endoftext|>In the previous article, we have discussed Python Program to Multiply Two Numbers Using Recursion
 Given two numbers and the task is to find the division of the given two numbers using recursion.
 Recursion:
 Recursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.
 Examples:
 Example1:
 Input:
 Given First Number = 18
 
 Given Second Number = 9
 Output:
 The Division of { 18 / 9 } using recursion = 2
 Example2:
 Input:
 Given First Number = 48
 
 Given Second Number = 6
 Output:
 The Division of { 48 / 6 } using recursion = 8:# Create a recursive function to say recur_div which takes the two numbers as arguments
 
 # and returns the division of the given two numbers using recursion.
 
 
 
 
 
 def recur_div(fst_numb, secnd_numb):
 
  # Check if the first number is less than the second number using the if conditional
 
  # statement.
 
  if fst_numb < secnd_numb:
 
  # If the statement is true, then return 0
 
  return 0
 
  # Return 1 + recur_div(fst_numb-secnd_numb, secnd_numb) {Recursive Logic}.
 
  return 1 + recur_div(fst_numb-secnd_numb, secnd_numb)
 
 
 
 
 
 # Give the first number as static input and store it in a variable.
 
 fst_numb = 18
 
 # Give the second number as static input and store it in another variable.
 
 secnd_numb = 9
 
 # Pass the given two numbers as the arguments to recur_div function.
 
 # Print the division of given two numbers using recursion.
 
 print(""The Division of {"", fst_numb, ""/"", secnd_numb,
 
  ""} using recursion ="", recur_div(fst_numb, secnd_numb))<|endoftext|>"
755,"<|endoftext|>Generate Perfect Numbers in an Interval (User Input):# function which returns true if the given number is
# perfect number else it will return False


def checkPerfectNumbr(givenNumb):
    # Taking a variable totalSum and initializing it with 1
    totalSum = 1
    # Iterating from 2 to n-1
    for i in range(2, givenNumb):
        # if the iterator value is divides the number then add the given number to totalSum
        if givenNumb % i == 0:
            totalSum += i

    # if the totalSum is equal to the given number
    # then it is perfect number else it is not perfect number

    if(totalSum == givenNumb):
        # if it is true then it is perfect number then return true
        return True
    # if nothing is returned then it is not a perfect number so return False
    return False


# Give the lower limit range and upper limit range as
# user input using map(),int(),split() functions.
# Store them in two separate variables.
lowlimrange, upplimrange = map(int, input(
    'Enter lower limit range and upper limit range separate by spaces = ').split())
print('The Perfect numbers in the given range',
      lowlimrange, 'and', upplimrange, 'are:')
# Loop from lower limit range to upper limit range using For loop.
for itrvalue in range(lowlimrange, upplimrange+1):
        # Inside the for loop pass the iterator value to checkNeonnumb() function.
    if(checkPerfectNumbr(itrvalue)):
        # If it returns true then print the iterator value.
        print(itrvalue, end=' ')<|endoftext|>"
756,"<|endoftext|>In this program, we need to calculate the sum of all the elements of an array. This can be solved by looping through the array and add the value of the element in each iteration to variable sum.:#Initialize array     
arr = [1, 2, 3, 4, 5];     
sum = 0;    
     
#Loop through the array to calculate sum of elements    
for i in range(0, len(arr)):    
   sum = sum + arr[i];    
     
print(""Sum of all the elements of an array: "" + str(sum));    <|endoftext|>"
757,"<|endoftext|>Python Program to Print the pattern of an Inverted Star: Given a number, the task is to print an Inverted Star Pattern in Python. In our python programming articles, you can also learn how to print a program of Inverted pyramid pattern and print inverted pyramid star pattern in python language.

Let’s see the examples of python program to print inverted star pattern from here:# given number numb
numb = int(input(""enter the number of rows required = ""))
# Make a duplicate of the integer by storing it in a variable
tem = numb
# Use a for loop in which the value of k varies
# between n-1 and 0 and is decremented by one with each iteration.
while(numb > 0):
  # Multiply empty spaces by n-i and '*' by k then print both of them.
    print((tem-numb) * ' ' + numb * '*')
    # decrement the number by 1
    numb = numb-1<|endoftext|>"
758,"<|endoftext|>0 represents the dog.
Each list represents a house and each 1 represents an empty room.
Return the house and the room where it is located, there can be only one dog lost per building.
Examples
lost_dog([1, 1, 1, 1, 1, 1],  [1, 1, 1, 1, 1, 1],  [1, 1, 1, 1, 1, 1],  [1, 1, 1, 1, 1, 1])
➞ ""Dog not found!""

lost_dog([1, 1, 1, 1, 1, 1],  [0, 1, 1, 1, 1, 1],  [1, 0, 1, 1, 1, 1],  [1, 1, 1, 1, 1, 1])
➞ {""Dog1"": ""House (2) and Room (1)"", ""Dog2"": ""House (3) and Room (2)""}

lost_dog([1, 1, 1, 1, 1, 0],  [0, 1, 1, 1, 1, 1],  [1, 0, 1, 1, 1, 1],  [1, 1, 0, 1, 1, 1])
➞ {""Dog1"": ""House (1) and Room (6)"", ""Dog2"": ""House (2) and Room (1)"", ""Dog3"": ""House (3) and Room (2)"", ""Dog4"": ""House (4) and Room (3)""}
Notes
Check the Resources if you're stuck.:def lost_dog(*args, n=0):
    res = dict()
    for r, row in enumerate(args):
        if 0 in row:
            n += 1
            res[""Dog{}"".format(n)] = (""House ({}) and Room ({})""
                                      .format(r + 1, row.index(0) + 1))
    return res if n else ""Dog not found!""<|endoftext|>"
759,"<|endoftext|>Create a function which returns the type of triangle, given the side lengths. Return the following values if they match the criteria.
No sides equal: ""scalene""
Two sides equal: ""isosceles""
All sides equal: ""equilateral""
Less or more than 3 sides given: ""not a triangle""
Examples
get_triangle_type([2, 6, 5]) ➞ ""scalene""

get_triangle_type([4, 4, 7]) ➞ ""isosceles""

get_triangle_type([8, 8, 8]) ➞ ""equilateral""

get_triangle_type([3, 5, 5, 2]) ➞ ""not a triangle""
Notes
You will be given a list of positive integers.
Check the Resources tab for more information on the types of triangles.:def get_triangle_type(lst):
  if len(lst) == 3:
    return ['equilateral', 'isosceles', 'scalene'][len(set(lst)) - 1]
  return 'not a triangle'<|endoftext|>"
760,"<|endoftext|>Factor Tree is an intuitive method to understand the factors of a number. It shows how all the factors are been derived from the number. It is a special diagram where you find the factors of a number, then the factors of those numbers, etc until you can’t factor anymore. The ends are all the prime factors of the original number.
Example: 
 

Input : v = 48
Output : Root of below tree
   48
   /\
  2  24
     /\
    2  12
       /\
      2  6
         /\
        2  3The factor tree is created recursively. A binary tree is used. 
 

We start with a number and find the minimum divisor possible.
Then, we divide the parent number by the minimum divisor.
We store both the divisor and quotient as two children of the parent number.
Both the children are sent into function recursively.
If a divisor less than half the number is not found, two children are stored as NULL.:# Python program to construct Factor Tree for
# a given number
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.key = key
 
# Utility function to create a new tree Node
def newNode(key):
    temp = Node(key)
    return temp
 
# Constructs factor tree for given value and stores
# root of tree at given reference.
def createFactorTree(node_ref, v):
    node_ref = newNode(v)
 
    # the number is factorized
    for i in range(2, int(v/2)):
 
        if (v % i != 0):
            continue
 
        # If we found a factor, we construct left
        # and right subtrees and return. Since we
        # traverse factors starting from smaller
        # to greater, left child will always have
        # smaller factor
        node_ref.left = createFactorTree(((node_ref).left), i)
        node_ref.right = createFactorTree(((node_ref).right), int(v/i))
        return node_ref
 
    return node_ref
 
# Iterative method to find the height of Binary Tree
def printLevelOrder(root):
 
    # Base Case
    if (root == None):
        return
    q = [];
    q.append(root);
    while (len(q) > 0):
 
        # Print front of queue and remove
        # it from queue
        node = q[0]
        print(node.key, end = "" "")
        q = q[1:]
        if (node.left != None):
                q.append(node.left)
        if (node.right != None):
                q.append(node.right)
 
val = 48# sample value
root = None
root = createFactorTree(root, val)
print(""Level order traversal of constructed factor tree"")
printLevelOrder(root)
 
# This code is contributed by shinjanpatra
<|endoftext|>"
761,"<|endoftext|>The issuperset() method returns True if all items in the specified set exists in the original set, otherwise it retuns False.:x = {""f"", ""e"", ""d"", ""c"", ""b"", ""a""}
y = {""a"", ""b"", ""c""}

z = x.issuperset(y)

print(z)<|endoftext|>"
762,"<|endoftext|>Consider a game where a player can score 3 or 5 or 10 points in a move. Given a total score n, find number of ways to reach the given score.:# Python program to count number of possible ways to a given
# score can be reached in a game where a move can earn 3 or
# 5 or 10.
 
# Returns number of ways to reach score n.
def count(n):
 
    # table[i] will store count of solutions for value i.
    # Initialize all table values as 0.
    table = [0 for i in range(n+1)]
 
    # Base case (If given value is 0)
    table[0] = 1
 
    # One by one consider given 3 moves and update the
    # table[] values after the index greater than or equal
    # to the value of the picked move.
    for i in range(3, n+1):
        table[i] += table[i-3]
    for i in range(5, n+1):
        table[i] += table[i-5]
    for i in range(10, n+1):
        table[i] += table[i-10]
 
    return table[n]
 
# Driver Program
n = 20
print('Count for', n, 'is', count(n))
 
n = 13
print('Count for', n, 'is', count(n))
 
# This code is contributed by Soumen Ghosh<|endoftext|>"
763,"<|endoftext|>Given a n x n matrix. The problem is to sort the given matrix in strict order. Here strict order means that matrix is sorted in a way such that all elements in a row are sorted in increasing order and for row ‘i’, where 1 <= i <= n-1, first element of row ‘i’ is greater than or equal to the last element of row ‘i-1’.:# Python3 implementation to sort
# the given matrix

SIZE = 10

# Function to sort the given matrix
def sortMat(mat, n) :
        
        # Temporary matrix of size n^2
        temp = [0] * (n * n)
        k = 0

        # Copy the elements of matrix
        # one by one into temp[]
        for i in range(0, n) :
                
                for j in range(0, n) :
                        
                        temp[k] = mat[i][j]
                        k += 1

        # sort temp[]
        temp.sort()
        
        # copy the elements of temp[]
        # one by one in mat[][]
        k = 0
        
        for i in range(0, n) :
                
                for j in range(0, n) :
                        mat[i][j] = temp[k]
                        k += 1


# Function to print the given matrix
def printMat(mat, n) :
        
        for i in range(0, n) :
                
                for j in range( 0, n ) :
                        
                        print(mat[i][j] , end = "" "")
                        
                print()
        
        
# Driver program to test above
mat = [ [ 5, 4, 7 ],
                [ 1, 3, 8 ],
                [ 2, 9, 6 ] ]
n = 3

print( ""Original Matrix:"")
printMat(mat, n)

sortMat(mat, n)

print(""\nMatrix After Sorting:"")
printMat(mat, n)


# This code is contributed by Nikita Tiwari.<|endoftext|>"
764,"<|endoftext|>Given a Binary Search Tree (BST), convert it to a Binary Tree such that every key of the original BST is changed to key plus sum of all greater keys in BST. :# Python3 Program to change a BST to
# Binary Tree such that key of a node
# becomes original key plus sum of all
# greater keys in BST
 
# A BST node has key, left child and
# right child */
class Node:
 
    # Constructor to create a new node
    def __init__(self, data):
        self.key = data
        self.left = None
        self.right = None
 
# A recursive function that traverses
# the given BST in reverse inorder and
# for every key, adds all greater keys to it
def addGreaterUtil(root, sum_ptr):
     
    # Base Case
    if root == None:
        return
 
    # Recur for right subtree first so that sum
    # of all greater nodes is stored at sum_ptr
    addGreaterUtil(root.right, sum_ptr)
 
    # Update the value at sum_ptr
    sum_ptr[0] = sum_ptr[0] + root.key
 
    # Update key of this node
    root.key = sum_ptr[0]
 
    # Recur for left subtree so that the
    # updated sum is added to smaller nodes
    addGreaterUtil(root.left, sum_ptr)
 
# A wrapper over addGreaterUtil(). It initializes
# sum and calls addGreaterUtil() to recursive
# update and use value of sum
def addGreater(root):
    Sum = [0]
    addGreaterUtil(root, Sum)
     
# A utility function to print inorder
# traversal of Binary Tree
def printInorder(node):
    if node == None:
        return
    printInorder(node.left)
    print(node.key, end = "" "")
    printInorder(node.right)
 
# Driver Code
if __name__ == '__main__':
     
    # Create following BST
    #         5
    #     / \
    #     2     13
    root = Node(5)
    root.left = Node(2)
    root.right = Node(13)
 
    print(""Inorder traversal of the given tree"")
    printInorder(root)
 
    addGreater(root)
    print()
    print(""Inorder traversal of the modified tree"")
    printInorder(root)
 
# This code is contributed by PranchalK
<|endoftext|>"
765,"<|endoftext|>Strong number:

A Strong number is a special number in which the total of all digit factorials equals the number itself.

Ex: 145 the sum of factorial of digits = 1 ! + 4 ! +5 ! = 1 + 24 +125

To determine whether a given number is strong or not. We take each digit from the supplied number and calculate its factorial, we will do this for each digit of the number.

We do the sum of factorials once we have the factorial of all digits. If the total equals the supplied number, the given number is strong; otherwise, it is not.

Given a list, and the task is to find all the Strong numbers in a given list.

Examples:

Example1:

Input:

Given List = [4, 1, 4, 145]
Output:

The Strong Numbers in a given List are :
1 145:# Import the math module using import keyword.
import math
# Give the list as static input and store it in a variable.
list1 = [4, 1, 4, 145]
# Loop in the above given list using For Loop.
print(""The Strong Numbers in a given List are :"")
for i in list1:
   # Taking a variable totalSum and initializing it with 0
    totalSum = 0
    # Put the iterator value in a temporary variable called tempNum.
    tempNum = i
    # using while to extract digit by digit of the given iterator value
    while(i):
        s = 1
        factNum = 1
        # Getting the last digit of the iterator value
        remainder = i % 10
        # calculating the factorial of the digit(extracted by remainder variable)
        # using math.fatorial function
        factNum = math.factorial(remainder)
        # Adding the factorial to the totalSum
        totalSum = totalSum + factNum
        # Dividing the given itertor value by 10
        i = i//10
    # checking if the totalSum is equal to the iterator value
    # if it is true then it is strong number then return true
    if(totalSum == tempNum):
        print(tempNum, end=' ')<|endoftext|>"
766,"<|endoftext|>Create a function that takes a string as an argument and returns True if each letter in the string is surrounded by a plus sign. Return False otherwise.
Examples
plus_sign(""+f+d+c+#+f+"") ➞ True

plus_sign(""+d+=3=+s+"") ➞ True

plus_sign(""f++d+g+8+"") ➞ False

plus_sign(""+s+7+fg+r+8+"") ➞ False
Notes
For clarity, each letter must have a plus sign on both sides.:import re
plus_sign=lambda t:re.findall(r'(?=\+([a-z])\+)',t)==re.findall(r'[a-z]',t)<|endoftext|>"
767,"<|endoftext|>Given a number and a dictionary with min and max properties, return True if the number lies within the given range (inclusive).
Examples
is_in_range(4, { ""min"": 0, ""max"": 5 }) ➞ True

is_in_range(4, { ""min"": 4, ""max"": 5 }) ➞ True

is_in_range(4, { ""min"": 6, ""max"": 10 }) ➞ False

is_in_range(5, { ""min"": 5, ""max"": 5 }) ➞ True
Notes
Numbers can be positive or negative, and they may not be integers.
You can assume min <= max is always true.
If you get stuck on a challenge, find help in the Resources tab.
If you're really stuck, unlock solutions in the Solutions tab.:def is_in_range(n, r):
  return r['min'] <= n <= r['max']<|endoftext|>"
768,"<|endoftext|>Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.:class Solution:
    def sumSubarrayMins(self, A: List[int]) -> int:
        A = [0]+A
        result = [0]*len(A)
        stack = [0]
        for i in range(len(A)):
            while A[stack[-1]] > A[i]:
                stack.pop() 
            j = stack[-1]
            result[i] = result[j] + (i-j)*A[i]
            stack.append(i)
        return sum(result) % (10**9+7)<|endoftext|>"
769,"<|endoftext|>Given a directed graph, check whether the graph contains a cycle or not. Your function should return true if the given graph contains at least one cycle, else return false.:# Python program to detect cycle in
# a directed graph
 
from collections import defaultdict
 
class Graph():
    def __init__(self, V):
        self.V = V
        self.graph = defaultdict(list)
 
    def addEdge(self, u, v):
        self.graph[u].append(v)
 
    def DFSUtil(self, u, color):
        # GRAY :  This vertex is being processed (DFS
        #         for this vertex has started, but not
        #         ended (or this vertex is in function
        #         call stack)
        color[u] = ""GRAY""
 
        for v in self.graph[u]:
 
            if color[v] == ""GRAY"":
                return True
 
            if color[v] == ""WHITE"" and self.DFSUtil(v, color) == True:
                return True
 
        color[u] = ""BLACK""
        return False
 
    def isCyclic(self):
        color = [""WHITE""] * self.V
 
        for i in range(self.V):
            if color[i] == ""WHITE"":
                if self.DFSUtil(i, color) == True:
                    return True
        return False
 
# Driver program to test above functions
 
g = Graph(4)
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)
print (""Graph contains cycle"" if g.isCyclic() == True\
                             else ""Graph doesn't contain cycle"")
                              
# This program is contributed by Divyanshu Mehta                            
<|endoftext|>"
770,"<|endoftext|>This is a reverse coding challenge. Normally you're given explicit directions with how to create a function. Here, you must generate your own function to satisfy the relationship between the inputs and outputs.
Your task is to create a function that, when fed the inputs below, produce the sample outputs shown.
Examples
832 ➞ 594

51 ➞ 36

7977 ➞ 198

1 ➞ 0

665 ➞ 99

149 ➞ 0
Notes
If you get stuck, see Comments for a hint.:def mystery_func(num):
    return num - int(''.join(sorted(str(num))))<|endoftext|>"
771,"<|endoftext|>Given a Sentence, the task is to Reverse each Word:# Give the string as static input and store it in a variable.
strng = ""Hello this is btechgeeks""
# Split the words of the given string to a list of words using the built-in split() function and store it in another variable.
splt_wrds = strng.split()
# Traverse in the above Given List of words using For Loop.
# Inside the Loop, Reverse each word of the list Using Slicing method and
# store it in a variable.
rversd_wrds = [wrd[::-1] for wrd in splt_wrds]
# Join all the reversed words of a given sentence using the built-in join( ) function
# and store it in another variable.
finl_sentnce = "" "".join(rversd_wrds)
# Print the reversed Sentence of each word of a given String.
print(""The Reverse of each word of the above given sentence = "", finl_sentnce)<|endoftext|>"
772,"<|endoftext|>You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.

Find the maximum profit you can achieve. You may complete at most k transactions.

Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

 

Example 1:

Input: k = 2, prices = [2,4,1]
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.
Example 2:

Input: k = 2, prices = [3,2,6,5,0,3]
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.:class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)

        # solve special cases
        if not prices or k==0:
            return 0

        if 2*k > n:
            res = 0
            for i, j in zip(prices[1:], prices[:-1]):
                res += max(0, i - j)
            return res

        # dp[i][used_k][ishold] = balance
        # ishold: 0 nothold, 1 hold
        dp = [[[-math.inf]*2 for _ in range(k+1)] for _ in range(n)]

        # set starting value
        dp[0][0][0] = 0
        dp[0][1][1] = -prices[0]

        # fill the array
        for i in range(1, n):
            for j in range(k+1):
                # transition equation
                dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1]+prices[i])
                # you can't hold stock without any transaction
                if j > 0:
                    dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0]-prices[i])

        res = max(dp[n-1][j][0] for j in range(k+1))
        return res<|endoftext|>"
773,"<|endoftext|>Create a matrix with alternating rectangles of O and X:# Python3 program to Create a matrix with
# alternating rectangles of O and X
 
# Function to print alternating rectangles
# of 0 and X
def fill0X(m, n):
     
    # k - starting row index
    # m - ending row index
    # l - starting column index
    # n - ending column index
    # i - iterator
    i, k, l = 0, 0, 0
 
    # Store given number of rows and
    # columns for later use
    r = m
    c = n
 
    # A 2D array to store the output
    # to be printed
    a = [[None] * n for i in range(m)]
    x = 'X' # Initialize the character to
            # be stored in a[][]
 
    # Fill characters in a[][] in spiral form.
    # Every iteration fills one rectangle of
    # either Xs or Os
    while k < m and l < n:
         
        # Fill the first row from the
        # remaining rows
        for i in range(l, n):
            a[k][i] = x
        k += 1
 
        # Fill the last column from
        # the remaining columns
        for i in range(k, m):
            a[i][n - 1] = x
        n -= 1
 
        # Fill the last row from the
        # remaining rows
        if k < m:
            for i in range(n - 1, l - 1, -1):
                a[m - 1][i] = x
            m -= 1
 
        # Print the first column from
        # the remaining columns
        if l < n:
            for i in range(m - 1, k - 1, -1):
                a[i][l] = x
            l += 1
 
        # Flip character for next iteration
        x = 'X' if x == '0' else '0'
 
    # Print the filled matrix
    for i in range(r):
        for j in range(c):
            print(a[i][j], end = "" "")
        print()
 
# Driver Code
if __name__ == '__main__':
     
    print(""Output for m = 5, n = 6"")
    fill0X(5, 6)
 
    print(""Output for m = 4, n = 4"")
    fill0X(4, 4)
 
    print(""Output for m = 3, n = 4"")
    fill0X(3, 4)
     
# This code is contributed by pranchalK<|endoftext|>"
774,"<|endoftext|>Try Finally
The finally block, if specified, will be executed regardless if the try block raises an error or not.:try:
  print(x)
except:
  print(""Something went wrong"")
finally:
  print(""The 'try except' is finished"")<|endoftext|>"
775,"<|endoftext|>Given an octal number and the task is to get the respective decimal number using the while loop in Python.

Examples:

Example1:

Input:

Given Octal Number = 15
Output:

The Decimal value of the given Octal number { 15 } is: 
13
Example2:

Input:

Given Octal Number = 32
Output:

The Decimal value of the given Octal number { 32 } is: 
26:# Give the octal number as static input and store it in a variable.
 gvn_octl_numb = 15
 # Take a variable say 'a 'and initialize its value with 0.
 a = 0
 # Take another variable say deciml_numb and initialize its value with 0.
 deciml_numb = 0
 # Loop till the given octal number is not equal to zero using the while loop.
 print(""The Decimal value of the given Octal number {"", gvn_octl_numb, ""} is: "")
 while(gvn_octl_numb != 0):
  # Inside the loop, calculate the value of the given octal number modulus 10
  # (to get the last digit) and store it in a variable say 'b'.
  b = (gvn_octl_numb % 10)
 # Calculate the value of 8 raised to the power 'a' using the pow() function and multiply
 # it with the above-obtained 'b'.
 # Store it in another variable 'c'.
  c = b*pow(8, a)
  # Add the above variable 'c' with the deciml_numb and store it in the same variable
  # deciml_numb.
  deciml_numb = deciml_numb+c
  # Increment the value a by 1 and store it in the same variable 'a'.
  a += 1
 # Divide the given octal number by 10 (to remove the last digit) and store it in the
 # same variable gvn_octl_numb.
  gvn_octl_numb = gvn_octl_numb // 10
 # Print the deciml_num to get the decimal value of the given Octal number.
 print(deciml_numb)<|endoftext|>"
776,"<|endoftext|>Create a function that creates a box based on dimension n.
Examples
make_box(5) ➞ [
  ""#####"",
  ""#   #"",
  ""#   #"",
  ""#   #"",
  ""#####""
]

make_box(3) ➞ [
  ""###"",
  ""# #"",
  ""###""
]

make_box(2) ➞ [
  ""##"",
  ""##""
]

make_box(1) ➞ [
  ""#""
]
Notes
N/A:def makeBox(n):
  if n == 1:
    return ['#']
  return ['#'*n] + ['#' + ' ' * (n-2) + '#'] * (n-2) + ['#'*n]<|endoftext|>"
777,"<|endoftext|>Create a function that takes a string containing money in dollars and pounds sterling (seperated by comma) and returns the sum of dollar bills only, as an integer.
For the input string:
Each amount is prefixed by the currency symbol: $ for dollars and £ for pounds.
Thousands are represented by the suffix k.
i.e. $4k = $4,000 and £40k = £40,000
Examples
add_bill(""d20,p40,p60,d50"") ➞ 20 + 50 = 70

add_bill(""p30,d20,p60,d150,p360"") ➞ 20  + 150 = 170

add_bill(""p30,d2k,p60,d200,p360"") ➞ 2 * 1000 + 200 = 2200
Notes
There is at least one dollar bill in string.:def add_bill(money):
   return sum(int(i[1:]) for i in money.replace('k', '000').split(',') if i.startswith('d'))<|endoftext|>"
778,"<|endoftext|>Given a list and the number N the task is to break a list into parts of size N in Python.:# Create a function listchunks() that accept the given list
# and the number as arguments and return the chunks of the given list.
def listchunks(gvnlst, gvnumb):
        # Calculate the length of a list using the len() function.
    lstleng = len(gvnlst)
    # Inside the function iterate from 0 to the length of the
    # given list and give the third parameter as n in the range() function
    # using the For loop.
    for m in range(0, lstleng, gvnumb):
        # Using the yield keyword slice from iterator value to the length of the list.
        yield gvnlst[m:m + gvnumb]

# Give the list as static input and store it in a variable.
gvnlist = ['hello', 'this', 'is', 'btechgeeks', 'online', 'coding', 'platform']
# Give the Number N as static input and store it in another Variable.
numb = 2
# Pass the given list and number N to listchunks() function.
resllt = listchunks(gvnlist, numb)
# Convert this result to the list() and store it in a variable.
resllt = list(resllt)
# Print the above result.
print(resllt)<|endoftext|>"
779,"<|endoftext|>Create a function that takes a list and finds the integer which appears an odd number of times.
Examples
find_odd([1, 1, 2, -2, 5, 2, 4, 4, -1, -2, 5]) ➞ -1

find_odd([20, 1, 1, 2, 2, 3, 3, 5, 5, 4, 20, 4, 5]) ➞ 5

find_odd([10]) ➞ 10
Notes
There will always only be one integer that appears an odd number of times.:def find_odd(lst):
  for num in lst:
    if lst.count(num) % 2:
      return num<|endoftext|>"
780,"<|endoftext|>You are given a string s. An awesome substring is a non-empty substring of s such that we can make any number of swaps in order to make it a palindrome.
Return the length of the maximum length awesome substring of s.
 
Example 1:

Input: s = ""3242415""
Output: 5
Explanation: ""24241"" is the longest awesome substring, we can form the palindrome ""24142"" with some swaps.

Example 2:

Input: s = ""12345678""
Output: 1

Example 3:

Input: s = ""213123""
Output: 6
Explanation: ""213123"" is the longest awesome substring, we can form the palindrome ""231132"" with some swaps.

 
Constraints:

1 <= s.length <= 105
s consists only of digits.:class Solution:
  def longestAwesome(self, s: str) -> int:
  mask, res = 0, 0
  dp = [-1] + [len(s)] * 1023
  for i in range(len(s)):
  mask ^= 1 << (ord(s[i]) - 48)
  for j in range(11):
  check_mask = 1023 & (mask ^ (1 << j))
  res = max(res, i - dp[check_mask])
  dp[mask] = min(dp[mask], i)
  return res<|endoftext|>"
781,"<|endoftext|>Given a singly linked list and a position, delete a linked list node at the given position.:
# Python program to delete a node in a linked list
# at a given position
 
# Node class
 
 
class Node:
 
    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None
 
 
class LinkedList:
 
    # Constructor to initialize head
    def __init__(self):
        self.head = None
 
    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node
 
    # Given a reference to the head of a list
    # and a position, delete the node at a given position
    #This delete function code is contributed by Arabin Islam
    def deleteNode(self, position):
        if self.head is None:
            return
        if position == 0:
            self.head = self.head.next
            return self.head
        index = 0
        current = self.head
        prev = self.head
        temp = self.head
        while current is not None:
            if index == position:
                temp = current.next
                break
            prev = current
            current = current.next
            index += 1
        prev.next = temp
        return prev
 
    # Utility function to print the LinkedList
 
    def printList(self):
        temp = self.head
        while(temp):
            print ("" %d "" % (temp.data),end="" "")
            temp = temp.next
 
 <|endoftext|>"
782,"<|endoftext|>Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.
Return the length of the smallest subarray that you need to remove, or -1 if it's impossible.
A subarray is defined as a contiguous block of elements in the array.
 
Example 1:

Input: nums = [3,1,4,2], p = 6
Output: 1
Explanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6.

Example 2:

Input: nums = [6,3,5,2], p = 9
Output: 2
Explanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9.

Example 3:

Input: nums = [1,2,3], p = 3
Output: 0
Explanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.

 
Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109
1 <= p <= 109:def minSubarray(self, A, p):
  need = sum(A) % p
  dp = {0: -1}
  cur = 0
  res = n = len(A)
  for i, a in enumerate(A):
  cur = (cur + a) % p
  dp[cur] = i
  if (cur - need) % p in dp:
  res = min(res, i - dp[(cur - need) % p])
  return res if res < n else -1<|endoftext|>"
783,"<|endoftext|>In the previous article, we have discussed Python Program to Get Tangent value Using math.tan()
 Disarium Number:
 A Disarium number is one in which the sum of each digit raised to the power of its respective position equals the original number.
 like 135 , 89, etc.
 Here 1^1 + 3^2 + 5^3 = 135 so it is disarium Number
 Examples:
 Example1:
 Input:
 Given lower limit range = 7
 
 Given upper limit range = 180
 Output:
 The disarium numbers in the given range 7 and 180 are: 
 
 7 8 9 89 135 175
 Example 2:
 Input:
 Given lower limit range = 1
 
 Given upper limit range = 250
 Output:
 The disarium numbers in the given range 1 and 250 are:
 
 1 2 3 4 5 6 7 8 9 89 135 175:# Give the lower limit range as static input and store it in a variable.
 
 lowlim_range = 7
 
 # Give the upper limit range as static input and store it in another variable.
 
 upplim_range = 180
 
 print('The disarium numbers in the given range',
 
  lowlim_range, 'and', upplim_range, 'are:')
 
 # Loop from lower limit range to upper limit range using For loop.
 
 for m in range(lowlim_range, upplim_range+1):
 
 
 
  # given number
 
  num = m
 
  # intialize result to zero(ans)
 
  ans = 0
 
 
 
  # calculating the digits
 
  digit_s = len(str(num))
 
  # copy the number in another variable(duplicate)
 
  dup_numbr = num
 
  while (dup_numbr != 0):
 
  # getting the last digit
 
  remaindr = dup_numbr % 10
 
  # multiply the result by a digit raised to the power of the iterator value.
 
  ans = ans + remaindr**digit_s
 
  digit_s = digit_s - 1
 
  dup_numbr = dup_numbr//10
 
  # It is disarium number if it is equal to original number
 
  if(num == ans):
 
  print(num, end=' ')
 
 </pre><|endoftext|>"
784,"<|endoftext|>Given a binary tree containing n nodes. The problem is to find and print the largest value present in each level.
Examples: 

Input :
        1
       / \
      2   3 
Output : 1 3

Input : 
        4
       / \
      9   2
     / \   \
    3   5   7 
Output : 4 9 7:# Python program to print largest value
# on each level of binary tree

INT_MIN = -2147483648

# Helper function that allocates a new
# node with the given data and None left
# and right pointers.


class newNode:

	# Constructor to create a new node
	def __init__(self, data):
		self.data = data
		self.left = None
		self.right = None

# function to find largest values


def largestValueInEachLevel(root):
	if (not root):
		return
	q = []
	nc = 10
	max = 0
	q.append(root)
	while (1):
		# node count for the current level
		nc = len(q)

		# if true then all the nodes of
		# the tree have been traversed
		if (nc == 0):
			break

		# maximum element for the current
		# level
		max = INT_MIN
		while (nc):

			# get the front element from 'q'
			front = q[0]

			# remove front element from 'q'
			q = q[1:]

			# if true, then update 'max'
			if (max < front.data):
				max = front.data

			# if left child exists
			if (front.left):
				q.append(front.left)

			# if right child exists
			if (front.right != None):
				q.append(front.right)
			nc -= 1

		# print maximum element of
		# current level
		print(max, end="" "")


# Driver Code
if __name__ == '__main__':
	"""""" Let us construct the following Tree
		4
		/ \
		9 2
	/ \ \
	3 5 7 """"""
	root = newNode(4)
	root.left = newNode(9)
	root.right = newNode(2)
	root.left.left = newNode(3)
	root.left.right = newNode(5)
	root.right.right = newNode(7)
	
	# Function call
	largestValueInEachLevel(root)

# This code is contributed
# Shubham Singh(SHUBHAMSINGH10)
<|endoftext|>"
785,"<|endoftext|>You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell.
You have two robots that can collect cherries for you:

Robot #1 is located at the top-left corner (0, 0), and
Robot #2 is located at the top-right corner (0, cols - 1).

Return the maximum number of cherries collection using both robots by following the rules below:

From a cell (i, j), robots can move to cell (i + 1, j - 1), (i + 1, j), or (i + 1, j + 1).
When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.
When both robots stay in the same cell, only one takes the cherries.
Both robots cannot move outside of the grid at any moment.
Both robots should reach the bottom row in grid.

 
Example 1:


Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
Output: 24
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.
Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.
Total of cherries: 12 + 12 = 24.

Example 2:


Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
Output: 28
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.
Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.
Total of cherries: 17 + 11 = 28.

 
Constraints:

rows == grid.length
cols == grid[i].length
2 <= rows, cols <= 70
0 <= grid[i][j] <= 100:class Solution:
  def cherryPickup(self, grid: List[List[int]]) -> int:
  m, n = len(grid), len(grid[0])

  @lru_cache(None)
  def dfs(r, c1, c2):
  if r == m: return 0
  cherries = grid[r][c1] if c1 == c2 else grid[r][c1] + grid[r][c2]
  ans = 0
  for nc1 in range(c1 - 1, c1 + 2):
  for nc2 in range(c2 - 1, c2 + 2):
  if 0 <= nc1 < n and 0 <= nc2 < n:
  ans = max(ans, dfs(r + 1, nc1, nc2))
  return ans + cherries

  return dfs(0, 0, n - 1)<|endoftext|>"
786,"<|endoftext|>Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.

 

Example 1:

Input: s = ""annabelle"", k = 2
Output: true
Explanation: You can construct two palindromes using all characters in s.
Some possible constructions ""anna"" + ""elble"", ""anbna"" + ""elle"", ""anellena"" + ""b""
Example 2:

Input: s = ""leetcode"", k = 3
Output: false
Explanation: It is impossible to construct 3 palindromes using all the characters of s.
Example 3:

Input: s = ""true"", k = 4
Output: true
Explanation: The only possible solution is to put each character in a separate string.
 

Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.
1 <= k <= 105:def canConstruct(self, s, k):
  return sum(i & 1 for i in collections.Counter(s).values()) <= k <= len(s)<|endoftext|>"
787,"<|endoftext|>The program sorts a list by bubble sort.:def bubble_sort(alist):
    for i in range(len(alist) - 1, 0, -1):
        no_swap = True
        for j in range(0, i):
            if alist[j + 1] < alist[j]:
                alist[j], alist[j + 1] = alist[j + 1], alist[j]
                no_swap = False
        if no_swap:
            return
 
 
alist = input('Enter the list of numbers: ').split()
alist = [int(x) for x in alist]
bubble_sort(alist)
print('Sorted list: ', end='')
print(alist)<|endoftext|>"
788,"<|endoftext|>Find Super Factorial of a Number (User input):# Import math module using the import keyword.
import math
# Give the number as User input and store it in a variable.
gvn_numbr = int(input(""Enter some Random Number =""))
# Take a variable and initialize it's value with '1'.
supr_factrl = 1
# Loop from '1 ' to above given number using For loop.
for iteror in range(gvn_numbr+1):
  # Calculate the factorial of the iterator value using built-in factorial method
  # and multiply it with above initialized superfactorial value.
 # Store it in another variable.
    supr_factrl = supr_factrl * math.factorial(iteror)
# Print the superfactorial value of the above given number.
print(""The super Factorial value of above given number = "", supr_factrl)<|endoftext|>"
789,"<|endoftext|>Merge sort is often preferred for sorting a linked list. The slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible. :
# Python3 program to merge sort of linked list
 
# create Node using class Node.
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
 
class LinkedList:
    def __init__(self):
        self.head = None
     
    # push new value to linked list
    # using append method
    def append(self, new_value):
         
        # Allocate new node
        new_node = Node(new_value)
         
        # if head is None, initialize it to new node
        if self.head is None:
            self.head = new_node
            return
        curr_node = self.head
        while curr_node.next is not None:
            curr_node = curr_node.next
             
        # Append the new node at the end
        # of the linked list
        curr_node.next = new_node
         
    def sortedMerge(self, a, b):
        result = None
         
        # Base cases
        if a == None:
            return b
        if b == None:
            return a
             
        # pick either a or b and recur..
        if a.data <= b.data:
            result = a
            result.next = self.sortedMerge(a.next, b)
        else:
            result = b
            result.next = self.sortedMerge(a, b.next)
        return result
     
    def mergeSort(self, h):
         
        # Base case if head is None
        if h == None or h.next == None:
            return h
 
        # get the middle of the list
        middle = self.getMiddle(h)
        nexttomiddle = middle.next
 
        # set the next of middle node to None
        middle.next = None
 
        # Apply mergeSort on left list
        left = self.mergeSort(h)
         
        # Apply mergeSort on right list
        right = self.mergeSort(nexttomiddle)
 
        # Merge the left and right lists
        sortedlist = self.sortedMerge(left, right)
        return sortedlist
     
    # Utility function to get the middle
    # of the linked list
    def getMiddle(self, head):
        if (head == None):
            return head
 
        slow = head
        fast = head
 
        while (fast.next != None and
               fast.next.next != None):
            slow = slow.next
            fast = fast.next.next
             
        return slow
         
# Utility function to print the linked list
def printList(head):
    if head is None:
        print(' ')
        return
    curr_node = head
    while curr_node:
        print(curr_node.data, end = "" "")
        curr_node = curr_node.next
    print(' ')
  <|endoftext|>"
790,"<|endoftext|>Given a Binary Tree, write a function to check whether the given Binary Tree is a perfect Binary Tree or not.
A Binary tree is Perfect Binary Tree in which all internal nodes have two children and all leaves are at same level.

Examples: 
The following tree is a perfect binary tree 

               10
           /       \  
         20         30  
        /  \        /  \
      40    50    60   70


               18
           /       \  
         15         30  
The following tree is not a perfect binary tree 

      1
    /    \
   2       3
    \     /  \   
     4   5    6
:# Python3 program to check whether a
# given Binary Tree is Perfect or not

# Helper class that allocates a new
# node with the given key and None
# left and right pointer.
class newNode:
	def __init__(self, k):
		self.key = k
		self.right = self.left = None

# Returns depth of leftmost leaf.
def findADepth(node):
	d = 0
	while (node != None):
		d += 1
		node = node.left
	return d

# This function tests if a binary tree
# is perfect or not. It basically checks
# for two things :
# 1) All leaves are at same level
# 2) All internal nodes have two children
def isPerfectRec(root, d, level = 0):
	
	# An empty tree is perfect
	if (root == None):
		return True

	# If leaf node, then its depth must
	# be same as depth of all other leaves.
	if (root.left == None and root.right == None):
		return (d == level + 1)

	# If internal node and one child is empty
	if (root.left == None or root.right == None):
		return False

	# Left and right subtrees must be perfect.
	return (isPerfectRec(root.left, d, level + 1) and
			isPerfectRec(root.right, d, level + 1))

# Wrapper over isPerfectRec()
def isPerfect(root):
	d = findADepth(root)
	return isPerfectRec(root, d)

# Driver Code
if __name__ == '__main__':
	root = None
	root = newNode(10)
	root.left = newNode(20)
	root.right = newNode(30)

	root.left.left = newNode(40)
	root.left.right = newNode(50)
	root.right.left = newNode(60)
	root.right.right = newNode(70)

	if (isPerfect(root)):
		print(""Yes"")
	else:
		print(""No"")
		
# This code is contributed by pranchalK
<|endoftext|>"
791,"<|endoftext|>There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character 'a'.


Each second, you may perform one of the following operations:

Move the pointer one character counterclockwise or clockwise.
Type the character the pointer is currently on.
Given a string word, return the minimum number of seconds to type out the characters in word.

 :class Solution:
    def minTimeToType(self, word: str) -> int:
        
        def get_index(c):
            return ord(c) - 96
        
        move = 0
        
        # initial start is block 'a'
        prev = 'a'
        
        for c in word:
            
            pi, ci = map(get_index, (prev, c))
            
            # basic move
            min_move = abs(ci - pi)
            
            if ci > pi:
                # e.g. current=""z"", prev=""a"", borrow 26 to prev 
                min_move = min(min_move, (pi + 26 - ci))
            else:
                # e.g. current=""a"", prev=""z"", borrow 26 to current
                min_move = min(min_move, (ci + 26 - pi))
                        
            # add print time
            move = move + min_move + 1
            
            # update prev pointer
            prev = c    
        
        return move<|endoftext|>"
792,"<|endoftext|>The task is to check if the sum of digits at odd places of a given number is divisible by the another given input number say K.:# Give the number as static input and store it in a variable.
gvn_numb = 12573
# Give the other number k as static input and store it in another variable.
gvn_k = 5
# Convert the given number to a string using the str() function and store it in
# another variable.
stringnum = str(gvn_numb)
# Create a list of digits say ""digtslst"" using map(),list(),int functions.
digtslst = list(map(int, stringnum))
# Take a variable say ""od_sum"" and initialize it with 0.
od_sum = 0
# Loop in the above list of digits until the length of the ""digtslst"" using the for loop.
for itr in range(len(digtslst)):
    # Check if the iterator value is odd or not using
    # the if conditional statement.
    if(itr % 2 != 0):
        # If the statement is true, then add the element of digits list at iterator value to
        # the ""od_sum""  and store it in the same variable od_sum.
        od_sum += digtslst[itr]
# Check if the od_sum modulus given number k is equal to 0 or not using the if conditional
# statement.
if(od_sum % gvn_k == 0):
    # If the statement is true, then print ""The sum of digits at odd places of the given
    # number is divisible by the another given number k.
    print(""The sum of digits at odd places of the given number{"", gvn_numb,
          ""} is divisible by the another given number k{"", gvn_k, ""}"")
else:
    # If the statement is false, then print ""The sum of digits at odd places of the given
    # number is Not divisible by the another given number k.
    print(""The sum of digits at odd places of the given number{"", gvn_numb,
          ""} is not divisible by the another given number k{"", gvn_k, ""}"")<|endoftext|>"
793,"<|endoftext|>Given two numbers a, b and the task is to find all x such that given a % x = b

Examples:

Example1:

Input:

Given a value = 21
Given b value = 5
Output:

The value of x such that given a%x==b {a,b = 21 5 } =  2
Explanation:

Here the values of x which satisfy a%x=b are 8,16 because 21%8=5 ,21%16=5.
so total number of possible x are 8,16 i.e 2 values
Example2:

Input:

Given a value = 35
Given b value = 8
Output:

The value of x such that given a%x==b {a,b = 35 8 } =  2:# Import the math module using the import keyword.
 import math
 # Create a function to say a_mod_xisb which takes the given two numbers as the arguments
 # and returns all the values of x such that given a % x = b.
 def a_mod_xisb(gvn_a_val, gvn_b_val):
  # Check if the given number a is less than the given b value using the if conditional
  # statement.
  if (gvn_a_val < gvn_b_val):
  # If it is true then print ""There are no solutions possible"".
  print(""There are no solutions possible"")
  # Return.
  return
  # Check if the given a value is equal to the given b value using the if conditional
  # statement.
  if (gvn_a_val == gvn_b_val):
  # If it is true then print ""Infinite Solutions are possible for the equation"".
  # Return.
  print(""Infinite Solutions are possible for the equation"")
  return
  # Take a variable say cnt and initialize its value to 0.
  cnt = 0
  # Subtract the given b value from the given a value and store it in another variable
  # say rslt.
  rslt = gvn_a_val - gvn_b_val
  # Calculate the value of square root of (gvn_a_val - gvn_b_val) using the math.sqrt()
  # function and convert result to an integer using the int() function.
  # Store it in another variable say k.
  k = (int)(math.sqrt(gvn_a_val - gvn_b_val))
  # Loop from 1 to the above result k using the for loop.
  for itr in range(1, k+1):
  # Inside the loop, check if the above value of rslt modulus iterator value is equal
  # to 0 using the if conditional statement.
  if (rslt % itr == 0):
  # Again check if the rslt divided by the iterator value greater than the given b value
  # using the if conditional statement.
  if (rslt / itr > gvn_b_val):
  # If it is true, increment the count value by 1 and store it in the same variable.
  cnt = cnt + 1
  # Check if the iterator value is greater than the given b value using the if
  # conditional statement.
  if (itr > gvn_b_val):
  # If it is true, increment the count value by 1 and store it in the same variable.
  cnt = cnt + 1
  # Check if the k multiplied with itself is equal to the rslt and k greater than the
  # given b value using the if conditional statement.
  if (k * k == rslt and k > gvn_b_val):
  # If it is true, decrement the count value by 1 and store it in the same variable.
  cnt = cnt - 1
  # Print the value of x such that given a%x==b.
  print(
  ""The value of x such that given a%x==b {a,b ="", gvn_a_val, gvn_b_val, ""} = "", cnt)
 # Give the number as static input and store it in a variable.
 gvn_a_val = 15
 # Give the other number as static input and store it in another variable.
 gvn_b_val = 2
 # Pass the given number two numbers as the arguments to the a_mod_xisb function.
 a_mod_xisb(gvn_a_val, gvn_b_val)<|endoftext|>"
794,"<|endoftext|>Method #1: Using For Loop (Static Input)
Approach:

Give the number of rows as static input and store it in a variable.
Take a variable and store the given number of rows in it say givennumbrows.
Loop from the number of rows to 0 in decreasing order using For loop.
Loop from 0 to the parent loop iterator using another For loop(Nested For Loop).
Print the givennumbrows.
Print the Newline character after the end of the inner loop.
The Exit of the Program.:# Give the number of rows as static input and store it in a variable.
numbrrows = 7
# Take a variable and store the given number of rows in it say givennumbrows.
givennumbrows = numbrrows
# Loop from the number of rows to 0 in decreasing order using For loop.
for m in range(numbrrows, 0, -1):
    # Loop from 0 to the parent loop iterator using another For loop(Nested For Loop).
    for n in range(0, m):
        # Print the givennumbrows.
        print(givennumbrows, end=' ')
    # Print the Newline character after the end of the inner loop.
    print()<|endoftext|>"
795,"<|endoftext|>Create a function that replaces ""the"" in the sentence with ""an"" or ""a"". Remember that if the next word begins with a vowel, use ""an"". In the case of a consonant, use ""a"".
Examples
replace_the(""the dog and the envelope"") ➞ ""a dog and an envelope""

replace_the(""the boy ran at the wall"") ➞ ""a boy ran at a wall""

replace_the(""the egg, the spoon and the espionage"") ➞ ""an egg, a spoon and an espionage""
Notes
Sentences will always be in lowercase.
The last word of the sentence will never be ""the"".
This won't cover edge cases such as ""an hour"" or ""a unique thing"" (since they sound differently to the rule).:import re
def replace_the(txt):
  def repl(match):
    a,b = match.group(1,2)
    return ('an ' if b in 'aeiou' else 'a ') + b
  return re.sub('(the) (\w)', repl, txt)<|endoftext|>"
796,"<|endoftext|>Given a string, K value and the task is to remove all the characters from the given string that appears more than k times.:# Take a dictionary and initialize it to empty
# using the {} or dict() say freqncyDictionary.
freqncyDictionary = {}
# Give the string as static input and store it in a variable
gvnstrng = ""hellobtechgeeks""
# Loop in the given string using the For loop.
for i in gvnstrng:
        # Inside the For loop,
    # Check if the string character is present in the dictionary
    # or not using the if conditional statement and 'in' keyword.
    if i in freqncyDictionary.keys():
                # If it is true then increment the count of the string character
        # in the dictionary by 1.
        freqncyDictionary[i] = freqncyDictionary[i]+1
    # Else initialize the dictionary with the string character as key and value as 1.
    else:
        freqncyDictionary[i] = 1
# Give the k value as static input and store it in a variable.
k = 3
# Take a string which stores all the characters which are not occuring even number
# of times and initialize it to null string using """" or str()
modifd_string = """"
# loop in the given string using the for loop
for charac in gvnstrng:

        # check if the character has frequency less than k by checking value of that character in frequency dictionary
        # we check using the if conditional statement
    if(freqncyDictionary[charac] < k):
        # if it is true then concatenate this character to modifd_string using string concatenation
        modifd_string = modifd_string+charac

# print the modifd_string string
print('The given string {', gvnstrng,
      '} after removal of all characters that appears more than k{', k, '} times :', modifd_string)<|endoftext|>"
797,"<|endoftext|>Given an age in seconds, calculate how old someone would be on:

Mercury: orbital period 0.2408467 Earth years
Venus: orbital period 0.61519726 Earth years
Earth: orbital period 1.0 Earth years, 365.25 Earth days, or 31557600 seconds
Mars: orbital period 1.8808158 Earth years
Jupiter: orbital period 11.862615 Earth years
Saturn: orbital period 29.447498 Earth years
Uranus: orbital period 84.016846 Earth years
Neptune: orbital period 164.79132 Earth years
So if you were told someone were 1,000,000,000 seconds old, you should be able to say that they're 31.69 Earth-years old.:class SpaceAge(object):
    PLANET_RATIOS = [(k, v * 31557600) for k, v in (
        ('earth', 1.0),
        ('mercury', 0.2408467),
        ('venus', 0.61519726),
        ('mars', 1.8808158),
        ('jupiter', 11.862615),
        ('saturn', 29.447498),
        ('uranus', 84.016846),
        ('neptune', 164.79132)
    )]
    def __init__(self, seconds):
        self.seconds = seconds
        for planet, ratio in self.PLANET_RATIOS:
            setattr(self, 'on_' + planet, self._planet_years(ratio))
    def _planet_years(self, ratio):
        return lambda ratio=ratio: round(self.seconds / ratio, 2)<|endoftext|>"
798,"<|endoftext|>Strings in Python:

A string is one of the most frequent data types in any computer language. A string is a collection of characters that can be used to represent usernames, blog posts, tweets, or any other text content in your code. You can make a string and assign it to a variable by doing something like this.

given_string='btechgeeks'

Strings are considered immutable in Python, once created, they cannot be modified. You may, however, construct new strings from existing strings using a variety of approaches. This form of programming effort is known as string manipulation.

Examples:

Example1:

Input:

given string = hello this is BtechGeeks
Output:

The original string before modification = hello this is BtechGeeks
The new string after modification = hello-this-is-BtechGeeks
Example2:

Input:

given string = files will be upload to a folder you can read those files in the program folder
Output:

Enter some random string = files will be upload to a folder you can read those files in the program folder
The original string before modification = files will be upload to a folder you can read those files in the program folder
The new string after modification = files-will-be-upload-to-a-folder-you-can-read-those-files-in-the-program-folder:# Give the string as static input and store it in a variable.
given_string = 'hello this is BtechGeeks'
# printing the original string before modification
print('The original string before modification =', given_string)
# Using the replace function replace all blank space with a hyphen by providing blank space as the first argument
# and hyphen as the second argument in replace function.
modified_string = given_string.replace(' ', '-')
# printing the new string after modification
print('The new string after modification =', modified_string)<|endoftext|>"
799,"<|endoftext|>Given a string and file, the task is to print the lines that contain the given string in Python.:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Give the word as static input and store it in a variable.
word = ""BTechGeeks""
print('Printing the lines that are containing the given word {', word, '} :')
# Open the file in read-only mode. In this case, we're simply reading the contents of the file.
with open(givenFilename, 'r') as givenfilecontent:
  for gvnfileline in givenfilecontent:
  # Split the words of the line using the split() function and store them in a variable(it is of type list).
  gvnfilewords = gvnfileline.split()
  # check if the given word is present in the above words using if and in keywords
  if word in gvnfilewords:
  # If it is true then print the line.
  print(gvnfileline)<|endoftext|>"
800,"<|endoftext|>Given a dictionary containing counts of both upvotes and downvotes, return what vote count should be displayed. This is calculated by subtracting the number of downvotes from upvotes.

Examples
get_vote_count({ ""upvotes"": 13, ""downvotes"": 0 }) ➞ 13

get_vote_count({ ""upvotes"": 2, ""downvotes"": 33 }) ➞ -31

get_vote_count({ ""upvotes"": 132, ""downvotes"": 132 }) ➞ 0
Notes
You can expect only positive integers for vote counts.:def get_vote_count(votes):
  return votes['upvotes'] - votes['downvotes']<|endoftext|>"
801,"<|endoftext|>Given a directed graph, a source vertex ‘s’ and a destination vertex ‘d’, print all paths from given ‘s’ to ‘d’. :# Python program to print all paths from a source to destination.
  
from collections import defaultdict
  
# This class represents a directed graph
# using adjacency list representation
class Graph:
  
    def __init__(self, vertices):
        # No. of vertices
        self.V = vertices
         
        # default dictionary to store graph
        self.graph = defaultdict(list)
  
    # function to add an edge to graph
    def addEdge(self, u, v):
        self.graph[u].append(v)
  
    '''A recursive function to print all paths from 'u' to 'd'.
    visited[] keeps track of vertices in current path.
    path[] stores actual vertices and path_index is current
    index in path[]'''
    def printAllPathsUtil(self, u, d, visited, path):
 
        # Mark the current node as visited and store in path
        visited[u]= True
        path.append(u)
 
        # If current vertex is same as destination, then print
        # current path[]
        if u == d:
            print (path)
        else:
            # If current vertex is not destination
            # Recur for all the vertices adjacent to this vertex
            for i in self.graph[u]:
                if visited[i]== False:
                    self.printAllPathsUtil(i, d, visited, path)
                     
        # Remove current vertex from path[] and mark it as unvisited
        path.pop()
        visited[u]= False
  
  
    # Prints all paths from 's' to 'd'
    def printAllPaths(self, s, d):
 
        # Mark all the vertices as not visited
        visited =[False]*(self.V)
 
        # Create an array to store paths
        path = []
 
        # Call the recursive helper function to print all paths
        self.printAllPathsUtil(s, d, visited, path)
  
  
  
# Create a graph given in the above diagram
g = Graph(4)
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(0, 3)
g.addEdge(2, 0)
g.addEdge(2, 1)
g.addEdge(1, 3)
  
s = 2 ; d = 3
print (""Following are all different paths from % d to % d :"" %(s, d))
g.printAllPaths(s, d)
# This code is contributed by Neelam Yadav
<|endoftext|>"
802,"<|endoftext|>You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.
A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.
 
Example 1:

Input: accounts = [[1,2,3],[3,2,1]]
Output: 6
Explanation:
1st customer has wealth = 1 + 2 + 3 = 6
2nd customer has wealth = 3 + 2 + 1 = 6
Both customers are considered the richest with a wealth of 6 each, so return 6.

Example 2:

Input: accounts = [[1,5],[7,3],[3,5]]
Output: 10
Explanation: 
1st customer has wealth = 6
2nd customer has wealth = 10 
3rd customer has wealth = 8
The 2nd customer is the richest with a wealth of 10.
Example 3:

Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]
Output: 17

 
Constraints:

m == accounts.length
n == accounts[i].length
1 <= m, n <= 50
1 <= accounts[i][j] <= 100:def maximumWealth(self, accounts):
  return max(map(sum, accounts))<|endoftext|>"
803,"<|endoftext|>Consider a List of distinct numbers that are sorted in ascending order. The list has been rotated k times (clockwise). The task is to determine the value of k.

In simple terms, print the minimum index value to get the rotation count.:# Give the list as static input and store it in a variable.
gvn_lst = [1, 3, 5, 7, 9]
# Calculate the length of the given list using the len() function and
# store it in another variable.
len_lst = len(gvn_lst)
# Take a variable say ""minim_index"" and initialize it with the first element of
# the given list.
minim_index = gvn_lst[0]
# Loop from 0 to the length of the given list using the for loop.
for itr in range(0, len_lst):
 # Check if the value of the variable ""minim_index"" is greater than the given list of
 # iterator value.
    if (minim_index > gvn_lst[itr]):
        # If the statement is true then assign the given list of iterator value to the ""minim_index"".
        minim_index = gvn_lst[itr]
# Store the iterator value in a variable ""minim_index"".
        minim_index = itr
# Print ""minim_index"" to get the number of rotations of a given list.
print(""The number of rotations of a gvn_lst"", gvn_lst, ""="", minim_index)<|endoftext|>"
804,"<|endoftext|>Consider lines of slope -1 passing between nodes. Given a Binary Tree, print all diagonal elements in a binary tree belonging to same line.:# Python3 program to construct string from binary tree
class Node:
	def __init__(self,data):
		self.val = data
		self.left = None
		self.right = None
		
# Function to print diagonal view
def diagonalprint(root):
	
	# base case
	if root is None:
		return
		
	# queue of treenode
	q = []
	
	# Append root
	q.append(root)
	
	# Append delimiter
	q.append(None)

	while len(q) > 0:
		temp = q.pop(0)
		
		# If current is delimiter then insert another
		# for next diagonal and cout nextline
		if not temp:
			
			# If queue is empty then return
			if len(q) == 0:
				return
				
			# Print output on nextline
			print(' ')
			
			# append delimiter again
			q.append(None)

		else:
			while temp:
				print(temp.val, end = ' ')
				
				# If left child is present
				# append into queue
				if temp.left:
					q.append(temp.left)
					
				# current equals to right child
				temp = temp.right

# Driver Code
root = Node(8)
root.left = Node(3)
root.right = Node(10)
root.left.left = Node(1)
root.left.right = Node(6)
root.right.right = Node(14)
root.right.right.left = Node(13)
root.left.right.left = Node(4)
root.left.right.right = Node(7)
diagonalprint(root)

# This code is contributed by Praveen kumar<|endoftext|>"
805,"<|endoftext|>Trie is an efficient information reTrieval data structure. Using Trie, search complexities can be brought to optimal limit (key length). If we store keys in binary search tree, a well balanced BST will need time proportional to M * log N, where M is maximum string length and N is number of keys in tree. Using Trie, we can search the key in O(M) time. However the penalty is on Trie storage requirements:
# Python program for insert and search
# operation in a Trie
 
class TrieNode:
     
    # Trie node class
    def __init__(self):
        self.children = [None]*26
 
        # isEndOfWord is True if node represent the end of the word
        self.isEndOfWord = False
 
class Trie:
     
    # Trie data structure class
    def __init__(self):
        self.root = self.getNode()
 
    def getNode(self):
     
        # Returns new trie node (initialized to NULLs)
        return TrieNode()
 
    def _charToIndex(self,ch):
         
        # private helper function
        # Converts key current character into index
        # use only 'a' through 'z' and lower case
         
        return ord(ch)-ord('a')
 
 
    def insert(self,key):
         
        # If not present, inserts key into trie
        # If the key is prefix of trie node,
        # just marks leaf node
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
 
            # if current character is not present
            if not pCrawl.children[index]:
                pCrawl.children[index] = self.getNode()
            pCrawl = pCrawl.children[index]
 
        # mark last node as leaf
        pCrawl.isEndOfWord = True
 
    def search(self, key):
         
        # Search key in the trie
        # Returns true if key presents
        # in trie, else false
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                return False
            pCrawl = pCrawl.children[index]
 
        return pCrawl.isEndOfWord
 
# driver function
def main():
 
    # Input keys (use only 'a' through 'z' and lower case)
    keys = [""the"",""a"",""there"",""anaswe"",""any"",
            ""by"",""their""]
    output = [""Not present in trie"",
              ""Present in trie""]
 
    # Trie object
    t = Trie()
 
    # Construct trie
    for key in keys:
        t.insert(key)
 
    # Search for different keys
    print(""{} ---- {}"".format(""the"",output[t.search(""the"")]))
    print(""{} ---- {}"".format(""these"",output[t.search(""these"")]))
    print(""{} ---- {}"".format(""their"",output[t.search(""their"")]))
    print(""{} ---- {}"".format(""thaw"",output[t.search(""thaw"")]))
 
if __name__ == '__main__':
    main()
 
# This code is contributed by Atul Kumar (www.facebook.com/atul.kr.007)<|endoftext|>"
806,"<|endoftext|>Create a function that takes a number a and finds the missing exponent x so that a when raised to the power of x is equal to b.
Examples
solve_for_exp(4, 1024) ➞ 5

solve_for_exp(2, 1024) ➞ 10

solve_for_exp(9, 3486784401) ➞ 10
Notes
a is raised to the power of what in order to equal b?:from math import log
def solve_for_exp(a, b):
  return round(log(b,a))<|endoftext|>"
807,"<|endoftext|>Here we will develop a program how to check if two strings are equal in python both condition case-sensitive and case-insensitive. In computers, case-sensitivity defines whether uppercase and lowercase letters are treated as distinct (case-sensitive) or equivalent (case-insensitive).:# Python program to check if two strings are equal # first string string1 = input('Enter first string: ') # second string string2 = input('Enter second string: ') # check strings is equal or not if(string1 == string2): print('The strings are the same.') else: print('The strings are not the same.')<|endoftext|>"
808,"<|endoftext|>Behold, Marvel Fans. Avengers are out there to save the Multiverse, so are we, ready to do whatever it takes to support them.
In this article, we will use Deep Learning and computer vision for the caption generation of Avengers Endgame characters. We will start will the basics, explaining concepts and use a pre-trained model to implement the project.:
import torch
import matplotlib.pyplot as plt
import numpy as np 
import argparse
import pickle 
import os
from torchvision import transforms 
from PIL import Image
  
# this file is located in pytorch tutorial/image 
# captioning which we pull from git remember
from build_vocab import Vocabulary   
from model import EncoderCNN, DecoderRNN
# Model path 
  
# make sure path must correct 
ENCODER_PATH = 'content/encoder-5-3000.pkl' 
DECODER_PATH = 'content/decoder-5-3000.pkl'
VOCAB_PATH =   'content/vocab.pkl'
  
# CONSTANTS because of architecture what we are using
EMBED_SIZE = 256
HIDDEN_SIZE = 512
NUM_LAYERS = 1
# Device configuration snippet
device = torch.cuda.device(0) # 0 represent default device
  
  
# Function to Load and Resize the image
def load_image(image_path, transform=None): 
  image = Image.open(image_path)
  image = image.resize([224, 224], Image.LANCZOS)
  if transform is not None:
    image = transform(image).unsqueeze(0)
  return image
def PretrainedResNet(image_path, encoder_path=ENCODER_PATH, 
                     decoder_path=DECODER_PATH,
                     vocab_path=VOCAB_PATH,
                     embed_size=EMBED_SIZE,
                     hidden_size=HIDDEN_SIZE,
                     num_layers=NUM_LAYERS):
  
    # Image preprocessing
    transform = transforms.Compose([
                transforms.ToTensor(), 
                transforms.Normalize((0.485, 0.456, 0.406), 
                                     (0.229, 0.224, 0.225))])
        
    # Load vocabulary wrapper
    with open(vocab_path, 'rb') as f:
        vocab = pickle.load(f)
  
    # Build models
  
    # eval mode (batchnorm uses moving mean/variance)
    encoder = EncoderCNN(embed_size).eval()  
    decoder = DecoderRNN(embed_size, hidden_size,
                          len(vocab), num_layers)
  
    encoder = encoder.to(device)
    decoder = decoder.to(device)
  
    # Load the trained model parameters
    encoder.load_state_dict(torch.load(encoder_path))
    decoder.load_state_dict(torch.load(decoder_path))
  
    # Prepare an image
    image = load_image(image_path, transform)
    image_tensor = image.to(device)
      
    # Generate a caption from the image
    feature = encoder(image_tensor)
    sampled_ids = decoder.sample(feature)
  
    # (1, max_seq_length) -> (max_seq_length)
    sampled_ids = sampled_ids[0].cpu().numpy()         
      
    # Convert word_ids to words
    sampled_caption = []
    for word_id in sampled_ids:
        word = vocab.idx2word[word_id]
        sampled_caption.append(word)
        if word == '<end>':
            break
    sentence = ' '.join(sampled_caption)[8:-5].title() 
  
    # Print out the image and the generated caption
    image = Image.open(image_path)
    return sentence, image
plt.figure(figsize=(24,24))
predicted_label, image = PretrainedResNet(image_path='IMAGE_PATH')
plt.imshow(image)
print(predicted_label)<|endoftext|>"
809,"<|endoftext|>Given an undirected tree with some marked nodes and a positive number K. We need to print the count of all such nodes which have distance from all marked nodes less than K that means every node whose distance from all marked nodes is less than K, should be counted in the result. 
 :# Python3 program to count nodes inside
# K distance range from marked nodes
import queue
 
# Utility bfs method to fill distance
# vector and returns most distant
# marked node from node u
def bfsWithDistance(g, mark, u, dis):
    lastMarked = 0
    q = queue.Queue()
 
    # push node u in queue and initialize
    # its distance as 0
    q.put(u)
    dis[u] = 0
 
    # loop until all nodes are processed
    while (not q.empty()):
        u = q.get()
         
        # if node is marked, update
        # lastMarked variable
        if (mark[u]):
            lastMarked = u
 
        # loop over all neighbors of u and
        # update their distance before
        # pushing in queue
        for i in range(len(g[u])):
            v = g[u][i]
             
            # if not given value already
            if (dis[v] == -1):
                dis[v] = dis[u] + 1
                q.put(v)
                 
    # return last updated marked value
    return lastMarked
 
# method returns count of nodes which
# are in K-distance range from marked nodes
def nodesKDistanceFromMarked(edges, V, marked, N, K):
     
    # vertices in a tree are one
    # more than number of edges
    V = V + 1
    g = [[] for i in range(V)]
 
    # fill vector for graph
    u, v = 0, 0
    for i in range(V - 1):
        u = edges[i][0]
        v = edges[i][1]
 
        g[u].append(v)
        g[v].append(u)
 
    # fill boolean array mark from
    # marked array
    mark = [False] * V
    for i in range(N):
        mark[marked[i]] = True
 
    # vectors to store distances
    tmp = [-1] * V
    dl = [-1] * V
    dr = [-1] * V
 
    # first bfs(from any random node)
    # to get one distant marked node
    u = bfsWithDistance(g, mark, 0, tmp)
 
    # second bfs to get other distant
    # marked node and also dl is filled
    # with distances from first chosen
    # marked node
    u = bfsWithDistance(g, mark, u, dl)
 
    # third bfs to fill dr by distances
    # from second chosen marked node
    bfsWithDistance(g, mark, u, dr)
 
    res = 0
     
    # loop over all nodes
    for i in range(V):
         
        # increase res by 1, if current node
        # has distance less than K from both
        # extreme nodes
        if (dl[i] <= K and dr[i] <= K):
            res += 1
    return res
 
# Driver Code
if __name__ == '__main__':
 
    edges = [[1, 0], [0, 3], [0, 8],
             [2, 3], [3, 5], [3, 6],
             [3, 7], [4, 5], [5, 9]]
    V = len(edges)
     
    marked = [1, 2, 4]
    N = len(marked)
 
    K = 3
    print(nodesKDistanceFromMarked(edges, V,
                                   marked, N, K))
 
# This code is contributed by PranchalK
<|endoftext|>"
810,"<|endoftext|>Given a tree represented as an undirected graph. Count the number of nodes at a given level l. It may be assumed that vertex 0 is the root of the tree.:# Python3 program to print
# count of nodes at given level.
from collections import deque
  
adj = [[] for i in range(1001)]
  
def addEdge(v, w):
     
    # Add w to v’s list.
    adj[v].append(w)
  
    # Add v to w's list.
    adj[w].append(v)
  
def BFS(s, l):
     
    V = 100
     
    # Mark all the vertices
    # as not visited
    visited = [False] * V
    level = [0] * V
  
    for i in range(V):
        visited[i] = False
        level[i] = 0
  
    # Create a queue for BFS
    queue = deque()
  
    # Mark the current node as
    # visited and enqueue it
    visited[s] = True
    queue.append(s)
    level[s] = 0
  
    while (len(queue) > 0):
         
        # Dequeue a vertex from
        # queue and print
        s = queue.popleft()
        #queue.pop_front()
  
        # Get all adjacent vertices
        # of the dequeued vertex s.
        # If a adjacent has not been
        # visited, then mark it
        # visited and enqueue it
        for i in adj[s]:
            if (not visited[i]):
  
                # Setting the level
                # of each node with
                # an increment in the
                # level of parent node
                level[i] = level[s] + 1
                visited[i] = True
                queue.append(i)
  
    count = 0
    for i in range(V):
        if (level[i] == l):
            count += 1
             
    return count
  
# Driver code
if __name__ == '__main__':
     
    # Create a graph given
    # in the above diagram
    addEdge(0, 1)
    addEdge(0, 2)
    addEdge(1, 3)
    addEdge(2, 4)
    addEdge(2, 5)
  
    level = 2
  
    print(BFS(0, level))
     
# This code is contributed by mohit kumar 29
<|endoftext|>"
811,"<|endoftext|>You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.
Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.
 
Example 1:

Input: s1 = ""bank"", s2 = ""kanb""
Output: true
Explanation: For example, swap the first character with the last character of s2 to make ""bank"".

Example 2:

Input: s1 = ""attack"", s2 = ""defend""
Output: false
Explanation: It is impossible to make them equal with one string swap.

Example 3:

Input: s1 = ""kelb"", s2 = ""kelb""
Output: true
Explanation: The two strings are already equal, so no string swap operation is required.

 
Constraints:

1 <= s1.length, s2.length <= 100
s1.length == s2.length
s1 and s2 consist of only lowercase English letters.:class Solution:
  def areAlmostEqual(self, s1: str, s2: str) -> bool:
  diff = [[x, y] for x, y in zip(s1, s2) if x != y]
  return not diff or len(diff) == 2 and diff[0][::-1] == diff[1]<|endoftext|>"
812,"<|endoftext|>Create a function that returns the sum of all even elements in a 2D matrix.
Examples
sum_of_evens([
  [1, 0, 2],
  [5, 5, 7],
  [9, 4, 3]
]) ➞ 6

// 2 + 4 = 6

sum_of_evens([
  [1, 1],
  [1, 1]
]) ➞ 0

sum_of_evens([
  [42, 9],
  [16, 8]
]) ➞ 66

sum_of_evens([
  [],
  [],
  []
]) ➞ 0
Notes
Submatrices will be of equal length.
Return 0 if the 2D matrix only consists of empty submatrices.:def sum_of_evens(lst):
  return sum([c for r in lst for c in r if c%2==0])<|endoftext|>"
813,"<|endoftext|>Count the Number of Odd and Even Digits (User Input):# Give the number as user input using the int(input()) function and
# store it in a variable.
numb = int(input(""Enter some random number = ""))
# Convert the given number to string using the str() function.
stringnum = str(numb)
# Create a list of digits say ""digtslst"" using map(),list(),int functions.
digtslst = list(map(int, stringnum))
# Take a variable say ""evn_count"" and initialize it with 0.
evn_count = 0
# Take another variable say ""od_count"" and initialize it with 0.
od_count = 0
# Loop in the above list of digits until the length of the ""digtslst"" using the for loop.
for itr in range(len(digtslst)):
    # Check if the iterator value of ""digtslst"" is even or not using
    # the if conditional statement.
    if(digtslst[itr] % 2 == 0):
        # If the statement is true, increment the count value of ""evn_count"" by 1.
        evn_count += 1
    else:
        # If the statement is false, increment the count value of ""od_count"" by 1.
        od_count += 1
# Print ""evn_count"" to get the count of even digits in a given number.
print(""The count of even digits in a given number{"", numb, ""} ="", evn_count)
# Print ""od_count"" to get the count of odd digits in a given number.
print(""The count of odd digits in a given number{"", numb, ""} ="", od_count)<|endoftext|>"
814,"<|endoftext|>Question: Write an efficient program for printing k largest elements in an array. Elements in an array can be in any order.
For example, if the given array is [1, 23, 12, 9, 30, 2, 50] and you are asked for the largest 3 elements i.e., k = 3 then your program should print 50, 30, and 23.:def FirstKelements(arr,size,k):
	
	# Creating Min Heap for given
	# array with only k elements
	# Create min heap with priority queue
	minHeap = []
	for i in range(k):
		minHeap.append(arr[i])
	
	# Loop For each element in array
	# after the kth element
	for i in range(k, size):
		minHeap.sort()
		
		# If current element is smaller
		# than minimum ((top element of
		# the minHeap) element, do nothing
		# and continue to next element
		if (minHeap[0] > arr[i]):
			continue
			
		# Otherwise Change minimum element
		# (top element of the minHeap) to
		# current element by polling out
		# the top element of the minHeap
		else:
			minHeap.pop(0)
			minHeap.append(arr[i])
			
	# Now min heap contains k maximum
	# elements, Iterate and print
	for i in minHeap:
		print(i, end = "" "")

# Driver code
arr=[11, 3, 2, 1, 15, 5, 4,45, 88, 96, 50, 45]
size = len(arr)

# Size of Min Heap
k=3
FirstKelements(arr, size, k)

# This code is contributed by avanitrachhadiya2155<|endoftext|>"
815,"<|endoftext|>Create a function that returns the number of arguments it was called with.
Examples
num_args() ➞ 0

num_args(""foo"") ➞ 1

num_args(""foo"", ""bar"") ➞ 2

num_args(True, False) ➞ 2

num_args({}) ➞ 1
Notes
If you get stuck on a challenge, find help in the Resources tab.
If you're really stuck, unlock solutions in the Solutions tab.:def num_args(*args):
  return(len(args))<|endoftext|>"
816,"<|endoftext|>You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.

Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.

You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.:class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        lo=0 ; hi=totalTrips*min(time)
        while lo<hi:
            mid=(lo+hi)//2
            if sum([mid//x for x in time])>=totalTrips: hi=mid
            else: lo=mid+1
        return hi<|endoftext|>"
817,"<|endoftext|>Intuition:

Draw the path that the spiral makes. We know that the path should turn clockwise whenever it would go out of bounds or into a cell that was previously visited.

Algorithm:

Let the array have R rows and C columns. seen[r] denotes that the cell on the r-th row and c-th column was previously visited. Our current position is (r, c), facing direction di, and we want to visit R x C total cells.

As we move through the matrix, our candidate’s next position is (cr, cc). If the candidate is in the bounds of the matrix and unseen, then it becomes our next position; otherwise, our next position is the one after performing a clockwise turn.:def spiralOrder(matrix):
    ans = []
 
    if (len(matrix) == 0):
        return ans
 
    R = len(matrix)
    C = len(matrix[0])
    seen = [[0 for i in range(C)] for j in range(R)]
    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]
    r = 0
    c = 0
    di = 0
 
    # Iterate from 0 to R * C - 1
    for i in range(R * C):
        ans.append(matrix[r])
        seen[r] = True
        cr = r + dr[di]
        cc = c + dc[di]
 
        if (0 <= cr and cr < R and 0 <= cc and cc < C and not(seen[cr][cc])):
            r = cr
            c = cc
        else:
            di = (di + 1) % 4
            r += dr[di]
            c += dc[di]
    return ans
 
 
# Driver code
a = [[1, 2, 3, 4],
     [5, 6, 7, 8],
     [9, 10, 11, 12],
     [13, 14, 15, 16]]
 
for x in spiralOrder(a):
    print(x, end="" "")
print()<|endoftext|>"
818,"<|endoftext|>Reverse the Order of Palindrome Words in a Sentence Using reverse() function (Static input):# Give the sentence/string as static input and store it in a variable.
gvnstrng = 'good bob how are you dod mom'
# Convert the given sentence to a list of words using list()
# and split() functions and store it another variable.
strngwrdslst = list(gvnstrng.split())
# Take an empty list to say palindromicwordslist
# that stores all the palindromic words in the given string
# and initialize it to null/empty using the list() function or [].
palindromicwordslist = []
# Traverse the given list of words using a for loop.
for wrd in strngwrdslst:
        # Check if the word is palindrome or not using the slicing
    # and if conditional statement.
    if(wrd == wrd[::-1]):
        # If it is true then append this word to the palindromicwordslist
        # using the append() function.
        palindromicwordslist.append(wrd)

# Reverse the palindromicwordslist using the reverse() function.
palindromicwordslist.reverse()
# Take a variable say tempo and initialize its value to 0
# (Here it acts as a pointer to palindromicwordslist ).
tempo = 0
# Traverse the list of words of the given sentence using the For loop.
for wrditr in range(len(strngwrdslst)):
  # Check if the word is palindrome or not using the slicing
    # and if conditional statement.
    if(strngwrdslst[wrditr] == strngwrdslst[wrditr][::-1]):
        # If it is true then modify the word with the palindromicwordslist[tempo] word.
        strngwrdslst[wrditr] = palindromicwordslist[tempo]
        tempo = tempo+1
        # Increment the tempo value by 1.


# Convert this list of words of the given sentence
# to the string using the join() function.
finalstrng = ' '.join(strngwrdslst)
print('The given string before reversing the order of paindromic words is = ', gvnstrng)
# Print the final string after reversing the palindromic words.
print('The given string after reversing the order of paindromic words is = ', finalstrng)<|endoftext|>"
819,"<|endoftext|>A no-intersecting ones matrix is one where no two ones exist on the same row or column.

To illustrate:

[
  [1, 0, 0, 0, 0],
  [0, 1, 0, 0, 0],
  [0, 0, 0, 1, 0],
  [0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0]
]
The list below is not a non-intersecting ones matrix:

[
  [1, 0, 0, 0, 0],
  [0, 1, 0, 0, 0],
  [0, 0, 0, 1, 0],
  [0, 1, 0, 0, 0],
  [0, 0, 0, 0, 0]
]

// Column 2 has two 1s.
Write a function that returns True if a 2D matrix is a no-intersecting ones matrix and False otherwise.

Examples
no_intersecting_nes([
  [0, 1],
  [1, 0]
]) ➞ True

no_intersecting_ones([
  [1, 1],
  [0, 0]
]) ➞ False

no_intersecting_ones([
  [0, 0, 0, 1],
  [1, 0, 0, 0],
  [0, 1, 0, 0]
]) ➞ True:def no_intersecting_ones(lst):
  lst.extend(zip(*lst))
  return all(sum(i) < 2 for i in lst)<|endoftext|>"
820,"<|endoftext|>The else Statement
With the else statement we can run a block of code once when the condition no longer is true::i = 1
while i < 6:
  print(i)
  i += 1
else:
  print(""i is no longer less than 6"")<|endoftext|>"
821,"<|endoftext|>Decision Tree is one of the most powerful and popular algorithm. Decision-tree algorithm falls under the category of supervised learning algorithms. It works for both continuous as well as categorical output variables.:# Run this program on your local python
# interpreter, provided you have installed
# the required libraries.

# Importing the required packages
import numpy as np
import pandas as pd
from sklearn.metrics import confusion_matrix
from sklearn.cross_validation import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report

# Function importing Dataset
def importdata():
	balance_data = pd.read_csv(
'https://archive.ics.uci.edu/ml/machine-learning-'+
'databases/balance-scale/balance-scale.data',
	sep= ',', header = None)
	
	# Printing the dataswet shape
	print (""Dataset Length: "", len(balance_data))
	print (""Dataset Shape: "", balance_data.shape)
	
	# Printing the dataset obseravtions
	print (""Dataset: "",balance_data.head())
	return balance_data

# Function to split the dataset
def splitdataset(balance_data):

	# Separating the target variable
	X = balance_data.values[:, 1:5]
	Y = balance_data.values[:, 0]

	# Splitting the dataset into train and test
	X_train, X_test, y_train, y_test = train_test_split(
	X, Y, test_size = 0.3, random_state = 100)
	
	return X, Y, X_train, X_test, y_train, y_test
	
# Function to perform training with giniIndex.
def train_using_gini(X_train, X_test, y_train):

	# Creating the classifier object
	clf_gini = DecisionTreeClassifier(criterion = ""gini"",
			random_state = 100,max_depth=3, min_samples_leaf=5)

	# Performing training
	clf_gini.fit(X_train, y_train)
	return clf_gini
	
# Function to perform training with entropy.
def tarin_using_entropy(X_train, X_test, y_train):

	# Decision tree with entropy
	clf_entropy = DecisionTreeClassifier(
			criterion = ""entropy"", random_state = 100,
			max_depth = 3, min_samples_leaf = 5)

	# Performing training
	clf_entropy.fit(X_train, y_train)
	return clf_entropy


# Function to make predictions
def prediction(X_test, clf_object):

	# Predicton on test with giniIndex
	y_pred = clf_object.predict(X_test)
	print(""Predicted values:"")
	print(y_pred)
	return y_pred
	
# Function to calculate accuracy
def cal_accuracy(y_test, y_pred):
	
	print(""Confusion Matrix: "",
		confusion_matrix(y_test, y_pred))
	
	print (""Accuracy : "",
	accuracy_score(y_test,y_pred)*100)
	
	print(""Report : "",
	classification_report(y_test, y_pred))

# Driver code
def main():
	
	# Building Phase
	data = importdata()
	X, Y, X_train, X_test, y_train, y_test = splitdataset(data)
	clf_gini = train_using_gini(X_train, X_test, y_train)
	clf_entropy = tarin_using_entropy(X_train, X_test, y_train)
	
	# Operational Phase
	print(""Results Using Gini Index:"")
	
	# Prediction using gini
	y_pred_gini = prediction(X_test, clf_gini)
	cal_accuracy(y_test, y_pred_gini)
	
	print(""Results Using Entropy:"")
	# Prediction using entropy
	y_pred_entropy = prediction(X_test, clf_entropy)
	cal_accuracy(y_test, y_pred_entropy)
	
	
# Calling main function
if __name__==""__main__"":
	main()<|endoftext|>"
822,"<|endoftext|>Union of Set of Tuples using or( | ) operator:# Give the set of tuples as static input and store them in Separate Variables.
first = {('hello', 5), ('this', 100)}
second = {('this', 100), ('is', 200)}
third = {('hello', 5), ('btechgeeks', 461), ('python', 234)}

# In Python, we may retrieve the union of a set of tuples
# by using the OR operator (|). In order to acquire the union of two variables,
# use the OR operator directly between them.
# Calculate the union using | operator and store it in a variable.

reslt1 = second | third
reslt2 = first | second
reslt3 = first | second | third
# Print the union of first and second
print(""first Union Second = "", reslt2)
# print the union of second and third
print(""Second Union third = "", reslt1)
# print the union of first second and third.
print(""first Union Second Union third = "", reslt3)<|endoftext|>"
823,"<|endoftext|>We are given an m*n matrix of positive integers and a row number. The task is to find all rows in given matrix which are permutations of given row elements. It is also given that values in every row are distinct.

Examples:  

Input : mat[][] = {{3, 1, 4, 2}, 
                   {1, 6, 9, 3},
                   {1, 2, 3, 4},
                   {4, 3, 2, 1}}
        row = 3    
Output: 0, 2
Rows at indexes 0 and 2 are permutations of
row at index 3. :# Python program to find all
# permutations of a given row

# Function to find all
# permuted rows of a given row r
def permutatedRows(mat, m, n, r):


	# Creating an empty set
	s=set()

	# Count frequencies of
	# elements in given row r
	for j in range(n):
		s.add(mat[r][j])

	# Traverse through all remaining rows
	for i in range(m):

		# we do not need to check
		# for given row r
		if i == r:
			continue

		# initialize hash i.e
		# count frequencies
		# of elements in row i
		for j in range(n):
			if mat[i][j] not in s:

				# to avoid the case when last
				# element does not match
				j = j - 2
				break;
		if j + 1 != n:
			continue
		print(i)
			
	

# Driver program to run the case
m = 4
n = 4
r = 3
mat = [[3, 1, 4, 2],
	[1, 6, 9, 3],
	[1, 2, 3, 4],
	[4, 3, 2, 1]]

permutatedRows(mat, m, n, r)

# This code is contributed
# by Upendra Singh Bartwal.<|endoftext|>"
824,"<|endoftext|>In this article, we will see how to implement graph in python using dictionary data structure in python. 
The keys of the dictionary used are the nodes of our graph and the corresponding values are lists with each nodes, which are connecting by an edge. 
This simple graph has six nodes (a-f) and five arcs: 
 

a -> c
b -> c
b -> e
c -> a
c -> b
c -> d
c -> e
d -> c
e -> c
e -> b
It can be represented by the following Python data structure. This is a dictionary whose keys are the nodes of the graph. For each key, the corresponding value is a list containing the nodes that are connected by a direct arc from this node. 
 

graph = { ""a"" : [""c""],
          ""b"" : [""c"", ""e""],
          ""c"" : [""a"", ""b"", ""d"", ""e""],
          ""d"" : [""c""],
          ""e"" : [""c"", ""b""],
          ""f"" : []
        } :# Python program for
# validation of a graph
 
# import dictionary for graph
from collections import defaultdict
 
# function for adding edge to graph
graph = defaultdict(list)
def addEdge(graph,u,v):
    graph[u].append(v)
 
# definition of function
def generate_edges(graph):
    edges = []
 
    # for each node in graph
    for node in graph:
         
        # for each neighbour node of a single node
        for neighbour in graph[node]:
             
            # if edge exists then append
            edges.append((node, neighbour))
    return edges
 
# declaration of graph as dictionary
addEdge(graph,'a','c')
addEdge(graph,'b','c')
addEdge(graph,'b','e')
addEdge(graph,'c','d')
addEdge(graph,'c','e')
addEdge(graph,'c','a')
addEdge(graph,'c','b')
addEdge(graph,'e','b')
addEdge(graph,'d','c')
addEdge(graph,'e','c')
 
# Driver Function call
# to print generated graph
print(generate_edges(graph))
<|endoftext|>"
825,"<|endoftext|>Are you looking for help to remove all the adjacent duplicate characters in a string? Then, this tutorial can be extremely helpful for you as we have compiled all about how to remove adjacent duplicate characters from a string in Python clearly. Refer to the Sample Programs for removing all adjacent duplicates from a string and the function used for doing so.:# Function to remove adjacent duplicates characters from a string
def remAdj(givenstrng):
  # convert the given string to list using list() function
  charslist = list(givenstrng)
  prevele = None
  p = 0
  # Traverse the given string
  for chars in givenstrng:
  if prevele != chars:
  charslist[p] = chars
  prevele = chars
  p = p + 1
  # join the list which contains characters to string using join function and return it
  return ''.join(charslist[:p])
# Driver code
# Give the string as static input and store it in a variable.
givenstrng = ""bteechhgeeeekkkkssss""
# printing the given string before removing adjacent duplicate characters
print('given string before removing adjacent duplicate characters = ', givenstrng)
# Pass the given string to the remAdj function which accepts
# the given string as the argument
# and returns the modified string with no adjacent duplicates.
modistring = remAdj(givenstrng)
# printing the given string after removing adjacent duplicate characters
print('given string without after adjacent duplicate characters = ', modistring)<|endoftext|>"
826,"<|endoftext|>There is a given array and split it from a specified position, and move the first part of the array add to the end. 
 

Split the array and add the first part to the end



Examples: 
 

Input : arr[] = {12, 10, 5, 6, 52, 36}
            k = 2
Output : arr[] = {5, 6, 52, 36, 12, 10}
Explanation : Split from index 2 and first 
part {12, 10} add to the end .

Input : arr[] = {3, 1, 2}
           k = 1
Output : arr[] = {1, 2, 3}
Explanation : Split from index 1 and first
part add to the end.:# Python3 program to split array and
# move first part to end.

# Function to split array and
# move first part to end
def SplitAndAdd(A, length, rotation):

	# make a temporary array with double
	# the size and each index is initialized to 0
	tmp = [ 0 for i in range(length * 2)]

	# copy array element in to new array twice
	for i in range(length):
		tmp[i] = A[i]
		tmp[i + length] = A[i]

	for i in range(rotation,
				rotation + length, 1):
		A[i - rotation] = tmp[i];
	
# Driver code
arr = [12, 10, 5, 6, 52, 36]
n = len(arr)
position = 2
SplitAndAdd(arr, n, position);
for i in range(n):
	print(arr[i], end = "" "")
print()

# This code is contributed by SOUMYA SEN<|endoftext|>"
827,"<|endoftext|>Syncopation means an emphasis on a weak beat of a bar of music; most commonly, beats 2 and 4 (and all other even-numbered beats if applicable).

You will be given a string representing beats, where hashtags # represent emphasized beats. Create a function that returns if the line of music contains any syncopation, and False otherwise.

Examples

has_syncopation("".#.#.#.#"") ➞ True
# There are Hash signs in the second, fourth, sixth and
# eighth positions of the string.

has_syncopation(""#.#...#."") ➞ False
# There are no Hash signs in the second, fourth, sixth or
# eighth positions of the string.

has_syncopation(""#.#.###."") ➞ True
# There is a Hash sign in the sixth position of the string.
Notes

All other unemphasized beats will be represented as a dot.:def has_syncopation(s):
  return '#' in s[1::2]<|endoftext|>"
828,"<|endoftext|>Imagine a school that kids attend for 6 years. In each year, there are five groups started, marked with the letters a, b, c, d, e. For the first year, the groups are 1a, 1b, 1c, 1d, 1e and for the last year, the groups are 6a, 6b, 6c, 6d, 6e.
Write a function that returns the groups in the school by year (as a string), separated with a comma and a space in the form of ""1a, 1b, 1c, 1d, 1e, 2a, 2b (....) 5d, 5e, 6a, 6b, 6c, 6d, 6e"".
Examples
print_all_groups() ➞ ""1a, 1b, 1c, 1d, 1e, 2a, 2b, 2c, 2d, 2e, 3a, 3b, 3c, 3d, 3e, 4a, 4b, 4c, 4d, 4e, 5a, 5b, 5c, 5d, 5e, 6a, 6b, 6c, 6d, 6e ""
Notes
Use nested ""for"" loops to achieve this, as well as the array of [""a"", ""b"", ""c"", ""d"", ""e""] groups.:def print_all_groups():
  return ', '.join(i+j for i in '123456' for j in 'abcde')<|endoftext|>"
829,"<|endoftext|>Given a text txt[0..n-1] and a pattern pat[0..m-1], write a function search(char pat[], char txt[]) that prints all occurrences of pat[] in txt[]. You may assume that n > m. 

Like the Naive Algorithm, Rabin-Karp algorithm also slides the pattern one by one. But unlike the Naive algorithm, Rabin Karp algorithm matches the hash value of the pattern with the hash value of current substring of text, and if the hash values match then only it starts matching individual characters. So Rabin Karp algorithm needs to calculate hash values for following strings.
1) Pattern itself. 
2) All the substrings of the text of length m. 

Since we need to efficiently calculate hash values for all the substrings of size m of text, we must have a hash function which has the following property. 
Hash at the next shift must be efficiently computable from the current hash value and next character in text or we can say hash(txt[s+1 .. s+m]) must be efficiently computable from hash(txt[s .. s+m-1]) and txt[s+m] i.e., hash(txt[s+1 .. s+m])= rehash(txt[s+m], hash(txt[s .. s+m-1])) and rehash must be O(1) operation.
The hash function suggested by Rabin and Karp calculates an integer value. The integer value for a string is the numeric value of a string. :# Following program is the python implementation of
# Rabin Karp Algorithm given in CLRS book
 
# d is the number of characters in the input alphabet
d = 256
 
# pat  -> pattern
# txt  -> text
# q    -> A prime number
 
def search(pat, txt, q):
    M = len(pat)
    N = len(txt)
    i = 0
    j = 0
    p = 0    # hash value for pattern
    t = 0    # hash value for txt
    h = 1
 
    # The value of h would be ""pow(d, M-1)%q""
    for i in range(M-1):
        h = (h*d)%q
 
    # Calculate the hash value of pattern and first window
    # of text
    for i in range(M):
        p = (d*p + ord(pat[i]))%q
        t = (d*t + ord(txt[i]))%q
 
    # Slide the pattern over text one by one
    for i in range(N-M+1):
        # Check the hash values of current window of text and
        # pattern if the hash values match then only check
        # for characters one by one
        if p==t:
            # Check for characters one by one
            for j in range(M):
                if txt[i+j] != pat[j]:
                    break
                else: j+=1
 
            # if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]
            if j==M:
                print (""Pattern found at index "" + str(i))
 
        # Calculate hash value for next window of text: Remove
        # leading digit, add trailing digit
        if i < N-M:
            t = (d*(t-ord(txt[i])*h) + ord(txt[i+M]))%q
 
            # We might get negative values of t, converting it to
            # positive
            if t < 0:
                t = t+q
 
# Driver Code
txt = ""GEEKS FOR GEEKS""
pat = ""GEEK""
 
# A prime number
q = 101
 
# Function Call
search(pat,txt,q)
 
# This code is contributed by Bhavya Jain<|endoftext|>"
830,"<|endoftext|>Given a value V, if we want to make a change for V cents, and we have an infinite supply of each of C = { C1, C2, .., Cm} valued coins, what is the minimum number of coins to make the change? If it’s not possible to make a change, print -1.:# A Dynamic Programming based Python3 program to
# find minimum of coins to make a given change V
import sys
 
# m is size of coins array (number of
# different coins)
def minCoins(coins, m, V):
     
    # table[i] will be storing the minimum
    # number of coins required for i value.
    # So table[V] will have result
    table = [0 for i in range(V + 1)]
 
    # Base case (If given value V is 0)
    table[0] = 0
 
    # Initialize all table values as Infinite
    for i in range(1, V + 1):
        table[i] = sys.maxsize
 
    # Compute minimum coins required
    # for all values from 1 to V
    for i in range(1, V + 1):
         
        # Go through all coins smaller than i
        for j in range(m):
            if (coins[j] <= i):
                sub_res = table[i - coins[j]]
                if (sub_res != sys.maxsize and
                    sub_res + 1 < table[i]):
                    table[i] = sub_res + 1
     
    if table[V] == sys.maxsize:
        return -1
       
    return table[V]
 
# Driver Code
if __name__ == ""__main__"":
 
    coins = [9, 6, 5, 1]
    m = len(coins)
    V = 11
    print(""Minimum coins required is "",
                 minCoins(coins, m, V))
 
# This code is contributed by ita_c<|endoftext|>"
831,"<|endoftext|>There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.

Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard.

 :class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        
        mylist=text.split()
        count=len(mylist)
        for word in mylist:
            for ch in word:
                if ch in set(brokenLetters):
                    count-=1
                    break
        
        return count
        <|endoftext|>"
832,"<|endoftext|>The program creates a stack and allows the user to perform push and pop operations on it.:class Stack:
    def __init__(self):
        self.items = []
 
    def is_empty(self):
        return self.items == []
 
    def push(self, data):
        self.items.append(data)
 
    def pop(self):
        return self.items.pop()
 
 
s = Stack()
while True:
    print('push <value>')
    print('pop')
    print('quit')
    do = input('What would you like to do? ').split()
 
    operation = do[0].strip().lower()
    if operation == 'push':
        s.push(int(do[1]))
    elif operation == 'pop':
        if s.is_empty():
            print('Stack is empty.')
        else:
            print('Popped value: ', s.pop())
    elif operation == 'quit':
        break<|endoftext|>"
833,"<|endoftext|>Given a binary tree, where every node value is a Digit from 1-9 .Find the sum of all the numbers which are formed from root to leaf paths.
For example consider the following Binary Tree. 
 

           6
       /      \
     3          5
   /   \          \
  2     5          4  
      /   \
     7     4
  There are 4 leaves, hence 4 root to leaf paths:
   Path                    Number
  6->3->2                   632
  6->3->5->7               6357
  6->3->5->4               6354
  6->5>4                    654   
Answer = 632 + 6357 + 6354 + 654 = 13997 :# Python program to find sum of all paths from root to leaves

# A Binary tree node
class Node:

	# Constructor to create a new node
	def __init__(self, data):
		self.data = data
		self.left = None
		self.right = None

# Returns sums of all root to leaf paths. The first parameter is root
# of current subtree, the second paramete""r is value of the number
# formed by nodes from root to this node
def treePathsSumUtil(root, val):

	# Base Case
	if root is None:
		return 0

	# Update val
	val = (val*10 + root.data)

	# If current node is leaf, return the current value of val
	if root.left is None and root.right is None:
		return val

	# Recur sum of values for left and right subtree
	return (treePathsSumUtil(root.left, val) +
			treePathsSumUtil(root.right, val))

# A wrapper function over treePathSumUtil()
def treePathsSum(root):
	
	# Pass the initial value as 0 as ther is nothing above root
	return treePathsSumUtil(root, 0)

# Driver function to test above function
root = Node(6)
root.left = Node(3)
root.right = Node(5)
root.left.left = Node(2)
root.left.right = Node(5)
root.right.right = Node(4)
root.left.right.left = Node(7)
root.left.right.right = Node(4)
print (""Sum of all paths is"", treePathsSum(root))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
<|endoftext|>"
834,"<|endoftext|>Given an array of n positive integers. We are required to write a program to print the minimum product of k integers of the given array.
Examples: 
 

Input : 198 76 544 123 154 675
         k = 2
Output : 9348
We get minimum product after multiplying
76 and 123.

Input : 11 8 5 7 5 100
        k = 4
Output : 1400:# Python3 program to find minimum
# product of k elements in an array
import math
import heapq

def minProduct(arr, n, k):

	heapq.heapify(arr)
	count = 0
	ans = 1

	# One by one extract
	# items from min heap
	while ( arr ) and count < k:
		x = heapq.heappop(arr)
		ans = ans * x
		count = count + 1
	
	return ans;

# Driver method
arr = [198, 76, 544, 123, 154, 675]
k = 2
n = len(arr)
print (""Minimum product is"",
	minProduct(arr, n, k))<|endoftext|>"
835,"<|endoftext|>You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

 

Example 1:

Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
Example 2:

Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step:def climbStairs2(self, n):
    if n == 1:
        return 1
    res = [0 for i in xrange(n)]
    res[0], res[1] = 1, 2
    for i in xrange(2, n):
        res[i] = res[i-1] + res[i-2]
    return res[-1]<|endoftext|>"
836,"<|endoftext|>Given a string and the task is to find the Lexicographic Rank of a given string in python.

Examples:

Example1:

Input:

Given String = ""btechgeeks""
Output:

The given String's { btechgeeks } Lexicographic Rank =  328009
Example2:

Input:

Given String = ""hello""
Output:

The given String's { hello } Lexicographic Rank =  25:# Import math module using the import keyword.
import math
# Give the string as static input and store it in a variable.
gven_str = ""btechgeeks""
# Take a variable to say lexicogrpc_rank and initialize its value to 1.
lexicogrpc_rank = 1
# Calculate the length of the given string using the len() function and decrease it by 1.
# Store it in another variable say str_lengt.
str_lengt = len(gven_str)-1
# Loop from 0 to the above length using the for loop.
for itr in range(0, str_lengt):
  # Inside the loop, take a variable to say cnt and initialize its value to 0.
  cnt = 0
  # Loop from the itr+1 to the above str_lengt (where itr is the iterator value of the parent
  # for loop) using the for loop.
  for k in range(itr+1, str_lengt+1):
  # Inside the loop, check if the character present at the iterator value of the parent for
  # loop is greater than the character present at the iterator value of the inner for
  # loop using the if conditional statement.
  if gven_str[itr] > gven_str[k]:
  # If the statement is true, then increment the value of the above-initialized cnt by 1.
  cnt += 1
  # Calculate the factorial of (str_lengt - itr) using the math.factorial() function and
  # store it in another variable. (where itr is the iterator value of the parent for loop)
  f = math.factorial(str_lengt-itr)
  # Multiply the above result with cnt and add the result to the lexicogrpc_rank.
  # Store it in the same variable lexicogrpc_rank.
  lexicogrpc_rank += cnt*f
# Print the lexicogrpc_rank to get the Lexicographic Rank of a given string.
print(""The given String's {"", gven_str,
  ""} Lexicographic Rank = "", lexicogrpc_rank)<|endoftext|>"
837,"<|endoftext|>Three arrays of same size are given. Find a triplet such that maximum – minimum in that triplet is minimum of all the triplets. A triplet should be selected in a way such that it should have one number from each of the three given arrays. 
If there are 2 or more smallest difference triplets, then the one with the smallest sum of its elements should be displayed.:# Python3 implementation of smallest
# difference triplet

# Function to find maximum number
def maximum(a, b, c):
	return max(max(a, b), c)

# Function to find minimum number
def minimum(a, b, c):
	return min(min(a, b), c)

# Finds and prints the smallest
# Difference Triplet
def smallestDifferenceTriplet(arr1, arr2, arr3, n):

	# sorting all the three arrays
	arr1.sort()
	arr2.sort()
	arr3.sort()

	# To store resultant three numbers
	res_min = 0; res_max = 0; res_mid = 0

	# pointers to arr1, arr2,
	# arr3 respectively
	i = 0; j = 0; k = 0

	# Loop until one array reaches to its end
	# Find the smallest difference.
	diff = 2147483647
	while (i < n and j < n and k < n):
	
		sum = arr1[i] + arr2[j] + arr3[k]

		# maximum number
		max = maximum(arr1[i], arr2[j], arr3[k])

		# Find minimum and increment its index.
		min = minimum(arr1[i], arr2[j], arr3[k])
		if (min == arr1[i]):
			i += 1
		else if (min == arr2[j]):
			j += 1
		else:
			k += 1

		# Comparing new difference with the
		# previous one and updating accordingly
		if (diff > (max - min)):
		
			diff = max - min
			res_max = max
			res_mid = sum - (max + min)
			res_min = min
		
	# Print result
	print(res_max, "","", res_mid, "","", res_min)

# Driver code
arr1 = [5, 2, 8]
arr2 = [10, 7, 12]
arr3 = [9, 14, 6]
n = len(arr1)
smallestDifferenceTriplet(arr1, arr2, arr3, n)

# This code is contributed by Anant Agarwal.<|endoftext|>"
838,"<|endoftext|>Given a list, the task is to find the sum of the elements which are having an odd frequency in the given array/List.

Examples:

Example1:

Input:

Given List =  [10, 4, 2, 10, 1, 2, 3, 4, 5, 6, 6]
Output:

The sum of all odd frequency elements in the given list [10, 4, 2, 10, 1, 2, 3, 4, 5, 6, 6] is:
9:# Take a dictionary and initialize it to empty
# using the {} or dict() say freqncyDictionary.
freqncyDictionary = {}
# Give the list as static input and store it in a variable.
gvnlst = [10, 4, 2, 10, 1, 2, 3, 4, 5, 6, 6]
# Loop in the given list using the For loop.
for i in gvnlst:
        # Inside the For loop,
    # Check if the list element is present in the dictionary
    # or not using the if conditional statement and 'in' keyword.
    if i in freqncyDictionary.keys():
                # If it is true then increment the count of the list element
        # in the dictionary by 1.
        freqncyDictionary[i] = freqncyDictionary[i]+1
    # Else initialize the dictionary with the list element as key and value as 1.
    else:
        freqncyDictionary[i] = 1

# Take a variable say oddfreqncycnt and initialize its value to 0.
oddfreqncycnt = 0
# Loop in the freqncyDictionary using the For loop.
for elemnt in freqncyDictionary:
    # Check if the key in the freqncyDictionary having value odd
    # using the if conditional statement.
    if(freqncyDictionary[elemnt] % 2 != 0):
                # If it is true then increment the oddfreqncycnt by the key
        # and store it in the same variable.
        oddfreqncycnt += elemnt
# After the end of For loop then print the oddfreqncycnt value.
print('The sum of all odd frequency elements in the given list', gvnlst, 'is:')
print(oddfreqncycnt)<|endoftext|>"
839,"<|endoftext|>Burrows-Wheeler transform (BWT) is an algorithm which is used in data compression. Given a string text, BWT of text is a modified version of the string with same length as text. It can then be used to efficiently find substrings of text (which won't be covered here). We will just find the BWT of text.
Build Burrows-Wheeler-Matrix (BWM) containing all rotations of text.
Sort BWM lexicographically ($ < a < b < ... < z).
BWT is the last coloumn of BWM and gets returned.
# Example with text = ""banana$""

# BWM (all rotations of text):
banana$
anana$b
nana$ba
ana$ban
na$bana
a$banan
$banana

# BWM sorted lexicographically:
$banana
a$banan
ana$ban
anana$b
banana$
na$bana
nana$ba

# BWT (last coloumn of BWM):
annb$aa
Examples
bw_transform(""banana$"") ➞ ""annb$aa""

bw_transform(""mississippi$"") ➞ ""ipssm$pissii""

bw_transform(""acccgtttgtttcaatagatccatcaa$"") ➞ ""aacc$tacgttctaccatcaatatttgg""
Notes
Consider $ as the terminator character at the end of every input text.:def bw_transform(txt):
    rotations = sorted(txt[i:] + txt[:i] for i in range(len(txt)))
    return ''.join(i[-1] for i in rotations)<|endoftext|>"
840,"<|endoftext|>Write a Python program to print triangle of same alphabets pattern in each row using for loop.

:rows = int(input(""Enter Triangle of Same Row Alphabets Rows = ""))

print(""====The Triangle of Same Alphabets in each Row Pattern===="")
alphabet = 65

for i in range(rows):
    for j in range(rows - 1, i, -1):
        print(end = ' ')
    for k in range(i + 1):
        print('%c' %(alphabet + i), end = ' ')
    print()<|endoftext|>"
841,"<|endoftext|>Don’t miss the chance of Java programs examples with output pdf free download as it is very essential for all beginners to experienced programmers for cracking the interviews.
 
 Given the number n, the task is to print nth Kynea Number in Python.
 
 Kynea number is a mathematical integer of the type
 
 nth = 4^n + 2^(n + 1) – 1, where n is a positive integer.
 
 Which can be also written as
 
  
 
 The initial Kynea numbers are
 
 7, 23, 79, 287, 1087, 4223, 16639,…………..
 
 Examples:
 
 Example1:
 
 Input:
 
 Given nth number =6
 Output:
 
 The nth Kynea number = 4223
 Example2:
 
 Input:
 
 Given nth number =8
 Output:
 
 The nth Kynea number = 66047:# Give the number n as static input and store it in a variable.
 nthNum = 6
 # Calculate the power of 2^n using the ** operator
 # and store it in another variable say partialres.
 partialres = 2**nthNum
 # Calculate the value of (partialres+1)^2-2 
 # using ** and arithmetic operators.
 nthresult = (partialres+1)**2-2
 # Print the result.
 print('The nth Kynea number =', nthresult)<|endoftext|>"
842,"<|endoftext|>There are n cars traveling at different speeds in the same direction along a one-lane road. You are given an array cars of length n, where cars[i] = [positioni, speedi] represents:

positioni is the distance between the ith car and the beginning of the road in meters. It is guaranteed that positioni < positioni+1.
speedi is the initial speed of the ith car in meters per second.

For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the slowest car in the fleet.
Return an array answer, where answer[i] is the time, in seconds, at which the ith car collides with the next car, or -1 if the car does not collide with the next car. Answers within 10-5 of the actual answers are accepted.
 
Example 1:

Input: cars = [[1,2],[2,1],[4,3],[7,2]]
Output: [1.00000,-1.00000,3.00000,-1.00000]
Explanation: After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.

Example 2:

Input: cars = [[3,4],[5,4],[6,3],[9,1]]
Output: [2.00000,1.00000,1.50000,-1.00000]

 
Constraints:

1 <= cars.length <= 105
1 <= positioni, speedi <= 106
positioni < positioni+1:def getCollisionTimes(self, A):
  stack = []
  n = len(A)
  res = [-1] * n
  for i in range(n-1, -1, -1):
  p, s = A[i]
  while stack and (s <= A[stack[-1]][1] or (A[stack[-1]][0] - p) / (s - A[stack[-1]][1]) >= res[stack[-1]] > 0):
  stack.pop()
  if stack:
  res[i] = (A[stack[-1]][0] - p) / (s - A[stack[-1]][1])
  stack.append(i)
  return res<|endoftext|>"
843,"<|endoftext|>You are given a list of strings of the same length words and a string target.
Your task is to form target using the given words under the following rules:

target should be formed from left to right.
To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].
Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.
Repeat the process until you form the string target.

Notice that you can use multiple characters from the same string in words provided the conditions above are met.
Return the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.
 
Example 1:

Input: words = [""acca"",""bbbb"",""caca""], target = ""aba""
Output: 6
Explanation: There are 6 ways to form target.
""aba"" -> index 0 (""acca""), index 1 (""bbbb""), index 3 (""caca"")
""aba"" -> index 0 (""acca""), index 2 (""bbbb""), index 3 (""caca"")
""aba"" -> index 0 (""acca""), index 1 (""bbbb""), index 3 (""acca"")
""aba"" -> index 0 (""acca""), index 2 (""bbbb""), index 3 (""acca"")
""aba"" -> index 1 (""caca""), index 2 (""bbbb""), index 3 (""acca"")
""aba"" -> index 1 (""caca""), index 2 (""bbbb""), index 3 (""caca"")

Example 2:

Input: words = [""abba"",""baab""], target = ""bab""
Output: 4
Explanation: There are 4 ways to form target.
""bab"" -> index 0 (""baab""), index 1 (""baab""), index 2 (""abba"")
""bab"" -> index 0 (""baab""), index 1 (""baab""), index 3 (""baab"")
""bab"" -> index 0 (""baab""), index 2 (""baab""), index 3 (""baab"")
""bab"" -> index 1 (""abba""), index 2 (""baab""), index 3 (""baab"")

 
Constraints:

1 <= words.length <= 1000
1 <= words[i].length <= 1000
All strings in words have the same length.
1 <= target.length <= 1000
words[i] and target contain only lowercase English letters.:class Solution:
  def numWays(self, words: List[str], target: str) -> int:
  MOD = 10 ** 9 + 7
  m, n = len(words[0]), len(target)
  charAtIndexCnt = [[0] * m for _ in range(128)]
  for word in words:
  for i, c in enumerate(word):
  charAtIndexCnt[ord(c)][i] += 1 # Count the number of character `c` at index `i` of all words

  @lru_cache(None)
  def dp(k, i):
  if i == n:  # Formed a valid target
  return 1
  if k == m:  # Reached to length of words[x] but don't found any result
  return 0
  c = target[i]
  ans = dp(k + 1, i)  # Skip k_th index of words
  if charAtIndexCnt[ord(c)][k] > 0: # Take k_th index of words if found character `c` at index k_th
  ans += dp(k + 1, i + 1) * charAtIndexCnt[ord(c)][k]
  ans %= MOD
  return ans

  return dp(0, 0)<|endoftext|>"
844,"<|endoftext|>This robot roams around a 2D grid. It starts at (0, 0) facing North. After each time it moves, the robot rotates 90 degrees clockwise. Given the amount the robot has moved each time, you have to calculate the robot's final position.
To illustrate, if the robot is given the movements 20, 30, 10, 40 then it will move:
20 steps North, now at (0, 20)
30 steps East, now at (30, 20)
10 steps South. now at (30, 10)
40 steps West, now at (-10, 10)
...and will end up at coordinates (-10, 10).
Examples
track_robot(20, 30, 10, 40) ➞ [-10, 10]

track_robot() ➞ [0, 0]
# No movement means the robot stays at (0, 0).

track_robot(-10, 20, 10) ➞ [20, -20]
# The amount to move can be negative.
Notes
Each movement is an integer (whole number).:def track_robot(*steps):
  ver = sum(steps[::4]) - sum(steps[2::4])
  hor = sum(steps[1::4]) - sum(steps[3::4])
  return [hor,ver]<|endoftext|>"
845,"<|endoftext|>Check If List Item Exists
To determine if a specified item is present in a list use the in keyword::thislist = [""apple"", ""banana"", ""cherry""]
if ""apple"" in thislist:
  print(""Yes, 'apple' is in the fruits list"")<|endoftext|>"
846,"<|endoftext|>Given a skewed tree (Every node has at most one child) with N nodes and K colors. You have to assign a color from 1 to K to each node such that parent and child has different colors. Find the maximum number of ways of coloring the nodes.


 :# Python3 program to count 
# number of ways to color
# a N node skewed tree with
# k colors such that parent
# and children have different
# colors.
 
# fast_way is recursive
# method to calculate power
def fastPow(N, K):
    if (K == 0):
        return 1;
     
    temp = fastPow(N, int(K / 2));
    if (K % 2 == 0):
        return temp * temp;
    else:
        return N * temp * temp;
 
def countWays(N, K):
    return K * fastPow(K - 1, N - 1);
 
# Driver Code
N = 3;
K = 3;
print(countWays(N, K));
 
# This code is contributed by mits
<|endoftext|>"
847,"<|endoftext|>The Stable Marriage Problem states that given N men and N women, where each person has ranked all members of the opposite sex in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. If there are no such people, all the marriages are “stable”:# Python3 program for stable marriage problem
 
# Number of Men or Women
N = 4
 
# This function returns true if
# woman 'w' prefers man 'm1' over man 'm'
def wPrefersM1OverM(prefer, w, m, m1):
     
    # Check if w prefers m over her
    # current engagement m1
    for i in range(N):
         
        # If m1 comes before m in list of w,
        # then w prefers her current engagement,
        # don't do anything
        if (prefer[w][i] == m1):
            return True
 
        # If m comes before m1 in w's list,
        # then free her current engagement
        # and engage her with m
        if (prefer[w][i] == m):
            return False
 
# Prints stable matching for N boys and N girls.
# Boys are numbered as 0 to N-1.
# Girls are numbered as N to 2N-1.
def stableMarriage(prefer):
     
    # Stores partner of women. This is our output
    # array that stores passing information.
    # The value of wPartner[i] indicates the partner
    # assigned to woman N+i. Note that the woman numbers
    # between N and 2*N-1. The value -1 indicates
    # that (N+i)'th woman is free
    wPartner = [-1 for i in range(N)]
 
    # An array to store availability of men.
    # If mFree[i] is false, then man 'i' is free,
    # otherwise engaged.
    mFree = [False for i in range(N)]
 
    freeCount = N
 
    # While there are free men
    while (freeCount > 0):
         
        # Pick the first free man (we could pick any)
        m = 0
        while (m < N):
            if (mFree[m] == False):
                break
            m += 1
 
        # One by one go to all women according to
        # m's preferences. Here m is the picked free man
        i = 0
        while i < N and mFree[m] == False:
            w = prefer[m][i]
 
            # The woman of preference is free,
            # w and m become partners (Note that
            # the partnership maybe changed later).
            # So we can say they are engaged not married
            if (wPartner[w - N] == -1):
                wPartner[w - N] = m
                mFree[m] = True
                freeCount -= 1
 
            else:
                 
                # If w is not free
                # Find current engagement of w
                m1 = wPartner[w - N]
 
                # If w prefers m over her current engagement m1,
                # then break the engagement between w and m1 and
                # engage m with w.
                if (wPrefersM1OverM(prefer, w, m, m1) == False):
                    wPartner[w - N] = m
                    mFree[m] = True
                    mFree[m1] = False
            i += 1
 
            # End of Else
        # End of the for loop that goes
        # to all women in m's list
    # End of main while loop
 
    # Print solution
    print(""Woman "", "" Man"")
    for i in range(N):
        print(i + N, ""\t"", wPartner[i])
 
# Driver Code
prefer = [[7, 5, 6, 4], [5, 4, 6, 7],
          [4, 5, 6, 7], [4, 5, 6, 7],
          [0, 1, 2, 3], [0, 1, 2, 3],
          [0, 1, 2, 3], [0, 1, 2, 3]]
 
stableMarriage(prefer)
 
# This code is contributed by Mohit Kumar
<|endoftext|>"
848,"<|endoftext|>You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.

Return all lonely numbers in nums. You may return the answer in any order.

 :def findLonely(self, nums: List[int]) -> List[int]:
        
        d = {}
        for n in nums:
            if n not in d:
                d[n]=1
            else:
                d[n]+=1
        
        res = []
        for k,v in d.items():
            if k-1 in d or k+1 in d:
                continue
                
            if v>1:
                continue
            
            res.append(k)
                   
        return res<|endoftext|>"
849,"<|endoftext|>There are n cities and there are roads in between some of the cities. Somehow all the roads are damaged simultaneously. We have to repair the roads to connect the cities again. There is a fixed cost to repair a particular road. Find out the minimum cost to connect all the cities by repairing roads. Input is in matrix(city) form, if city[i][j] = 0 then there is not any road between city i and city j, if city[i][j] = a > 0 then the cost to rebuild the path between city i and city j is a. Print out the minimum cost to connect all the cities. 
It is sure that all the cities were connected before the roads were damaged.:# Python3 code to find out minimum cost
# path to connect all the cities
 
# Function to find out minimum valued
# node among the nodes which are not
# yet included in MST
def minnode(n, keyval, mstset):
    mini = 999999999999
    mini_index = None
     
    # Loop through all the values of
    # the nodes which are not yet
    # included in MST and find the
    # minimum valued one.
    for i in range(n):
        if (mstset[i] == False and
            keyval[i] < mini):
            mini = keyval[i]
            mini_index = i
    return mini_index
 
# Function to find out the MST and
# the cost of the MST.
def findcost(n, city):
 
    # Array to store the parent
    # node of a particular node.
    parent = [None] * n
     
    # Array to store key value
    # of each node.
    keyval = [None] * n
     
    # Boolean Array to hold bool
    # values whether a node is
    # included in MST or not.
    mstset = [None] * n
     
    # Set all the key values to infinite and
    # none of the nodes is included in MST.
    for i in range(n):
        keyval[i] = 9999999999999
        mstset[i] = False
     
    # Start to find the MST from node 0.
    # Parent of node 0 is none so set -1.
    # key value or minimum cost to reach
    # 0th node from 0th node is 0.
    parent[0] = -1
    keyval[0] = 0
     
    # Find the rest n-1 nodes of MST.
    for i in range(n - 1):
     
        # First find out the minimum node
        # among the nodes which are not yet
        # included in MST.
        u = minnode(n, keyval, mstset)
     
        # Now the uth node is included in MST.
        mstset[u] = True
     
        # Update the values of neighbor
        # nodes of u which are not yet
        # included in MST.
        for v in range(n):
            if (city[u][v] and mstset[v] == False and
                city[u][v] < keyval[v]):
                keyval[v] = city[u][v]
                parent[v] = u
     
    # Find out the cost by adding
    # the edge values of MST.
    cost = 0
    for i in range(1, n):
        cost += city[parent[i]][i]
    print(cost)
 
# Driver Code
if __name__ == '__main__':
 
    # Input 1
    n1 = 5
    city1 = [[0, 1, 2, 3, 4],
             [1, 0, 5, 0, 7],
             [2, 5, 0, 6, 0],
             [3, 0, 6, 0, 0],
             [4, 7, 0, 0, 0]]
    findcost(n1, city1)
     
    # Input 2
    n2 = 6
    city2 = [[0, 1, 1, 100, 0, 0],
             [1, 0, 1, 0, 0, 0],
             [1, 1, 0, 0, 0, 0],
             [100, 0, 0, 0, 2, 2],
             [0, 0, 0, 2, 0, 2],
             [0, 0, 0, 2, 2, 0]]
    findcost(n2, city2)
 
# This code is contributed by PranchalK
<|endoftext|>"
850,"<|endoftext|>Given a string s and an array of strings words, determine whether s is a prefix string of words.

A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length.

Return true if s is a prefix string of words, or false otherwise.:def isPrefixString(self, s, words):
        tester = []
        for w in words :
                tester.append(w)
                if """".join(tester) == s :
                        return True
        return False<|endoftext|>"
851,"<|endoftext|>You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.
It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.
 
Example 1:

Input: paths = [[""London"",""New York""],[""New York"",""Lima""],[""Lima"",""Sao Paulo""]]
Output: ""Sao Paulo"" 
Explanation: Starting at ""London"" city you will reach ""Sao Paulo"" city which is the destination city. Your trip consist of: ""London"" -> ""New York"" -> ""Lima"" -> ""Sao Paulo"".

Example 2:

Input: paths = [[""B"",""C""],[""D"",""B""],[""C"",""A""]]
Output: ""A""
Explanation: All possible trips are: 
""D"" -> ""B"" -> ""C"" -> ""A"". 
""B"" -> ""C"" -> ""A"". 
""C"" -> ""A"". 
""A"". 
Clearly the destination city is ""A"".

Example 3:

Input: paths = [[""A"",""Z""]]
Output: ""Z""

 
Constraints:

1 <= paths.length <= 100
paths[i].length == 2
1 <= cityAi.length, cityBi.length <= 10
cityAi != cityBi
All strings consist of lowercase and uppercase English letters and the space character.:class Solution:
  def destCity(self, paths: List[List[str]]) -> str:
  A, B = map(set, zip(*paths))
  return (B - A).pop()<|endoftext|>"
852,"<|endoftext|>You are given a 0-indexed array of strings words. Each string consists of lowercase English letters only. No letter occurs more than once in any string of words.

Two strings s1 and s2 are said to be connected if the set of letters of s2 can be obtained from the set of letters of s1 by any one of the following operations:

Adding exactly one letter to the set of the letters of s1.
Deleting exactly one letter from the set of the letters of s1.
Replacing exactly one letter from the set of the letters of s1 with any letter, including itself.
The array words can be divided into one or more non-intersecting groups. A string belongs to a group if any one of the following is true:

It is connected to at least one other string of the group.
It is the only string present in the group.
Note that the strings in words should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique.

Return an array ans of size 2 where:

ans[0] is the maximum number of groups words can be divided into, and
ans[1] is the size of the largest group.
 :class UnionFind: 
    def __init__(self, n): 
        self.parent = list(range(n))
        self.rank = [1] * n 
        
    def find(self, p): 
        if p != self.parent[p]: 
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]
    
    def union(self, p, q): 
        prt, qrt = self.find(p), self.find(q)
        if prt == qrt: return False 
        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt
        self.parent[prt] = self.parent[qrt]
        self.rank[qrt] += self.rank[prt]
        return True 


class Solution:
    def groupStrings(self, words: List[str]) -> List[int]:
        n = len(words)
        uf = UnionFind(n)
        seen = {}
        for i, word in enumerate(words): 
            m = reduce(or_, (1<<ord(ch)-97 for ch in word))
            if m in seen: uf.union(i, seen[m])
            for k in range(26): 
                if m ^ 1<<k in seen: uf.union(i, seen[m ^ 1<<k])
                if m & 1<<k: 
                    mm = m ^ 1<<k ^ 1<<26
                    if mm in seen: uf.union(i, seen[mm])
                    seen[mm] = i
            seen[m] = i 
        freq = Counter(uf.find(i) for i in range(n))
        return [len(freq), max(freq.values())]<|endoftext|>"
853,"<|endoftext|>Write a function rotate(arr[], d, n) that rotates arr[] of size n by d elements. 
Example : 

Input :  arr[] = [1, 2, 3, 4, 5, 6, 7]
         d = 2
Output : arr[] = [3, 4, 5, 6, 7, 1, 2] :# Python program for reversal algorithm of array rotation

# Function to reverse arr[] from index start to end


def reverseArray(arr, start, end):
	while (start < end):
		temp = arr[start]
		arr[start] = arr[end]
		arr[end] = temp
		start += 1
		end = end-1

# Function to left rotate arr[] of size n by d


def leftRotate(arr, d):

	if d == 0:
		return
	n = len(arr)
	# in case the rotating factor is
	# greater than array length
	d = d % n
	reverseArray(arr, 0, d-1)
	reverseArray(arr, d, n-1)
	reverseArray(arr, 0, n-1)

# Function to print an array


def printArray(arr):
	for i in range(0, len(arr)):
		print (arr[i],end=' ')


# Driver function to test above functions
arr = [1, 2, 3, 4, 5, 6, 7]
n = len(arr)
d = 2

leftRotate(arr, d) # Rotate array by 2
printArray(arr)

# This code is contributed by Devesh Agrawal<|endoftext|>"
854,"<|endoftext|>Strong Number Program in Python | A strong number is a special number in which where the sum of all digit factorial is equal to the sum itself. For example, consider 145 = 1! + 4! + 5! = 145, Sum of digit factorial in the sense 1! added to 4! again added to 5! is 145, hence 145 is strong number. Now let us see the Python program for strong numbers.:number = int(input(""Enter number: "")) s = 0 temp = number while(temp > 0): fact = 1 rem = temp % 10 for i in range(1, rem + 1): fact = fact * i print(""Factorial of %d = %d "" %(rem, fact)) s = s +fact temp = temp // 10 print(""Sum of factorials of the number %d = %d "" %(number,s)) if(s == number): print(""Strong Number"") else: print(""Not a strong number"")<|endoftext|>"
855,"<|endoftext|>In the previous article, we have discussed Python Program to Select a Random Element from a Tuple
 Strong number:
 A Strong number is a special number in which the total of all digit factorials equals the number itself.
 Ex: 145 the sum of factorial of digits = 1 ! + 4 ! +5 ! = 1 + 24 +125
 
 To determine whether a given number is strong or not. We take each digit from the supplied number and calculate its factorial, we will do this for each digit of the number.
 We do the sum of factorials once we have the factorial of all digits. If the total equals the supplied number, the given number is strong; otherwise, it is not.
 Given a number, the task is to check whether the given number is strong number or not.
 Examples:
 Example 1:
 Input:
 Given lower limit range = 1
 
 Given upper limit range= 200
 Output:
 The Strong Numbers in a given range 1 and 200 are :
 
 1 2 145
 Example 2:
 Input:
 Given lower limit range = 100
 
 Given upper limit range= 60000
 Output:
 The Strong Numbers in a given range 100 and 60000 are :
 
 145 40585
 Program to Generate Strong Numbers in an Interval
 Below are the ways to generate Strong Numbers in a given interval.
 
 Using While loop and factorial() function (Static input)
 Using While loop and factorial() function (User input)
 
 Method #1: Using While loop and factorial() function (Static input)
 Approach:
 
 Import math function using import keyword.
 Give the lower limit range as static input and store it in a variable.
 Give the upper limit range as static input and store it in another variable.
 Loop from lower limit range to upper limit range using For loop.
 Put the iterator value in a temporary variable called tempNum.
 Set a variable, say totalSum to zero. This will save the factorial sum of each of N’s digits.
 The number’s final digit must be saved in a variable, such as last_Digit = N % 10.
 Calculate the factorial of the last_Digit using math.factorial() function
 When the factorial of the last digit is found, it should be added to the totalSum = totalSum+ factNum
 Following each factorial operation, the number must be reduced in terms of units by dividing it by ten that is Itr = Itr /10
 Steps 5–8 should be repeated until N > 0.
 Check if the totalSum is equal to tempNum using the if conditional statement.
 If it is true then print the tempNum(which is the iterator value).
 The Exit of the program.
 
 Below is the implementation:
 # Import the math module using import keyword.
 
 import math
 
 # Give the lower limit range as static input and store it in a variable.
 
 gvn_lower_lmt = 1
 
 # Give the upper limit range as static input and store it in another variable.
 
 gvn_upper_lmt = 200
 
 # Loop from lower limit range to upper limit range using For loop.
 
 print(""The Strong Numbers in a given range"",
 
  gvn_lower_lmt, ""and"", gvn_upper_lmt, ""are :"")
 
 for itr in range(gvn_lower_lmt, gvn_upper_lmt+1):
 
  # Taking a variable totalSum and initializing it with 0
 
  totalSum = 0
 
  # Put the iterator value in a temporary variable called tempNum.
 
  tempNum = itr
 
  # using while to extract digit by digit of the given iterator value
 
  while(itr):
 
  s = 1
 
  factNum = 1
 
  # Getting the last digit of the iterator value
 
  remainder = itr % 10
 
  # calculating the factorial of the digit(extracted by remainder variable)
 
  # using math.fatorial function
 
  factNum = math.factorial(remainder)
 
  # Adding the factorial to the totalSum
 
  totalSum = totalSum + factNum
 
  # Dividing the given itertor value by 10
 
  itr = itr//10
 
  # checking if the totalSum is equal to the iterator value
 
  # if it is true then it is strong number then return true
 
  if(totalSum == tempNum):
 
  print(tempNum, end=' ')
 
 
 Output:
 The Strong Numbers in a given range 1 and 200 are :
 
 1 2 145
 Method #2: Using While loop and factorial() function (User input)
 Approach:
 
 Import math function using the import keyword.
 Give the lower limit range as user input using int(input()) and store it in a variable.
 Give the upper limit range as user input using int(input()) and store it in another variable.
 Loop from lower limit range to upper limit range using For loop.
 Put the iterator value in a temporary variable called tempNum.
 Set a variable, say totalSum to zero. This will save the factorial sum of each of N’s digits.
 The number’s final digit must be saved in a variable, such as last_Digit = N % 10.
 Calculate the factorial of the last_Digit using math.factorial() function
 When the factorial of the last digit is found, it should be added to the totalSum = totalSum+ factNum
 Following each factorial operation, the number must be reduced in terms of units by dividing it by ten that is Itr = Itr /10
 Steps 5–8 should be repeated until N > 0.
 Check if the totalSum is equal to tempNum using the if conditional statement.
 If it is true then print the tempNum(which is the iterator value).
 The Exit of the program.
 
 Below is the implementation:
 # Import the math module using import keyword.
 
 import math
 
 #Give the lower limit range as user input using int(input()) and
 
 #store it in a variable.
 
 gvn_lower_lmt = int(input(""Enter some random number = ""))
 
 #Give the upper limit range as user input using int(input()) and 
 
 #store it in another variable.
 
 gvn_upper_lmt = int(input(""Enter some random number = ""))
 
 # Loop from lower limit range to upper limit range using For loop.
 
 print(""The Strong Numbers in a given range"",
 
  gvn_lower_lmt, ""and"", gvn_upper_lmt, ""are :"")
 
 for itr in range(gvn_lower_lmt, gvn_upper_lmt+1):
 
  # Taking a variable totalSum and initializing it with 0
 
  totalSum = 0
 
  # Put the iterator value in a temporary variable called tempNum.
 
  tempNum = itr
 
  # using while to extract digit by digit of the given iterator value
 
  while(itr):
 
  s = 1
 
  factNum = 1
 
  # Getting the last digit of the iterator value
 
  remainder = itr % 10
 
  # calculating the factorial of the digit(extracted by remainder variable)
 
  # using math.fatorial function
 
  factNum = math.factorial(remainder)
 
  # Adding the factorial to the totalSum
 
  totalSum = totalSum + factNum
 
  # Dividing the given itertor value by 10
 
  itr = itr//10
 
  # checking if the totalSum is equal to the iterator value
 
  # if it is true then it is strong number then return true
 
  if(totalSum == tempNum):
 
  print(tempNum, end=' ')
 
 
 Output:
 Enter some random number = 1
 
 Enter some random number = 5000
 
 The Strong Numbers in a given range 1 and 5000 are :
 
 1 2 145
 Explore more instances related to python concepts from Python Programming Examples Guide and get promoted from beginner to professional programmer level in Python Programming Language.
 
 Python Program to Find the Sine Series for the Given range
 Python Program to Find Armstrong Number in an Interval
 Python Program to Print all Disarium Numbers within Given range
 Python Program to Find GCD of Elements in a Given Range
 
 
 
 Related:# Import the math module using import keyword.
 
 import math
 
 # Give the lower limit range as static input and store it in a variable.
 
 gvn_lower_lmt = 1
 
 # Give the upper limit range as static input and store it in another variable.
 
 gvn_upper_lmt = 200
 
 # Loop from lower limit range to upper limit range using For loop.
 
 print(""The Strong Numbers in a given range"",
 
  gvn_lower_lmt, ""and"", gvn_upper_lmt, ""are :"")
 
 for itr in range(gvn_lower_lmt, gvn_upper_lmt+1):
 
  # Taking a variable totalSum and initializing it with 0
 
  totalSum = 0
 
  # Put the iterator value in a temporary variable called tempNum.
 
  tempNum = itr
 
  # using while to extract digit by digit of the given iterator value
 
  while(itr):
 
  s = 1
 
  factNum = 1
 
  # Getting the last digit of the iterator value
 
  remainder = itr % 10
 
  # calculating the factorial of the digit(extracted by remainder variable)
 
  # using math.fatorial function
 
  factNum = math.factorial(remainder)
 
  # Adding the factorial to the totalSum
 
  totalSum = totalSum + factNum
 
  # Dividing the given itertor value by 10
 
  itr = itr//10
 
  # checking if the totalSum is equal to the iterator value
 
  # if it is true then it is strong number then return true
 
  if(totalSum == tempNum):
 
  print(tempNum, end=' ')
 
 </pre><|endoftext|>"
856,"<|endoftext|>Write a Python Program to Print 1 and 0 in alternative Rows :# Python Program to Print 1 and 0 in alternative rows
 
rows = int(input(""Please Enter the total Number of Rows  : ""))
columns = int(input(""Please Enter the total Number of Columns  : ""))

print(""Print Number Pattern - 1 and 0 in alternative rows"") 
 
for i in range(1, rows + 1):
    for j in range(1, columns + 1):
        print('%d' %(i % 2), end = '  ')
    print()<|endoftext|>"
857,"<|endoftext|>Write the regular expression that will match all whitespaces at the beginning or the end of a string so that the re.sub() fuction in the tests (you do not need to write it) will function like the .trim() method. Use the character class \s in your expression.
Example
txt1 = ""    Hello World    ""
txt2 = ""    We need more space   ""
pattern = ""yourregularexpressionhere""

re.sub(pattern, """", txt1) ➞ ""Hello World""
re.sub(pattern, """", txt2) ➞ ""We need more space""
Notes
You don't need to write a function, just the pattern.
Do not remove import re from the code.
Find more info on RegEx and character classes in Resources.
You can find all the challenges of this series in my Basic RegEx collection.:import re
pattern = '^\s+|\s+$'<|endoftext|>"
858,"<|endoftext|>Scikit-learn is one of the most popular ML libraries for classical ML algorithms. It is built on top of two basic Python libraries, viz., NumPy and SciPy. Scikit-learn supports most of the supervised and unsupervised learning algorithms. Scikit-learn can also be used for data-mining and data-analysis, which makes it a great tool who is starting out with ML. :# Python script using Scikit-learn
# for Decision Tree Classifier
 
# Sample Decision Tree Classifier
from sklearn import datasets
from sklearn import metrics
from sklearn.tree import DecisionTreeClassifier
 
# load the iris datasets
dataset = datasets.load_iris()
 
# fit a CART model to the data
model = DecisionTreeClassifier()
model.fit(dataset.data, dataset.target)
print(model)
 
# make predictions
expected = dataset.target
predicted = model.predict(dataset.data)
 
# summarize the fit of the model
print(metrics.classification_report(expected, predicted))
print(metrics.confusion_matrix(expected, predicted))<|endoftext|>"
859,"<|endoftext|>In the previous article, we have discussed Python Program to Print Series 2 ,15, 41, 80…n
 Given a number N and the task is to print the series (2, 4, 7, 12, 21, … N) till the given number N in Python.
 Examples:
 Example1:
 Input:
 Given Number (Limit) = 8
 Output:
 The above series till the given number{ 8 } is :
 
 2 4 7 12 21 38 71 136
 Example2:
 Input:
 Given Number (Limit) = 10
 Output:
 The above series till the given number{ 10 } is :
 
 2 4 7 12 21 38 71 136 265 522:# Give the number N(limit) as static input and store it in a variable.
 
 gvn_numb = 8
 
 # Take a variable to say itr and initialize its value to 0.
 
 itr = 0
 
 # Take another variable say previous_val and initialize its value to 2.
 
 previous_val = 2
 
 print(""The above series till the given number{"", gvn_numb, ""} is :"")
 
 # print the value 2 separated by spaces.
 
 print(""2 "",end="""")
 
 # Loop until the above-declared variable itr value is less than the
 
 # given number-1 using the while loop.
 
 while itr&lt;gvn_numb-1:
 
  #Inside the loop, Multiply the variable previous_val with 2 and subtract the above
 
  #itr value from it.
 
  #Store it in the same variable previous_val.
 
  previous_val = (previous_val * 2) -itr
 
  # Print the value of the above previous_val separated by spaces.
 
  print(previous_val,end="" "")
 
  # Increment the above itr value by 1.
 
  itr+=1</pre><|endoftext|>"
860,"<|endoftext|>Given an array of length N that contains only integers, the task is to print the special numbers of array. A number in this array is called Special number if it is divisible by at least one other number in the array.
Examples : 
 

Input : 1 2 3 
Output : 2 3 
Explanation : both 2 and 3 are divisible by 1.:# Python3 program to find special numbers
# in an array
import math as mt

# Function to find special numbers
def divisibilityCheck(arr, n):

        # Storing all array elements in a hash
        # and finding maximum element in array
        s = dict()
        max_ele = -10**9
        for i in range(n):
                s[arr[i]] = 1

                # finding maximum element of array
                max_ele = max(max_ele, arr[i])
        
        # traversing array element and storing
        # the array multiples that are present
        # in s in res.
        res = dict()
        for i in range(n):

                # Check for non-zero values only
                if (arr[i] != 0):

                        # checking the factor of current element
                        for j in range(arr[i] * 2,
                                                max_ele + 1, arr[i]):
                                
                                # if factor is already part of
                                # array element then store it
                                if (j in s.keys()):
                                        res[j] = 1
                        
        # displaying elements that are divisible
        # by at least one other in array
        for x in res:
                print(x, end = "" "")

# Driver code
arr = [ 2, 3, 8, 6, 9, 10]
n = len(arr)
divisibilityCheck(arr, n)

# This code is contributed by
# Mohit Kumar 29
<|endoftext|>"
861,"<|endoftext|>In this example, you will learn to delete an element from a dictionary.:my_dict = {31: 'a', 21: 'b', 14: 'c'}

del my_dict[31]

print(my_dict)
my_dict = {31: 'a', 21: 'b', 14: 'c'}

print(my_dict.pop(31))

print(my_dict)<|endoftext|>"
862,"<|endoftext|>If a number is divisible by the sum of its digits, then it will be known as a Harshad Number.

For example:

The number 156 is divisible by the sum (12) of its digits (1, 5, 6 ).

Some Harshad numbers are 8, 54, 120, etc.:num = 156;    
rem = sum = 0;    
     
#Make a copy of num and store it in variable n    
n = num;    
     
#Calculates sum of digits    
while(num > 0):    
    rem = num%10;    
    sum = sum + rem;    
    num = num//10;    
     
#Checks whether the number is divisible by the sum of digits    
if(n%sum == 0):    
    print(str(n) + "" is a harshad number"");    
else:    
    print(str(n) + "" is not a harshad number"");    <|endoftext|>"
863,"<|endoftext|>You may recall that an array arr is a mountain array if and only if:

arr.length >= 3
There exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:

arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]



Given an integer array nums​​​, return the minimum number of elements to remove to make nums​​​ a mountain array.
 
Example 1:

Input: nums = [1,3,1]
Output: 0
Explanation: The array itself is a mountain array so we do not need to remove any elements.

Example 2:

Input: nums = [2,1,1,5,6,2,3,1]
Output: 3
Explanation: One solution is to remove the elements at indices 0, 1, and 5, making the array nums = [1,5,6,3,1].

 
Constraints:

3 <= nums.length <= 1000
1 <= nums[i] <= 109
It is guaranteed that you can make a mountain array out of nums.:class Solution:
  def minimumMountainRemovals(self, nums):
  def LIS(nums):
  dp = [10**10] * (len(nums) + 1)
  lens = [0]*len(nums)
  for i, elem in enumerate(nums): 
  lens[i] = bisect_left(dp, elem) + 1
  dp[lens[i] - 1] = elem 
  return lens
  
  l1, l2 = LIS(nums), LIS(nums[::-1])[::-1]
  ans, n = 0, len(nums)
  for i in range(n):
  if l1[i] >= 2 and l2[i] >= 2:
  ans = max(ans, l1[i] + l2[i] - 1)
  
  return n - ans<|endoftext|>"
864,"<|endoftext|>Counter function in Python:

The counter is a set and dict subset. Counter() takes an iterable entity as an argument and stores the elements as keys and the frequency of the elements as a value. So, in collections, if we transfer a string. When you call Counter(), you’ll get a Counter class object with characters as keys and their frequency in a string as values.

Counter() returns a Counter type object (a subclass of dict) with all characters in the string as keys and their occurrence count as values. We’ll use the [] operator to get the occurrence count of the characters from it.

For example:

let given string = “pqrspqrspp”.

In this p occurred 4 times, q,r,s occurred 2 times.

Therefore the frequency of all the characters in a given string is Even.

Examples:

Example1:

Input:

Given String = ""pqrspqrstutu""
Output:

Yes,the given string { pqrspqrstutu } contains all characters at even intervals:# Import the Counter() function from collections using the import keyword.
from collections import Counter
# Pass the given string as an argument to the function determine.


def determine(gvn_strng):
  # Calculate the frequency of all the given string elements using the Counter() function
    # which returns the element and its frequency as a key-value pair and stores this
    # dictionary in another variable (say strngfreqelements).

    strngfreqelements = Counter(gvn_strng)
 # Traverse in this frequency dictionary using the for loop.
    for key in strngfreqelements:
        # Inside the loop, check if the Key has a value even or odd using the modulus operator
        # and if conditional statement.
        if (strngfreqelements[key] % 2 == 1):
           # If the statement is true, then return False.
            return False
  # Return true after the for loop.
    return True


# Give the string as static input and store it in a variable.
gvn_strng = ""pqrspqrstutu""
# Check if the function returns true or false using the if conditional statement.
if(determine(gvn_strng)):
  # If it is true, print ""yes, the given string contains all characters at even intervals"".
    print(""Yes,the given string {"", gvn_strng,
          ""} contains all characters at even intervals"")
else:
  # Else print ""No, the given string does not contain all characters at even intervals"".
    print(""No,the given string {"", gvn_strng,
          ""} does not contains all characters at even intervals"")<|endoftext|>"
865,"<|endoftext|>Create a function that takes a list lst and returns the types of values (data types) in a new list.
Examples
list_values_types([1, 10]) ➞ [""int"", ""int""])

list_values_types([[""hello"" , 1] , 10]) ➞ [""list"", ""int""])

list_values_types([""shashwat"", 10, 90]) ➞ [""str"", ""int"", ""int""])
Notes
Check the Resources tab for help if needed.:def list_values_types(lst):
  return [type(x).__name__ for x in lst]<|endoftext|>"
866,"<|endoftext|>There is an m x n grid, where (0, 0) is the top-left cell and (m - 1, n - 1) is the bottom-right cell. You are given an integer array startPos where startPos = [startrow, startcol] indicates that initially, a robot is at the cell (startrow, startcol). You are also given an integer array homePos where homePos = [homerow, homecol] indicates that its home is at the cell (homerow, homecol).

The robot needs to go to its home. It can move one cell in four directions: left, right, up, or down, and it can not move outside the boundary. Every move incurs some cost. You are further given two 0-indexed integer arrays: rowCosts of length m and colCosts of length n.

If the robot moves up or down into a cell whose row is r, then this move costs rowCosts[r].
If the robot moves left or right into a cell whose column is c, then this move costs colCosts[c].
Return the minimum total cost for this robot to return home.:class Solution:
    def minCost(self, sp: List[int], hp: List[int], rCost: List[int], cCost: List[int]) -> int:
        cost = 0
        cost += sum(cCost[min(hp[1],sp[1]) : max(hp[1],sp[1])+1])
        cost -= cCost[sp[1]] 
        cost += sum(rCost[min(hp[0],sp[0]) : max(hp[0],sp[0])+1])
        cost -= rCost[sp[0]]
        return cost<|endoftext|>"
867,"<|endoftext|>Given a string, the task is to count the Number of Alphabets in a given String.

isalpha() Method:

The isalpha() method is a built-in method for string-type objects. If all of the characters are alphabets from a to z, the isalpha() method returns true otherwise, it returns False.

Examples:

Example1:

Input:

Given String = hello btechgeeks
Output:

The Number of Characters in a given string { hello btechgeeks } =  15
Example 2:

Input:

Given String = good morning btechgeeks
Output:

The Number of Characters in a given string { good morning btechgeeks } =  21:# Give the String as static input and store it in a variable.
gvn_str = ""hello btechgeeks""
# Take a variable say 'count' and initialize it's value with '0'
count_no = 0
# Loop from 0 to the length of the above given String using For Loop.
for itrtor in gvn_str:
  # Inside the loop, check whether  if the value of iterator is alphabet or
  # using built-in isalpha() method inside the if conditional statement.
  if(itrtor.isalpha()):
  # If the given condition is true ,then increment the above initialized count value by '1'.
  count_no = count_no+1
# Print the number of Alphabets in a given string by printing the above count value.
print(
  ""The Number of Characters in a given string {"", gvn_str, ""} = "", count_no)<|endoftext|>"
868,"<|endoftext|>Strings:

A string data type is used in most computer languages for data values that are made up of ordered sequences of characters, such as “hello world.” A string can include any visible or unseen series of characters, and characters can be repeated. The length of a string is the number of characters in it, and “hello world” has length 11 – made up of 10 letters and 1 space. The maximum length of a string is usually restricted. There is also the concept of an empty string, which includes no characters and has a length of zero.

A string can be both a constant and a variable. If it is a constant, it is commonly expressed as a string of characters surrounded by single or double quotes.

Stack:

Stacking objects means putting them on top of one another in the English language. This data structure allocates memory in the same manner.

Data structures are essential for organizing storage in computers so that humans can access and edit data efficiently. Stacks were among the first data structures to be defined in computer science. In layman’s terms, a stack is a linear accumulation of items. It is a collection of objects that provides fast last-in, first-out (LIFO) insertion and deletion semantics. It is a modern computer programming and CPU architecture array or list structure of function calls and parameters. Elements in a stack are added or withdrawn from the top of the stack in a “last in, first out” order, similar to a stack of dishes at a restaurant.



Unlike lists or arrays, the objects in the stack do not allow for random access.

Given a string the task is to reverse the given string using stack data structure in C++ and python.

Examples:

Example1:

Input:

given string =""hellothisisBTechGeeks""
Output:

Printing the given string before reversing : hellothisisBTechGeeks
Printing the given string after reversing : skeeGhceTBsisihtolleh
Example2:

Input:

given string =""skyisbluieIFC""
Output:

Printing the given string before reversing : skyisbluieIFC
Printing the given string after reversing : CFIeiulbsiyks
Example3:

Input:

given string=""cirusfinklestein123""
Output:

Printing the given string before reversing : cirusfinklestein123
Printing the given string after reversing : 321nietselknifsuric:from collections import deque
# given string
givenstr = ""HellothisisBTechGeeks""
# Printing the given string before reversing
print(""Printing the given string before reversing : "")
print(givenstr)
# creating the stack from the given string
st = deque(givenstr)
# pop all characters from the stack and join them back into a string
givenstr = ''.join(st.pop() for _ in range(len(givenstr)))
# Printing the given string after reversing
print(""Printing the given string after reversing : "")
print(givenstr)<|endoftext|>"
869,"<|endoftext|>Given an integer n, you must transform it into 0 using the following operations any number of times:

Change the rightmost (0th) bit in the binary representation of n.
Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.

Return the minimum number of operations to transform n into 0.
 
Example 1:

Input: n = 3
Output: 2
Explanation: The binary representation of 3 is ""11"".
""11"" -> ""01"" with the 2nd operation since the 0th bit is 1.
""01"" -> ""00"" with the 1st operation.

Example 2:

Input: n = 6
Output: 4
Explanation: The binary representation of 6 is ""110"".
""110"" -> ""010"" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.
""010"" -> ""011"" with the 1st operation.
""011"" -> ""001"" with the 2nd operation since the 0th bit is 1.
""001"" -> ""000"" with the 1st operation.

 
Constraints:

0 <= n <= 109:def minimumOneBitOperations(self, n):
  res = 0
  while n:
  res = -res - (n ^ (n - 1))
  n &= n - 1
  return abs(res)<|endoftext|>"
870,"<|endoftext|>When a chord is drawn in a circle, it divides the circle into two parts. These two parts of the circle are known as circle segments. The smaller area is referred to as the Minor segment, while the larger area is referred to as the Major segment.

Given the radius of the circle and the angle that forms a minor segment, the task is to find the areas of both major and minor segments of a circle.

Formula:

pi * r2 * (angle/360) – 1/2 * r2 * Sin(angle):# Import math module using the import keyword.
import math

# Create a function to say BothSegments_area() which takes the given radius and angle
# as the arguments, and returns the major and minor segments area.


def BothSegments_area(gven_radius, gven_angl):
        # Inside the function, calculate the value area of the sector using the above
        # given mathematical formula and store it in a variable.
    rsltareaof_sectr = pi * (gven_radius * gven_radius) * (gven_angl / 360)

    # Calculate the area of the triangle using the above given mathematical formula and
    #  math.sin() function.
    # store it in another variable.
    rsltareaof_triangl = 1 / 2 * \
        (gven_radius * gven_radius) * math.sin((gven_angl * pi) / 180)

    # Subtract the area of a triangle from the area of a sector and return it.
    return rsltareaof_sectr - rsltareaof_triangl


# Give the radius as static input and store it in a variable.
gven_radius = 20
# Give the angle as static input and store it in another variable.
gven_angl = 60
# Take a variable and initialize the pi value as 3.14159.
pi = 3.14159
# Pass the given radius and angle as the arguments to the BothSegments_area()
# function and print the area of the minor segment.
print(""The minor segment area ="",
      BothSegments_area(gven_radius, gven_angl))
# Pass the given radius and 360-angle as the arguments to the BothSegments_area()
# function and print the area of the major segment.
print(""The major segment area ="",
      BothSegments_area(gven_radius, (360 - gven_angl)))<|endoftext|>"
871,"<|endoftext|>Given a Weighted Directed Acyclic Graph (DAG) and a source vertex s in it, find the longest distances from s to all other vertices in the given graph.:# A recursive function used by longestPath. See below
# link for details
# https:#www.geeksforgeeks.org/topological-sorting/
def topologicalSortUtil(v):
    global Stack, visited, adj
    visited[v] = True
 
    # Recur for all the vertices adjacent to this vertex
    # list<AdjListNode>::iterator i
    for i in adj[v]:
        if (not visited[i[0]]):
            topologicalSortUtil(i[0])
 
    # Push current vertex to stack which stores topological
    # sort
    Stack.append(v)
 
# The function to find longest distances from a given vertex.
# It uses recursive topologicalSortUtil() to get topological
# sorting.
def longestPath(s):
    global Stack, visited, adj, V
    dist = [-10**9 for i in range(V)]
 
    # Call the recursive helper function to store Topological
    # Sort starting from all vertices one by one
    for i in range(V):
        if (visited[i] == False):
            topologicalSortUtil(i)
    # print(Stack)
 
    # Initialize distances to all vertices as infinite and
    # distance to source as 0
    dist[s] = 0
    # Stack.append(1)
 
    # Process vertices in topological order
    while (len(Stack) > 0):
       
        # Get the next vertex from topological order
        u = Stack[-1]
        del Stack[-1]
        #print(u)
 
        # Update distances of all adjacent vertices
        # list<AdjListNode>::iterator i
        if (dist[u] != 10**9):
            for i in adj[u]:
                # print(u, i)
                if (dist[i[0]] < dist[u] + i[1]):
                    dist[i[0]] = dist[u] + i[1]
 
    # Print calculated longest distances
    # print(dist)
    for i in range(V):
        print(""INF "",end="""") if (dist[i] == -10**9) else print(dist[i],end="" "")
 
# Driver code
if __name__ == '__main__':
    V, Stack, visited = 6, [], [False for i in range(7)]
    adj = [[] for i in range(7)]
     
    # Create a graph given in the above diagram.
    # Here vertex numbers are 0, 1, 2, 3, 4, 5 with
    # following mappings:
    # 0=r, 1=s, 2=t, 3=x, 4=y, 5=z
    adj[0].append([1, 5])
    adj[0].append([2, 3])
    adj[1].append([3, 6])
    adj[1].append([2, 2])
    adj[2].append([4, 4])
    adj[2].append([5, 2])
    adj[2].append([3, 7])
    adj[3].append([5, 1])
    adj[3].append([4, -1])
    adj[4].append([5, -2])
 
    s = 1
    print(""Following are longest distances from source vertex "",s)
    longestPath(s)
 
    # This code is contributed by mohit kumar 29.<|endoftext|>"
872,"<|endoftext|>A string r is a subsequence of a string s if r can be obtained from s by dropping zero or more characters from s. A string r is a common subsequence of s and t if r is a subsequence of both s and t. A string r is a longest common subsequence (LCS) of s and t if there is no string that is longer than r and is a common subsequence of s and t. The problem is to find an LCS of two given strings.:def lcs(u, v):
    """"""Return c where c[i][j] contains length of LCS of u[i:] and v[j:].""""""
    c = [[-1]*(len(v) + 1) for _ in range(len(u) + 1)]
    lcs_helper(u, v, c, 0, 0)
    return c
 
 
def lcs_helper(u, v, c, i, j):
    """"""Return length of LCS of u[i:] and v[j:] and fill in table c.
 
    c[i][j] contains the length of LCS of u[i:] and v[j:].
    This function fills in c as smaller subproblems for solving c[i][j] are
    solved.""""""
    if c[i][j] >= 0:
        return c[i][j]
 
    if i == len(u) or j == len(v):
        q = 0
    else:
        if u[i] == v[j]:
            q = 1 + lcs_helper(u, v, c, i + 1, j + 1)
        else:
            q = max(lcs_helper(u, v, c, i + 1, j),
                    lcs_helper(u, v, c, i, j + 1))
    c[i][j] = q
    return q
 
 
def print_lcs(u, v, c):
    """"""Print one LCS of u and v using table c.""""""
    i = j = 0
    while not (i == len(u) or j == len(v)):
        if u[i] == v[j]:
            print(u[i], end='')
            i += 1
            j += 1
        elif c[i][j + 1] > c[i + 1][j]:
            j += 1
        else:
            i += 1
 
 
u = input('Enter first string: ')
v = input('Enter second string: ')
c = lcs(u, v)
print('Longest Common Subsequence: ', end='')
print_lcs(u, v, c)<|endoftext|>"
873,"<|endoftext|>There is a country of n cities numbered from 0 to n - 1 where all the cities are connected by bi-directional roads. The roads are represented as a 2D integer array edges where edges[i] = [xi, yi, timei] denotes a road between cities xi and yi that takes timei minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.

Each time you pass through a city, you must pay a passing fee. This is represented as a 0-indexed integer array passingFees of length n where passingFees[j] is the amount of dollars you must pay when you pass through city j.

In the beginning, you are at city 0 and want to reach city n - 1 in maxTime minutes or less. The cost of your journey is the summation of passing fees for each city that you passed through at some moment of your journey (including the source and destination cities).

Given maxTime, edges, and passingFees, return the minimum cost to complete your journey, or -1 if you cannot complete it within maxTime minutes.:from collections import defaultdict
from heapq import heappop,heappush
class Solution:
    mn = float('inf')
    def minCost(self, mxt: int, edges: List[List[int]], fees: List[int]) -> int:
        n = len(fees)
        adj = defaultdict(list)
        tms = defaultdict(lambda : float('inf'))   ### need this dictionary to  account the reaching time at ith node. 
        for x,y,t in edges:
            adj[x].append([y,t])
            adj[y].append([x,t])
        qu = []
        heappush(qu,(fees[0],0,0))
        while qu:
            fee,tm,nd = heappop(qu)
            if tm > mxt :
                continue
            if nd == n-1 :
                return fee
            if tm < tms[nd]:            ### simply if we come again at the same node and in lesser time we allow bfs over that node. 
                for dest,time in adj[nd]:
                    heappush(qu,(fee+fees[dest],tm+time,dest))
            tms[nd] = min(tms[nd],tm)  ## store the  min reachable  time at the  node
        return -1<|endoftext|>"
874,"<|endoftext|>This is a reverse coding challenge. Normally you're given explicit directions with how to create a function. Here, you must generate your own function to satisfy the relationship between the inputs and outputs.
Your task is to create a function that, when fed the inputs below, produce the sample outputs shown.
Examples
""hello"" ➞ [4, 1, 3, 3, 1]

""maybe"" ➞ [4, 2, 1, 3, 1]

""hopeless"" ➞ [0, 7, 0, 5, 4, 5, 3, 3]

""higher"" ➞ [2, 3, 1, 2, 5, 0]

""movement"" ➞ [5, 7, 6, 5, 5, 5, 6, 4]
Notes
If you get stuck, see Comments for a hint.:def mystery_func(txt):
  return [ord(let)%len(txt) for let in txt]<|endoftext|>"
875,"<|endoftext|>Given a number, return a list containing the two halves of the number. If the number is odd, make the rightmost number higher.

Examples
number_split(4) ➞ [2, 2]

number_split(10) ➞ [5, 5]

number_split(11) ➞ [5, 6]

number_split(-9) ➞ [-5, -4]
Notes
All numbers will be integers.
You can expect negative numbers too.:def number_split(n):
  return [n//2, n - n//2]<|endoftext|>"
876,"<|endoftext|>Clear nth Bit of a Number Using Bitwise &(and) Operator (Static Input):# Give the number as static input and store it in a variable.
gvn_numb = 60
# Give the bit position as static input and store it in another variable.
bitpositin = 3
# Apply the left shift operator to 1 and the above-given bit position and
# store it in another variable.
numbr_bit = (1 << bitpositin)
# Apply the complement operator (which converts 0 to 1 and vice-versa) to the above result
# and store it in another variable.
complemt = (~numbr_bit)
# Apply bitwise & operation for the given number and the above result and store it in
# another variable say rslt_numb.
rslt_numb = gvn_numb & complemt
# Print the number after clearing the bit at the given position for a given number.
print(""The Number after clearing the bit at the given position{"",
      bitpositin, ""} for a given number{"", gvn_numb, ""} ="", rslt_numb)<|endoftext|>"
877,"<|endoftext|>Files in Python:

One of the most important subjects for programmers and automation testers is Python file handling (also known as File I/O). It is necessary to work with files in order to write to or read data from them.

Also, if you didn’t know, I/O operations are the most expensive processes where a programme can go wrong. As a result, you must use extreme caution while implementing file processing for reporting or any other reason. Optimizing a single file action can help in the creation of a high-performing application or a reliable automated software testing solution.



Consider the following scenario: you’re planning to construct a large Python project with a large number of workflows. Then it’s unavoidable that you don’t make a log file. You’ll also be handling the log file’s read and write activities. Debugging huge applications with log files is a terrific way to go. It’s usually better to consider a scalable design from the start, as you won’t be sorry later if you didn’t.

Given a file, the task is to assess if a given file is closed or not in Python:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in read-only mode. In this case, we're simply reading the contents of the file.
file = open(givenFilename, 'r') 
# Check if the file is closed or not using the closed function and print the result.
print(file.closed)
# Close the given file using the close() function.
file.close()
# Again, Check if the file is closed or not using the closed function and print the result.
print(file.closed)<|endoftext|>"
878,"<|endoftext|>Find all Numbers in a Range which are Perfect Squares and Sum of all Digits in the Number is Less than 10 Using List Comprehension (Static Input):# given lower limit range as static input
lowerlimit = 5
# given upper limit range as static input
upperlimit = 525
# When the element is a perfect square within the range and the total of the digits of the number
# is less than 10, a list must be generated using list comprehension.
prftSquaresList = [k for k in range(
    lowerlimit, upperlimit+1) if (int(k**0.5))**2 == k and sum(list(map(int, str(k)))) < 10]
# printing the list
print(""Printing the perfect squares numbers list which are less than 10: "", prftSquaresList)<|endoftext|>"
879,"<|endoftext|>You are given two strings word1 and word2. You want to construct a string merge in the following way: while either word1 or word2 are non-empty, choose one of the following options:

If word1 is non-empty, append the first character in word1 to merge and delete it from word1.


For example, if word1 = ""abc"" and merge = ""dv"", then after choosing this operation, word1 = ""bc"" and merge = ""dva"".


If word2 is non-empty, append the first character in word2 to merge and delete it from word2.

For example, if word2 = ""abc"" and merge = """", then after choosing this operation, word2 = ""bc"" and merge = ""a"".



Return the lexicographically largest merge you can construct.
A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b. For example, ""abcd"" is lexicographically larger than ""abcc"" because the first position they differ is at the fourth character, and d is greater than c.
 
Example 1:

Input: word1 = ""cabaa"", word2 = ""bcaaa""
Output: ""cbcabaaaaa""
Explanation: One way to get the lexicographically largest merge is:
- Take from word1: merge = ""c"", word1 = ""abaa"", word2 = ""bcaaa""
- Take from word2: merge = ""cb"", word1 = ""abaa"", word2 = ""caaa""
- Take from word2: merge = ""cbc"", word1 = ""abaa"", word2 = ""aaa""
- Take from word1: merge = ""cbca"", word1 = ""baa"", word2 = ""aaa""
- Take from word1: merge = ""cbcab"", word1 = ""aa"", word2 = ""aaa""
- Append the remaining 5 a's from word1 and word2 at the end of merge.

Example 2:

Input: word1 = ""abcabc"", word2 = ""abdcaba""
Output: ""abdcabcabcaba""

 
Constraints:

1 <= word1.length, word2.length <= 3000
word1 and word2 consist only of lowercase English letters.:def largestMerge(self, s1, s2):
  if s1 >= s2 > '':
  return s1[0] + self.largestMerge(s1[1:], s2)
  if s2 >= s1 > '':
  return s2[0] + self.largestMerge(s1, s2[1:])
  return s1 + s2<|endoftext|>"
880,"<|endoftext|>User Input: Find Sum of Series (1+(1*2)+(1*2*3)+…till N):# Give the number N as user input using the int(input()) function and
# store it in a variable.
gvn_numb = int(input(""Enter some Random Number = ""))
# Take a variable say resltsum which gives the sum of the given series till N and
# initialize its value to 0.
resltsum = 0
# Take another variable say k and initialize its value with 1.
k = 1
# Loop until the value of k is less than or equal to the given number using the while loop.
while(k <= gvn_numb):
    # Inside the loop take a variable say gvn_multiplr and initialize its value with 1.
    gvn_multiplr = 1
  # Iterate from 1 to the value of k using the for loop.
    for itr in range(1, k+1):
      # Multiply the iterator value to the above-initialized gvn_multiplr and store it in the same
        # variable gvn_multiplr.
        gvn_multiplr *= itr
 # Add the above-obtained value of gvn_multiplr to the resltsum outside the for loop.
# Store it in the same variable resltsum.
    resltsum += gvn_multiplr
  # Increment the value of k by 1 outside the for loop.
    k += 1
# Print the resltsum value which is the result of the series till the given Number N.
print(
    ""The total sum of the series till the given number {"", gvn_numb, ""} = "", resltsum)<|endoftext|>"
881,"<|endoftext|>Rearrange the Letters of Multiple strings separated by spaces in Alphabetical Order Using sorted() and join() functions (User Input):# Give the string as user input using the input() function and store it in a variable.
gvnstrng = input('Enter some random string = ')
# Reorder the letters of a string alphabetically using
# the sorted function(This method returns a list of letters in alphabetical order).
sortdstrng = sorted(gvnstrng)
# Join this using the join() function.
# Use the strip() function to remove spaces between the strings.
finalstrng = ''.join(sortdstrng).strip()
# Print the modified string after reordering the letters of a string alphabetically.
print('The original string is [', gvnstrng, ']')
print(
    'The modified string after reordering the letters of a string alphabetically is [', finalstrng, ']')<|endoftext|>"
882,"<|endoftext|>Given a positive number x:
p = (p1, p2, …)
# Set of *prime* factors of x
If the square of every item in p is also a factor of x, then x is said to be a powerful number.
Create a function that takes a number and returns True if it's powerful, False if it's not.
Examples
is_powerful(36) ➞ True
# p = (2, 3) (prime factors of 36)
# 2^2 = 4 (factor of 36)
# 3^2 = 9 (factor of 36)

is_powerful(27) ➞ True

is_powerful(674) ➞ False
Notes
N/A:def is_powerful(n):
    start = n
    res = [] 
    while n % 2 == 0: 
        res.append(2) 
        n = n // 2 
    for i in range(3, int(n**0.5) + 1, 2): 
        while n % i == 0: 
            res.append(i) 
            n = n // i 
    return all(start%(i**2) == 0 for i in res + [n])<|endoftext|>"
883,"<|endoftext|>Access Tuple Items
You can access tuple items by referring to the index number, inside square brackets::thistuple = (""apple"", ""banana"", ""cherry"")
print(thistuple[1])<|endoftext|>"
884,"<|endoftext|>Given two strings comprised of + and -, return a new string which shows how the two strings interact in the following way:

When positives and positives interact, they remain positive.
When negatives and negatives interact, they remain negative.
But when negatives and positives interact, they become neutral, and are shown as the number 0.

Worked Example

neutralise(""+-+"", ""+--"") ➞ ""+-0""
# Compare the first characters of each string, then the next in turn.
# ""+"" against a ""+"" returns another ""+"".
# ""-"" against a ""-"" returns another ""-"".
# ""+"" against a ""-"" returns ""0"".
# Return the string of characters.
Examples

neutralise(""--++--"", ""++--++"") ➞ ""000000""

neutralise(""-+-+-+"", ""-+-+-+"") ➞ ""-+-+-+""

neutralise(""-++-"", ""-+-+"") ➞ ""-+00""
Notes

The two strings will be the same length.:def neutralise(s1, s2):
  return ''.join(a if a == b else '0' for a, b in zip(s1, s2))<|endoftext|>"
885,"<|endoftext|>Create a function that takes three parameters where:
x is the start of the range (inclusive).
y is the end of the range (inclusive).
n is the divisor to be checked against.
Return an ordered list with numbers in the range that are divisible by the third parameter n. Return an empty list if there are no numbers that are divisible by n.
Examples
list_operation(1, 10, 3) ➞ [3, 6, 9]

list_operation(7, 9, 2) ➞ [8]

list_operation(15, 20, 7) ➞ []
Notes
N/A:def list_operation(x, y, n):
  return [i for i in range(x,y+1) if i%n==0]<|endoftext|>"
886,"<|endoftext|>Given a Binary Tree having positive and negative nodes, the task is to find the maximum sum level in it.

Examples: 

Input :               4
                    /   \
                   2    -5
                  / \    /\
                -1   3 -2  6
Output: 6
Explanation :
Sum of all nodes of 0'th level is 4
Sum of all nodes of 1'th level is -3
Sum of all nodes of 0'th level is 6
Hence maximum sum is 6

Input :          1
               /   \
             2      3
           /  \      \
          4    5      8
                    /   \
                   6     7  
Output :  17:# A queue based Python3 program to find
# maximum sum of a level in Binary Tree
from collections import deque

# A binary tree node has data, pointer
# to left child and a pointer to right
# child
class Node:
	
	def __init__(self, key):
		
		self.data = key
		self.left = None
		self.right = None

# Function to find the maximum sum
# of a level in tree
# using level order traversal
def maxLevelSum(root):
	
	# Base case
	if (root == None):
		return 0

	# Initialize result
	result = root.data
	
	# Do Level order traversal keeping
	# track of number
	# of nodes at every level.
	q = deque()
	q.append(root)
	
	while (len(q) > 0):
		
		# Get the size of queue when the
		# level order traversal for one
		# level finishes
		count = len(q)

		# Iterate for all the nodes in
		# the queue currently
		sum = 0
		while (count > 0):
			
			# Dequeue an node from queue
			temp = q.popleft()

			# Add this node's value to current sum.
			sum = sum + temp.data

			# Enqueue left and right children of
			# dequeued node
			if (temp.left != None):
				q.append(temp.left)
			if (temp.right != None):
				q.append(temp.right)
				
			count -= 1

		# Update the maximum node count value
		result = max(sum, result)

	return result
	
# Driver code
if __name__ == '__main__':
	
	root = Node(1)
	root.left = Node(2)
	root.right = Node(3)
	root.left.left = Node(4)
	root.left.right = Node(5)
	root.right.right = Node(8)
	root.right.right.left = Node(6)
	root.right.right.right = Node(7)

	# Constructed Binary tree is:
	#			 1
	#		 / \
	#		 2	 3
	#	 / \	 \
	#	 4 5	 8
	#				 / \
	#			 6	 7
	print(""Maximum level sum is"", maxLevelSum(root))

# This code is contributed by mohit kumar 29
<|endoftext|>"
887,"<|endoftext|>Given the number of rows of the Triangle, the task is to Print an Inverted Right Triangle of Numbers in C, C++, and Python

Examples:

Example1:

Input:

given number of rows of the Inverted Right Triangle Pattern =13
Output:

13 13 13 13 13 13 13 13 13 13 13 13 13 
12 12 12 12 12 12 12 12 12 12 12 12 
11 11 11 11 11 11 11 11 11 11 11 
10 10 10 10 10 10 10 10 10 10 
9 9 9 9 9 9 9 9 9 
8 8 8 8 8 8 8 8 
7 7 7 7 7 7 7 
6 6 6 6 6 6 
5 5 5 5 5 
4 4 4 4 
3 3 3 
2 2 
1
Example2:

Input:

given number of rows of the Inverted Right Triangle Pattern =8
Output:

8 8 8 8 8 8 8 8 
7 7 7 7 7 7 7 
6 6 6 6 6 6 
5 5 5 5 5 
4 4 4 4 
3 3 3 
2 2 
1:# Give the number of rows of the Inverted Right Triangle as static input and store it in a variable.
triNumRows = 13
# Loop from the given number of rows to 0 using For loop and take iterator value as m.
for m in range(triNumRows, -1, -1):
  # Loop till the iterator value of the first loop using another nested For loop.
  for n in range(m):
  # Print the First Loop iterator value that is m and space character.
  print(m, end=' ')
  # Print the newline character after inner for loop.
  print()<|endoftext|>"
888,"<|endoftext|>A binary tree and a number k are given. Print every path in the tree with sum of the nodes in the path as k. 
A path can start from any node and end at any node and must be downward only, i.e. they need not be root node and leaf node; and negative numbers can also be there in the tree.
Examples: 
 

Input : k = 5  
        Root of below binary tree:
           1
        /     \
      3        -1
    /   \     /   \
   2     1   4     5                        
        /   / \     \                    
       1   1   2     6    
                       
Output :
3 2 
3 1 1 
1 3 1 
4 1 
1 -1 4 1 
-1 4 2 
5 
1 -1 5 :# Python3 program to print all paths
# with sum k

# utility function to print contents of
# a vector from index i to it's end


def printVector(v, i):
	for j in range(i, len(v)):
		print(v[j], end="" "")
	print()


# Binary Tree Node
"""""" utility that allocates a newNode
with the given key """"""


class newNode:

	# Construct to create a newNode
	def __init__(self, key):
		self.data = key
		self.left = None
		self.right = None

# This function prints all paths
# that have sum k


def printKPathUtil(root, path, k):

	# empty node
	if (not root):
		return

	# add current node to the path
	path.append(root.data)

	# check if there's any k sum path
	# in the left sub-tree.
	printKPathUtil(root.left, path, k)

	# check if there's any k sum path
	# in the right sub-tree.
	printKPathUtil(root.right, path, k)

	# check if there's any k sum path that
	# terminates at this node
	# Traverse the entire path as
	# there can be negative elements too
	f = 0
	for j in range(len(path) - 1, -1, -1):
		f += path[j]

		# If path sum is k, print the path
		if (f == k):
			printVector(path, j)

	# Remove the current element
	# from the path
	path.pop(-1)

# A wrapper over printKPathUtil()


def printKPath(root, k):

	path = []
	printKPathUtil(root, path, k)


# Driver Code
if __name__ == '__main__':

	root = newNode(1)
	root.left = newNode(3)
	root.left.left = newNode(2)
	root.left.right = newNode(1)
	root.left.right.left = newNode(1)
	root.right = newNode(-1)
	root.right.left = newNode(4)
	root.right.left.left = newNode(1)
	root.right.left.right = newNode(2)
	root.right.right = newNode(5)
	root.right.right.right = newNode(2)

	k = 5
	printKPath(root, k)

# This code is contributed by
# Shubham Singh(SHUBHAMSINGH10)<|endoftext|>"
889,"<|endoftext|>A sequence is special if it consists of a positive number of 0s, followed by a positive number of 1s, then a positive number of 2s.

For example, [0,1,2] and [0,0,1,1,1,2] are special.
In contrast, [2,1,0], [1], and [0,1,2,0] are not special.
Given an array nums (consisting of only integers 0, 1, and 2), return the number of different subsequences that are special. Since the answer may be very large, return it modulo 109 + 7.

A subsequence of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Two subsequences are different if the set of indices chosen are different.:class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -> int:
        term=10**9+7
        dp=[0]*3
        for i in range(len(nums)):
            item=int(nums[i])
            dp[item]=2*dp[item]+(1 if item==0 else dp[item-1])
            dp[item]%=term
        return dp[-1]<|endoftext|>"
890,"<|endoftext|>In this post, we will write the programs for octal to decimal conversion in Python language. We will be given a decimal number and the python program to convert the given octal number into an equivalent decimal number.:# Python program to convert octal to decimal def OctalDecimal(num): #user-defined function decimal = 0 base = 1 #Initializing base value to 1, i.e 8^0  while (num): # Extracting last digit last_digit = num % 10 num = int(num / 10) decimal += last_digit * base base = base * 8 return decimal # take inputs num = int(input('Enter an octal number: ')) # calling function and display result print('The decimal value is =',OctalDecimal(num))<|endoftext|>"
891,"<|endoftext|>Create a program that will take two lists of integers, a and b. Each list will consist of 3 positive integers, representing the dimensions of cuboids a and b. Find the difference of the cuboids' volumes.
For example, if the parameters passed are ([2, 2, 3], [5, 4, 1]), the volume of a is 12 and the volume of b is 20. Therefore, the function should return 8.
Examples
find_difference([ 28, 16, 29 ], [ 7, 8, 17 ]) ➞ 12040

find_difference([ 9, 22, 18 ], [ 16, 24, 10 ]) ➞ 276

find_difference([ 1, 9, 25 ], [ 10, 7, 9 ]) ➞ 405

find_difference([ 7, 6, 16 ], [ 26, 9, 26 ]) ➞ 5412
Notes
Each list element is greater than 0.:def find_difference(a, b):
  l1,w1,h1 = a
  l2,w2,h2 = b
  return abs((l1*w1*h1)-(l2*h2*w2))<|endoftext|>"
892,"<|endoftext|>Given the number of rows of the diamond pattern, the task is to print the diamond star pattern in C, C++, and Python:# Give the number of rows of the diamond pattern as static input and store it in a variable.

diamondrows = 5
# Loop from 1 to the number of rows using For Loop.
for m in range(1, diamondrows+1):
    # Loop from 1 to the number of rows -iterator value of the parent
    # For loop using another For loop(Nested For loop).
    for n in range(1, diamondrows - m + 1):
        # Print the space character in the inner For loop.
        print(end=' ')
    # Loop from 0 to the 2* iterator value - 1 of the parent For loop
    # using another For loop(Nested For loop).
    for l in range(0, (2 * m) - 1):
        # Print the star character
        print('*', end='')
    # After the end of the inner for Loops print the Newline Character.
    print()

# Loop from 1 to the number of rows using For loop.
for m in range(1, diamondrows):
    # Loop from 1 to iterator value of the parent For loop
    # using another For loop(Nested For loop).
    for n in range(1, m+1):
        # Print the space character in the inner For loop.
        print(end=' ')
    # Loop from 1 to 2*(number of rows - iterator value of the parent for loop)
    # using another For loop(Nested For loop).
    for l in range(1, (2 * (diamondrows - m))):
        # Print the star character
        print('*', end='')

    # After the end of the inner for Loops print the Newline Character.
    print()<|endoftext|>"
893,"<|endoftext|>In this tutorial, we will learn how to calculate the union of sets of tuples in Python. Let us begin by defining the union in set theory.
 The set of every element in the collection of sets is the set of the union of sets. In the case of duplicate elements in different sets, the final union will only contain the specific element once. The letter ‘U’ represents the union.
 This problem is centered on finding the union of sets of tuples, which indicates that the set is made up of tuple elements.
 Examples:
 Example1:
 Input:
 first = {('hello', 5), ('this', 100)}
 
 second = {('this', 100), ('is', 200)}
 
 third = {('hello', 5), ('btechgeeks', 461), ('python', 234)}
 Output:
 first Union Second = {('is', 200), ('this', 100), ('hello', 5)}
 
 Second Union third = {('python', 234), ('is', 200), ('this', 100), ('hello', 5), ('btechgeeks', 461)}
 
 first Union Second Union third = {('python', 234), ('is', 200), ('this', 100), ('hello', 5), ('btechgeeks', 461)}:# Give the set of tuples as static input and store them in Separate Variables.
 
 first = {('hello', 5), ('this', 100)}
 
 second = {('this', 100), ('is', 200)}
 
 third = {('hello', 5), ('btechgeeks', 461), ('python', 234)}
 
 
 
 # In Python, we may retrieve the union of a set of tuples
 
 # by using the OR operator (|). In order to acquire the union of two variables,
 
 # use the OR operator directly between them.
 
 # Calculate the union using | operator and store it in a variable.
 
 
 
 reslt1 = second | third
 
 reslt2 = first | second
 
 reslt3 = first | second | third
 
 # Print the union of first and second
 
 print(""first Union Second = "", reslt2)
 
 # print the union of second and third
 
 print(""Second Union third = "", reslt1)
 
 # print the union of first second and third.
 
 print(""first Union Second Union third = "", reslt3)
 
 </pre><|endoftext|>"
894,"<|endoftext|>The ""Reverser"" takes a string as input and returns that string in reverse order, with the opposite case.
Examples
reverse(""Hello World"") ➞ ""DLROw OLLEh""

reverse(""ReVeRsE"") ➞ ""eSrEvEr""

reverse(""Radar"") ➞ ""RADAr""
Notes
There will be no punctuation in any of the test cases.:def reverse(txt):
  return txt[::-1].swapcase()<|endoftext|>"
895,"<|endoftext|>Odd numbers like to hangout with odd numbers. Even numbers like to hangout with even numbers.
A spot is an insertion between two numbers in a list. Given a list of n integers in length, there are n-1 spots available.
For instance:
[3, 4, 9, 10, 1]  # List of 5 digits can also be thought of as...

[3, __ , 4, __ , 9, __, 10, __, 1]  # ...a list of 4 spots.
After a number is newly inserted into a spot, it's left neighbor is the number directly to the left of it and it's right neighbor is the number directly to the right of it.
For instance:
[3, 6, 4, 9, 10, 1]  # Left neighbor of 6 is 3, right neighbor of 6 is 4.
Odd numbers like having the following (left neighbor, right neighbor combinations): (odd, even), (even, odd), (odd, odd) .They dislike having both neighbors being even, or (even, even).
Similarly, even numbers like the following neighbor combinations: (even, odd), (odd, even), (even, even). They dislike having both neighbors being odd, or (odd, odd).
Given a list, calculate the number of liked spots.
Examples
available_spots([0, 4, 6, 8], 9) ➞ 0
# 9 likes NONE of the following spots: [0, __, 4], [4, __ , 6], [6, __, 8] b/c all of his neighbors are even.

available_spots([0, 4, 6, 8], 12) ➞ 3
# 12 likes ALL of the spots.

available_spots([4, 4, 4, 4, 5], 7) ➞ 1
# 7 dislikes every spot except the last one at: [4, __, 5].

available_spots([4, 4], 8) ➞ 1
Notes
N/A:def available_spots(lst, num):
  return sum(1 for i, j in zip(lst, lst[1:]) if not (i%2==j%2!=num%2))<|endoftext|>"
896,"<|endoftext|>Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.

You must write an algorithm that runs in O(n) time.

 

Example 1:

Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
Example 2:

Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9:class Solution:
    def longestConsecutive(self, nums):
        if not nums:
            return 0

        nums.sort()

        longest_streak = 1
        current_streak = 1

        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]:
                if nums[i] == nums[i-1]+1:
                    current_streak += 1
                else:
                    longest_streak = max(longest_streak, current_streak)
                    current_streak = 1

        return max(longest_streak, current_streak)<|endoftext|>"
897,"<|endoftext|>Find the distance between two keys in a binary tree, no parent pointers are given. The distance between two nodes is the minimum number of edges to be traversed to reach one node from another.


 :# Python Program to find distance between
# n1 and n2 using one traversal
 
class Node:
    def __init__(self, data):
        self.data = data
        self.right = None
        self.left = None
 
def pathToNode(root, path, k):
 
    # base case handling
    if root is None:
        return False
 
     # append the node value in path
    path.append(root.data)
  
    # See if the k is same as root's data
    if root.data == k :
        return True
  
    # Check if k is found in left or right
    # sub-tree
    if ((root.left != None and pathToNode(root.left, path, k)) or
            (root.right!= None and pathToNode(root.right, path, k))):
        return True
  
    # If not present in subtree rooted with root,
    # remove root from path and return False
    path.pop()
    return False
 
def distance(root, data1, data2):
    if root:
        # store path corresponding to node: data1
        path1 = []
        pathToNode(root, path1, data1)
 
        # store path corresponding to node: data2
        path2 = []
        pathToNode(root, path2, data2)
 
        # iterate through the paths to find the
        # common path length
        i=0
        while i<len(path1) and i<len(path2):
            # get out as soon as the path differs
            # or any path's length get exhausted
            if path1[i] != path2[i]:
                break
            i = i+1
 
        # get the path length by deducting the
        # intersecting path length (or till LCA)
        return (len(path1)+len(path2)-2*i)
    else:
        return 0
 
# Driver Code to test above functions
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.right.right= Node(7)
root.right.left = Node(6)
root.left.right = Node(5)
root.right.left.right = Node(8)
 
dist = distance(root, 4, 5)
print (""Distance between node {} & {}: {}"".format(4, 5, dist))
 
dist = distance(root, 4, 6)
print (""Distance between node {} & {}: {}"".format(4, 6, dist))
 
dist = distance(root, 3, 4)
print (""Distance between node {} & {}: {}"".format(3, 4, dist))
 
dist = distance(root, 2, 4)
print (""Distance between node {} & {}: {}"".format(2, 4, dist))
 
dist = distance(root, 8, 5)
print (""Distance between node {} & {}: {}"".format(8, 5, dist))
 
# This program is contributed by Aartee
<|endoftext|>"
898,"<|endoftext|>Create a function that returns any of the items you can afford in the store with the money you have in your wallet. Sort the list in alphabetical order.
Examples
items_purchase({
  ""Water"": ""$1"",
  ""Bread"": ""$3"",
  ""TV"": ""$1,000"",
  ""Fertilizer"": ""$20""
}, ""$300"") ➞ [""Bread"", ""Fertilizer"", ""Water""]

items_purchase({
  ""Apple"": ""$4"",
  ""Honey"": ""$3"",
  ""Fan"": ""$14"",
  ""Bananas"": ""$4"",
  ""Pan"": ""$100"",
  ""Spoon"": ""$2""
  }, ""$100"") ➞ [""Apple"", ""Bananas"", ""Fan"", ""Honey"", ""Pan"", ""Spoon""]

items_purchase({
  ""Phone"": ""$999"",
  ""Speakers"": ""$300"",
  ""Laptop"": ""$5,000"",
  ""PC"": ""$1200""},
""$1"") ➞ ""Nothing""
Notes
Return ""Nothing"" if you can't afford anything from the store.:def val(s):
  return int(s.replace('$','').replace(',',''))
def items_purchase(store, wallet):
  return sorted([item for item in store if val(store[item])<=val(wallet)]) or 'Nothing'<|endoftext|>"
899,"<|endoftext|>Instructions
A complex number is a number in the form a + b * i where a and b are real and i satisfies i^2 = -1.

a is called the real part and b is called the imaginary part of z. The conjugate of the number a + b * i is the number a - b * i. The absolute value of a complex number z = a + b * i is a real number |z| = sqrt(a^2 + b^2). The square of the absolute value |z|^2 is the result of multiplication of z by its complex conjugate.

The sum/difference of two complex numbers involves adding/subtracting their real and imaginary parts separately: (a + i * b) + (c + i * d) = (a + c) + (b + d) * i, (a + i * b) - (c + i * d) = (a - c) + (b - d) * i.

Multiplication result is by definition (a + i * b) * (c + i * d) = (a * c - b * d) + (b * c + a * d) * i.

The reciprocal of a non-zero complex number is 1 / (a + i * b) = a/(a^2 + b^2) - b/(a^2 + b^2) * i.

Dividing a complex number a + i * b by another c + i * d gives: (a + i * b) / (c + i * d) = (a * c + b * d)/(c^2 + d^2) + (b * c - a * d)/(c^2 + d^2) * i.

Raising e to a complex exponent can be expressed as e^(a + i * b) = e^a * e^(i * b), the last term of which is given by Euler's formula e^(i * b) = cos(b) + i * sin(b).

Implement the following operations:

addition, subtraction, multiplication and division of two complex numbers,
conjugate, absolute value, exponent of a given complex number.
Assume the programming language you are using does not have an implementation of complex numbers.

Building a Numeric Type
See Emulating numeric types for help on operator overloading and customization.:from math import cos, e, sin, sqrt
class ComplexNumber:
    @classmethod
    def real2complex(cls, real):
        imaginary = 0
        return ComplexNumber(real, imaginary)
    def __init__(self, real, imaginary):
        self.real = real
        self.imaginary = imaginary
    def __eq__(self, other):
        if not isinstance(other, ComplexNumber):
            other = ComplexNumber.real2complex(other)
        return self.real == other.real and self.imaginary == other.imaginary
    def __add__(self, other):
        if not isinstance(other, ComplexNumber):
            other = ComplexNumber.real2complex(other)
        real = self.real + other.real
        imaginary = self.imaginary + other.imaginary
        return ComplexNumber(real, imaginary)
    def __radd__(self, other):
        return self.__add__(other)
    def __mul__(self, other):
        if not isinstance(other, ComplexNumber):
            other = ComplexNumber.real2complex(other)
        a, b, c, d = self.real, self.imaginary, other.real, other.imaginary
        real = (a * c - b * d)
        imaginary = (b * c + a * d)
        return ComplexNumber(real, imaginary)
    def __rmul__(self, other):
        return self.__mul__(other)
    def __neg__(self):
        return ComplexNumber(-self.real, -self.imaginary)
    def __sub__(self, other):
        if not isinstance(other, ComplexNumber):
            other = ComplexNumber.real2complex(other)
        real = self.real - other.real
        imaginary = self.imaginary - other.imaginary
        return ComplexNumber(real, imaginary)
    def __rsub__(self, other):
        return self.__neg__().__add__(other)
    def __truediv__(self, other):
        if not isinstance(other, ComplexNumber):
            other = ComplexNumber.real2complex(other)
        a, b, c, d = self.real, self.imaginary, other.real, other.imaginary
        real = (a * c + b * d) / (c**2 + d**2)
        imaginary = (b * c - a * d) / (c**2 + d**2)
        return ComplexNumber(real, imaginary)
    def __rtruediv__(self, other):
        if not isinstance(other, ComplexNumber):
            other = ComplexNumber.real2complex(other)
        a, b, c, d = other.real, other.imaginary, self.real, self.imaginary
        real = (a * c + b * d) / (c**2 + d**2)
        imaginary = (b * c - a * d) / (c**2 + d**2)
        return ComplexNumber(real, imaginary)
    def __abs__(self):
        return sqrt(self.real**2 + self.imaginary**2)
    def conjugate(self):
        real = self.real
        imaginary = -self.imaginary
        return ComplexNumber(real, imaginary)
    def exp(self):
        a, b = self.real, self.imaginary
        real = e**a * cos(b)
        imaginary = e**a * sin(b)
        return ComplexNumber(real, imaginary)
<|endoftext|>"
900,"<|endoftext|>The program creates a d-ary max-heap and presents a menu to the user to perform various operations on it.:class D_aryHeap:
    def __init__(self, d):
        self.items = []
        self.d = d
 
    def size(self):
        return len(self.items)
 
    def parent(self, i):
        return (i - 1)//self.d
 
    def child(self, index, position):
        return index*self.d + (position + 1)
 
    def get(self, i):
        return self.items[i]
 
    def get_max(self):
        if self.size() == 0:
            return None
        return self.items[0]
 
    def extract_max(self):
        if self.size() == 0:
            return None
        largest = self.get_max()
        self.items[0] = self.items[-1]
        del self.items[-1]
        self.max_heapify(0)
        return largest
 
    def max_heapify(self, i):
        largest = i
        for j in range(self.d):
            c = self.child(i, j)
            if (c < self.size() and self.get(c) > self.get(largest)):
                largest = c
        if (largest != i):
            self.swap(largest, i)
            self.max_heapify(largest)
 
    def swap(self, i, j):
        self.items[i], self.items[j] = self.items[j], self.items[i]
 
    def insert(self, key):
        index = self.size()
        self.items.append(key)
        while (index != 0):
            p = self.parent(index)
            if self.get(p) < self.get(index):
                self.swap(p, index)
            index = p
 
 
d = int(input('Enter the value of D: '));
dheap = D_aryHeap(d)
 
print('Menu (this assumes no duplicate keys)')
print('insert <data>')
print('max get')
print('max extract')
print('quit')
 
while True:
    do = input('What would you like to do? ').split()
 
    operation = do[0].strip().lower()
    if operation == 'insert':
        data = int(do[1])
        dheap.insert(data)
    elif operation == 'max':
        suboperation = do[1].strip().lower()
        if suboperation == 'get':
            print('Maximum value: {}'.format(dheap.get_max()))
        elif suboperation == 'extract':
            print('Maximum value removed: {}'.format(dheap.extract_max()))
 
    elif operation == 'quit':
        break<|endoftext|>"
901,"<|endoftext|>Find the Greatest Digit in a Number Using list() Function (User input):#Give the number as user input using int(input()) and store it in a variable.
gvn_num = int(input(""Enter some random number = ""))
# Convert the given number into string using str() function and
# store it in another variable. 
str_numbr = str(gvn_num)
# Convert the above obtained string number into list of digits using bulit-in list()
# method and store it in another variable.
lst = list(str_numbr)
# Find the maximum of list of digits using bulit-in max() function
# and store it in another variable.
maxim_digit = max(lst)
# Print the greatest digit in a given number.
print(""The maximum digit in given number {"", gvn_num, ""} = "", maxim_digit)<|endoftext|>"
902,"<|endoftext|>The program prompts the user for the number of disks n and the program prints the procedure to move n disks from peg A to peg C using peg B.:def hanoi(disks, source, auxiliary, target):
    if disks == 1:
        print('Move disk 1 from peg {} to peg {}.'.format(source, target))
        return
 
    hanoi(disks - 1, source, target, auxiliary)
    print('Move disk {} from peg {} to peg {}.'.format(disks, source, target))
    hanoi(disks - 1, auxiliary, source, target)
 
 
disks = int(input('Enter number of disks: '))
hanoi(disks, 'A', 'B', 'C')<|endoftext|>"
903,"<|endoftext|>ASCII Table in Python | In this post, we will develop a Python program to print the ASCII table using the chr() function. ASCII stands for American Standard Code for Information Interchange. It was developed by the ANSI (American National Standards Institute) and it is used to interchange the information from a high-level language to low-level language. Machine or Computer understand only binary languages. So, the character data type represents integers. For example, the ASCII value of the letter ‘A’ is 65.:# Python program to print ASCII table # print ASCII table from 0 to 255 for i in range(256): ch = chr(i) print('ASCII value of', i, 'is =', ch)<|endoftext|>"
904,"<|endoftext|>Files in Python:

One of the most important subjects for programmers and automation testers is Python file handling (also known as File I/O). It is necessary to work with files in order to write to or read data from them.

Also, if you didn’t know, I/O operations are the most expensive processes where a programme can go wrong. As a result, you must use extreme caution while implementing file processing for reporting or any other reason. Optimizing a single file action can help in the creation of a high-performing application or a reliable automated software testing solution.



Consider the following scenario: you’re planning to construct a large Python project with a large number of workflows. Then it’s unavoidable that you don’t make a log file. You’ll also be handling the log file’s read and write activities. Debugging huge applications with log files is a terrific way to go. It’s usually better to consider a scalable design from the start, as you won’t be sorry later if you didn’t.

File close() Method in Python:

The close() function is a built-in Python method that is used to flush and close the IO object (file). It has no effect if we close a closed file.

Syntax:

fileobject.close()
Parameters: This method has no arguments

Return Value: This method doesn’t return anything. This method’s return type is <class ‘NoneType’>, which means it returns nothing.:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in write mode. In this case, we're writing the contents into the file.
gvn_file = open(givenFilename, 'w') 
# Print some random text for acknowledgment
print(""your file is opened now!"")
# Print the given file
print(gvn_file)
# Close the given file using the close() function
gvn_file.close()
# Print some random text for acknowledgment
print(""your file is closed now!"")<|endoftext|>"
905,"<|endoftext|>Given the base of the isosceles triangle, the task is to find the count of the maximum number of 2*2 squares required that can be fixed inside the given isosceles triangle.

The side of the square must be parallel to the base of the given isosceles triangle.:# Create a function to say count_Squares() which takes the given base of the isosceles
# triangle as an argument and returns the count of the maximum number of 2*2
# squares required that can be fixed inside the given isosceles triangle.


def count_Squares(gvn_trianglebase):
    # Inside the function, subtract 2 from the given base value as it is the extra part.
    # Store it in the same variable.

    gvn_trianglebase = (gvn_trianglebase - 2)
    # Divide the given base of the triangle by 2 since each square has a base length of 2.
    # Store it in the same variable.
    gvn_trianglebase = gvn_trianglebase // 2
    # Calculate the value of gvn_trianglebase * (gvn_trianglebase + 1) / 2
    # (Mathematical Formula) and store it in another variable.
    rslt = gvn_trianglebase * (gvn_trianglebase + 1) // 2
    # Return the above result which is the count of the maximum number of 2*2 squares
    # required that can be fixed inside the given isosceles triangle.
    return rslt


# Give the base of the triangle as static input and store it in a variable.
gvn_trianglebase = 6
# Pass the given base of the isosceles triangle to the count_Squares() function
# and print it.
print(""The maximum number of 2*2 squares required that can be fixed inside the given isosceles triangle = "",
      count_Squares(gvn_trianglebase))<|endoftext|>"
906,"<|endoftext|>Implement a Queue Data Structure in Python.The difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added.

Operations on Queue: 
Enqueue: Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition. 
Dequeue: Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition. 
Front: Get the front item from queue. 
Rear: Get the last item from queue. 


 :# Python3 program for array implementation of queue
 
# Class Queue to represent a queue
class Queue:
 
    # __init__ function
    def __init__(self, capacity):
        self.front = self.size = 0
        self.rear = capacity -1
        self.Q = [None]*capacity
        self.capacity = capacity
     
    # Queue is full when size becomes
    # equal to the capacity
    def isFull(self):
        return self.size == self.capacity
     
    # Queue is empty when size is 0
    def isEmpty(self):
        return self.size == 0
 
    # Function to add an item to the queue.
    # It changes rear and size
    def EnQueue(self, item):
        if self.isFull():
            print(""Full"")
            return
        self.rear = (self.rear + 1) % (self.capacity)
        self.Q[self.rear] = item
        self.size = self.size + 1
        print(""% s enqueued to queue""  % str(item))
 
    # Function to remove an item from queue.
    # It changes front and size
    def DeQueue(self):
        if self.isEmpty():
            print(""Empty"")
            return
         
        print(""% s dequeued from queue"" % str(self.Q[self.front]))
        self.front = (self.front + 1) % (self.capacity)
        self.size = self.size -1
         
    # Function to get front of queue
    def que_front(self):
        if self.isEmpty():
            print(""Queue is empty"")
 
        print(""Front item is"", self.Q[self.front])
         
    # Function to get rear of queue
    def que_rear(self):
        if self.isEmpty():
            print(""Queue is empty"")
        print(""Rear item is"",  self.Q[self.rear])
 
 
# Driver Code
if __name__ == '__main__':
 
    queue = Queue(30)
    queue.EnQueue(10)
    queue.EnQueue(20)
    queue.EnQueue(30)
    queue.EnQueue(40)
    queue.DeQueue()
    queue.que_front()
    queue.que_rear()
<|endoftext|>"
907,"<|endoftext|>Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers which has negative and positive numbers.

Examples: 

Input: a[] = {20, -5, -1} 
         k = 3
Output: 14
Explanation: All sum of contiguous 
subarrays are (20, 15, 14, -5, -6, -1) 
so the 3rd largest sum is 14.

Input: a[] = {10, -10, 20, -40} 
         k = 6
Output: -10 
Explanation: The 6th largest sum among 
sum of all contiguous subarrays is -10.:# Python program to find the k-th largest sum
# of subarray
import heapq

# function to calculate kth largest element
# in contiguous subarray sum
def kthLargestSum(arr, n, k):
	
	# array to store prefix sums
	sum = []
	sum.append(0)
	sum.append(arr[0])
	for i in range(2, n + 1):
		sum.append(sum[i - 1] + arr[i - 1])
		
	# priority_queue of min heap
	Q = []
	heapq.heapify(Q)
	
	# loop to calculate the contiguous subarray
	# sum position-wise
	for i in range(1, n + 1):
		
		# loop to traverse all positions that
		# form contiguous subarray
		for j in range(i, n + 1):
			x = sum[j] - sum[i - 1]
			
			# if queue has less then k elements,
			# then simply push it
			if len(Q) < k:
				heapq.heappush(Q, x)
			else:
				# it the min heap has equal to
				# k elements then just check
				# if the largest kth element is
				# smaller than x then insert
				# else its of no use
				if Q[0] < x:
					heapq.heappop(Q)
					heapq.heappush(Q, x)
	
	# the top element will be then kth
	# largest element
	return Q[0]

# Driver program to test above function
a = [10,-10,20,-40]
n = len(a)
k = 6

# calls the function to find out the
# k-th largest sum
print(kthLargestSum(a,n,k))


# This code is contributed by Kumar Suman<|endoftext|>"
908,"<|endoftext|>Let's say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome.

Given two positive integers left and right represented as strings, return the number of super-palindromes integers in the inclusive range [left, right].

 

Example 1:

Input: left = ""4"", right = ""1000""
Output: 4
Explanation: 4, 9, 121, and 484 are superpalindromes.
Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.
Example 2:

Input: left = ""1"", right = ""2""
Output: 1
 

Constraints:

1 <= left.length, right.length <= 18
left and right consist of only digits.
left and right cannot have leading zeros.
left and right represent integers in the range [1, 1018 - 1].
left is less than or equal to right.:class Solution(object):
    def superpalindromesInRange(self, L, R):
        L, R = int(L), int(R)
        MAGIC = 100000

        def reverse(x):
            ans = 0
            while x:
                ans = 10 * ans + x % 10
                x /= 10
            return ans

        def is_palindrome(x):
            return x == reverse(x)

        ans = 0

        # count odd length
        for k in xrange(MAGIC):
            s = str(k)  # Eg. s = '1234'
            t = s + s[-2::-1]  # t = '1234321'
            v = int(t) ** 2
            if v > R: break
            if v >= L and is_palindrome(v):
                ans += 1

        # count even length
        for k in xrange(MAGIC):
            s = str(k)  # Eg. s = '1234'
            t = s + s[::-1]  # t = '12344321'
            v = int(t) ** 2
            if v > R: break
            if v >= L and is_palindrome(v):
                ans += 1

        return ans<|endoftext|>"
909,"<|endoftext|>You can assign variables from lists like this:
lst = [1, 2, 3, 4, 5, 6]
first = lst[0]
middle = lst[1:-1]
last = lst[-1]

print(first) ➞ outputs 1
print(middle) ➞ outputs [2, 3, 4, 5]
print(last) ➞ outputs 6
With Python 3, you can assign variables from lists in a much more succinct way. Create variables first, middle and last from the given list using destructuring assignment (check the Resources tab for some examples), where:
first  ➞ 1

middle ➞ [2, 3, 4, 5]

last ➞ 6
Your task is to unpack the list writeyourcodehere into three variables, being first, middle, and last, with middle being everything in between the first and last element. Then print all three variables.
Notes
Your solution should be just one line of code.
If your solution is longer than one line of code, please review the Resources tab.:first, *middle, last = [1, 2, 3, 4, 5, 6]<|endoftext|>"
910,"<|endoftext|>A Bagging classifier is an ensemble meta-estimator that fits base classifiers each on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a black-box estimator (e.g., a decision tree), by introducing randomization into its construction procedure and then making an ensemble out of it.
Each base classifier is trained in parallel with a training set which is generated by randomly drawing, with replacement, N examples(or data) from the original training dataset – where N is the size of the original training set. Training set for each of the base classifiers is independent of each other. Many of the original data may be repeated in the resulting training set while others may be left out.

Bagging reduces overfitting (variance) by averaging or voting, however, this leads to an increase in bias, which is compensated by the reduction in variance though.

How Bagging works on training dataset ?
How bagging works on an imaginary training dataset is shown below. Since Bagging resamples the original training dataset with replacement, some instance(or data) may be present multiple times while others are left out.

Original training dataset: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10

Resampled training set 1: 2, 3, 3, 5, 6, 1, 8, 10, 9, 1
Resampled training set 2: 1, 1, 5, 6, 3, 8, 9, 10, 2, 7
Resampled training set 3: 1, 5, 8, 9, 2, 10, 9, 7, 5, 4

Algorithm for the Bagging classifier:

Classifier generation:

Let N be the size of the training set.
for each of t iterations:
    sample N instances with replacement from the original training set.
    apply the learning algorithm to the sample.
    store the resulting classifier.

Classification:
for each of the t classifiers:
    predict class of instance using classifier.
return class that was predicted most often.:from sklearn import model_selection
from sklearn.ensemble import BaggingClassifier
from sklearn.tree import DecisionTreeClassifier
import pandas as pd

# load the data
url = ""/home/debomit/Downloads/wine_data.xlsx""
dataframe = pd.read_excel(url)
arr = dataframe.values
X = arr[:, 1:14]
Y = arr[:, 0]

seed = 8
kfold = model_selection.KFold(n_splits = 3,
					random_state = seed)

# initialize the base classifier
base_cls = DecisionTreeClassifier()

# no. of base classifier
num_trees = 500

# bagging classifier
model = BaggingClassifier(base_estimator = base_cls,
						n_estimators = num_trees,
						random_state = seed)

results = model_selection.cross_val_score(model, X, Y, cv = kfold)
print(""accuracy :"")
print(results.mean())<|endoftext|>"
911,"<|endoftext|>Given a 2D array, print it in spiral form. See the following examples.:def spiralOrder(matrix):
	ans = []

	if (len(matrix) == 0):
		return ans

	R = len(matrix)
	C = len(matrix[0])
	seen = [[0 for i in range(C)] for j in range(R)]
	dr = [0, 1, 0, -1]
	dc = [1, 0, -1, 0]
	r = 0
	c = 0
	di = 0

	# Iterate from 0 to R * C - 1
	for i in range(R * C):
		ans.append(matrix[r])
		seen[r] = True
		cr = r + dr[di]
		cc = c + dc[di]

		if (0 <= cr and cr < R and 0 <= cc and cc < C and not(seen[cr][cc])):
			r = cr
			c = cc
		else:
			di = (di + 1) % 4
			r += dr[di]
			c += dc[di]
	return ans


# Driver code
a = [[1, 2, 3, 4],
	[5, 6, 7, 8],
	[9, 10, 11, 12],
	[13, 14, 15, 16]]

for x in spiralOrder(a):
	print(x, end="" "")
print()
<|endoftext|>"
912,"<|endoftext|>Instructions
You're a teaching assistant correcting student exams. Keeping track of results manually is getting both tedious and mistake-prone. You decide to make things a little more interesting by putting together some functions to count and calculate results for the class.

1. Rounding Scores
While you can give ""partial credit"" on exam questions, overall exam scores have to be ints. So before you can do anything else with the class scores, you need to go through the grades and turn any float scores into ints. Lucky for you, Python has the built-in round() function you can use.

A score of 75.45 or 75.49 will round to 75. A score of 40.50 will round to 40. A score of 43.50 (or above) will round to 44. There shouldn't be any scores that have more than two places after the decimal point.

Create the function round_scores() that takes a list of student_scores. This function should consume the input list and return a new list with all the scores converted to ints. The order of the scores in the resulting list is not important.

>>> student_scores = [90.33, 40.5, 55.44, 70.05, 30.55, 25.45, 80.45, 95.3, 38.7, 40.3]
>>> round_scores(student_scores)
...
[40, 39, 95, 80, 25, 31, 70, 55, 40, 90]
2. Non-Passing Students
As you were grading the exam, you noticed some students weren't performing as well as you'd hoped. But you were distracted, and forgot to note exactly how many students.

Create the function count_failed_students() that takes a list of student_scores. This function should count up the number of students who don't have passing scores and return that count as an integer. A student needs a score greater than 40 to achieve a passing grade on the exam.

>>> count_failed_students(student_scores=[90,40,55,70,30,25,80,95,38,40])
5
3. The ""Best""
The teacher you're assisting wants to find the group of students who've performed ""the best"" on this exam. What qualifies as ""the best"" fluctuates, so you need to find the student scores that are greater than or equal to the current threshold.

Create the function above_threshold() taking student_scores (a list of grades), and threshold (the ""top score"" threshold) as parameters. This function should return a list of all scores that are >= to threshold.

>>> above_threshold(student_scores=[90,40,55,70,30,68,70,75,83,96], threshold=75)
[90,75,83,96]
4. Calculating Letter Grades
The teacher you're assisting likes to assign letter grades as well as numeric scores. Since students rarely score 100 on an exam, the ""letter grade"" lower thresholds are calculated based on the highest score achieved, and increment evenly between the high score and the failing threshold of <= 40.

Create the function letter_grades() that takes the ""highest"" score on the exam as a parameter, and returns a list of lower score thresholds for each ""American style"" grade interval: [""D"", ""C"", ""B"", ""A""].

""""""Where the highest score is 100, and failing is <= 40.
       ""F"" <= 40
 41 <= ""D"" <= 55
 56 <= ""C"" <= 70
 71 <= ""B"" <= 85
 86 <= ""A"" <= 100
""""""

>>> letter_grades(highest=100)
[41, 56, 71, 86]


""""""Where the highest score is 88, and failing is <= 40.
       ""F"" <= 40
 41 <= ""D"" <= 52
 53 <= ""C"" <= 64
 65 <= ""B"" <= 76
 77 <= ""A"" <= 88
""""""

>>> letter_grades(highest=88)
[41, 53, 65, 77]
5. Matching Names to Scores
You have a list of exam scores in descending order, and another list of student names also sorted in descending order by their exam scores. You would like to match each student name with their exam score and print out an overall class ranking.

Create the function student_ranking() with parameters student_scores and student_names. Match each student name on the student_names list with their score from the student_scores list. You can assume each argument list will be sorted from highest score(er) to lowest score(er). The function should return a list of strings with the format <rank>. <student name>: <student score>.

>>> student_scores = [100, 99, 90, 84, 66, 53, 47]
>>> student_names =  ['Joci', 'Sara','Kora','Jan','John','Bern', 'Fred']
>>> student_ranking(student_scores, student_names)
...
['1. Joci: 100', '2. Sara: 99', '3. Kora: 90', '4. Jan: 84', '5. John: 66', '6. Bern: 53', '7. Fred: 47']
6. A ""Perfect"" Score
Although a ""perfect"" score of 100 is rare on an exam, it is interesting to know if at least one student has achieved it.

Create the function perfect_score() with parameter student_info. student_info is a list of lists containing the name and score of each student: [[""Charles"", 90], [""Tony"", 80]]. The function should return the first [<name>, <score>] pair of the student who scored 100 on the exam.

If no 100 scores are found in student_info, an empty list [] should be returned.

>>> perfect_score(student_info=[[""Charles"", 90], [""Tony"", 80], [""Alex"", 100]])
[""Alex"", 100]

>>> perfect_score(student_info=[[""Charles"", 90], [""Tony"", 80]])
[]:def round_scores(student_scores):
    """"""
    :param student_scores: list of student exam scores as float or int.
    :return: list of student scores *rounded* to nearest integer value.
    """"""
    return [round(item) for item in student_scores]
    
def count_failed_students(student_scores):
    """"""
    :param student_scores: list of integer student scores.
    :return: integer count of student scores at or below 40.
    """"""
    return sum(1 for score in round_scores(student_scores) if score <= 40)
    
def above_threshold(student_scores, threshold):
    """"""
    :param student_scores: list of integer scores
    :param threshold :  integer
    :return: list of integer scores that are at or above the ""best"" threshold.
    """"""
    best = []
    for score in student_scores:
        if score >= threshold:
            best.append(score)
    return best
def letter_grades(highest):
    """"""
    :param highest: integer of highest exam score.
    :return: list of integer lower threshold scores for each D-A letter grade interval.
             For example, where the highest score is 100, and failing is <= 40,
             The result would be [41, 56, 71, 86]:
 
             41 <= ""D"" <= 55
             56 <= ""C"" <= 70
             71 <= ""B"" <= 85
             86 <= ""A"" <= 100
    """"""
    step = int((highest-40)/4)
    return [41 + step*i for i in range(4)]
def student_ranking(student_scores, student_names):
    """"""
     :param student_scores: list of scores in descending order.
     :param student_names: list of names in descending order by exam score.
     :return: list of strings in format [""<rank>. <student name>: <score>""].
     """"""
    rank = list()
    for i in range(len(student_scores)):
        rank.append(""{}. {}: {}"".format(i+1,student_names[i],student_scores[i]))
    return rank
def perfect_score(student_info):
    """"""
    :param student_info: list of [<student name>, <score>] lists
    :return: first `[<student name>, 100]` or `[]` if no student score of 100 is found.
    """"""
    for student in student_info:
        if student[1] == 100:
            return student
    return []<|endoftext|>"
913,"<|endoftext|>Generate Strong Numbers in an Interval (Static input):# Import the math module using import keyword.
import math
# Give the lower limit range as static input and store it in a variable.
gvn_lower_lmt = 1
# Give the upper limit range as static input and store it in another variable.
gvn_upper_lmt = 200
# Loop from lower limit range to upper limit range using For loop.
print(""The Strong Numbers in a given range"",
      gvn_lower_lmt, ""and"", gvn_upper_lmt, ""are :"")
for itr in range(gvn_lower_lmt, gvn_upper_lmt+1):
   # Taking a variable totalSum and initializing it with 0
    totalSum = 0
    # Put the iterator value in a temporary variable called tempNum.
    tempNum = itr
    # using while to extract digit by digit of the given iterator value
    while(itr):
        s = 1
        factNum = 1
        # Getting the last digit of the iterator value
        remainder = itr % 10
        # calculating the factorial of the digit(extracted by remainder variable)
        # using math.fatorial function
        factNum = math.factorial(remainder)
        # Adding the factorial to the totalSum
        totalSum = totalSum + factNum
        # Dividing the given itertor value by 10
        itr = itr//10
    # checking if the totalSum is equal to the iterator value
    # if it is true then it is strong number then return true
    if(totalSum == tempNum):
        print(tempNum, end=' ')<|endoftext|>"
914,"<|endoftext|>MS Excel columns have a pattern like A, B, C, …, Z, AA, AB, AC, …., AZ, BA, BB, … ZZ, AAA, AAB ….. etc. In other words, column 1 is named as “A”, column 2 as “B”, column 27 as “AA”.
Given a column number, find its corresponding Excel column name. The following are more examples.

Input          Output
 26             Z
 51             AY
 52             AZ
 80             CB
 676            YZ
 702            ZZ
 705            AAC:# Python program to find Excel column name from a
# given column number

MAX = 50

# Function to print Excel column name
# for a given column number
def printString(n):

	# To store result (Excel column name)
	string = [""\0""] * MAX

	# To store current index in str which is result
	i = 0

	while n > 0:
		# Find remainder
		rem = n % 26

		# if remainder is 0, then a
		# 'Z' must be there in output
		if rem == 0:
			string[i] = 'Z'
			i += 1
			n = (n / 26) - 1
		else:
			string[i] = chr((rem - 1) + ord('A'))
			i += 1
			n = n / 26
	string[i] = '\0'

	# Reverse the string and print result
	string = string[::-1]
	print """".join(string)

# Driver program to test the above Function
printString(26)
printString(51)
printString(52)
printString(80)
printString(676)
printString(702)
printString(705)

# This code is contributed by BHAVYA JAIN<|endoftext|>"
915,"<|endoftext|>Given an array of n positive integers. Write a program to find the sum of maximum sum subsequence of the given array such that the integers in the subsequence are sorted in increasing order.:# Dynamic Programming based Python
# implementation of Maximum Sum
# Increasing Subsequence (MSIS)
# problem

# maxSumIS() returns the maximum
# sum of increasing subsequence
# in arr[] of size n
def maxSumIS(arr, n):
	max = 0
	msis = [0 for x in range(n)]

	# Initialize msis values
	# for all indexes
	for i in range(n):
		msis[i] = arr[i]

	# Compute maximum sum
	# values in bottom up manner
	for i in range(1, n):
		for j in range(i):
			if (arr[i] > arr[j] and
				msis[i] < msis[j] + arr[i]):
				msis[i] = msis[j] + arr[i]

	# Pick maximum of
	# all msis values
	for i in range(n):
		if max < msis[i]:
			max = msis[i]

	return max

# Driver Code
arr = [1, 101, 2, 3, 100, 4, 5]
n = len(arr)
print(""Sum of maximum sum increasing "" +
					""subsequence is "" +
				str(maxSumIS(arr, n)))

# This code is contributed
# by Bhavya Jain<|endoftext|>"
916,"<|endoftext|>Given a string and the task is to check whether the given string contains at least one number in it.:# Give the string as user input using the input() function and
# store it in a variable.
gvn_str = input(""Enter some random String = "")
# Take a variable say k and initialize its value to 0.
k = 0
# Calculate the length of the given string using the len() function.
# store it in another variable.
str_lengt = len(gvn_str)
# Loop from 0 to the length of the given string using the for loop.
for itr in range(0, str_lengt):
  # Check if the character present at the iterator value of the given string string is
  # greater than or equal to 0 and less than or equal to 9 using the if
  # conditional statement.
    if gvn_str[itr] >= '0' and gvn_str[itr] <= '9':
        # If the statement is true, then increment the value of the above-initialized k by 1.
        # Exit the loop.
        k += 1
# Check if the value of k is greater than or equal to 1 using the if conditional statement.
if k >= 1:
    # If the statement is true, then print ""Yes, the above-given string has at least one
    # digit in it"".
    print(""Yes, the above given string has at least one digit in it"")
else:
    # Else print ""No, the above-given string doesn't have at least one digit in it"".
    print(""No, the above-given string doesn't have at least one digit in it"")<|endoftext|>"
917,"<|endoftext|>Print all Happy Numbers within a given Range (Static Input):# Create a function digitSquareSum() that accepts the given number
# as an argument and returns the sum of squares of digits.


def digitSquareSum(resltnumber):
    # Inside the digitSquareSum() function.
    # Convert the given argument to string using the str() function.
    strnumbe = str(resltnumber)
    # Convert the given argument into list of digits using list(),map(),int() functions.
    # Store it in a variable.
    numbrlistdigits = list(map(int, strnumbe))
    # Take a variable sumsquaredigits and initialize its value to 0.
    sumsquaredigits = 0
    # Loop in this digits list using For loop.
    for digitvalu in numbrlistdigits:
        # Increment the value of sumsquaredigits by the square
        # of the digit(iterator value).
        sumsquaredigits = sumsquaredigits+(digitvalu**2)
    # Return the sumsquaredigits value
    return sumsquaredigits

# Create a function checkhapppynumb() which accepts the number as an argument
# and returns true if it is happy number else returns False.


def checkhapppynumb(numb):
    # Take a variable rest and initialize its value to the given argument.
    rest = numb
    # Loop till the rest is not equal to 1 or 4 using while loop.
    while(rest != 1 and rest != 4):
        # Inside the loop pass the reslt value to digitSquareSum()
        # and store it in the same variable reslt.
        rest = digitSquareSum(rest)
    # After the end of the while loop,
    # Check whether rest value is 1 or not using the If statement.
    if(rest == 1):
        # If it is true then the given number is a happy number so return True
        return True
    else:
        # Else it is not a happy number so return False.
        return False


# Give the lower limit range as static input and store it in a variable.
lowlimrange = 19
# Give the upper limit range as static input and store it in another variable.
upplimrange = 145
print('The happy numbers in the given range',
      lowlimrange, 'and', upplimrange, 'are:')
# Loop from lower limit range to upper limit range using For loop.
for l in range(lowlimrange, upplimrange+1):
        # IInside the for loop pass the iterator value to checkhapppynumb() function.
    if(checkhapppynumb(l)):
        # If it returns true then print the iterator value.
        print(l, end=' ')<|endoftext|>"
918,"<|endoftext|>Access Items
You access the list items by referring to the index number::#Print the second item of the list:

thislist = [""apple"", ""banana"", ""cherry""]
print(thislist[1])<|endoftext|>"
919,"<|endoftext|>The following example shows how to use a default parameter value.

If we call the function without argument, it uses the default value::def my_function(country = ""Norway""):
  print(""I am from "" + country)

my_function(""Sweden"")
my_function(""India"")
my_function()
my_function(""Brazil"")<|endoftext|>"
920,"<|endoftext|>The Fibonacci numbers are the numbers in the following integer sequence.
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ……..

In mathematical terms, the sequence Fn of Fibonacci numbers is defined by the recurrence relation 

Fn = Fn-1 + Fn-2
with seed values 

F0 = 0 and F1 = 1.


Given a number n, print n-th Fibonacci Number. 

Examples: 

Input  : n = 2
Output : 1

Input  : n = 9
Output : 34:# Function for nth fibonacci number - Space Optimisation
# Taking 1st two fibonacci numbers as 0 and 1

def fibonacci(n):
	a = 0
	b = 1
	if n < 0:
		print(""Incorrect input"")
	elif n == 0:
		return a
	elif n == 1:
		return b
	else:
		for i in range(2,n+1):
			c = a + b
			a = b
			b = c
		return b

# Driver Program

print(fibonacci(9))

#This code is contributed by Saket Modi<|endoftext|>"
921,"<|endoftext|>Exercise 6: Delete a list of keys from a dictionary:sample_dict = {
    ""name"": ""Kelly"",
    ""age"": 25,
    ""salary"": 8000,
    ""city"": ""New york""
}
# Keys to remove
keys = [""name"", ""salary""]

sample_dict = {k: sample_dict[k] for k in sample_dict.keys() - keys}
print(sample_dict)<|endoftext|>"
922,"<|endoftext|>There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.
You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.
It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.
Return the original array nums. If there are multiple solutions, return any of them.
 
Example 1:

Input: adjacentPairs = [[2,1],[3,4],[3,2]]
Output: [1,2,3,4]
Explanation: This array has all its adjacent pairs in adjacentPairs.
Notice that adjacentPairs[i] may not be in left-to-right order.

Example 2:

Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]
Output: [-2,4,1,-3]
Explanation: There can be negative numbers.
Another solution is [-3,1,4,-2], which would also be accepted.

Example 3:

Input: adjacentPairs = [[100000,-100000]]
Output: [100000,-100000]

 
Constraints:

nums.length == n
adjacentPairs.length == n - 1
adjacentPairs[i].length == 2
2 <= n <= 105
-105 <= nums[i], ui, vi <= 105
There exists some nums that has adjacentPairs as its pairs.:def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
  adj, ans, n = defaultdict(list), [], len(adjacentPairs) + 1
  for a, b in adjacentPairs:
  adj[a] += [b]
  adj[b] += [a]
  prev = -math.inf
  for k, v in adj.items():
  if len(v) == 1:
  ans += [k]
  break
  while len(ans) < n:
  for next in adj.pop(ans[-1]):
  if next != prev:
  prev = ans[-1]
  ans += [next]
  break
  return ans<|endoftext|>"
923,"<|endoftext|>Given a N * N matrix and the task is to check matrix is idempotent matrix or not.


Idempotent matrix: A matrix is said to be idempotent matrix if matrix multiplied by itself return the same matrix. The matrix M is said to be idempotent matrix if and only if M * M = M. In idempotent matrix M is a square matrix.


 :# Python Program to check given matrix
# is idempotent matrix or not.
import math
 
# Function for matrix multiplication.
def multiply(mat, res):
 
    N= len(mat)
    for i in range(0,N):
     
        for j in range(0,N):
         
            res[i][j] = 0
            for k in range(0,N):
                res[i][j] += mat[i][k] * mat[k][j]
 
# Function to check idempotent
# property of matrix.
def checkIdempotent(mat):
 
    N= len(mat)
    # Calculate multiplication of matrix
    # with itself and store it into res.
    res =[[0]*N for i in range(0,N)]
    multiply(mat, res)
 
    for i in range(0,N):
        for j in range(0,N):    
            if (mat[i][j] != res[i][j]):
                return False
    return True
 
# driver Function
mat = [ [2, -2, -4],
        [-1, 3, 4],
        [1, -2, -3] ]
     
# checkIdempotent function call.
if (checkIdempotent(mat)):
    print(""Idempotent Matrix"")
else:
    print(""Not Idempotent Matrix."")
 
# This code is contributed by Gitanjali.
<|endoftext|>"
924,"<|endoftext|>Tuple in Python:
 Tuples, like Python lists, are a common data type that allows you to store values in a series. They could be handy in cases when you want to communicate data with someone but not enable them to change it. They can use the data values, but no change is reflected in the original data that was supplied.
 Examples:
 Example1:
 Input:
 given list of tuples =[(5, 12, 98), (7, 1), (4, 19, 11, 9), (36, 82, 19, 1, 2, 5, 3, 6, 9, 6)]
 Output:
 Printing the sorted list of tuples : 
 
 [(7, 1), (36, 82, 19, 1, 2, 5, 3, 6, 9, 6), (4, 19, 11, 9), (5, 12, 98)]
 Example2:
 Input:
   given list of tuples = [(7, 12, 23), (999, 4), (234, 245, 129), (10, 23, 456)]
 Output:
 Printing the sorted list of tuples : 
 
 [(999, 4), (7, 12, 23), (234, 245, 129), (10, 23, 456)]
 Example3:
 Input:
   given list of tuples = [('hello', 'this'), ('BTechGeeks', 'online', 'platform'), ('for', 'students')]
 Output:
 Printing the sorted list of tuples : 
 
 [('BTechGeeks', 'online', 'platform'), ('for', 'students'), ('hello', 'this')]:def lastEle(ele):
 
  # returning the last element
 
  return ele[-1]
 
 
 
 
 
 def sortlastElementTuple(listTuple):
 
  # using sorted function with first parameter as given list of tuples and
 
  # key as last element
 
  # To get last element we create a function which returns the last element
 
  # returning the sorted list of tuples
 
  return sorted(listTuple, key=lastEle)
 
 
 
 
 
 listofTuples = [(5, 12, 98), (7, 1), (4, 19, 11, 9),
 
  (36, 82, 19, 1, 2, 5, 3, 6, 9, 6)]
 
 # printing the sorted list of tuples by last element
 
 print(""Printing the sorted list of tuples : "")
 
 # Passing the given list of tuples to sortlastElementTuple function
 
 print(sortlastElementTuple(listofTuples))<|endoftext|>"
925,"<|endoftext|>Given an integer ‘x’, write a C function that returns true if binary representation of x is palindrome else return false.
For example a numbers with binary representation as 10..01 is palindrome and number with binary representation as 10..00 is not palindrome.
The idea is similar to checking a string is palindrome or not. We start from leftmost and rightmost bits and compare bits one by one. If we find a mismatch, then return false. 

Algorithm: 
isPalindrome(x) 
1) Find number of bits in x using sizeof() operator. 
2) Initialize left and right positions as 1 and n respectively. 
3) Do following while left ‘l’ is smaller than right ‘r’. 
..…..a) If bit at position ‘l’ is not same as bit at position ‘r’, then return false. 
..…..b) Increment ‘l’ and decrement ‘r’, i.e., do l++ and r–-. 
4) If we reach here, it means we didn’t find a mismatching bit.
To find the bit at a given position, we can use the idea similar to this post. The expression “x & (1 << (k-1))” gives us non-zero value if bit at k’th position from right is set and gives a zero value if if k’th bit is not set.:// C++ Program to Check if binary representation
// of a number is palindrome
#include<iostream>
using namespace std;

// This function returns true if k'th bit in x
// is set (or 1). For example if x (0010) is 2
// and k is 2, then it returns true
bool isKthBitSet(unsigned int x, unsigned int k)
{
	return (x & (1 << (k - 1))) ? true : false;
}

// This function returns true if binary
// representation of x is palindrome.
// For example (1000...001) is palindrome
bool isPalindrome(unsigned int x)
{
	int l = 1; // Initialize left position
	int r = sizeof(unsigned int) * 8; // initialize right position

	// One by one compare bits
	while (l < r)
	{
		if (isKthBitSet(x, l) != isKthBitSet(x, r))
			return false;
		l++; r--;
	}
	return true;
}

// Driver Code
int main()
{
	unsigned int x = 1 << 15 + 1 << 16;
	cout << isPalindrome(x) << endl;
	x = 1 << 31 + 1;
	cout << isPalindrome(x) << endl;
	return 0;
}
<|endoftext|>"
926,"<|endoftext|>Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

 

Example 1:


Input: board = [[""X"",""X"",""X"",""X""],[""X"",""O"",""O"",""X""],[""X"",""X"",""O"",""X""],[""X"",""O"",""X"",""X""]]
Output: [[""X"",""X"",""X"",""X""],[""X"",""X"",""X"",""X""],[""X"",""X"",""X"",""X""],[""X"",""O"",""X"",""X""]]
Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
Example 2:

Input: board = [[""X""]]
Output: [[""X""]]
 

Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 200
board[i][j] is 'X' or 'O'.:class Solution(object):
    def solve(self, board):
        """"""
        :type board: List[List[str]]
        :rtype: None Do not return anything, modify board in-place instead.
        """"""
        if not board or not board[0]:
            return

        self.ROWS = len(board)
        self.COLS = len(board[0])

        # Step 1). retrieve all border cells
        from itertools import product
        borders = list(product(range(self.ROWS), [0, self.COLS-1])) \
                + list(product([0, self.ROWS-1], range(self.COLS)))

        # Step 2). mark the ""escaped"" cells, with any placeholder, e.g. 'E'
        for row, col in borders:
            self.DFS(board, row, col)

        # Step 3). flip the captured cells ('O'->'X') and the escaped one ('E'->'O')
        for r in range(self.ROWS):
            for c in range(self.COLS):
                if board[r][c] == 'O':   board[r][c] = 'X'  # captured
                elif board[r][c] == 'E': board[r][c] = 'O'  # escaped


    def DFS(self, board, row, col):
        if board[row][col] != 'O':
            return
        board[row][col] = 'E'
        if col < self.COLS-1: self.DFS(board, row, col+1)
        if row < self.ROWS-1: self.DFS(board, row+1, col)
        if col > 0: self.DFS(board, row, col-1)
        if row > 0: self.DFS(board, row-1, col)<|endoftext|>"
927,"<|endoftext|>Given a list, and the task is to print all the elements from a given list that appears more than once in python.:# Take a dictionary and initialize it to empty
# using the {} or dict() say freqncyDictionary.
freqncyDictionary = {}
# Give the list as static input and store it in a variable.
gvnlst = [20, 30, 40, 50, 20, 50]
# Loop in the given list using the For loop.
for i in gvnlst:
        # Inside the For loop,
    # Check if the list element is present in the dictionary
    # or not using the if conditional statement and 'in' keyword.
    if i in freqncyDictionary.keys():
                # If it is true then increment the count of the list element
        # in the dictionary by 1.
        freqncyDictionary[i] = freqncyDictionary[i]+1
    # Else initialize the dictionary with the list element as key and value as 1.
    else:
        freqncyDictionary[i] = 1
# Take a new empty list say modifdlst and store it in a variable.
modifdlst = []
# Loop in the above calculated frequency dictionary using the For loop
for key in freqncyDictionary:
  # Check if the key in the freqncyDictionary having value greater than 1
  # using the if conditional statement.

    if(freqncyDictionary[key] > 1):
      # If it is true then append the key value to the above declared empty list modifdlst.
        modifdlst.append(key)
# Print all the elements from a given list that appears more than once.
print(""The Elements from a given list"", gvnlst,
      ""that appears more than once : "")
print(*modifdlst)<|endoftext|>"
928,"<|endoftext|>Given a string, the task is to check whether the given string contains all the unique characters in Python.

Examples:

Example1:

Input:

Given string =btech
Output:

The given string [ btech ] contains unique characters:# Import the Counter() function from collections using the import keyword.
from collections import Counter
# Give the string as static input and store it in a variable.
givenstrng = 'btech'
# Calculate the frequency of all the given string elements
# using the Counter() function which returns the element
# and its frequency as key-value pair and
# store this dictionary in a variable(say strngfreqelements)
strngfreqelements = Counter(givenstrng)
# Calculate the length of this frequency dictionary
# using the len() function and store it in a variable.
lengthfreq = len(strngfreqelements)
# Calculate the length of the given string using
# the len() function and store it in another variable.
lengthstrng = len(givenstrng)
# Check if both lengths are equal or not using the If conditional statement.
# If both lengths are equal then the given string contains all the unique characters.
if(lengthfreq == lengthstrng):
    print('The given string [', givenstrng, '] contains unique characters')
# Else the given string contains duplicate characters.
else:
    print('The given string [', givenstrng, '] contains duplicate characters')<|endoftext|>"
929,"<|endoftext|>Given n blocks of size 1*1, the task is to find the minimum perimeter of the grid made by these given n blocks in python.:# Import math module using the import keyword.
import math

# Create a function to say Minimum_perimtr() which takes the given n value as an
# argument and returns the minimum perimeter of the grid made by these given n blocks.
def Minimum_perimtr(gvn_n_val):
    # Calculate the square root of the given n value using the math.sqrt() function
    # and store it in a variable say sqrt_val.
    sqrt_val = math.sqrt(gvn_n_val)
    # Multiply the above result with itself and store it in another variable.
    sqre_rslt = sqrt_val * sqrt_val

    # Check if the given n value is a perfect square by using the if
    # conditional statement.
    if (sqre_rslt == gvn_n_val):
        # If it is true, then return the value of above sqrt_val multiplied by 4.
        return sqrt_val * 4
    else:
        # Else calculate the number of rows by dividing the given n value by sqrt_val.
        no_of_rows = gvn_n_val / sqrt_val

        # Add the above sqrt_val with the number of rows obtained and multiply the result
        # by 2 to get the perimeter of the rectangular grid.
        # Store it in another variable.
        rslt_perimetr = 2 * (sqrt_val + no_of_rows)

        # Check whether there are any blocks left using the if conditional statement.
        if (gvn_n_val % sqrt_val != 0):
            # If it is true, then add 2 to the above-obtained perimeter of the rectangular
                    # grid and store it in the same variable.
            rslt_perimetr += 2
        # Return the minimum perimeter of the grid made by the given n blocks.
        return rslt_perimetr


# Give the n value as static input and store it in a variable.
gvn_n_val = 6
# Pass the given n value as an argument to the Minimum_perimtr() function, convert
# it into an integer using the int() function and store it in another variable.
fnl_rslt = int(Minimum_perimtr(gvn_n_val))
# Print the above result which is the minimum perimeter of the grid made by the
# given n blocks.
print(
    ""The minimum perimeter of the grid made by the given n blocks{"", gvn_n_val, ""} = "", fnl_rslt)<|endoftext|>"
930,"<|endoftext|>A Multistage graph is a directed graph in which the nodes can be divided into a set of stages such that all edges are from a stage to next stage only (In other words there is no edge between vertices of same stage and from a vertex of current stage to previous stage).

We are given a multistage graph, a source and a destination, we need to find shortest path from source to destination. By convention, we consider source at stage 1 and destination as last stage.:# Python3 program to find shortest
# distance in a multistage graph.
 
# Returns shortest distance from
# 0 to N-1.
def shortestDist(graph):
    global INF
 
    # dist[i] is going to store shortest
    # distance from node i to node N-1.
    dist = [0] * N
 
    dist[N - 1] = 0
 
    # Calculating shortest path
    # for rest of the nodes
    for i in range(N - 2, -1, -1):
 
        # Initialize distance from 
        # i to destination (N-1)
        dist[i] = INF
 
        # Check all nodes of next stages
        # to find shortest distance from
        # i to N-1.
        for j in range(N):
             
            # Reject if no edge exists
            if graph[i][j] == INF:
                continue
 
            # We apply recursive equation to
            # distance to target through j.
            # and compare with minimum
            # distance so far.
            dist[i] = min(dist[i],
                          graph[i][j] + dist[j])
 
    return dist[0]
 
# Driver code
N = 8
INF = 999999999999
 
# Graph stored in the form of an
# adjacency Matrix
graph = [[INF, 1, 2, 5, INF, INF, INF, INF],
         [INF, INF, INF, INF, 4, 11, INF, INF],
         [INF, INF, INF, INF, 9, 5, 16, INF],
         [INF, INF, INF, INF, INF, INF, 2, INF],
         [INF, INF, INF, INF, INF, INF, INF, 18],
         [INF, INF, INF, INF, INF, INF, INF, 13],
         [INF, INF, INF, INF, INF, INF, INF, 2]]
 
print(shortestDist(graph))
 
# This code is contributed by PranchalK
<|endoftext|>"
931,"<|endoftext|>Given an array that contains the preorder traversal of the full k-ary tree, construct the full k-ary tree and print its postorder traversal. A full k-ary tree is a tree where each node has either 0 or k children.

Examples: 

Input : preorder[] = {1, 2, 5, 6, 7, 
                     3, 8, 9, 10, 4}
        k = 3
Output : Postorder traversal of constructed 
         full k-ary tree is: 5 6 7 2 8 9 10 
         3 4 1 
         Tree formed is:         1
                             /   |   \
                           2     3    4
                          /|\   /|\
                         5 6 7 8 9 10

Input : preorder[] = {1, 2, 5, 6, 7, 3, 4}
        k = 3 
Output : Postorder traversal of constructed 
         full k-ary tree is: 5 6 7 2 4 3 1
         Tree formed is:        1
                             /  |  \
                           2    3   4
                          /|\   
                         5 6 7  :# Python3 program to build full k-ary tree
# from its preorder traversal and to print the
# postorder traversal of the tree.
from math import ceil, log

# Utility function to create a new
# tree node with k children
class newNode:
	def __init__(self, value):
		self.key = value
		self.child = []

# Function to build full k-ary tree
def BuildkaryTree(A, n, k, h, ind):
	
	# For None tree
	if (n <= 0):
		return None

	nNode = newNode(A[ind[0]])
	if (nNode == None):
		print(""Memory error"")
		return None

	# For adding k children to a node
	for i in range(k):

		# Check if ind is in range of array
		# Check if height of the tree is
		# greater than 1
		if (ind[0] < n - 1 and h > 1):
			ind[0] += 1

			# Recursively add each child
			nNode.child.append(BuildkaryTree(A, n, k,
											h - 1, ind))
		else:
			nNode.child.append(None)
	return nNode

# Function to find the height of the tree
def BuildKaryTree(A, n, k, ind):
	height = int(ceil(log(float(n) * (k - 1) + 1) /
									log(float(k))))
	return BuildkaryTree(A, n, k, height, ind)

# Function to print postorder traversal
# of the tree
def postord(root, k):
	if (root == None):
		return
	for i in range(k):
		postord(root.child[i], k)
	print(root.key, end = "" "")

# Driver Code
if __name__ == '__main__':
	ind = [0]
	k = 3
	n = 10
	preorder = [ 1, 2, 5, 6, 7, 3, 8, 9, 10, 4]
	root = BuildKaryTree(preorder, n, k, ind)
	print(""Postorder traversal of constructed"",
						""full k-ary tree is: "")
	postord(root, k)
	
# This code is contributed by pranchalK
<|endoftext|>"
932,"<|endoftext|>Classification is the process of categorizing a given set of data into classes.
In Machine Learning(ML), you frame the problem, collect and clean the data, add some necessary feature variables(if any), train the model, measure its performance, improve it by using some cost function, and then it is ready to deploy. 
But how do we measure its performance? Is there any particular feature to look at?
A trivial and broad answer would be to compare the actual values to the predicted values. But that does not solve the issue. 
Let us consider the famous MNIST dataset and try to analyze the problem.:
# Importing the dataset.
from sklearn.datasets import fetch_openml
mnist = fetch_openml('mnist_784', version=1)
 
# Creating independent and dependent variables.
X, y = mnist['data'], mnist['target']
 
# Splitting the data into training set and test set.
X_train, X_test, y_train, y_test = X[:60000], X[60000:], y[:60000], y[60000:]
 
""""""
The training set is already shuffled for us, which is good as this guarantees that all
cross-validation folds will be similar.
""""""
 
# Training a binary classifier.
y_train_5 = (y_train == 5) # True for all 5s, False for all other digits.
y_test_5 = (y_test == 5)
 
""""""
Building a dumb classifier that just classifies every single image in the “not-5” class.
""""""
 
from sklearn.model_selection import cross_val_score
from sklearn.base import BaseEstimator
class Never5Classifier(BaseEstimator):
    def fit(self, X, y=None):
        pass
    def predict(self, X):
        return np.zeros((len(X), 1), dtype=bool)
 
never_5_clf = Never5Classifier()
cross_val_score(never_5_clf, X_train, y_train_5, cv=3, scoring=""accuracy"")
# Creating some predictions.
from sklearn.model_selection import cross_val_predict
y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv=3)
 
""""""
You could make predictions on the test set, but use the test set only at the very end of your project, once you have a classifier that you are ready to launch.
""""""
 
# Constructing the confusion matrix.
from sklearn.metrics import confusion_matrix
confusion_matrix(y_train_5, y_train_pred)
# Finding precision and recall
from sklearn.metrics import precision_score, recall_score
precision_score(y_train_5, y_train_pred)
recall_score(y_train_5, y_train_pred)
# To compute the F1 score, simply call the f1_score() function:
from sklearn.metrics import f1_score
f1_score(y_train_5, y_train_pred)<|endoftext|>"
933,"<|endoftext|>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.
 

Example 1:


Input: board = 
[[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
Output: true
Example 2:

Input: board = 
[[""8"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
 

Constraints:

board.length == 9
board[i].length == 9
board[i][j] is a digit 1-9 or '.'.:class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        N = 9
        # Use binary number to check previous occurrence
        rows = [0] * N
        cols = [0] * N
        boxes = [0] * N

        for r in range(N):
            for c in range(N):
                # Check if the position is filled with number
                if board[r][c] == ""."":
                    continue

                pos = int(board[r][c]) - 1

                # Check the row
                if rows[r] & (1 << pos):
                    return False
                rows[r] |= (1 << pos)

                # Check the column
                if cols[c] & (1 << pos):
                    return False
                cols[c] |= (1 << pos)

                # Check the box
                idx = (r // 3) * 3 + c // 3
                if boxes[idx] & (1 << pos):
                    return False
                boxes[idx] |= (1 << pos)

        return True<|endoftext|>"
934,"<|endoftext|>Python provides multiple ways to compare the two lists. Comparison is the process when the data items of are checked against another data item of list, whether they are the same or not.

list1 - [11, 12, 13, 14, 15]  
list2 - [11, 12, 13, 14, 15]  
Output - The lists are equal  :list1 = [11, 12, 13, 14, 15]  
list2 = [12, 13, 11, 15, 14]  
  
a = set(list1)  
b = set(list2)  
  
if a == b:  
    print(""The list1 and list2 are equal"")  
else:  
    print(""The list1 and list2 are not equal"")  <|endoftext|>"
935,"<|endoftext|>Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

 

Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: 3
Example 2:

Input: root = [1,null,2]
Output: 2:class Solution:
    def maxDepth(self, root):
        """"""
        :type root: TreeNode
        :rtype: int
        """""" 
        if root is None: 
            return 0 
        else: 
            left_height = self.maxDepth(root.left) 
            right_height = self.maxDepth(root.right) 
            return max(left_height, right_height) + 1 <|endoftext|>"
936,"<|endoftext|>The input() built-in method in Python can read user input from the keyboard.
The user’s input is read as a string, which can then be assigned to a variable.
We must press the “Enter” button after entering the value from the keyboard. The user’s value is then read by the input() function.
The program will pause indefinitely while waiting for user input. There is no way to specify a timeout value.
The EOFError is produced and the application is ended if we type EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return).:value = input(""Enter the value "")
print(""the value of entered input = "", value)<|endoftext|>"
937,"<|endoftext|>Files In Python:

A file is a piece of data or information stored on a computer’s hard drive. You’re already familiar with a variety of file kinds, including music, video, and text files. Manipulation of these files is trivial with Python. Text files and binary files are the two types of files that are commonly used. Binary files contain binary data that can only be read by a computer, whereas text files include plain text.

For programmers and automation testers, Python file handling (also known as File I/O) is a crucial topic. Working with files is required in order to write to or read data from them.



In addition, if you didn’t know, I/O activities are the most expensive techniques via which software might fail. As a result, when implementing file processing for reporting or any other reason, you should proceed with caution. The construction of a high-performance application or a robust solution for automated software testing can benefit from optimizing a single file activity.

File read() Method in Python:

The read() method is a built-in method in Python that is used to read the content of a file.

The read() method reads the specified number of bytes from the file and returns them. The default value is -1, which means the entire file.

Syntax:

file.read()
Parameters

size: This is optional. The number of bytes that will be returned. The default value is -1, which means the entire file.

Return Value:

This method’s return type is <class’str’>; it returns the string, i.e. the file’s content (if the file is in text mode).:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in read mode. In this case, we're simply reading the contents of the file.
read_file = open(givenFilename, 'r') 
# Read the contents of the file using the read() function and print it
print(read_file.read())<|endoftext|>"
938,"<|endoftext|>Given the complete factorization of a number, create a function that converts this list of factors to a string.

To illustrate: 24's complete factorization is [2, 2, 2, 3], which should be converted to ""2^3 x 3"".

Examples
string_factor([2, 2, 2, 3, 3]) ➞ ""2^3 x 3^2""

string_factor([2, 7]) ➞ ""2 x 7""

string_factor([2, 3, 3]) ➞ ""2 x 3^2""
Notes
Factors should be joined with x (multiplication sign).
Multiple instances of the same factor should be exponentiated.
Factors raised to the 1 power should be left as is, i.e. write 7 instead of 7^1.:def string_factor(lst):
    formatted = ['{}^{}'.format(num, lst.count(num)) if lst.count(num) > 1
                 else str(num)
                 for num in sorted(set(lst))]
    return ' x '.join(formatted)<|endoftext|>"
939,"<|endoftext|>In this program, we will create a doubly linked list and delete a node from the end of the list. If the list is empty, print the message ""List is empty"". If the list is not empty, the tail's previous node will become the new tail of the list thus, deleting the last node from the list.:#Represent a node of doubly linked list    
class Node:    
    def __init__(self,data):    
        self.data = data;    
        self.previous = None;    
        self.next = None;    
            
class DeleteEnd:    
    #Represent the head and tail of the doubly linked list    
    def __init__(self):    
        self.head = None;    
        self.tail = None;    
            
    #addNode() will add a node to the list    
    def addNode(self, data):    
        #Create a new node    
        newNode = Node(data);    
            
        #If list is empty    
        if(self.head == None):    
            #Both head and tail will point to newNode    
            self.head = self.tail = newNode;    
            #head's previous will point to None    
            self.head.previous = None;    
            #tail's next will point to None, as it is the last node of the list    
            self.tail.next = None;    
        else:    
            #newNode will be added after tail such that tail's next will point to newNode    
            self.tail.next = newNode;    
            #newNode's previous will point to tail    
            newNode.previous = self.tail;    
            #newNode will become new tail    
            self.tail = newNode;    
            #As it is last node, tail's next will point to None    
            self.tail.next = None;    
                
    #deleteFromEnd() will delete a node from the end of the list    
    def deleteFromEnd(self):    
        #Checks whether list is empty    
        if(self.head == None):    
            return;    
        else:    
            #Checks whether the list contains only one node    
            if(self.head != self.tail):    
                #Previous node to the tail will become new tail    
                self.tail = self.tail.previous;    
                #Node next to current tail will be made None    
                self.tail.next = None;    
                    
            #If the list contains only one element     
            #Then it will remove the node, and now both head and tail will point to None    
    
            else:    
                self.head = self.tail = None;    
                    
    #display() will print out the nodes of the list    
    def display(self):    
        #Node current will point to head    
        current = self.head;    
        if(self.head == None):    
            print(""List is empty"");    
            return;    
        while(current != None):    
            #Prints each node by incrementing pointer.    
            print(current.data),    
            current = current.next;    
        print();    
           
dList = DeleteEnd();    
#Add nodes to the list    
dList.addNode(1);    
dList.addNode(2);    
dList.addNode(3);    
dList.addNode(4);    
dList.addNode(5);    
     
#Printing original list    
print(""Original List: "");    
dList.display();    
while(dList.head != None):    
    dList.deleteFromEnd();    
    #Printing updated list    
    print(""Updated List: "");    
    dList.display();    <|endoftext|>"
940,"<|endoftext|>In this program. you'll learn to check whether a string is palindrome or Not:# Program to check if a string is palindrome or not

my_str = 'aIbohPhoBiA'

# make it suitable for caseless comparison
my_str = my_str.casefold()

# reverse the string
rev_str = reversed(my_str)

# check if the string is equal to its reverse
if list(my_str) == list(rev_str):
   print(""The string is a palindrome."")
else:
   print(""The string is not a palindrome."")<|endoftext|>"
941,"<|endoftext|>Given the number N, the task is to print the first n numbers of the pell series in Python.
 Pell Series:
 The Pell Series is a series in which the next number equals the sum of twice the previous number and the number preceding the previous number.
 It begins with 1 and 2.
 Pell Numbers: 1,2,5,12,29,70,169,…
 Consider the following number sequence and try to match it to the definition of the Pell Series:
 1 + 2 x 2 = 5
 2 + 5* 2 = 12
 5 + 12 x 2 = 29
 12 + 29*2 = 70
 29 + 70*2 = 169
 and so on…
 Now that you have a clear idea of what the Pell Series are, let’s move on to how we shall write the Python code to generate the same.
 Examples:
 Example1:
 Given number = 12
 Input:
 The first 12 numbers of the pell series are :
 
 1 2 5 12 29 70 169 408 985 2378 5741 13860
 Output:
 Example2:
 Input:
 Given number = 21
 Output:
 The first 21 numbers of the pell series are :
 
 1 2 5 12 29 70 169 408 985 2378 5741 13860 33461 80782 195025 470832 1136689 2744210 6625109
 
  15994428 38613965:# Give the number N as static input and store it in a variable.
 
 numb = 21
 
 # Take a variable temp1 and initialize it to 1.
 
 temp1 = 1
 
 # Take another variable temp2 and initialize it to 2.
 
 temp2 = 2
 
 # Take the third variable temp3 and initialize it to 0.
 
 temp3 = 0
 
 # Now, print the first two numbers in the series,
 
 # and we'll print the other generated numbers in the order they were generated.
 
 print('The first', numb, 'numbers of the pell series are :')
 
 print(temp1, temp2, end=' ')
 
 # Loop till number -2 using For loop.
 
 for i in range(numb-2):
 
  # Add the value of temp1 and twice the temp2 value
 
  # and initialize the temp3 with this value.
 
  temp3 = temp1+2*temp2
 
  # Swap the previous number for the previous number's predecessor (temp1 =temp2).
 
  temp1 = temp2
 
  # Swap the generated and previously generated numbers (temp2 = temp3)
 
  temp2 = temp3
 
  # Print the value of temp3.
 
  print(temp3, end=' ')
 
 </pre><|endoftext|>"
942,"<|endoftext|>In the previous article, we have discussed Python Program to Swap Upper Diagonal Elements with Lower Diagonal Elements of Matrix.
 Given a number N and the task is to print the series (1,2,4,8,16,32…N) till the given number N in Python.
 Examples:
 Example1:
 Input:
 Given Number = 200
 Output:
 The above series till the given number{ 200 } is : 
 
 1 2 4 8 16 32 64 128
 Explanation:
 1, 1*2, 2*2, 4*2, 8*2, 16*2, 32*2, 64*2
 
 we cannot have 128*2=256 because it exceeds the given limit number 200.
 Example2:
 Input:
 Given Number = 50
 Output:
 The above series till the given number{ 50 } is :
 
 1 2 4 8 16 32
 Explanation:
 1, 1*2, 2*2, 4*2, 8*2, 16*2
 
 we cannot have 32*2= 64 because it exceeds the given limit number 50.:# Give the number N as static input and store it in a variable.
 
 gvn_numb = 200
 
 # Take a variable to say itr and initialize its value to 1.
 
 itr = 1
 
 # Loop until the above-declared variable itr value is less than or equal to the
 
 # given number using the while loop.
 
 print(""The above series till the given number{"", gvn_numb, ""} is :"")
 
 while itr &lt;= gvn_numb:
 
  # If it is true then print the value of itr separated by spaces.
 
  print(itr, end="" "")
 
  # Multiply the itr value with 2 and store it in the same variable itr.
 
  itr *= 2
 
 </pre><|endoftext|>"
943,"<|endoftext|>Print Numbers, that contain 1, 2 and 3, in Ascending Order (Static Input):# Give the list as static input and store it in a variable.
gven_lst = [67123, 1234, 985, 126, 1011]
# Take a new empty list say ""numb"" and store it in another variable.
numb = []
# Loop in the given list using the for loop.
for itr in gven_lst:
 # Inside the loop, convert the iterator value to the string using the str() function
    # and store it in another variable.
    strng_number = str(itr)
# Check if 1 and 2 and 3 are present in the string number using the if conditional
# statement and 'and' keyword.
    if '1' in strng_number and '2' in strng_number and '3' in strng_number:
        # If the statement is true, then append the iterator value to the above initialized
        # new empty list ""numb"".
        numb.append(itr)
 # Sort the above list ""numb"" using the sort() function.
numb.sort()
# print the list ""numb"" to print the numbers with the digits 1, 2, and 3 in ascending order,
# which is separated by commas.
print(""The numbers with the digits 1, 2, and 3 in ascending order, which is separated by commas= "", numb)<|endoftext|>"
944,"<|endoftext|>In the previous article, we have discussed Python Program to Find the Sum of all Elements in a 2D Array
 
 Given a matrix and the task is to find the sum of an upper triangular matrix of the given matrix in Python.
 
 What is a matrix:
 
 A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.
 
 Example:
 
 
 
 Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.
 
 In this order, the dimensions of a matrix indicate the number of rows and columns.
 
 
 
 Here as there are 5 rows and 4 columns it is called a 5*4 matrix.
 
 Upper Triangular Matrix:
 
 An upper triangular matrix is a square matrix in which all of the entries below the major diagonal are zero.
 
 Examples:
 
 Example1:
 
 Input:
 
 Given Matrix :
 6 2 1
 1 5 0
 2 8 3
 Output:
 
 The sum of Upper Triangular matrix of the given matrix is :
 11
 Example2:
 
 Input:
 
 Given Matrix :
 4 3
 9 8
 Output:
 
 The sum of Upper Triangular matrix of the given matrix is :
 9:# Give the matrix as static input and store it in a variable.
 mtrx = [[6, 2, 1], [1, 5, 0], [2, 8, 3]]
 # Calculate the number of rows of the given matrix by
 # calculating the length of the nested list using the len() function
 # and store it in a variable mtrxrows.
 mtrxrows = len(mtrx)
 # Calculate the number of columns of the given matrix by
 # calculating the length of the first list in the nested list
 # using the len() function and store it in a variable mtrxcols.
 mtrxcols = len(mtrx[0])
 print(""The sum of Upper Triangular matrix of the given matrix is :"")
 # Take a variable say uppr_sum and initialize its value to 0.
 uppr_sum = 0
 # To print all the elements of the given matrix.
 # Loop till the given number of rows using the For loop.
 for n in range(mtrxrows):
  # Inside the For loop, Iterate till the given number of columns using another
  # Nested For loop(Inner For loop).
  for m in range(mtrxcols):
  # Check if the condition n is greater than m using the if conditional statement where n
  # is the iterator value of the parent For loop and m is the iterator value of the
  # inner For loop.
  if n > m:
  # If the statement is true, add the gvnmatrix[n][m] to the above-initialized
  # uppr_sum and store it in the same variable uppr_sum.
  uppr_sum += mtrx[n][m]
 # Print the variable uppr_sum to get the sum of an upper triangular matrix of the
 # given matrix.
 print(uppr_sum)<|endoftext|>"
945,"<|endoftext|>Create a function that takes a list and returns the most frequently occurring element contained within it.

Examples
find_frequent([3, 7, 3]) ➞ 3

find_frequent([None, ""hello"", True, None]) ➞ None

find_frequent([False, ""up"", ""down"", ""left"", ""right"", True, False]) ➞ False:def find_frequent(lst):
	return sorted(lst , key = lst.count)[-1];<|endoftext|>"
946,"<|endoftext|>Armstrong Number Program in Python | In this post, we will discuss how to check Armstrong numbers in python with the explanation. Armstrong number is a number that when raised to the power of a number of its own digits is equal to the sum of that number.:# Python program to check armstrong number def digits_count(n): i = 0 while n > 0: n //= 10 i += 1 return i def sum(n): i = digits_count(n) s = 0 while n > 0: digit = n%10 n //= 10 s += pow(digit,i) return s # take inputs num = int(input(""Enter number: "")) # calling function s = sum(num) # check armstrong number or not if s == num: print(""The number is an Armstrong number."") else: print(""The number is not an Armstrong number."")<|endoftext|>"
947,"<|endoftext|>Given a number n, find if its 2nd, 4th and 8th roots are all integers (perfect roots), return True if it exists, False if not.
Examples
perfect_roots(256) ➞ True
# 2nd root of 256 is 16
# 4th root of 256 is 4
# 8th root of 256 is 2

perfect_roots(1000) ➞ False

perfect_roots(6561) ➞ True
Notes
n > 1:def perfect_roots(n):
  return (n ** 0.125) % 1 == 0<|endoftext|>"
948,"<|endoftext|>In the previous article, we have discussed Python Program to Find the Sum of Series 9+99+999…..+N
 Given a number N and the task is to find the sum of the given series (3+7+13+21…..+N) for the given number in Python.
 Examples:
 Example1:
 Input:
 Given Number = 9
 Output:
 The total sum of the series till the given number { 9 } = 339
 Example2:
 Input:
 Given Number = 15
 Output:
 The total sum of the series till the given number { 15 } = 1375:# Give the number N as static input and store it in a variable.
 
 gvn_numb = 9
 
 # Take a variable say resltsum which gives the sum of the given series till N and
 
 # initialize its value to 0.
 
 resltsum = 0
 
 # Loop from 2 to the given number+1 using the for loop.
 
 for itr in range(2, gvn_numb+2):
 
  # Inside the loop, subtract 1 from the iterator value and multiply it with the
 
  # iterator and add 1 to this result.
 
  # Store it in another variable say p.
 
  p = 1+(itr*(itr-1))
 
  # Add the value of above p to the above-initialized resltsum and store it in the same
 
  # variable resltsum.
 
  resltsum += p
 
 # Print the resltsum value which is the result of the series till the given Number N.
 
 print(
 
  ""The total sum of the series till the given number {"", gvn_numb, ""} = "", resltsum)
 
 </pre><|endoftext|>"
949,"<|endoftext|>Given a Queue consisting of first n natural numbers (in random order). The task is to check whether the given Queue elements can be arranged in increasing order in another Queue using a stack. The operation allowed are: 

1. Push and pop elements from the stack 
2. Pop (Or Dequeue) from the given Queue. 
3. Push (Or Enqueue) in the another Queue.:# Python Program to check if a queue of first
# n natural number can be sorted using a stack
from queue import Queue
 
# Function to check if given queue element
# can be sorted into another queue using a
# stack.
def checkSorted(n, q):
    st = []
    expected = 1
    fnt = None
 
    # while given Queue is not empty.
    while (not q.empty()):
        fnt = q.queue[0]
        q.get()
 
        # if front element is the
        # expected element
        if (fnt == expected):
            expected += 1
 
        else:
             
            # if stack is empty, put the element
            if (len(st) == 0):
                st.append(fnt)
 
            # if top element is less than element which
            # need to be puted, then return false.
            elif (len(st) != 0 and st[-1] < fnt):
                return False
 
            # else put into the stack.
            else:
                st.append(fnt)
 
        # while expected element are coming
        # from stack, pop them out.
        while (len(st) != 0 and
                   st[-1] == expected):
            st.pop()
            expected += 1
 
    # if the final expected element value is equal
    # to initial Queue size and the stack is empty.
    if (expected - 1 == n and len(st) == 0):
        return True
 
    return False
 
# Driver Code
if __name__ == '__main__':
    q = Queue()
    q.put(5)
    q.put(1)
    q.put(2)
    q.put(3)
    q.put(4)
 
    n = q.qsize()
 
    if checkSorted(n, q):
        print(""Yes"")
    else:
        print(""No"")
 
# This code is contributed by PranchalK
<|endoftext|>"
950,"<|endoftext|>Given a number N the task is to find the Nth Pentagonal Number in Python.

Nth Pentagonal Number:

n is the nth pentagonal number. When the pentagons are overlapped so that they share one vertex, Pn is the number of different dots in a pattern of dots consisting of the outlines of regular pentagons with sides up to n dots.

A polygonal number (triangular number, square number, and so on) is a number that is represented as dots or pebbles ordered in the shape of a regular polygon. The first few pentagonal numbers are as follows: 1, 5, 12, and so on.:# Create a function nthPentagonalNumb() which accepts the given number
# as an argument and returns the nth pentagonal number.


def nthPentagonalNumb(numb):
        # Inside the nthPentagonalNumb() function.
        # Calculate the value of (3*n*n - n)/2 where n is the argument and
    # store it in a variable say reslt.
    reslt = (3*numb*numb - numb)/2
    # Return the reslt.
    return int(reslt)


# Give the number N as static Input and store it in a variable.
gvnnumb = 4
# Pass the given Number as an argument to nthPentagonalNumb() 
# function and store the result returned from the function in a variable say nthNumb.
nthNumb = nthPentagonalNumb(gvnnumb)
# Print the nthNumb value.
print('The {', gvnnumb, '} pentagonal number = ', nthNumb)<|endoftext|>"
951,"<|endoftext|>Given a basic salary, calculate the Gross salary of an employee.:# Give the basic salary as static input and store it in a variable.
gvn_basc_sal = 23000
# Calculate the value of da from the above given mathematical formula and store
# it in another variable.
gvn_da = (float)(15 * gvn_basc_sal) / 100.0
# Calculate the value of hr from the above given mathematical formula and store
# it in another variable.
gvn_hr = (float)(10 * gvn_basc_sal) / 100.0
# Calculate the value of da-on-ta from the above given mathematical formula and store
# it in another variable.
gvn_da_on_ta = (float)(3 * gvn_basc_sal) / 100.0
# Calculate the gross salary using the above given mathematical formula and store
# it in another variable.
gros_sal = gvn_basc_sal + gvn_da + gvn_hr + gvn_da_on_ta
# Print the Gross salary of an employee from the given basic salary.
print(
    ""The Employee's Gross salary from the given basic salary {"", gvn_basc_sal, ""} ="", gros_sal)<|endoftext|>"
952,"<|endoftext|>The False keyword is a Boolean value, and result of a comparison operation.

The False keyword is the same as 0 (True is the same as 1).:print(5 > 6)<|endoftext|>"
953,"<|endoftext|>User Input: Sum of Harmonic Series using For loop:# Scan the total number of terms as user input by using int(input()) function.
numb = int(input(""Enter the total numbers of terms =""))
# Set a totalsum variable which calculates the total sum and initialize it to 0.
totalsum = 0
# Find the total of the series using a for loop ranging from 1 to the number.
for value in range(1, numb+1):
  # calculating the total sum
    totalsum = totalsum+(1/value)
# Print the totalsum of the series, rounded to two decimal places.
print(""The total sum of the series "", round(totalsum, 2))<|endoftext|>"
954,"<|endoftext|>Given a Preorder traversal of a Binary Search Tree. The task is to print leaf nodes of the Binary Search Tree from the given preorder.
Examples: 
 

Input : preorder[] = {890, 325, 290, 530, 965};
Output : 290 530 965
Explanation : Tree represented is,
      890
     /   \
  325    965
  /  \
290   530

Input : preorder[] = { 3, 2, 4 };
Output : 2 4:# Python3 program to print leaf node from
# preorder of binary search tree.

# Binary Search
def binarySearch(inorder, l, r, d):

	mid = (l + r) >> 1
	if (inorder[mid] == d):
		return mid
	elif (inorder[mid] > d):
		return binarySearch(inorder, l,
							mid - 1, d)
	else:
		return binarySearch(inorder,
							mid + 1, r, d)

# Function to print Leaf Nodes by doing
# preorder traversal of tree using
# preorder and inorder arrays.
def leafNodesRec(preorder, inorder,
					l, r, ind, n):

	# If l == r, therefore no right or left subtree.
	# So, it must be leaf Node, print it.
	if(l == r):
		print(inorder[l], end = "" "")
		ind[0] = ind[0] + 1
		return

	# If array is out of bound, return.
	if (l < 0 or l > r or r >= n):
		return

	# Finding the index of preorder element
	# in inorder array using binary search.
	loc = binarySearch(inorder, l, r,
					preorder[ind[0]])

	# Incrementing the index.
	ind[0] = ind[0] + 1

	# Finding on the left subtree.
	leafNodesRec(preorder, inorder,	
				l, loc - 1, ind, n)

	# Finding on the right subtree.
	leafNodesRec(preorder, inorder,
				loc + 1, r, ind, n)

# Finds leaf nodes from
# given preorder traversal.
def leafNodes(preorder, n):

	# To store inorder traversal
	inorder = [0] * n
	
	# Copy the preorder into another array.
	for i in range(n):
		inorder[i] = preorder[i]

	# Finding the inorder by sorting the array.
	inorder.sort()
	
	# Point to the index in preorder.
	ind = [0]
	
	# Print the Leaf Nodes.
	leafNodesRec(preorder, inorder, 0,
				n - 1, ind, n)


# Driver Code
preorder = [890, 325, 290, 530, 965]
n = len(preorder)
leafNodes(preorder, n)

# This code is contributed
# by SHUBHAMSINGH10<|endoftext|>"
955,"<|endoftext|>Given the number of rows of the triangle, the task is to print Floyd’s triangle in C, C++, and Python.:# Give the number of rows of the triangle as static input and store it in a variable.
triRows = 10
# Take a variable and initialize it with 1 say sampNum.
sampNum = 1
# Loop from 1 to the number of rows of the triangle using For loop.
for m in range(1, triRows+1):
  # Using another For loop, loop from 1 to the parent loop iterator value (Nested For loop).
    for n in range(1, m+1):
        # Inside the inner for loop print the sampNum with a space character.
        print(sampNum, end=' ')
        # Increase the value of sampNum by 1.
        sampNum = sampNum+1
    # Print the Newline Character after the end of the inner for loop.
    print()<|endoftext|>"
956,"<|endoftext|>Given a stream of integers, lookup the rank of a given integer x. Rank of an integer in-stream is “Total number of elements less than or equal to x (not including x)”.
If an element is not found in the stream or is smallest in stream, return -1. 
Examples: 
 

Input :  arr[] = {10, 20, 15, 3, 4, 4, 1}
              x = 4;
Output : Rank of 4 in stream is: 3
There are total three elements less than
or equal to x (and not including x)

Input : arr[] = {5, 1, 14, 4, 15, 9, 7, 20, 11}, 
           x = 20;
Output : Rank of 20 in stream is: 8:# Python3 program to find rank of an
# element in a stream.

class newNode:
	def __init__(self, data):
		self.data = data
		self.left = self.right = None
		self.leftSize = 0

# Inserting a new Node.
def insert(root, data):
	if root is None:
		return newNode(data)

	# Updating size of left subtree.
	if data <= root.data:
		root.left = insert(root.left, data)
		root.leftSize += 1
	else:
		root.right = insert(root.right, data)
	return root

# Function to get Rank of a Node x.
def getRank(root, x):
	
	# Step 1.
	if root.data == x:
		return root.leftSize

	# Step 2.
	if x < root.data:
		if root.left is None:
			return -1
		else:
			return getRank(root.left, x)

	# Step 3.
	else:
		if root.right is None:
			return -1
		else:
			rightSize = getRank(root.right, x)
			if rightSize == -1:
				# x not found in right sub tree, i.e. not found in stream
				return -1
			else:
				return root.leftSize + 1 + rightSize

# Driver code
if __name__ == '__main__':
	arr = [5, 1, 4, 4, 5, 9, 7, 13, 3]
	n = len(arr)
	x = 4

	root = None
	for i in range(n):
		root = insert(root, arr[i])

	print(""Rank of"", x, ""in stream is:"",
					getRank(root, x))
	x = 13
	print(""Rank of"", x, ""in stream is:"",
					getRank(root, x))
	x = 8
	print(""Rank of"", x, ""in stream is:"",
					getRank(root, x))
		
# This code is contributed by PranchalK
<|endoftext|>"
957,"<|endoftext|>Given an array of n elements, where each element is at most k away from its target position, devise an algorithm that sorts in O(n log k) time. For example, let us consider k is 2, an element at index 7 in the sorted array, can be at indexes 5, 6, 7, 8, 9 in the given array.

Examples: 



Input : arr[] = {6, 5, 3, 2, 8, 10, 9}
            k = 3 
Output : arr[] = {2, 3, 5, 6, 8, 9, 10}

Input : arr[] = {10, 9, 8, 7, 4, 70, 60, 50}
         k = 4
Output : arr[] = {4, 7, 8, 9, 10, 50, 60, 70}:# Function to sort an array using
# insertion sort

def insertionSort(A, size):
	i, key, j = 0, 0, 0
	for i in range(size):
		key = A[i]
		j = i-1

		# Move elements of A[0..i-1], that are
		# greater than key, to one position
		# ahead of their current position.
		# This loop will run at most k times
		while j >= 0 and A[j] > key:
			A[j + 1] = A[j]
			j = j - 1
		A[j + 1] = key<|endoftext|>"
958,"<|endoftext|>Given a binary tree, find the path length having maximum number of bends. 
Note: Here, bend indicates switching from left to right or vice versa while traversing in the tree. 
For example, consider below paths (L means moving leftwards, R means moving rightwards): 
LLRRRR – 1 Bend 
RLLLRR – 2 Bends 
LRLRLR – 5 Bends:# Python3 program to find path Length
# having maximum number of bends

# Utility function to create a new node
class newNode:
	def __init__(self, key):
		self.left = None
		self.right = None
		self.key = key

# Recursive function to calculate the path
# Length having maximum number of bends.
# The following are parameters for this function.
	
# node -. pointer to the current node
# Dir -. determines whether the current node
# is left or right child of it's parent node
# bends -. number of bends so far in the
# current path.
# maxBends -. maximum number of bends in a
# path from root to leaf
# soFar -. Length of the current path so
# far traversed
# Len -. Length of the path having maximum
# number of bends

def findMaxBendsUtil(node, Dir, bends,
					maxBends, soFar, Len):
						
	# Base Case
	if (node == None):
		return

	# Leaf node
	if (node.left == None and
		node.right == None):
		if (bends > maxBends[0]):
			maxBends[0] = bends
			Len[0] = soFar
							
	# Having both left and right child
	else:
		if (Dir == 'l'):
			findMaxBendsUtil(node.left, Dir, bends,
							maxBends, soFar + 1, Len)
			findMaxBendsUtil(node.right, 'r', bends + 1,
							maxBends, soFar + 1, Len)
		else:
			findMaxBendsUtil(node.right, Dir, bends,
							maxBends, soFar + 1, Len)
			findMaxBendsUtil(node.left, 'l', bends + 1,
							maxBends, soFar + 1, Len)

# Helper function to call findMaxBendsUtil()
def findMaxBends(node):
	if (node == None):
		return 0

	Len = [0]
	bends = 0
	maxBends = [-1]

	# Call for left subtree of the root
	if (node.left):
		findMaxBendsUtil(node.left, 'l', bends,
						maxBends, 1, Len)

	# Call for right subtree of the root
	if (node.right):
		findMaxBendsUtil(node.right, 'r', bends,
						maxBends, 1, Len)

	# Include the root node as well
	# in the path Length
	Len[0] += 1

	return Len[0]

# Driver code
if __name__ == '__main__':
	
	# Constructed binary tree is
	# 10
	# / \
	# 8 2
	# / \ /
	# 3 5 2
	#	 \
	#	 1
	#	 /
	#	 9
	root = newNode(10)
	root.left = newNode(8)
	root.right = newNode(2)
	root.left.left = newNode(3)
	root.left.right = newNode(5)
	root.right.left = newNode(2)
	root.right.left.right = newNode(1)
	root.right.left.right.left = newNode(9)

	print(findMaxBends(root) - 1)

# This code is contributed by PranchalK<|endoftext|>"
959,"<|endoftext|>You are given an integer num. Rearrange the digits of num such that its value is minimized and it does not contain any leading zeros.

Return the rearranged number with minimal value.

Note that the sign of the number does not change after rearranging the digits.:class Solution:
    def smallestNumber(self, num: int) -> int:
        
        str_num = str(abs(num))
        
        str_num = list(str_num)
        
        if num>0:
            str_num.sort()
            i= 0
            while(str_num[i]=='0'):
                i+=1
            temp = str_num[0]
            str_num[0] = str_num[i]
            str_num[i] = temp
    
        else:
            str_num.sort(reverse=True)
            
        new_num = int("""".join(str_num))
    
        
        if num<0:
            new_num *= -1
            
        return new_num
                <|endoftext|>"
960,"<|endoftext|>The math.atanh() method returns the inverse hyperbolic tangent of a number.

Note: The parameter passed in math.atanh() must lie between -0.99 to 0.99.:#Import math Library
import math

#print the hyperbolic arctangent of different numbers
print(math.atanh(0.59))
print(math.atanh(-0.12))<|endoftext|>"
961,"<|endoftext|>You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index.

For example, given s = ""EnjoyYourCoffee"" and spaces = [5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain ""Enjoy Your Coffee"".
Return the modified string after the spaces have been added.:def addSpaces(self, s: str, spaces: List[int]) -> str:        
    l=0
    a=''
    for i in spaces:            
        a += s[l:i]+ ' '
        l=i
    a+=s[spaces[-1]:]
    return a<|endoftext|>"
962,"<|endoftext|>Write a function that returns a list of elements [number, multiplicity]. The multiplicity of a number refers to the number of times it occurs in the list.
To illustrate:
[5, 5, 1, 1, 5, 5, 3]
[[5, 4], [1, 2], [3, 1]]

# Since 5 appears 4 times, 1 appears twice, and 3 appearance once.
The final list should only include unique elements, and the elements should be ordered by when they first appeared in the original list.
Examples
multiplicity([1, 1, 1, 2, 2, 3]) ➞ [[1, 3], [2, 2], [3, 1]]

multiplicity([1, 1, 1, 1, 1]) ➞ [[1, 5]]

multiplicity([1, 5, 4, 3, 2]) ➞ [[1, 1], [5, 1], [4, 1], [3, 1], [2, 1]]
Notes
N/A:def multiplicity(lst):
  return [[i, lst.count(i)] for i in sorted(set(lst), key=lst.index)]<|endoftext|>"
963,"<|endoftext|>Given two circles of radius r and R, their centers are both at the origin. Given another circle with radius r1 and center at (x1, y1). Check to see if the third circle (circle of radius r1) is entirely contained within the ring formed by two circles of radius r and R:# import the math module using the import keyword
import math
# Give the first circle radius(small circle) r as static input and
# store it in a variable say rVal.
rVal = 8
# Give the second circle radius (Big circle) R as static input and
# store it in another variable say RVal.
RVal = 4
# Give the Third Circle(Which we want to check Condition) radius r1 as
# static input and store it in another variable say r1Val
r1Val = 2
# Give the x coordinates and y coordinates of the third circle and
# store them in two separate variables.
xCoordinate = 6
yCoordinate = 0
# Calculate the distance(dis value) using Pythagoras theorem and sqrt() function
# and store the result in a variable say disVal.
disVal = math.sqrt(xCoordinate * xCoordinate + yCoordinate * yCoordinate)
# Check the Condition (dis – r1)> = r and (dis + r1)< = R 
# using the if conditional Statement.
if((disVal-r1Val >= RVal and disVal+r1Val <= rVal)):
    # If it is true then Print the given circle inside the ring 
    print('The given circle lies inside the ring')
else:
    # Else print the circle does not lie inside.
    print('The given circle does not lies inside the ring')<|endoftext|>"
964,"<|endoftext|>Given a matrix, the task is to find the sum of all maximum Frequency elements of the given Matrix in Python:# import the Counter Function from collections using the import keyword
from collections import Counter
# Give the matrix as static input and store it in a variable.
mtrx = [[1, 2, 2], [3, 4, 2], [5, 1, 5]]
# Calculate the number of rows of the given matrix by
# calculating the length of the nested list using the len() function
# and store it in a variable mtrxrows.
mtrxrows = len(mtrx)
# Calculate the number of columns of the given matrix by
# calculating the length of the first list in the nested list
# using the len() function and store it in a variable mtrxcols.
mtrxcols = len(mtrx[0])
# take a list and initialize it to empty using [] or list() function
mtrxlist = []
# Loop till the given number of rows using the For loop.
for n in range(mtrxrows):
    # Inside the For loop, Iterate till the given number of columns using another
    # Nested For loop(Inner For loop).
    for m in range(mtrxcols):
        # add the gvnmatrix[n][m] value to the list using the append() function
        # where n is the iterator value of the parent For loop and m is the iterator
        # value of the inner For loop.
        mtrxlist.append(mtrx[n][m])
# Apply the Counter function to the matrix elements list which stores the matrix element
# as key and its frequency as value
mtrxfreq = Counter(mtrxlist)
# Calculate the maximum frequency using the values() and max() function
# (Here values function convert the frequency dictionary values to list
# and we find the maximum value from it using the max() function)
# and store it in a variable say maxFreq.
maxFreq = max(mtrxfreq.values())
# Take a variable(say maxFreqSum) that stores the sum of all the maximum frequency elements of the matrix
# and initialize its value to 0.
maxFreqSum = 0
# Loop in this frequency dictionary using the For loop.
for key in mtrxfreq:
    # Check if any key has a frequency equal to maxFreq using the if conditional statement.
    if(mtrxfreq[key] == maxFreq):
        # If it is true then add the key(Matrix Element) to the maxFreqSum.
        maxFreqSum = maxFreqSum+key
# Print the maxFreqSum.
print(
    'The sum of all the maximum frequency elements in the given matrix is = {', maxFreqSum, '}')<|endoftext|>"
965,"<|endoftext|>Given n cities and distances between every pair of cities, select k cities to place warehouses (or ATMs or Cloud Server) such that the maximum distance of a city to a warehouse (or ATM or Cloud Server) is minimized. 

For example consider the following four cities, 0, 1, 2, and 3, and distances between them, how to do place 2 ATMs among these 4 cities so that the maximum distance of a city to an ATM is minimized. :# Python3 program for the above approach
def maxindex(dist, n):
	mi = 0
	for i in range(n):
		if (dist[i] > dist[mi]):
			mi = i
	return mi

def selectKcities(n, weights, k):
	dist = [0]*n
	centers = []

	for i in range(n):
		dist[i] = 10**9
		
	# index of city having the
	# maximum distance to it's
	# closest center
	max = 0
	for i in range(k):
		centers.append(max)
		for j in range(n):

			# updating the distance
			# of the cities to their
			# closest centers
			dist[j] = min(dist[j], weights[max][j])

		# updating the index of the
		# city with the maximum
		# distance to it's closest center
		max = maxindex(dist, n)

	# Printing the maximum distance
	# of a city to a center
	# that is our answer
	# print()
	print(dist[max])

	# Printing the cities that
	# were chosen to be made
	# centers
	for i in centers:
		print(i, end = "" "")

# Driver Code
if __name__ == '__main__':
	n = 4
	weights = [ [ 0, 4, 8, 5 ],
			[ 4, 0, 10, 7 ],
			[ 8, 10, 0, 9 ],
			[ 5, 7, 9, 0 ] ]
	k = 2

	# Function Call
	selectKcities(n, weights, k)

# This code is contributed by mohit kumar 29.<|endoftext|>"
966,"<|endoftext|>You are given the root of a binary tree containing digits from 0 to 9 only.

Each root-to-leaf path in the tree represents a number.

For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.

A leaf node is a node with no children.

 

Example 1:


Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Example 2:


Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.:class Solution:
    def sumNumbers(self, root: TreeNode):
        def preorder(r, curr_number):
            nonlocal root_to_leaf
            if r:
                curr_number = curr_number * 10 + r.val
                # if it's a leaf, update root-to-leaf sum
                if not (r.left or r.right):
                    root_to_leaf += curr_number
                    
                preorder(r.left, curr_number)
                preorder(r.right, curr_number) 
        
        root_to_leaf = 0
        preorder(root, 0)
        return root_to_leaf<|endoftext|>"
967,"<|endoftext|>Instructions
The Collatz Conjecture or 3x+1 problem can be summarized as follows:

Take any positive integer n. If n is even, divide n by 2 to get n / 2. If n is odd, multiply n by 3 and add 1 to get 3n + 1. Repeat the process indefinitely. The conjecture states that no matter which number you start with, you will always reach 1 eventually.

Given a number n, return the number of steps required to reach 1.

Examples
Starting with n = 12, the steps would be as follows:

12
6
3
10
5
16
8
4
2
1
Resulting in 9 steps. So for input n = 12, the return value would be 9.

Exception messages
Sometimes it is necessary to raise an exception. When you do this, you should always include a meaningful error message to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the built in error types, but should still include a meaningful message.

The Collatz Conjecture is only concerned with strictly positive integers, so this exercise expects you to use the raise statement and ""throw"" a ValueError in your solution if the given value is zero or a negative integer. The tests will only pass if you both raise the exception and include a message with it.

To raise a ValueError with a message, write the message as an argument to the exception type:

# example when argument is zero or a negative integer
raise ValueError(""Only positive numbers are allowed"")
:def steps(n):
    if n <= 0:
        raise ValueError('Only positive integers are allowed')
    steps = 0
    while n != 1:
        n = 3 * n + 1 if n % 2 else n / 2
        steps += 1
    return steps
<|endoftext|>"
968,"<|endoftext|>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

 

Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]
 

Constraints:

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists.
 

Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?:class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashmap = {}
        for i in range(len(nums)):
            complement = target - nums[i]
            if complement in hashmap:
                return [i, hashmap[complement]]
            hashmap[nums[i]] = i<|endoftext|>"
969,"<|endoftext|>Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them.
A grid is said to be valid if all the cells above the main diagonal are zeros.
Return the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid.
The main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n).
 
Example 1:


Input: grid = [[0,0,1],[1,1,0],[1,0,0]]
Output: 3

Example 2:


Input: grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]
Output: -1
Explanation: All rows are similar, swaps have no effect on the grid.

Example 3:


Input: grid = [[1,0,0],[1,1,0],[1,1,1]]
Output: 0

 
Constraints:

n == grid.length == grid[i].length
1 <= n <= 200
grid[i][j] is either 0 or 1:class Solution:
  def minSwaps(self, grid: List[List[int]]) -> int:
  n = len(grid)
  
  def count(arr):
  ans = 0
  for i in range(n-1, -1, -1):
  if arr[i] == 0:
  ans += 1
  else:
  break
  return ans
  
  arr = [count(row) for row in grid]
  ans = 0
  for i in range(n):
  target = n - i - 1
  if arr[i] >= target:
  continue
  flag = False
  for j in range(i+1, n):
  if arr[j] >= target:
  flag = True
  ans += (j - i)
  arr[i+1:j+1] = arr[i:j]
  break
  if not flag:
  return -1
  
  return ans<|endoftext|>"
970,"<|endoftext|>Print Neon numbers in a Range (Static Input):# Create a function checkNeonNumb() which accepts the number as an argument and
# returns true if it is Neon number else returns False.


def checkNeonNumb(numb):
    # Calculate the square of the given number/argument using the ** operator or multiply
    # the given number by itself and store it in a variable.
    squarnumb = numb**2
    # Convert this squared number into a list of digits
    # using list(),int(),map(),str() functions.
    # Store this list in a variable.
    numbedigit = list(map(int, str(squarnumb)))
    # Calculate the sum of digits of this list using the sum() function.
    sumdigi = sum(numbedigit)
    # Check if this sum is equal to the given number
    # or not using the If conditional statement.
    # If it is true then the given number is a Neon Number so return True
    if(sumdigi == numb):
        return True
    # Else the given number is not a Neon Number so return False.
    else:
        return False


# Give the lower limit range as static input and store it in a variable.
lowlimrange = 1
# Give the upper limit range as static input and store it in another variable.
upplimrange = 7
print('The Neon numbers in the given range',
      lowlimrange, 'and', upplimrange, 'are:')
# Loop from lower limit range to upper limit range using For loop.
for p in range(lowlimrange, upplimrange+1):
        # Inside the for loop pass the iterator value to checkNeonnumb() function.
    if(checkNeonNumb(p)):
        # If it returns true then print the iterator value.
        print(p, end=' ')<|endoftext|>"
971,"<|endoftext|>Given two strings s and t, transform string s into string t using the following operation any number of times:

Choose a non-empty substring in s and sort it in place so the characters are in ascending order.


For example, applying the operation on the underlined substring in ""14234"" results in ""12344"".



Return true if it is possible to transform s into t. Otherwise, return false.
A substring is a contiguous sequence of characters within a string.
 
Example 1:

Input: s = ""84532"", t = ""34852""
Output: true
Explanation: You can transform s into t using the following sort operations:
""84532"" (from index 2 to 3) -> ""84352""
""84352"" (from index 0 to 2) -> ""34852""

Example 2:

Input: s = ""34521"", t = ""23415""
Output: true
Explanation: You can transform s into t using the following sort operations:
""34521"" -> ""23451""
""23451"" -> ""23415""

Example 3:

Input: s = ""12345"", t = ""12435""
Output: false

 
Constraints:

s.length == t.length
1 <= s.length <= 105
s and t consist of only digits.:def isTransformable(self, s: str, t: str) -> bool:
idx, pos = [[] for _ in range(10)], [0 for _ in range(10)]
for i, ch in enumerate(s):
idx[int(ch)].append(i)
for ch in t:
d = int(ch)
if pos[d] >= len(idx[d]):
return False
for i in range(d):
if pos[i] < len(idx[i]) and idx[i][pos[i]] < idx[d][pos[d]]:
return False
pos[d] += 1
return True<|endoftext|>"
972,"<|endoftext|>Given a Binary Search Tree (BST) of integer values and a range [low, high], return count of nodes where all the nodes under that node (or subtree rooted with that node) lie in the given range. 
:# Python3 program to count subtrees that
# lie in a given range
 
# Utility function to create new node
class newNode:
 
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
         
# A utility function to check if data of
# root is in range from low to high
def inRange(root, low, high):
    return root.data >= low and root.data <= high
 
# A recursive function to get count of nodes
# whose subtree is in range from low to high.
# This function returns true if nodes in subtree
# rooted under 'root' are in range.
def getCountUtil(root, low, high, count):
     
    # Base case
    if root == None:
        return True
 
    # Recur for left and right subtrees
    l = getCountUtil(root.left, low, high, count)
    r = getCountUtil(root.right, low, high, count)
 
    # If both left and right subtrees are in range
    # and current node is also in range, then
    # increment count and return true
    if l and r and inRange(root, low, high):
        count[0] += 1
        return True
 
    return False
 
# A wrapper over getCountUtil(). This function
# initializes count as 0 and calls getCountUtil()
def getCount(root, low, high):
    count = [0]
    getCountUtil(root, low, high, count)
    return count
 
# Driver Code
if __name__ == '__main__':
     
    # Let us construct the BST shown in
    # the above figure
    root = newNode(10)
    root.left = newNode(5)
    root.right = newNode(50)
    root.left.left = newNode(1)
    root.right.left = newNode(40)
    root.right.right = newNode(100)
     
    # Let us constructed BST shown in above example
    # 10
    # / \
    # 5     50
    # /     / \
    # 1     40 100
    l = 5
    h = 45
    print(""Count of subtrees in ["", l, "", "", h, ""] is "",
                                   getCount(root, l, h))
 
# This code is contributed by PranchalK
<|endoftext|>"
973,"<|endoftext|>Implement a Greedy Coloring Algorithm: 
1. Color first vertex with first color. 
2. Do following for remaining V-1 vertices. 
….. a) Consider the currently picked vertex and color it with the 
lowest numbered color that has not been used on any previously 
colored vertices adjacent to it. If all previously used colors 
appear on vertices adjacent to v, assign a new color to it.:# Python3 program to implement greedy
# algorithm for graph coloring

def addEdge(adj, v, w):
        
        adj[v].append(w)
        
        # Note: the graph is undirected
        adj[w].append(v)
        return adj

# Assigns colors (starting from 0) to all
# vertices and prints the assignment of colors
def greedyColoring(adj, V):
        
        result = [-1] * V

        # Assign the first color to first vertex
        result[0] = 0;


        # A temporary array to store the available colors.
        # True value of available[cr] would mean that the
        # color cr is assigned to one of its adjacent vertices
        available = [False] * V

        # Assign colors to remaining V-1 vertices
        for u in range(1, V):
                
                # Process all adjacent vertices and
                # flag their colors as unavailable
                for i in adj[u]:
                        if (result[i] != -1):
                                available[result[i]] = True

                # Find the first available color
                cr = 0
                while cr < V:
                        if (available[cr] == False):
                                break
                        
                        cr += 1
                        
                # Assign the found color
                result[u] = cr

                # Reset the values back to false
                # for the next iteration
                for i in adj[u]:
                        if (result[i] != -1):
                                available[result[i]] = False

        # Print the result
        for u in range(V):
                print(""Vertex"", u, "" ---> Color"", result[u])

# Driver Code
if __name__ == '__main__':
        
        g1 = [[] for i in range(5)]
        g1 = addEdge(g1, 0, 1)
        g1 = addEdge(g1, 0, 2)
        g1 = addEdge(g1, 1, 2)
        g1 = addEdge(g1, 1, 3)
        g1 = addEdge(g1, 2, 3)
        g1 = addEdge(g1, 3, 4)
        print(""Coloring of graph 1 "")
        greedyColoring(g1, 5)

        g2 = [[] for i in range(5)]
        g2 = addEdge(g2, 0, 1)
        g2 = addEdge(g2, 0, 2)
        g2 = addEdge(g2, 1, 2)
        g2 = addEdge(g2, 1, 4)
        g2 = addEdge(g2, 2, 4)
        g2 = addEdge(g2, 4, 3)
        print(""\nColoring of graph 2"")
        greedyColoring(g2, 5)

# This code is contributed by mohit kumar 29
<|endoftext|>"
974,"<|endoftext|>Given an array of numbers, return true if given array can represent preorder traversal of a Binary Search Tree, else return false. Expected time complexity is O(n).:# Python program for an efficient solution to check if
# a given array can represent Preorder traversal of
# a Binary Search Tree
 
INT_MIN = -2**32
 
def canRepresentBST(pre):
 
    # Create an empty stack
    s = []
 
    # Initialize current root as minimum possible value
    root = INT_MIN
 
    # Traverse given array
    for value in pre:
        #NOTE:value is equal to pre[i] according to the
        #given algo  
     
        # If we find a node who is on the right side
        # and smaller than root, return False
        if value < root :
            return False
     
        # If value(pre[i]) is in right subtree of stack top,
        # Keep removing items smaller than value
        # and make the last removed items as new root
        while(len(s) > 0 and s[-1] < value) :
            root = s.pop()
         
        # At this point either stack is empty or value
        # is smaller than root, push value
        s.append(value)
 
    return True
 
# Driver Program
pre1 = [40 , 30 , 35 , 80 , 100]
print (""true"" if canRepresentBST(pre1) == True else ""false"")
pre2 = [40 , 30 , 35 , 20 ,  80 , 100]
print (""true"" if canRepresentBST(pre2) == True else ""false"")
 
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
<|endoftext|>"
975,"<|endoftext|>Given an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col].
The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:

The rank is an integer starting from 1.
If two elements p and q are in the same row or column, then:

If p < q then rank(p) < rank(q)
If p == q then rank(p) == rank(q)
If p > q then rank(p) > rank(q)


The rank should be as small as possible.

The test cases are generated so that answer is unique under the given rules.
 
Example 1:


Input: matrix = [[1,2],[3,4]]
Output: [[1,2],[2,3]]
Explanation:
The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.
The rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1], matrix[1][1] > matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.

Example 2:


Input: matrix = [[7,7],[7,7]]
Output: [[1,1],[1,1]]

Example 3:


Input: matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
Output: [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]

 
Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 500
-109 <= matrix[row][col] <= 109:class UnionFind:
  def __init__(self):
  self.parent = {}
  def find(self, u):
  if u != self.parent[u]:
  self.parent[u] = self.find(self.parent[u])
  return self.parent[u]
  def union(self, u, v):
  self.parent.setdefault(u, u)
  self.parent.setdefault(v, v)
  pu, pv = self.find(u), self.find(v)
  if pu != pv: self.parent[pu] = pv
  def getGroups(self):
  groups = defaultdict(list)
  for i in self.parent.keys():
  groups[self.find(i)].append(i)
  return groups

class Solution:
  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
  m, n = len(matrix), len(matrix[0])
  d = defaultdict(list)

  for r in range(m):
  for c in range(n):
  d[matrix[r][c]].append([r, c])

  rank = [0] * (m + n)  # rank[i] is the largest rank of the row or column so far.
  for a in sorted(d):
  uf = UnionFind()
  
  for r, c in d[a]:
  uf.union(r, c + m)  # Union row `r` with column `c` (column +m to separate with r)
  
  for group in uf.getGroups().values():
  maxRank = max(rank[i] for i in group)  # Get max rank of all included rows and columns
  for i in group: rank[i] = maxRank + 1  # Update all rows or columns in the same groups to new rank
  
  for r, c in d[a]:
  matrix[r][c] = rank[r]  # or matrix[r][c] = rank[c+m], both are correct!

  return matrix<|endoftext|>"
976,"<|endoftext|>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.:class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        
        #Sort Greed Factor and Cookie Size
        g.sort()
        s.sort()
        
        #Initialise ans
        ans = 0
        
        i = 0
        j = 0
        
        while(i<len(g) and j<len(s)):
            
            #Cookie Assigned
            if(s[j] >= g[i]):
                ans += 1
                j += 1
                i += 1
            #Search if any cookie will be enough for greed    
            else:
                j += 1
        return ans<|endoftext|>"
977,"<|endoftext|>Given two given arrays of equal length, the task is to find if given arrays are equal or not. Two arrays are said to be equal if both of them contain the same set of elements, arrangements (or permutation) of elements may be different though.

Note: If there are repetitions, then counts of repeated elements must also be the same for two arrays to be equal. 

Examples : 

Input  : arr1[] = {1, 2, 5, 4, 0};
         arr2[] = {2, 4, 5, 0, 1}; 
Output : Yes

Input  : arr1[] = {1, 2, 5, 4, 0, 2, 1};
         arr2[] = {2, 4, 5, 0, 1, 1, 2}; 
Output : Yes
 
Input : arr1[] = {1, 7, 1};
        arr2[] = {7, 7, 1};
Output : No:# Python3 program to find given
# two array are equal or not

# Returns true if arr1[0..n-1] and
# arr2[0..m-1] contain same elements.


def areEqual(arr1, arr2, n, m):

	# If lengths of array are not
	# equal means array are not equal
	if (n != m):
		return False

	# Sort both arrays
	arr1.sort()
	arr2.sort()

	# Linearly compare elements
	for i in range(0, n):
		if (arr1[i] != arr2[i]):
			return False

	# If all elements were same.
	return True


# Driver Code
arr1 = [3, 5, 2, 5, 2]
arr2 = [2, 3, 5, 5, 2]
n = len(arr1)
m = len(arr2)

if (areEqual(arr1, arr2, n, m)):
	print(""Yes"")
else:
	print(""No"")

# This code is contributed
# by Shivi_Aggarwal.<|endoftext|>"
978,"<|endoftext|>Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.

A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.

 

Example 1:


Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: [[5,4,11,2],[5,8,4,5]]
Explanation: There are two paths whose sum equals targetSum:
5 + 4 + 11 + 2 = 22
5 + 8 + 4 + 5 = 22
Example 2:


Input: root = [1,2,3], targetSum = 5
Output: []
Example 3:

Input: root = [1,2], targetSum = 0
Output: []:# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    
    def recurseTree(self, node, remainingSum, pathNodes, pathsList):
        
        if not node:
            return 
        
        # Add the current node to the path's list
        pathNodes.append(node.val)
        
        # Check if the current node is a leaf and also, if it
        # equals our remaining sum. If it does, we add the path to
        # our list of paths
        if remainingSum == node.val and not node.left and not node.right:
            pathsList.append(list(pathNodes))
        else:    
            # Else, we will recurse on the left and the right children
            self.recurseTree(node.left, remainingSum - node.val, pathNodes, pathsList)
            self.recurseTree(node.right, remainingSum - node.val, pathNodes, pathsList)
            
        # We need to pop the node once we are done processing ALL of it's
        # subtrees.
        pathNodes.pop()    
    
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
        pathsList = []
        self.recurseTree(root, sum, [], pathsList)
        return pathsList<|endoftext|>"
979,"<|endoftext|>If Inside If
You can have if statements inside if statements, this is called nested if statements.:x = 41

if x > 10:
  print(""Above ten,"")
  if x > 20:
    print(""and also above 20!"")
  else:
    print(""but not above 20."")<|endoftext|>"
980,"<|endoftext|>Create a function that takes a list lst and a number n and returns a list of two integers whose product is that of the number n.
Examples
two_product([1, 2, 3, 4, 13, 5], 39) ➞ [3, 13]

two_product([11, 2, 7, 3, 5, 0], 55) ➞ [5, 11]

two_product([100, 12, 4, 1, 2], 15) ➞ None
Notes
No duplicates.
Sort the number.
Try doing this with 0(n) time complexity.
The list can have multiple solutions, so return the first match you find.:def two_product(lst, n):
  for i in lst:
    if n/i in lst:
      return sorted([i, int(n/i)])
  return None<|endoftext|>"
981,"<|endoftext|>In this example, you will learn to return multiple values from a function.:def name():
    return ""John"",""Armin""

# print the tuple with the returned values
print(name())

# get the individual items
name_1, name_2 = name()
print(name_1, name_2)
def name():
    n1 = ""John""
    n2 = ""Armin""

    return {1:n1, 2:n2}

names = name()
print(names)<|endoftext|>"
982,"<|endoftext|>A city skyline can be represented as a 2-D list with 1s representing buildings. In the example below, the height of the tallest building is 4 (second-most right column).
[[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 1, 0],
[0, 0, 1, 0, 1, 0],
[0, 1, 1, 1, 1, 0],
[1, 1, 1, 1, 1, 1]]
Create a function that takes a skyline (2-D list of 0's and 1's) and returns the height of the tallest skyscraper.
Examples
tallest_skyscraper([
  [0, 0, 0, 0],
  [0, 1, 0, 0],
  [0, 1, 1, 0],
  [1, 1, 1, 1]
]) ➞ 3

tallest_skyscraper([
  [0, 1, 0, 0],
  [0, 1, 0, 0],
  [0, 1, 1, 0],
  [1, 1, 1, 1]
]) ➞ 4

tallest_skyscraper([
  [0, 0, 0, 0],
  [0, 0, 0, 0],
  [1, 1, 1, 0],
  [1, 1, 1, 1]
]) ➞ 2
Notes
N/A:def tallest_skyscraper(lst):
  return sum(1 for i in lst if sum(i)>0)<|endoftext|>"
983,"<|endoftext|>Consider the following C implementation of Binary Search function, is there anything wrong in this?:// A iterative binary search function. It returns location of x in
// given array arr[l..r] if present, otherwise -1
int binarySearch(int arr[], int l, int r, int x)
{
	while (l <= r)
	{
		// find index of middle element
		int m = (l+r)/2;

		// Check if x is present at mid
		if (arr[m] == x) return m;

		// If x greater, ignore left half
		if (arr[m] < x) l = m + 1;

		// If x is smaller, ignore right half
		else r = m - 1;
	}

	// if we reach here, then element was not present
	return -1;
}<|endoftext|>"
984,"<|endoftext|>Mubashir needs your help to count a specific digit in a list.
You have to create a function that takes two integers n and d and makes a list of squares of all numbers from 0...<= n and returns the count of the digits d in the list.
Examples
count_digits(10, 1) ➞ 4
# Squared list from 0 to 10 = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
# Digit 1 appeared 4 times in the list.

count_digits(25, 2) ➞ 9 

count_digits(10, 1) ➞ 4
Notes
d will always be 0<=d<10.:def count_digits(n, d):
  return sum(str(i*i).count(str(d)) for i in range(n+1))<|endoftext|>"
985,"<|endoftext|>In the previous article, we have discussed Python Program for Markov Matrix
 
 Given a matrix with just 0 and 1 elements, the task is to find the row in the matrix with the greatest number of 1s in that row in Python.
 
 What is a matrix:
 
 A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.
 
 Example:
 
 
 
 Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.
 
 In this order, the dimensions of a matrix indicate the number of rows and columns.
 
 
 
 Here as there are 5 rows and 4 columns it is called a 5*4 matrix.
 
 Examples:
 
 Example1:
 
 Input:
 
 Given Matrix : 
 1 0 0
 1 1 1
 1 0 1
 Output:
 
 The row which is containing maximum number of 1 is : 2
 Example2:
 
 Input:
 
 Given Matrix : 
 1 1 0
 0 0 1
 0 1 1
 Output:
 
 The row which is containing maximum number of 1 is : 3
 Note: If both the rows are having the same number of 1’s then it prints the last row.:# Give the matrix as static input and store it in a variable.
 mtrx = [[1, 0, 0], [1, 1, 1], [1, 0, 1]]
 # Calculate the number of rows of the given matrix by
 # calculating the length of the nested list using the len() function
 # and store it in a variable mtrxrows.
 mtrxrows = len(mtrx)
 # Calculate the number of columns of the given matrix by
 # calculating the length of the first list in the nested list
 # using the len() function and store it in a variable mtrxcols.
 mtrxcols = len(mtrx[0])
 # take a variable which stores the number of 1's in the row and initialize it with 0
 maxOnes = 0
 # Loop till the given number of rows using the For loop.
 for p in range(mtrxrows):
  # calculate the number of ones in that row using the count() function
  numbOfOnes = mtrx[p].count(1)
  # check if the number of ones in that row is greater or equal to
  # than maxOnes using the if conditional statement
  if(numbOfOnes >= maxOnes):
  # if it is true then initializee maxOnes with numbOfOnes
  maxOnes = numbOfOnes
  # take a variable and store this row number in this row
  maxOnesRow = p+1
 # print the row that is containing maximum number of 1's by printing maxOnesRow
 print('The row which is containing maximum number of 1 is :', maxOnesRow)<|endoftext|>"
986,"<|endoftext|>The array’s length is n-1. So, using the formula n*(n+1)/2, the sum of all n elements, i.e. the sum of numbers from 1 to n, can be determined.

The aim is to use the above formula to find the sum of integers between 1 and n+1, where is the size of the array. Calculate the real sum of the integers in the array as well. The difference between the two is now the missing number.:def findMissingNumb(given_list):

    # calculating the length of the given list
    n = len(given_list)

    # Because a number is missing from the list, the real size is n+1.
    length = n + 1

    # Getting sum of all numbers from 1 to length using mathematical formula
    totalSum = length * (length + 1) / 2
    # calculating the sum of all elements in the given list
    # initializing a variable to store arraysum as 0
    arraysum = 0
    # Traversing the list
    for ele in given_list:
        arraysum = arraysum+ele

    # The difference between the totalsum and arraysum
    # of the integers in the list is the missing number.
    # missing number
    missnum = totalSum-arraysum
    # reeturn the missing number
    return int(missnum)


# Driver code
# given list
given_list = [1, 3, 2, 6, 5]
# passing the given list to findMissingNumb  to print the missing number

print(""The missing number in the given list"", findMissingNumb(given_list))<|endoftext|>"
987,"<|endoftext|>Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
 

Example 1:


Input: root = [2,1,3]
Output: true
Example 2:


Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
-231 <= Node.val <= 231 - 1:class Solution:
    def isValidBST(self, root: TreeNode) -> bool:

        def validate(node, low=-math.inf, high=math.inf):
            # Empty trees are valid BSTs.
            if not node:
                return True
            # The current node's value must be between low and high.
            if node.val <= low or node.val >= high:
                return False

            # The left and right subtree must also be valid.
            return (validate(node.right, node.val, high) and
                   validate(node.left, low, node.val))

        return validate(root)<|endoftext|>"
988,"<|endoftext|>Given a m x n 2D matrix, check if it is a Markov Matrix.


Markov Matrix : The matrix in which the sum of each row is equal to 1.


 :# Python 3 code to check Markov Matrix
 
def checkMarkov(m) :
     
    # Outer loop to access rows
    # and inner to access columns
    for i in range(0, len(m)) :
         
        # Find sum of current row
        sm = 0
        for j in range(0, len(m[i])) :
            sm = sm + m[i][j]
 
        if (sm != 1) :
            return False
             
    return True
     
# Matrix to check
m = [ [ 0, 0, 1 ],
      [ 0.5, 0, 0.5 ],
      [ 1, 0, 0 ]      ]
 
# Calls the function check()
if (checkMarkov(m)) :
    print("" yes "")
else :
    print("" no "")
     
     
# This code is contributed by Nikita Tiwari.
<|endoftext|>"
989,"<|endoftext|>Merge sort is often preferred for sorting a linked list. The slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible. :# Python3 program to merge sort of linked list

# create Node using class Node.
class Node:
	def __init__(self, data):
		self.data = data
		self.next = None

class LinkedList:
	def __init__(self):
		self.head = None
	
	# push new value to linked list
	# using append method
	def append(self, new_value):
		
		# Allocate new node
		new_node = Node(new_value)
		
		# if head is None, initialize it to new node
		if self.head is None:
			self.head = new_node
			return
		curr_node = self.head
		while curr_node.next is not None:
			curr_node = curr_node.next
			
		# Append the new node at the end
		# of the linked list
		curr_node.next = new_node
		
	def sortedMerge(self, a, b):
		result = None
		
		# Base cases
		if a == None:
			return b
		if b == None:
			return a
			
		# pick either a or b and recur..
		if a.data <= b.data:
			result = a
			result.next = self.sortedMerge(a.next, b)
		else:
			result = b
			result.next = self.sortedMerge(a, b.next)
		return result
	
	def mergeSort(self, h):
		
		# Base case if head is None
		if h == None or h.next == None:
			return h

		# get the middle of the list
		middle = self.getMiddle(h)
		nexttomiddle = middle.next

		# set the next of middle node to None
		middle.next = None

		# Apply mergeSort on left list
		left = self.mergeSort(h)
		
		# Apply mergeSort on right list
		right = self.mergeSort(nexttomiddle)

		# Merge the left and right lists
		sortedlist = self.sortedMerge(left, right)
		return sortedlist
	
	# Utility function to get the middle
	# of the linked list
	def getMiddle(self, head):
		if (head == None):
			return head

		slow = head
		fast = head

		while (fast.next != None and
			fast.next.next != None):
			slow = slow.next
			fast = fast.next.next
			
		return slow
		
# Utility function to print the linked list
def printList(head):
	if head is None:
		print(' ')
		return
	curr_node = head
	while curr_node:
		print(curr_node.data, end = "" "")
		curr_node = curr_node.next
	print(' ')
	
# Driver Code
if __name__ == '__main__':
	li = LinkedList()
	
	# Let us create a unsorted linked list
	# to test the functions created.
	# The list shall be a: 2->3->20->5->10->15
	li.append(15)
	li.append(10)
	li.append(5)
	li.append(20)
	li.append(3)
	li.append(2)
	
	# Apply merge Sort
	li.head = li.mergeSort(li.head)
	print (""Sorted Linked List is:"")
	printList(li.head)

# This code is contributed by Vikas Chitturi<|endoftext|>"
990,"<|endoftext|>Bob is standing at cell (0, 0), and he wants to reach destination: (row, column). He can only travel right and down. You are going to help Bob by providing instructions for him to reach destination.
The instructions are represented as a string, where each character is either:

'H', meaning move horizontally (go right), or
'V', meaning move vertically (go down).

Multiple instructions will lead Bob to destination. For example, if destination is (2, 3), both ""HHHVV"" and ""HVHVH"" are valid instructions.
However, Bob is very picky. Bob has a lucky number k, and he wants the kth lexicographically smallest instructions that will lead him to destination. k is 1-indexed.
Given an integer array destination and an integer k, return the kth lexicographically smallest instructions that will take Bob to destination.
 
Example 1:


Input: destination = [2,3], k = 1
Output: ""HHHVV""
Explanation: All the instructions that reach (2, 3) in lexicographic order are as follows:
[""HHHVV"", ""HHVHV"", ""HHVVH"", ""HVHHV"", ""HVHVH"", ""HVVHH"", ""VHHHV"", ""VHHVH"", ""VHVHH"", ""VVHHH""].

Example 2:


Input: destination = [2,3], k = 2
Output: ""HHVHV""

Example 3:


Input: destination = [2,3], k = 3
Output: ""HHVVH""

 
Constraints:

destination.length == 2
1 <= row, column <= 15
1 <= k <= nCr(row + column, row), where nCr(a, b) denotes a choose b​​​​​.:def kthSmallestPath(self, destination: List[int], k: int) -> str:
  from math import comb
  r, c = destination
  
  ret = []
  remDown = r
  for i in range(r + c):
  remSteps = r + c - (i + 1)
  com = comb(remSteps, remDown)
  if com >= k:
  ret.append(""H"")
  else:
  remDown -= 1
  k -= com
  ret.append(""V"")
  
  return ''.join(ret)<|endoftext|>"
991,"<|endoftext|>In the previous article, we have discussed Python Program to Toggle the Last m Bits
 Given three numbers and the task is to swap the given three numbers without using any temporary variable in python
 Examples:
 Example1:
 Input:
 Given first number= 30
 
 Given second number= 45
 
 Given third number= 21
 Output:
 The above given three numbers before swapping :
 
 first number = 30 second number = 45 third number = 21
 
 The above given three numbers after swapping without using temporary variable:
 
 first number = 21 second number = 30 third number = 45
 Example2:
 Input:
 Given first number= 60
 
 Given second number= 80
 
 Given third number= 70
 Output:
 The above given three numbers before swapping :
 
 first number = 60 second number = 80 third number = 70
 
 The above given three numbers after swapping without using temporary variable:
 
 first number = 70 second number = 60 third number = 80:# Give the first number as static input and store it in a variable.
 
 fst_numb = 30
 
 # Give the second number as static input and store it in another variable.
 
 scnd_numb = 45
 
 # Give the third number as static input and store it in another variable.
 
 thrd_numb = 21
 
 print(""The above given three numbers before swapping :"")
 
 print(""first number = "", fst_numb, ""second number = "",
 
  scnd_numb, ""third number = "", thrd_numb)
 
 # Add first, second, and third numbers and assign the result to the first number.
 
 fst_numb = fst_numb + scnd_numb + thrd_numb
 
 # Add second, and third numbers and subtract the result from the given first number.
 
 # Assign the result to the second number.
 
 scnd_numb = fst_numb - (scnd_numb+thrd_numb)
 
 # Add second, and third numbers and subtract the result from the given first number.
 
 # Assign the result to the given third number.
 
 thrd_numb = fst_numb - (scnd_numb+thrd_numb)
 
 # Add second, and third numbers and subtract the result from the given first number.
 
 # Assign the result to the given first number.
 
 fst_numb = fst_numb - (scnd_numb+thrd_numb)
 
 # Print the given three numbers after swapping without using a temporary variable.
 
 print(""The above given three numbers after swapping without using temporary variable:"")
 
 print(""first number = "", fst_numb, ""second number = "",
 
  scnd_numb, ""third number = "", thrd_numb)
 
 </pre><|endoftext|>"
992,"<|endoftext|>Create a function that takes a number n as an argument and checks whether the given number can be expressed as a sum of two or more consecutive positive numbers.
Examples
consecutiveSum(9) ➞ True
# 9 can be expressed as a sum of (2 + 3 + 4) or (4 + 5).

consecutiveSum(10) ➞ True
# 10 can be expressed as a sum of 1 + 2 + 3 + 4.

consecutiveSum(64) ➞ False
Notes
N/A:def consecutive_sum(n):
  i, res = 2, 0
  while 2 ** i <= n:
    res = 2 ** i
    i += 1
  return res != n<|endoftext|>"
993,"<|endoftext|>Character recognition software often makes mistakes when documents (especially old ones written with a typewriter) are digitized.

Your task is to correct the errors in the digitized text. You only have to handle the following mistakes:

A is misinterpreted as 4
S is misinterpreted as 5
O is misinterpreted as 0
I is misinterpreted as 1
The test cases contain numbers only by mistake.

Examples
keyboard_mistakes(""MUB45H1R"") ➞ ""MUBASHIR""

keyboard_mistakes(""DUBL1N"") ➞ ""DUBLIN""

keyboard_mistakes(""51NG4P0RE"") ➞ ""SINGAPORE"":def keyboard_mistakes(txt):
	d = {'0' : 'O', '1' : 'I', '4' : 'A', '5' : 'S'}
	return ''.join(d[i] if i in d else i for i in txt)<|endoftext|>"
994,"<|endoftext|>You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time.

The ith day is a good day to rob the bank if:

There are at least time days before and after the ith day,
The number of guards at the bank for the time days before i are non-increasing, and
The number of guards at the bank for the time days after i are non-decreasing.
More formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].

Return a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter.:class Solution:
    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:
            n = len(security)
        if not time: return range(n)
        sols = []
        p0 = p1 = 0         
                if n < 2*time: return sols
        for i in range(1, n-time):
            p0 += 1 if security[i-1] >= security[i] else -p0
            p1 += 1 if security[i+time-1] <= security[i+time] else -p1
            if p0 >= time and p1 >= time: sols.append(i)
        return sols<|endoftext|>"
995,"<|endoftext|>Given a directed tree with V vertices and V-1 edges, we need to choose such a root (from given nodes from where we can reach to every other node) with a minimum number of edge reversal. :# Python3 program to find min edge reversal
# to make every node reachable from root
import sys
  
# Method to dfs in tree and populates 
# disRev values
def dfs(g, disRev, visit, u):
      
    # Visit current node
    visit[u] = True
    totalRev = 0
  
    # Looping over all neighbors
    for i in range(len(g[u])):
        v = g[u][i][0]
          
        if (not visit[v]):
              
            # Distance of v will be one more
            # than distance of u
            disRev[v][0] = disRev[u][0] + 1
  
            # Initialize back edge count same as
            # parent node's count
            disRev[v][1] = disRev[u][1]
  
            # If there is a reverse edge from u to i,
            # then only update
            if (g[u][i][1]):
                disRev[v][1] = disRev[u][1] + 1
                totalRev += 1
                  
            totalRev += dfs(g, disRev, visit, v)
  
    # Return total reversal in subtree rooted at u
    return totalRev
  
# Method prints root and minimum number of
# edge reversal
def printMinEdgeReverseForRootNode(edges, e):
      
    # Number of nodes are one more than
    # number of edges
    V = e + 1
  
    # Data structure to store directed tree
    g = [[] for i in range(V)]
  
    # disRev stores two values - distance
    # and back edge count from root node
    disRev = [[0, 0] for i in range(V)]
  
    visit = [False for i in range(V)]
  
    # u, v
    for i in range(e):
        u = edges[i][0]
        v = edges[i][1]
          
        # Add 0 weight in direction of u to v
        g[u].append([v, 0])
  
        # Add 1 weight in reverse direction
        g[v].append([u, 1])
  
    # Initialize all variables
    for i in range(V):
        visit[i] = False
        disRev[i][0] = disRev[i][1] = 0
  
    root = 0
  
    # dfs populates disRev data structure and
    # store total reverse edge counts
    totalRev = dfs(g, disRev, visit, root)
  
    # UnComment below lines to preach node's
    # distance and edge reversal count from root node
    # for (i = 0 i < V i++)
    # {
    #     cout << i << "" : "" << disRev[i][0]
    #         << "" "" << disRev[i][1] << endl
    # }
    res = sys.maxsize
  
    # Loop over all nodes to choose 
    # minimum edge reversal
    for i in range(V):
          
        # (reversal in path to i) + (reversal
        # in all other tree parts)
        edgesToRev = ((totalRev - disRev[i][1]) + 
                  (disRev[i][0] - disRev[i][1]))
  
        # Choose minimum among all values
        if (edgesToRev < res):
            res = edgesToRev
            root = i
  
    # Print the designated root and total
    # edge reversal made
    print(root, res) 
  
# Driver code 
if __name__ == '__main__':
      
    edges = [ [ 0, 1 ], [ 2, 1 ],
              [ 3, 2 ], [ 3, 4 ],
              [ 5, 4 ], [ 5, 6 ],
              [ 7, 6 ] ]
  
    e = len(edges)
  
    printMinEdgeReverseForRootNode(edges, e)
  
# This code is contributed by mohit kumar 29
<|endoftext|>"
996,"<|endoftext|>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.

Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.

 

Example 1:

Input: num1 = ""2"", num2 = ""3""
Output: ""6""
Example 2:

Input: num1 = ""123"", num2 = ""456""
Output: ""56088""
 

Constraints:

1 <= num1.length, num2.length <= 200
num1 and num2 consist of digits only.
Both num1 and num2 do not contain any leading zero, except the number 0 itself.:def multiply(self, num1: str, num2: str) -> str:
    n = len(num1)
    m = len(num2)
    sum_arr = [0]*(n+m)
    for i in range(n-1,-1,-1):
        for j in range(m-1,-1,-1):
            print(i,j)
            pos1 = i+j
            pos2 = pos1+1
            n1 = int(num1[i])
            n2 = int(num2[j])
            
            mul = (n1 * n2) + sum_arr[pos2]
            print(n1*n2,sum_arr[pos2])
            sum_arr[pos1] += mul // 10
            sum_arr[pos2] = mul % 10
    print(sum_arr)
    ans = """"
    for i in range(0,m+n):
        ans += str(sum_arr[i])
    
    return ""0"" if ans.lstrip('0') == """" else ans.lstrip('0')<|endoftext|>"
997,"<|endoftext|>Files in Python:

One of the most important subjects for programmers and automation testers is Python file handling (also known as File I/O). It is necessary to work with files in order to write to or read data from them.

Also, if you didn’t know, I/O operations are the most expensive processes where a programme can go wrong. As a result, you must use extreme caution while implementing file processing for reporting or any other reason. Optimizing a single file action can help in the creation of a high-performing application or a reliable automated software testing solution.



Consider the following scenario: you’re planning to construct a large Python project with a large number of workflows. Then it’s unavoidable that you don’t make a log file. You’ll also be handling the log file’s read and write activities. Debugging huge applications with log files is a terrific way to go. It’s usually better to consider a scalable design from the start, as you won’t be sorry later if you didn’t.

File truncate() Method in Python:

The truncate() method resizes the size of a file to the specified number of bytes.

If no size is given, the current position is taken.

Syntax:

file.truncate(size)
Parameters

size: This is Optional. The file’s size (in bytes) after truncation. The default value is None, which represents the current file stream position.:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in append mode. In this case, we're simply appending the contents into the file.
gvn_file = open(givenFilename, 'a') 
# Pass some random number as an argument to the truncate() function to truncate the filelines 
# to the given number
gvn_file.truncate(15)
# Close the given file using the close function
gvn_file.close()
# Open the file in read mode. In this case, we're simply reading the contents of the file.
gvn_file = open(givenFilename, 'r') 
# Read the contents of the file using the read() function
print(gvn_file.read())<|endoftext|>"
998,"<|endoftext|>Now in this post, we will develop a palindrome number in python. It will check the given number is a palindrome number or not.:# Python program to check if number is Palindrome # take inputs num = int(input('Enter the number : ')) # calculate reverse of number reverse = 0 number = num while(num != 0): remainder = num % 10 reverse = reverse * 10 + remainder num = int(num / 10) # compare reverse to original number if(number == reverse): print(number,'is a Palindrome') else: print(number,'is not a Palindrome')<|endoftext|>"
999,"<|endoftext|>Mubashir was reading about Doubleton Numbers on Wikipedia.
A natural number is a ""Doubleton Number"", if it contains exactly two distinct digits. For example, 23, 35, 100, 12121 are doubleton numbers, and 123 and 114455 are not.
Create a function which takes a number n and finds the next doubleton number.
Examples
doubleton(10) ➞ 12
# 12 has only two distinct numbers 1 and 2

doubleton(120) ➞ 121
# 121 has only two distinct numbers 1 and 2

doubleton(1234) ➞ 1311
# 1311 has only two distinct numbers 1 and 3
Notes
N/A:def doubleton(n):
  n+=1
  while len(set(str(n)))!=2:
    n+=1
  return n<|endoftext|>"
1000,"<|endoftext|>Given a binary search tree and a sorted sub-sequence. the task is to check if the given sorted sub-sequence exist in binary search tree or not.


 :# Python3 program to find if given array
# exists as a subsequence in BST
class Node:
 
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
         
# A utility function to insert a
# given key to BST
def insert(root, key):
    if root == None:
        return Node(key)
    if root.data > key:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    return root
 
# function to check if given sorted
# sub-sequence exist in BST index .
# iterator for given sorted sub-sequence
# seq[] . given sorted sub-sequence
def seqExistUtil(ptr, seq, index):
    if ptr == None:
        return
 
    # We traverse left subtree
    # first in Inorder
    seqExistUtil(ptr.left, seq, index)
 
    # If current node matches with se[index[0]]
    # then move forward in sub-sequence
    if ptr.data == seq[index[0]]:
        index[0] += 1
 
    # We traverse left subtree in
    # the end in Inorder
    seqExistUtil(ptr.right, seq, index)
 
# A wrapper over seqExistUtil. It returns
# true if seq[0..n-1] exists in tree.
def seqExist(root, seq, n):
     
    # Initialize index in seq[]
    index = [0]
 
    # Do an inorder traversal and find if
    # all elements of seq[] were present
    seqExistUtil(root, seq, index)
 
    # index would become n if all elements
    # of seq[] were present
    if index[0] == n:
        return True
    else:
        return False
 
# Driver Code
if __name__ == '__main__':
    root = None
    root = insert(root, 8)
    root = insert(root, 10)
    root = insert(root, 3)
    root = insert(root, 6)
    root = insert(root, 1)
    root = insert(root, 4)
    root = insert(root, 7)
    root = insert(root, 14)
    root = insert(root, 13)
 
    seq = [4, 6, 8, 14]
    n = len(seq)
    if seqExist(root, seq, n):
        print(""Yes"")
    else:
        print(""No"")
 
# This code is contributed by PranchalK
<|endoftext|>"
1001,"<|endoftext|>You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).

Return the largest possible value of num after any number of swaps.:def largestInteger(self, num: int) -> int:
        digits = [int(d) for d in str(num)]
        odd = sorted([d for d in digits if d%2 == 1])
        even = sorted([d for d in digits if d%2 == 0])
        resDigits =[even.pop() if digits[i]%2==0 else odd.pop() for i in range(len(digits))]
        return int(''.join([str(d) for d in resDigits]))<|endoftext|>"
1002,"<|endoftext|>In this example, you will learn to iterate over dictionaries using for loop.:dt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}

for key, value in dt.items():
    print(key, value)
dt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}

for key in dt:
    print(key, dt[key])
dt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}

for key, value in dt.iteritems():
    print(key, value)
dt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}

for key in dt.keys():
    print(key)

for value in dt.values():
    print(value)<|endoftext|>"
1003,"<|endoftext|>Create a function that takes a number as an argument and returns the amount of digits it has.
Examples
find_digit_amount(123) ➞ 3

find_digit_amount(56) ➞ 2

find_digit_amount(7154) ➞ 4

find_digit_amount(61217311514) ➞ 11

find_digit_amount(0) ➞ 1
Notes
If you get stuck on a challenge, find help in the Resources tab.
If you're really stuck, unlock solutions in the Solutions tab.:def find_digit_amount(num):
  return (len(str(abs(num))))<|endoftext|>"
1004,"<|endoftext|>Mubashir needs your help in a simple task.
Given a list of numbers lst:
Create a dictionary for each given number.
The dictionary key will be the number converted to a string.
The value will be the corresponding character code converted to a string (check ASCII table).
Return a list of the resulting dictionaries.
Examples
num_to_dict([118, 117, 120]) ➞ [{""118"":""v""}, {""117"":""u""}, {""120"":""x""}]

num_to_dict([101, 121, 110, 113, 103]) ➞ [{""101"":""e""}, {""121"":""y""}, {""110"":""n""}, {""113"":""q""}, {""103"":""g""}]

num_to_dict([118, 103, 110]) ➞ [{""118"":""v""}, {""103"":""g""}, {""110"":""n""}]
Notes
All inputs will be a list of numbers.
All character codes are valid lower case letters.
The input array will not be empty.:def num_to_dict(lst):
  return [{str(i) : chr(i)} for i in lst]<|endoftext|>"
1005,"<|endoftext|>Given a directed graph, find out whether the graph is strongly connected or not. A directed graph is strongly connected if there is a path between any two pair of vertices. For example, following is a strongly connected graph.:# Python program to check if a given directed graph is strongly
# connected or not

from collections import defaultdict

# This class represents a directed graph using adjacency list representation


class Graph:

        def __init__(self, vertices):
                self.V = vertices # No. of vertices
                self.graph = defaultdict(list) # default dictionary to store graph

        # function to add an edge to graph
        def addEdge(self, u, v):
                self.graph[u].append(v)

        # A function used by isSC() to perform DFS
        def DFSUtil(self, v, visited):

                # Mark the current node as visited
                visited[v] = True

                # Recur for all the vertices adjacent to this vertex
                for i in self.graph[v]:
                        if visited[i] == False:
                                self.DFSUtil(i, visited)

        # Function that returns reverse (or transpose) of this graph

        def getTranspose(self):

                g = Graph(self.V)

                # Recur for all the vertices adjacent to this vertex
                for i in self.graph:
                        for j in self.graph[i]:
                                g.addEdge(j, i)

                return g

        # The main function that returns true if graph is strongly connected
        def isSC(self):

                # Step 1: Mark all the vertices as not visited (For first DFS)
                visited =[False]*(self.V)
                
                # Step 2: Do DFS traversal starting from first vertex.
                self.DFSUtil(0,visited)

                # If DFS traversal doesnt visit all vertices, then return false
                if any(i == False for i in visited):
                        return False

                # Step 3: Create a reversed graph
                gr = self.getTranspose()
                
                # Step 4: Mark all the vertices as not visited (For second DFS)
                visited =[False]*(self.V)

                # Step 5: Do DFS for reversed graph starting from first vertex.
                # Starting Vertex must be same starting point of first DFS
                gr.DFSUtil(0,visited)

                # If all vertices are not visited in second DFS, then
                # return false
                if any(i == False for i in visited):
                        return False

                return True

# Create a graph given in the above diagram
g1 = Graph(5)
g1.addEdge(0, 1)
g1.addEdge(1, 2)
g1.addEdge(2, 3)
g1.addEdge(3, 0)
g1.addEdge(2, 4)
g1.addEdge(4, 2)
print (""Yes"" if g1.isSC() else ""No"")

g2 = Graph(4)
g2.addEdge(0, 1)
g2.addEdge(1, 2)
g2.addEdge(2, 3)
print (""Yes"" if g2.isSC() else ""No"")

# This code is contributed by Neelam Yadav
<|endoftext|>"
1006,"<|endoftext|>List Comprehension
List comprehension offers a shorter syntax when you want to create a new list based on the values of an existing list.

Example: You want to create a list of all the fruits that has the letter ""a"" in the name.

Without list comprehension you will have to write a for statement with a conditional test inside::fruits = [""apple"", ""banana"", ""cherry"", ""kiwi"", ""mango""]
newlist = []

for x in fruits:
  if ""a"" in x:
    newlist.append(x)

print(newlist)<|endoftext|>"
1007,"<|endoftext|>Factorial:

The product of all positive integers less than or equal to n is the factorial of a non-negative integer n, denoted by n! in mathematics:



n! = n * (n – 1) *(n – 2) * . . . . . . . . . . 3 * 2 * 1.

4 != 4 * 3 * 2 *1= 24

Given a number N and the task is to calculate the value of 1/N!

Examples:

Example1:

Input:

Given Number = 4
Output:

The value of 1/n! with given n value{ 4 } = 0.041666666666666664
Example2:

Input:

Given Number = 6
Output:

The value of 1/n! with given n value{ 6 } = 0.001388888888888889:# Give the number as static input and store it in a variable.
 gven_nval = 4
 # Take a variable, initialize it with the value '1', and store it in another variable say
 # 'factorl'.
 factorl = 1
 # Loop from 1 to the given number using the for loop.
 for itr in range(1, gven_nval+1):
  # Inside the loop, calculate the factorial of a given number by multiplying the value of
  # the above variable ""factorl"" with the iterator value.
  # Store it in the same variable 'factorl'.
  factorl *= itr
 # Calculate the value of 1/factorl and store it in another variable.
 fnl_reslt = 1.0/factorl
 # Print the value of 1/N! for the given number.
 print(""The value of 1/n! with given n value{"", gven_nval, ""} ="", fnl_reslt)<|endoftext|>"
1008,"<|endoftext|>Given a word, write a function that returns the first index and the last index of a character.
Examples
char_index(""hello"", ""l"") ➞ [2, 3]
# The first ""l"" has index 2, the last ""l"" has index 3.

char_index(""circumlocution"", ""c"") ➞ [0, 8]
# The first ""c"" has index 0, the last ""c"" has index 8.

char_index(""happy"", ""h"") ➞ [0, 0]
# Only one ""h"" exists, so the first and last index is 0.

char_index(""happy"", ""e"") ➞ None
# ""e"" does not exist in ""happy"", so we return undefined.
Notes
If the character does not exist in the word, return None.
If only one instance of the character exists, the first and last index will be the same.
Check the Resources tab for hints.:def char_index(word, char):
  return None if char not in word else [word.index(char), word.rindex(char)]<|endoftext|>"
1009,"<|endoftext|>Accessing Dictionary Items
You can access the items of a dictionary by referring to its key name, inside square brackets::x = thisdict[""model""]<|endoftext|>"
1010,"<|endoftext|>Given a Prefix expression, convert it into a Postfix expression. 
Conversion of Prefix expression directly to Postfix without going through the process of converting them first to Infix and then to Postfix is much better in terms of computation and better understanding the expression (Computers evaluate using Postfix expression). :# Write Python3 code here
# -*- coding: utf-8 -*-
 
# Example Input
s = ""*-A/BC-/AKL""
 
# Stack for storing operands
stack = []
 
operators = set(['+', '-', '*', '/', '^'])
 
# Reversing the order
s = s[::-1]
 
# iterating through individual tokens
for i in s:
 
    # if token is operator
    if i in operators:
 
        # pop 2 elements from stack
        a = stack.pop()
        b = stack.pop()
 
        # concatenate them as operand1 +
        # operand2 + operator
        temp = a+b+i
        stack.append(temp)
 
    # else if operand
    else:
        stack.append(i)
 
# printing final output
print(*stack)
<|endoftext|>"
1011,"<|endoftext|>Given a number N and the task is to find the triangular number series (1 3 6 10 15 …N) until the given number.

int() function in Python:

The int() function is used to transform a value into an integer number.:# Give the number N as static input and store it in a variable.
gvn_numb = 8
# Take a variable say k and initialize its value with 1.
k = 1
print(""The Triangular series until the given number{"", gvn_numb, ""} is :"")
# Loop until the value of k is less than or equal to the given number using the while loop.
while(k <= gvn_numb):
   # Inside the loop, multiply the value of k with k+1 and divide the result by 2 and
   # convert it into an integer using the int() function.
   # Store it in a variable say p.
    p = int((k*(k+1))/2)
   # Print the above result (p) separated by spaces to get the triangular series until
   # the given number.
    print(p, end="" "")
   # Increment the value of k by 1 and store it in the same variable k.
    k += 1<|endoftext|>"
1012,"<|endoftext|>This python program calculates number of digit in a given number. For example, 2893 has 4 digit it it, 323 has 3 digit and so on.
In this program augmented assignment operators like n //= 10 is used. Which is simply short form of writing n = n//10 & n//10 indicates Floor or Integer Division.:# Counting digit in number

# Defining function to count digit
def count_digit(n):
    count = 0
    while n:
        n //= 10
        count += 1

    return count

# Reading number
number = int(input('Enter number: '))

# Displaying result
print('Number of digit in %d is %d.' %(number, count_digit(number)))<|endoftext|>"
1013,"<|endoftext|>In this example, you will learn to check if a string is a number (float).:def isfloat(num):
    try:
        float(num)
        return True
    except ValueError:
        return False

print(isfloat('s12'))
print(isfloat('1.123'))<|endoftext|>"
1014,"<|endoftext|>Write three functions:
boolean_and
boolean_or
boolean_xor
These functions should evaluate a list of True and False values, starting from the leftmost element and evaluating pairwise.
Examples
boolean_and([True, True, False, True]) ➞ False
# [True, True, False, True] => [True, False, True] => [False, True] => False

boolean_or([True, True, False, False]) ➞ True
# [True, True, False, True] => [True, False, False] => [True, False] => True

boolean_xor([True, True, False, False]) ➞ False
# [True, True, False, False] => [False, False, False] => [False, False] => False
Notes
XOR is the same as OR, except that it excludes [True, True].
Each time you evaluate an element at 0 and at 1, you collapse it into the single result.:boolean_and=all
boolean_or=any  
boolean_xor=lambda l:sum(l)%2<|endoftext|>"
1015,"<|endoftext|>In this article, we have to develop a program to check given character vowels or consonants using many methods. The characters A, E, I, O, U (uppercase and lowercase) are called vowels. Except all other characters are called consonants.:# Python program to check character is vowel or consonant # input from user ch = input('Enter any character: ') # check vowel or constant and display result if(ch=='A' or ch=='a' or ch=='E' or ch =='e' or ch=='I' or ch=='i' or ch=='O' or ch=='o' or ch=='U' or ch=='u'): print(ch, ""is a Vowel"") else: print(ch, ""is a Consonant"")<|endoftext|>"
1016,"<|endoftext|>The program takes a list and i as input and prints the ith largest element in the list.:def select(alist, start, end, i):
    """"""Find ith largest element in alist[start... end-1].""""""
    if end - start <= 1:
        return alist[start]
    pivot = partition(alist, start, end)
 
    # number of elements in alist[pivot... end - 1]
    k = end - pivot
 
    if i < k:
        return select(alist, pivot + 1, end, i)
    elif i > k:
        return select(alist, start, pivot, i - k)
 
    return alist[pivot]
 
def partition(alist, start, end):
    pivot = alist[start]
    i = start + 1
    j = end - 1
 
    while True:
        while (i <= j and alist[i] <= pivot):
            i = i + 1
        while (i <= j and alist[j] >= pivot):
            j = j - 1
 
        if i <= j:
            alist[i], alist[j] = alist[j], alist[i]
        else:
            alist[start], alist[j] = alist[j], alist[start]
            return j
 
 
alist = input('Enter the list of numbers: ')
alist = alist.split()
alist = [int(x) for x in alist]
i = int(input('The ith smallest element will be found. Enter i: '))
 
ith_smallest_item = select(alist, 0, len(alist), i)
print('Result: {}.'.format(ith_smallest_item))<|endoftext|>"
1017,"<|endoftext|>Write a function that sorts a list of characters alphabetically in ascending order (a-z) by the character at the n-th character.
Examples
sort_by_character([""az16"", ""by35"", ""cx24""], 2) ➞ [""cx24"", ""by35"", ""az16""]
// By 2nd character: [""x"", ""y"", ""z""] is in alphabetical order.

sort_by_character([""mayor"", ""apple"", ""petal""], 5) ➞ [""apple"", ""petal"", ""mayor""]
# By 5th character: [""e"", ""l"", ""r""] is in alphabetical order

sort_by_character([""mate"", ""team"", ""bade""], 3) ➞ [""team"", ""bade"", ""mate""]
Notes
All inputs will be of same length.:def sort_by_character(lst, n):
  return sorted(lst,key= lambda x: x[n-1])<|endoftext|>"
1018,"<|endoftext|>Given the Pentagon’s side length and the task is to calculate the area and perimeter of the given Pentagon.:# Import the math module using the import keyword.
import math
# Give the Pentagon's side length as user input using float(input()) function and
# store it in a variable.
side_len = float(input('Enter some random number = '))
# Calculate the area of the given pentagon using the above given mathematical formula and
# math.sqrt() function.
# Store it in another variable.
pentgn_area = (math.sqrt(5*(5+2*math.sqrt(5)))*pow(side_len, 2))/4.0
# Calculate the perimeter of the given pentagon using the above given mathematical formula.
# Store it in another variable.
pentgn_perimtr = (5*side_len)
# Print the Pentagon's area with the given side length.
print(
    ""The Pentagon's area with given side length {"", side_len, ""} ="", pentgn_area)
# Print the Pentagon's perimeter with the given side length.
print(
    ""The Pentagon's Perimeter with given side length {"", side_len, ""} ="", pentgn_perimtr)<|endoftext|>"
1019,"<|endoftext|>We will develop a program to reverse each word in a string python. In this article, we are using the split() function, list comprehension, and join() function to reverse each word of a string in Python. The split() method splits the string from the specified separator and returns a list object with string elements. The join() method takes all items in an iterable and joins them into one string. A string must be specified as the separator. List comprehensions provide a concise way to create lists.:# Python program to reverse each word in a string # take inputs string = 'Know Program' # splitting the string into list of words words = string.split(' ') # reversing each word and creating a new list of words reverseWords = [word[::-1] for word in words] # joining the new list of words to for a new string reverseString = "" "".join(reverseWords) # print reverse of each word in a string print('The reverse is', reverseString)<|endoftext|>"
1020,"<|endoftext|>Given an array of distinct elements. The task is to find triplets in the array whose sum is zero.:# python program to find triplets in a given
# array whose sum is zero

# function to print triplets with 0 sum
def findTriplets(arr, n):

	found = False

	# sort array elements
	arr.sort()

	for i in range(0, n-1):
	
		# initialize left and right
		l = i + 1
		r = n - 1
		x = arr[i]
		while (l < r):
		
			if (x + arr[l] + arr[r] == 0):
				# print elements if it's sum is zero
				print(x, arr[l], arr[r])
				l+=1
				r-=1
				found = True
			

			# If sum of three elements is less
			# than zero then increment in left
			elif (x + arr[l] + arr[r] < 0):
				l+=1

			# if sum is greater than zero than
			# decrement in right side
			else:
				r-=1
		
	if (found == False):
		print("" No Triplet Found"")


# Driven source
arr = [0, -1, 2, -3, 1]
n = len(arr)
findTriplets(arr, n)

# This code is contributed by Smitha Dinesh Semwal<|endoftext|>"
1021,"<|endoftext|>We will develop a Python program for multiplication of two numbers. A mathematical operation is performed on a pair of numbers in order to derive a third number called a product. We will give two numbers num1 and num2. Then, calculate the product of those numbers using the multiplication operator (*). Here, we will calculate the product of two numbers using various methods.:# Python program to multiply two number

# take inputs
num1 = 3
num2 = 5

# calculate product
product = num1*num2

# print multiplication value
print(""The Product of Number:"", product)<|endoftext|>"
1022,"<|endoftext|>Write a C function to insert a new value in a sorted Circular Linked List (CLL). For example, if the input CLL is following. :# Node class
class Node:

	# Constructor to initialize the node object
	def __init__(self, data):
		self.data = data
		self.next = None

class LinkedList:

	# Function to initialize head
	def __init__(self):
		self.head = None

	# Function to insert a new node at the beginning
	def push(self, new_data):
		new_node = Node(new_data)
		new_node.next = self.head
		self.head = new_node

	# Utility function to print the linked LinkedList
	def printList(self):
		temp = self.head
		print(temp.data,end=' ')
		temp = temp.next
		while(temp != self.head):
			print (temp.data,end=' ')
			temp = temp.next

	"""""" function to insert a new_node in a list in sorted way.
	Note that this function expects a pointer to head node
	as this can modify the head of the input linked list """"""
	def sortedInsert(self, new_node):
		
		current = self.head

		# Case 1 of the above algo
		if current is None:
			new_node.next = new_node
			self.head = new_node
		
		# Case 2 of the above algo
		elif (current.data >= new_node.data):
			
			# If value is smaller than head's value then we
			# need to change next of last node
			while current.next != self.head :
				current = current.next
			current.next = new_node
			new_node.next = self.head
			self.head = new_node		

		
		# Case 3 of the above algo
		else:
			
			# Locate the node before the point of insertion
			while (current.next != self.head and
				current.next.data < new_node.data):
				current = current.next

			new_node.next = current.next
			current.next = new_node


# Driver program to test the above function
#llist = LinkedList()
arr = [12, 56, 2, 11, 1, 90]

list_size = len(arr)

# start with empty linked list
start = LinkedList()

# Create linked list from the array arr[]
# Created linked list will be 1->2->11->12->56->90
for i in range(list_size):
	temp = Node(arr[i])
	start.sortedInsert(temp)

start.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)<|endoftext|>"
1023,"<|endoftext|>A rational number is defined as the quotient of two integers a and b, called the numerator and denominator, respectively, where b != 0.
:from __future__ import division
import math
class Rational(object):
    def __init__(self, numer, denom):
        gcd = math.gcd(numer, denom)
        self.numer = int(numer / gcd)
        self.denom = int(denom / gcd)
        if numer < 0 or denom < 0:
            self.numer = -1 * abs(self.numer)
            self.denom = abs(self.denom)
            
    def __eq__(self, other):
        return self.numer == other.numer and self.denom == other.denom
    def __repr__(self):
        return '{}/{}'.format(self.numer, self.denom)
    def __add__(self, other):
        return Rational(self.numer*other.denom + self.denom*other.numer,
                        self.denom * other.denom)
    def __sub__(self, other):
        return Rational(self.numer*other.denom - self.denom*other.numer,
                        self.denom * other.denom)
    def __mul__(self, other):
        return Rational(self.numer*other.numer, self.denom * other.denom)
    def __truediv__(self, other):
        if (self.numer < 0 and other.numer < 0) or (self.numer > 0 and other.numer > 0):
            return Rational(abs(self.numer*other.denom), abs(self.denom * other.numer))
        else:
            return Rational(-1*abs(self.numer*other.denom), abs(self.denom * other.numer))
    def __abs__(self):
        return Rational(abs(self.numer),abs(self.denom))
    def __pow__(self, power):
        if type(power) is int and power >= 0:
            return Rational(self.numer ** power,self.denom ** power)
        elif type(power) is int and power < 0:
            return Rational(self.denom ** abs(power),self.numer ** abs(power))
        else:
            return self.numer ** power / self.denom ** power
    def __rpow__(self, base):
        return math.pow(base**self.numer, 1/self.denom)<|endoftext|>"
1024,"<|endoftext|>Create a function that validates a password to conform to the following rules:
Length between 6 and 24 characters.
At least one uppercase letter (A-Z).
At least one lowercase letter (a-z).
At least one digit (0-9).
Maximum of 2 repeated characters.
""aa"" is OK 👍
""aaa"" is NOT OK 👎
Supported special characters:
! @ # $ % ^ & * ( ) + = _ - { } [ ] : ; "" ' ? < > , .
Examples
validate_password(""P1zz@"") ➞ False
// Too short.

validate_password(""iLoveYou"") ➞ False
// Missing a number.

validate_password(""Fhg93@"") ➞ True
// OK!
Notes
N/A:import re
def validate_password(password):
    lenght = 6 <= len(password) <= 24
    uppercase = re.search(r'[A-Z]', password)
    lowercase = re.search(r'[a-z]', password)
    digits = re.search(r'\d', password)
    repeated = not re.search(r'(.)\1{2,}', password)
    conditions = (lenght, uppercase, lowercase, digits, repeated)
    return all(conditions)<|endoftext|>"
1025,"<|endoftext|>In the previous article, we have discussed about Program to Read a Number n and Compute n+nn+nnn in C++ and Python. Let us learn Program to Print Collatz Conjecture for a Given Number in C++ Program.
 Given a number , the task is to print Collatz Conjecture of the given number in C++ and Python.
 Collatz Conjecture:
 
 The Collatz Conjecture states that a specific sequence will always reach the value 1.
 It is given as follows, beginning with some integer n:
 If n is an even number, the following number in the sequence is n/2.
 Otherwise, the following number is 3n+1 (if n is odd).
 
 Examples:
 Example1:
 Input:
 given number =5425
 Output:
 The Collatz Conjecture of the number :
 
 5425 16276 8138 4069 12208 6104 3052 1526 763 2290 1145 3436 1718 859 2578 1289 3868 1934 967 2902 1451 4354 2177 6532 3266 1633 4900 2450 1225 3676 1838 919 2758 1379 4138 2069 6208 3104 1552 776 388 194 97 292 146 73 220 110 55 166 83 250 125 376 188 94 47 142 71 214 107 322 161 484 242 121 364 182 91 274 137 412 206 103 310 155 466 233 700 350 175 526 263 790 395 1186 593 1780 890 445 1336 668 334 167 502 251 754 377 1132 566 283 850 425 1276 638 319 958 479 1438 719 2158 1079 3238 1619 4858 2429 7288 3644 1822 911 2734 1367 4102 2051 6154 3077 9232 4616 2308 1154 577 1732 866 433 1300 650 325 976 488 244 122 61 184 92 46 23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1
 Example2:
 Input:
 given number=847
 Output:
 The Collatz Conjecture of the number :
 
 847 2542 1271 3814 1907 5722 2861 8584 4292 2146 1073 3220 1610 805 2416 1208 604 302 151 454 227 682 341 1024 512 256 128 64 32 16 8 4 2 1:# function which prints collatz sequence of the given number
 
 def printCollatz(numb):
 
  # Iterate till the given number is not equal to 1 using while loop.
 
  while numb > 1:
 
  # Print the number numb
 
  print(numb, end=' ')
 
  # If the number is even then set n to n/2.
 
  if (numb % 2 == 0):
 
  numb = numb//2
 
  # If the number is odd then set n to 3*n+1.
 
  else:
 
  numb = 3*numb + 1
 
  # Print 1 after end of while loop.
 
  print(1, end='')
 
 
 
 
 
 # given number
 
 numb = 179
 
 print('The Collatz Conjecture of the number :')
 
 # passing the given numb to printCollatz function to
 
 # print collatzConjecture sequence of the given number
 
 printCollatz(numb)<|endoftext|>"
1026,"<|endoftext|>Given a number ,the task is to count the set bits of the given number in its binary representation.
 Examples:
 Example1:
 Input:
 given number =235
 Output:
 The total number of set bits in the given number 235 : 
 
 6
 Example2:
 Input:
 given number =8
 Output:
 The total number of set bits in the given number 8 : 
 
 1
 Example3:
 Input:
 given number =375
 Output:
 The total number of set bits in the given number 375 : 
 
 7:def countSetBit(numb):
 
  # checking if the given number is greater than 1
 
  if numb > 1:
 
  # Set the variable say setbitcount to 0 to count the total number of set bits.
 
  setbitcount = 0
 
  # looping till number greater than 0 using while loop
 
  while(numb > 0):
 
  # We will get the last check bit whether it is set bit or not using % operator
 
  checkbit = numb % 2
 
  # checking if the check bit is 1 or not
 
  # if the check bit is 1 then increment the setbitcount
 
  if(checkbit == 1):
 
  setbitcount = setbitcount+1
 
  # divide the number by 2
 
  numb = numb//2
 
  # return the setbitcount
 
  return setbitcount
 
 
 
 
 
 # Driver code
 
 given_numb = 235
 
 # passing given number to countSetBit function to
 
 # count the total number of set bits in the given number
 
 print(""The total number of set bits in the given number "", given_numb, "" : "")
 
 print(countSetBit(given_numb))<|endoftext|>"
1027,"<|endoftext|>Jack and Jill are twins. When they are 10 years of age, Jack leaves earth in his spaceship bound for Altair IV, some 17 light-years distant. Though not equipped with warp drive, Jack's ship is still capable of attaining near light speed. When he returns to earth he finds that Jill has grown to adulthood while he, Jack, remains a young boy.
Albert Einstein had predicted this strange quirk of time in his 1905 paper ""On the Electrodynamics of Moving Bodies"" aka The Theory of Special Relativity. It has been verified experimentally many times.
Implement a function that has as it's arguments: The twins' age at the time of Jack's departure, the distance in light-years to the destination star, and the speed of Jack's ship as a fraction of the speed of light. The function will return Jack's age and Jill's age at the time of Jack's return to earth, rounded to the nearest tenth of a year. The math is simple enough for 10-year-old Jack to understand. See Resources for help.
Examples
twins(20, 10, 0.4) ➞ ""Jack's age is 65.8, Jill's age is 70.0""

twins(20, 10, 0.8) ➞ ""Jack's age is 35.0, Jill's age is 45.0""

twins(10, 16.73, 0.999) ➞ ""Jack's age is 11.5, Jill's age is 43.5""
# The Altair IV trip.
Notes
We are assuming for the sake of simplicity that Jack's periods of acceleration and deceleration are negligibly brief. That is a huge assumption but, nevertheless, it doesn't invalidate the age calculations.:from math import sqrt
def twins(age,distance,velocity):
    te=2*distance/velocity
    jill=age+round(te,1)
    jack=age+round(te*sqrt(1-velocity**2),1)
    ans=""Jack's age is {}, Jill's age is {}""
    return ans.format(jack,jill)<|endoftext|>"
1028,"<|endoftext|>Given a matrix and the product value k, the task is to check whether the pair with the given product value exists in the given matrix or not.:# Create a function to say CheckPairwith_prodctK() which takes the given matrix and
# given product k value as the arguments and returns true or false.


def CheckPairwith_prodctK(mtrx, gvn_k_val):
        # Inside the function, take a new empty list and store it in another variable.
    new_lst = []
    # Loop till the given number of rows using the For loop.
    for n in range(mtrxrows):
      # Inside the For loop, Iterate till the given number of columns using another Nested
          # For loop(Inner For loop).
        for m in range(mtrxcols):
          # Check if the value of given k modulus mtrx[n][m] is equal to 0 and given k
          # value divided by mtrx[n[m] is present in the above declared new list using
          # the if # conditional statement.
            if ((gvn_k_val % mtrx[n][m] == 0) and
                    (gvn_k_val // mtrx[n][m]) in new_lst):
                # If it is true, then return true.
                return True
                # Else append mtrx[n][m] to the above new list using the append() function.
            else:
                new_lst.append(mtrx[n][m])


# Give the matrix as static input and store it in a variable.
mtrx = [[1, 5, 4], [8, 6, 1], [6, 2, 4]]
# Calculate the number of rows of the given matrix by
# calculating the length of the nested list using the len() function
# and store it in a variable mtrxrows.
mtrxrows = len(mtrx)
# Calculate the number of columns of the given matrix by
# calculating the length of the first list in the nested list
# using the len() function and store it in a variable mtrxcols.
mtrxcols = len(mtrx[0])
# Give the k value as static input and store it in another variable.
gvn_k_val = 30
# Pass the given matrix and the given k value as the arguments to the
# CheckPairwith_prodctK() function and check if it returns true or false using
# the if conditional statement.
if (CheckPairwith_prodctK(mtrx, gvn_k_val)):
        # If it is true, then print ""Yes, the pair with the given product value k exists in
        # the given matrix"".
    print(""Yes, the pair with the given product value k exists in the given matrix"")

else:
    # Else print ""No, the pair with the given product value k does not exist in the given
        # matrix"".
    print(""No, the pair with the given product value k does not exist in the given matrix"")<|endoftext|>"
1029,"<|endoftext|>Given a string columnTitle that represents the column title as appear in an Excel sheet, return its corresponding column number.

For example:

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...:class Solution:
    def titleToNumber(self, s: str) -> int:
        result = 0
        
        # Decimal 65 in ASCII corresponds to char 'A'
        alpha_map = {chr(i + 65): i + 1 for i in range(26)}

        n = len(s)
        for i in range(n):
            cur_char = s[n - 1 - i]
            result += (alpha_map[cur_char] * (26 ** i))
        return result<|endoftext|>"
1030,"<|endoftext|>A value is omnipresent if it exists in every sublist inside the main list.
To illustrate:
[[3, 4], [8, 3, 2], [3], [9, 3], [5, 3], [4, 3]]
# 3 exists in every element inside this list, so is omnipresent.
Create a function that determines whether an input value is omnipresent for a given list.
Examples
is_omnipresent([[1, 1], [1, 3], [5, 1], [6, 1]], 1) ➞ True

is_omnipresent([[1, 1], [1, 3], [5, 1], [6, 1]], 6) ➞ False

is_omnipresent([[5], [5], [5], [6, 5]], 5) ➞ True

is_omnipresent([[5], [5], [5], [6, 5]], 6) ➞ False
Notes
Sub-lists can be any length.:def is_omnipresent(lst, val):
  return all([val in l for l in lst])<|endoftext|>"
1031,"<|endoftext|>A palindrome is a word, phrase, number or other sequence of characters which reads the same backward or forward, such as madam or kayak.
Write a function that takes a string and determines whether it's a palindrome or not. The function should return a boolean (True or False value).
Examples
is_palindrome(""Neuquen"") ➞ True

is_palindrome(""Not a palindrome"") ➞ False

is_palindrome(""A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal-Panama!"") ➞ True
Notes
Should be case insensitive.
Special characters (punctuation or spaces) should be ignored.:def is_palindrome(txt):
  check = [s.lower() for s in txt if s.isalpha()]
  return check[::-1] == check<|endoftext|>"
1032,"<|endoftext|>Given a sentence text (A sentence is a string of space-separated words) in the following format:

First letter is in upper case.
Each word in text are separated by a single space.

Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.
Return the new text following the format shown above.
 
Example 1:

Input: text = ""Leetcode is cool""
Output: ""Is cool leetcode""
Explanation: There are 3 words, ""Leetcode"" of length 8, ""is"" of length 2 and ""cool"" of length 4.
Output is ordered by length and the new first word starts with capital letter.

Example 2:

Input: text = ""Keep calm and code on""
Output: ""On and keep calm code""
Explanation: Output is ordered as follows:
""On"" 2 letters.
""and"" 3 letters.
""keep"" 4 letters in case of tie order by position in original text.
""calm"" 4 letters.
""code"" 4 letters.

Example 3:

Input: text = ""To be or not to be""
Output: ""To be or to be not""

 
Constraints:

text begins with a capital letter and then contains lowercase letters and single space between words.
1 <= text.length <= 10^5:class Solution:
  def arrangeWords(self, text: str) -> str:
  return "" "".join(sorted(text.split(), key=len)).capitalize()<|endoftext|>"
1033,"<|endoftext|>Given an array of 0s and 1s, find the position of 0 to be replaced with 1 to get longest continuous sequence of 1s. Expected time complexity is O(n) and auxiliary space is O(1). :# Python program to find Index
# of 0 to be replaced with 1 to get
# longest continuous sequence
# of 1s in a binary array
 
# Returns index of 0 to be
# replaced with 1 to get longest
# continuous sequence of 1s.
#  If there is no 0 in array, then
# it returns -1.
def maxOnesIndex(arr,n):
     
    # for maximum number of 1 around a zero
    max_count = 0
 
    # for storing result 
    max_index =0 
 
    # index of previous zero
    prev_zero = -1 
 
    # index of previous to previous zero
    prev_prev_zero = -1
  
    # Traverse the input array
    for curr in range(n):
     
        # If current element is 0,
        # then calculate the difference
        # between curr and prev_prev_zero
        if (arr[curr] == 0):
         
            # Update result if count of
            # 1s around prev_zero is more
            if (curr - prev_prev_zero > max_count):
             
                max_count = curr - prev_prev_zero
                max_index = prev_zero
             
  
            # Update for next iteration
            prev_prev_zero = prev_zero
            prev_zero = curr
  
    # Check for the last encountered zero
    if (n-prev_prev_zero > max_count):
        max_index = prev_zero
  
    return max_index
  
# Driver program
 
arr = [1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1]
n = len(arr)
 
print(""Index of 0 to be replaced is "",
    maxOnesIndex(arr, n))
 
# This code is contributed
# by Anant Agarwal.<|endoftext|>"
1034,"<|endoftext|>Write a function that takes a list and returns a new list with unique positive (more than 0) numbers.
Examples
unique_lst([-5, 1, -7, -5, -2, 3, 3, -5, -1, -1]) ➞ [1, 3]

unique_lst([3, -3, -3, 5, 5, -6, -2, -4, -1, 3]) ➞ [3, 5]

unique_lst([10, 6, -12, 13, 5, 5, 13, 6, 5]) ➞ [10, 6, 13, 5]
Notes
Return the elements in the order that they are found in the list.
Your function should also work for empty lists.:def unique_lst(lst):
  return sorted(set(i for i in lst if i > 0), key=lst.index)<|endoftext|>"
1035,"<|endoftext|>Given an array of N integers and an integer K, pick two distinct elements whose sum is K and find the maximum shortest distance of the picked elements from the endpoints.
Examples: 
 

Input : a[] = {2, 4, 3, 2, 1}
        k = 5.
Output :  2
Explanation:
Select the pair(4, 1). 
Shortest distance of 4 from ends = 2
Shortest distance of 1 from ends = 1
Hence, answer is max(2, 1) = 2      

Input : a[] = {2, 4, 1, 9, 5}
        k = 3
Output : 3
Explanation:
Select the pair (2, 1)
Shortest distance of 2 from ends = 1
Shortest distance of 1 from ends = 3
Hence, answer is max(1, 3) = 3. :# Python3 code to find maximum shortest
# distance from endpoints

# function to find maximum shortest distance
def find_maximum(a, n, k):
	
	# stores the shortest distance of every
	# element in original array.
	b = dict()
	
	for i in range(n):
		x = a[i]
		
		# shortest distance from ends
		d = min(1 + i, n - i)
		if x not in b.keys():
			b[x] = d
		else:

			# if duplicates are found, b[x]
			# is replaced with minimum of the
			# previous and current position's
			# shortest distance*/
			b[x] = min(d, b[x])
	
	ans = 10**9
	for i in range(n):
		x = a[i]
		
		# similar elements ignore them
		# cause we need distinct elements
		if (x != (k - x) and (k - x) in b.keys()):		
			ans = min(max(b[x], b[k - x]), ans)

	return ans

# Driver code
a = [3, 5, 8, 6, 7]
K = 11
n = len(a)
print(find_maximum(a, n, K))

# This code is contributed by mohit kumar<|endoftext|>"
1036,"<|endoftext|>The left shift operation is similar to multiplication by powers of two, thus, the process is repetitive and can be done recursively.
Sample calculation using the left shift operator (<<):
10 << 3 = 10 * 2^3 = 10 * 8 = 80
-32 << 2 = -32 * 2^2 = -32 * 4 = -128
5 << 2 = 5 * 2^2 = 5 * 4 = 20
Write a recursive function that mimics (without the use of <<) the left shift operator and returns the result from the two given integers.
Examples
shift_to_left(5, 2) ➞ 20

shift_to_left(10, 3) ➞ 80

shift_to_left(-32, 2) ➞ -128

shift_to_left(-6, 5) ➞ -192

shift_to_left(12, 4) ➞ 192

shift_to_left(46, 6) ➞ 2944
Notes
There will be no negative values for the second parameter y.
This challenge is more like recreating of the left shift operation, thus, the use of the operator directly is prohibited.
You are expected to solve this challenge via recursion.
An iterative version of this challenge can be found via this link.:def shift_to_left(x, y):
  return 2 * shift_to_left(x, y-1) if y else x<|endoftext|>"
1037,"<|endoftext|>Using list comprehensions, create a function that finds all even numbers from 1 to the given number.
Examples
find_even_nums(8) ➞ [2, 4, 6, 8]

find_even_nums(4) ➞ [2, 4]

find_even_nums(2) ➞ [2]
Try to use list comprehensions in your solution. Here's an example:
vals = [expression 
  for value in collection 
    if condition]
This is equivalent to:
vals = []
for value in collection:
  if condition:
    vals.append(expression)
Notes
Try to use list comprehensions instead of logic.
If there are no even numbers, return an empty list.:def find_even_nums(num):
  return [ x for x in range(2,num+1,2)]<|endoftext|>"
1038,"<|endoftext|>Sometimes it is necessary to define a custom data structure of some type, like a set. In this exercise you will define your own set. How it works internally doesn't matter, as long as it behaves like a set of unique elements.:class CustomSet(object):
    def __init__(self, elements=[]):
        self.elements = []
        for element in elements:
            self.add(element)
    def isempty(self):
        return len(self.elements) == 0
    def __contains__(self, element):
        return element in self.elements
    def issubset(self, other):
        for element in self.elements:
            if element not in other.elements:
                return False
        return True
    def isdisjoint(self, other):
        for element in self.elements:
            if element in other.elements:
                return False
        return True
    def __eq__(self, other):
        if len(self.elements) != len(other.elements):
            return False
        else:
            for element in self.elements:
                if element not in other.elements:
                    return False
            return True
    def add(self, element):
        if element not in self.elements:
            self.elements.append(element)
    def intersection(self, other):
        result_elements = []
        for element in self.elements:
            if element in other.elements:
                result_elements.append(element)
        return CustomSet(result_elements)
    def __sub__(self, other):
        result_elements = []
        for element in self.elements:
            if element not in other.elements:
                result_elements.append(element)
        return CustomSet(result_elements)
    def __add__(self, other):
        result = CustomSet(self.elements)
        for element in other.elements:
            result.add(element)
        return result<|endoftext|>"
1039,"<|endoftext|>Searching a graph is quite famous problem and have a lot of practical use. We have already discussed here how to search for a goal vertex starting from a source vertex using BFS. In normal graph search using BFS/DFS we begin our search in one direction usually from source vertex toward the goal vertex, but what if we start search from both direction simultaneously.


Bidirectional search is a graph search algorithm which find smallest path from source to goal vertex. It runs two simultaneous search – 
1. Forward search from source/initial vertex toward goal vertex
2. Backward search from goal/target vertex toward source vertex
Bidirectional search replaces single search graph(which is likely to grow exponentially) with two smaller sub graphs – one starting from initial vertex and other starting from goal vertex. The search terminates when two graphs intersect.
Just like A* algorithm, bidirectional search can be guided by a heuristic estimate of remaining distance from source to goal and vice versa for finding shortest path possible.:# Python3 program for Bidirectional BFS
# Search to check path between two vertices
 
# Class definition for node to
# be added to graph
class AdjacentNode:
     
    def __init__(self, vertex):
         
        self.vertex = vertex
        self.next = None
 
# BidirectionalSearch implementation
class BidirectionalSearch:
     
    def __init__(self, vertices):
         
        # Initialize vertices and
        # graph with vertices
        self.vertices = vertices
        self.graph = [None] * self.vertices
         
        # Initializing queue for forward
        # and backward search
        self.src_queue = list()
        self.dest_queue = list()
         
        # Initializing source and
        # destination visited nodes as False
        self.src_visited = [False] * self.vertices
        self.dest_visited = [False] * self.vertices
         
        # Initializing source and destination
        # parent nodes
        self.src_parent = [None] * self.vertices
        self.dest_parent = [None] * self.vertices
         
    # Function for adding undirected edge
    def add_edge(self, src, dest):
         
        # Add edges to graph
         
        # Add source to destination
        node = AdjacentNode(dest)
        node.next = self.graph[src]
        self.graph[src] = node
 
        # Since graph is undirected add
        # destination to source
        node = AdjacentNode(src)
        node.next = self.graph[dest]
        self.graph[dest] = node
         
    # Function for Breadth First Search
    def bfs(self, direction = 'forward'):
         
        if direction == 'forward':
             
            # BFS in forward direction
            current = self.src_queue.pop(0)
            connected_node = self.graph[current]
             
            while connected_node:
                vertex = connected_node.vertex
                 
                if not self.src_visited[vertex]:
                    self.src_queue.append(vertex)
                    self.src_visited[vertex] = True
                    self.src_parent[vertex] = current
                     
                connected_node = connected_node.next
        else:
             
            # BFS in backward direction
            current = self.dest_queue.pop(0)
            connected_node = self.graph[current]
             
            while connected_node:
                vertex = connected_node.vertex
                 
                if not self.dest_visited[vertex]:
                    self.dest_queue.append(vertex)
                    self.dest_visited[vertex] = True
                    self.dest_parent[vertex] = current
                     
                connected_node = connected_node.next
                 
    # Check for intersecting vertex
    def is_intersecting(self):
         
        # Returns intersecting node
        # if present else -1
        for i in range(self.vertices):
            if (self.src_visited[i] and
                self.dest_visited[i]):
                return i
                 
        return -1
 
    # Print the path from source to target
    def print_path(self, intersecting_node,
                   src, dest):
                        
        # Print final path from
        # source to destination
        path = list()
        path.append(intersecting_node)
        i = intersecting_node
         
        while i != src:
            path.append(self.src_parent[i])
            i = self.src_parent[i]
             
        path = path[::-1]
        i = intersecting_node
         
        while i != dest:
            path.append(self.dest_parent[i])
            i = self.dest_parent[i]
             
        print(""*****Path*****"")
        path = list(map(str, path))
         
        print(' '.join(path))
     
    # Function for bidirectional searching
    def bidirectional_search(self, src, dest):
         
        # Add source to queue and mark
        # visited as True and add its
        # parent as -1
        self.src_queue.append(src)
        self.src_visited[src] = True
        self.src_parent[src] = -1
         
        # Add destination to queue and
        # mark visited as True and add
        # its parent as -1
        self.dest_queue.append(dest)
        self.dest_visited[dest] = True
        self.dest_parent[dest] = -1
 
        while self.src_queue and self.dest_queue:
             
            # BFS in forward direction from
            # Source Vertex
            self.bfs(direction = 'forward')
             
            # BFS in reverse direction
            # from Destination Vertex
            self.bfs(direction = 'backward')
             
            # Check for intersecting vertex
            intersecting_node = self.is_intersecting()
             
            # If intersecting vertex exists
            # then path from source to
            # destination exists
            if intersecting_node != -1:
                print(f""Path exists between {src} and {dest}"")
                print(f""Intersection at : {intersecting_node}"")
                self.print_path(intersecting_node,
                                src, dest)
                exit(0)
        return -1
 
# Driver code
if __name__ == '__main__':
     
    # Number of Vertices in graph
    n = 15
     
    # Source Vertex
    src = 0
     
    # Destination Vertex
    dest = 14
     
    # Create a graph
    graph = BidirectionalSearch(n)
    graph.add_edge(0, 4)
    graph.add_edge(1, 4)
    graph.add_edge(2, 5)
    graph.add_edge(3, 5)
    graph.add_edge(4, 6)
    graph.add_edge(5, 6)
    graph.add_edge(6, 7)
    graph.add_edge(7, 8)
    graph.add_edge(8, 9)
    graph.add_edge(8, 10)
    graph.add_edge(9, 11)
    graph.add_edge(9, 12)
    graph.add_edge(10, 13)
    graph.add_edge(10, 14)
     
    out = graph.bidirectional_search(src, dest)
     
    if out == -1:
        print(f""Path does not exist between {src} and {dest}"")
 
# This code is contributed by Nirjhari Jankar
<|endoftext|>"
1040,"<|endoftext|>In the previous article, we have discussed Python Program to Check if a Number has Bits in Alternate Pattern
 Given an N-bit binary sequence consisting of three binary sequences A, B, and C. Count the minimal number of bits required to flip A and B in such a way that the XOR of A and B equals C.
 X Y X XOR Y
 0 0 0
 0 1 1
 1 0 1
 1 1 0
 Cases:
 
 If A[i]==B[i] and C[i]==0 then no flip,
 If A[i]==B[i] and C[i]==1 then flip either A[i] or B[i] and increase flip count by 1
 If A[i]!=B[i] and C[i]==0 then flip either A[i] or B[i] and increase flip count by 1
 If A[i]!=B[i] and C[i]==1 then no flip required.
 
 Examples:
 Example1:
 Input:
 Given number = 5
 
 Given first string= ""11011""
 
 Given second string= ""11001""
 
 Given third string = ""11100""
 Output:
 The count of minimum bits to Flip in such a way that the XOR of A and B equals C = 4
 Example2:
 Input:
 Given number = 3
 
 Given first string= ""110""
 
 Given second string= ""111""
 
 Given third string = ""101""
 Output:
 The count of minimum bits to Flip in such a way that the XOR of A and B equals C = 1:# Create a function to say Flips_Count which takes the given three sequence
 
 # strings and the given number as the arguments and returns the count of minimum bits
 
 # to Flip in such a way that the XOR of A and B equals C.
 
 
 
 
 
 def Flips_Count(fst_seqnce, scnd_seqnce, third_seqnce, numb):
 
  # Take a variable say totl_cnt and initialize its value to 0.
 
  totl_cnt = 0
 
  # Loop till the given number using the for loop.
 
  for itr in range(numb):
 
  # Check if the fst_seqnce[itr] == scnd_seqnce[itr] and third_seqnce[itr] == '1'
 
  # using the if conditional statement.
 
  if fst_seqnce[itr] == scnd_seqnce[itr] and third_seqnce[itr] == '1':
 
  # If the statement is true, then increment the value of above totl_cnt by 1.
 
  # Store it in the same variable.
 
  totl_cnt = totl_cnt+1
 
 
 
  # Check if the fst_seqnce[itr] != scnd_seqnce[itr] and third_seqnce[itr] == '0' using
 
  # the elif conditional statement.
 
  elif fst_seqnce[itr] != scnd_seqnce[itr] and third_seqnce[itr] == '0':
 
  # If the statement is true, then increment the value of above totl_cnt by 1.
 
  # Store it in the same variable.
 
  totl_cnt = totl_cnt+1
 
  # Return the value of totl_cnt.
 
  return totl_cnt
 
 
 
 
 
 # Give the number (which is the count of bits) as static input and store it in a variable.
 
 numb = 5
 
 # Give the first binary sequence string as static input and store it in another variable.
 
 fst_seqnce = ""11011""
 
 # Give the second binary sequence string as static input and store it in another variable.
 
 scnd_seqnce = ""11001""
 
 # Give the third binary sequence string as static input and store it in another variable.
 
 third_seqnce = ""11100""
 
 # Pass the given three sequence strings and the given number as the arguments to the
 
 # Flips_Count function.
 
 # Print the count of minimum bits to Flip in such a way that the XOR of A and B equals C.
 
 print(""The count of minimum bits to Flip in such a way that the XOR of A and B equals C = "",
 
  Flips_Count(fst_seqnce, scnd_seqnce, third_seqnce, numb))
 
 </pre><|endoftext|>"
1041,"<|endoftext|>Create a function that takes a list of dictionaries like [{ ""name"": ""John"", ""notes"": [3, 5, 4]}, { ""name"": ""Mich"", ""notes"": [1, 3, 5]}] and returns a list of dictionaries like [{ ""name"": ""John"", ""top_note"": 5 }, {""name"": ""Mich"", ""top_note"": 5}].
If a student has no notes (an empty list), return top_note: 0.
Examples
get_name_and_top_note([{ ""name"": ""John"", ""notes"": [2, 4, 5]}, { ""name"": ""Mich"", ""notes"": [1, 3, 5]}])  ➞ [{ ""name"": ""John"", ""top_note"": 5 }, {""name"": ""Mich"", ""top_note"": 5}]

get_name_and_top_note([{ ""name"": ""Paul"", ""notes"": []}, {""name"": ""Victoria"", ""notes"": [3, 4, 2, 1]}])  ➞ [{ ""name"": ""Paul"", ""top_note"": 0 }, {""name"": ""Victoria"", ""top_note"": 4}]
Notes
Please do not translate this challenge into JavaScript.
This challenge is a translation of Bartosz Cytrowski's JavaScript challenge that was not properly translated to Python. You can find the challenge here.:def get_name_and_top_note(students):
    for s in students:
        s['top_note'] = max(s['notes'] + [0])
        s.pop('notes')
    return students<|endoftext|>"
1042,"<|endoftext|>The lambda keyword is used to create small anonymous functions.

A lambda function can take any number of arguments, but can only have one expression.

The expression is evaluated and the result is returned.

:x = lambda a : a + 10

print(x(5))<|endoftext|>"
1043,"<|endoftext|>There are M transmitter and N receiver stations. Given a matrix that keeps track of the number of packets to be transmitted from a given transmitter to a receiver. If the (i; j)-th entry of the matrix is k, it means at that time the station i has k packets for transmission to station j. 
During a time slot, a transmitter can send only one packet and a receiver can receive only one packet. Find the channel assignments so that maximum number of packets are transferred from transmitters to receivers during the next time slot. 
Example: 
0 2 0
3 0 1
2 4 0
The above is the input format. We call the above matrix M. Each value M[i; j] represents the number of packets Transmitter ‘i’ has to send to Receiver ‘j’. The output should be:
The number of maximum packets sent in the time slot is 3
T1 -> R2
T2 -> R3
T3 -> R1 
Note that the maximum number of packets that can be transferred in any slot is min(M, N).
Algorithm: 
The channel assignment problem between sender and receiver can be easily transformed into Maximum Bipartite Matching(MBP) problem that can be solved by converting it into a flow network.
Step 1: Build a Flow Network 
There must be a source and sink in a flow network. So we add a dummy source and add edges from source to all senders. Similarly, add edges from all receivers to dummy sink. The capacity of all added edges is marked as 1 unit.
Step 2: Find the maximum flow. 
We use Ford-Fulkerson algorithm to find the maximum flow in the flow network built in step 1. The maximum flow is actually the maximum number of packets that can be transmitted without bandwidth interference in a time slot.
Implementation: 
Let us first define input and output forms. Input is in the form of Edmonds matrix which is a 2D array ‘table[M][N]‘ with M rows (for M senders) and N columns (for N receivers). The value table[i][j] is the number of packets that has to be sent from transmitter ‘i’ to receiver ‘j’. Output is the maximum number of packets that can be transmitted without bandwidth interference in a time slot. 
A simple way to implement this is to create a matrix that represents adjacency matrix representation of a directed graph with M+N+2 vertices. Call the fordFulkerson() for the matrix. This implementation requires O((M+N)*(M+N)) extra space. 
Extra space can be reduced and code can be simplified using the fact that the graph is bipartite. The idea is to use DFS traversal to find a receiver for a transmitter (similar to augmenting path in Ford-Fulkerson). We call bpm() for every applicant, bpm() is the DFS based function that tries all possibilities to assign a receiver to the sender. In bpm(), we one by one try all receivers that a sender ‘u’ is interested in until we find a receiver or all receivers are tried without luck. 
For every receiver we try, we do following: 
If a receiver is not assigned to anybody, we simply assign it to the sender and return true. If a receiver is assigned to somebody else say x, then we recursively check whether x can be assigned some other receiver. To make sure that x doesn’t get the same receiver again, we mark the receiver ‘v’ as seen before we make recursive call for x. If x can get other receiver, we change the sender for receiver ‘v’ and return true. We use an array maxR[0..N-1] that stores the senders assigned to different receivers. 
If bmp() returns true, then it means that there is an augmenting path in flow network and 1 unit of flow is added to the result in maxBPM().
Time and space complexity analysis: 
In case of bipartite matching problem, F ? |V| since there can be only |V| possible edges coming out from source node. So the total running time is O(m’n) = O((m + n)n). The space complexity is also substantially reduced from O ((M+N)*(M+N)) to just a single dimensional array of size M thus storing the mapping between M and N.:# A Depth First Search based recursive
# function that returns true if a matching
# for vertex u is possible
def bpm(table, u, seen, matchR):
	global M, N
	
	# Try every receiver one by one
	for v in range(N):
		
		# If sender u has packets to send to
		# receiver v and receiver v is not
		# already mapped to any other sender
		# just check if the number of packets
		# is greater than '0' because only one
		# packet can be sent in a time frame anyways
		if (table[u][v] > 0 and not seen[v]):
			seen[v] = True # Mark v as visited

			# If receiver 'v' is not assigned to any
			# sender OR previously assigned sender
			# for receiver v (which is matchR[v]) has
			# an alternate receiver available. Since
			# v is marked as visited in the above line,
			# matchR[v] in the following recursive call
			# will not get receiver 'v' again
			if (matchR[v] < 0 or bpm(table, matchR[v],
									seen, matchR)):
				matchR[v] = u
				return True
	return False

# Returns maximum number of packets
# that can be sent parallelly in 1
# time slot from sender to receiver
def maxBPM(table):
	global M, N
	
	# An array to keep track of the receivers
	# assigned to the senders. The value of
	# matchR[i] is the sender ID assigned to
	# receiver i. The value -1 indicates nobody
	# is assigned.

	# Initially all receivers are not mapped
	# to any senders
	matchR = [-1] * N

	result = 0 # Count of receivers assigned to senders
	for u in range(M):
		
		# Mark all receivers as not seen
		# for next sender
		seen = [0] * N

		# Find if the sender 'u' can be assigned
		# to the receiver
		if (bpm(table, u, seen, matchR)):
			result += 1

	print(""The number of maximum packets sent"",
		""in the time slot is"", result)

	for x in range(N):
		if (matchR[x] + 1 != 0):
			print(""T"", matchR[x] + 1, ""-> R"", x + 1)
	return result

# Driver Code
M = 3
N = 4

table = [[0, 2, 0], [3, 0, 1], [2, 4, 0]]
max_flow = maxBPM(table)

# This code is contributed by PranchalK<|endoftext|>"
1044,"<|endoftext|>A snail goes up the stairs. Every step, he must go up the step, then go across to the next step. He wants to reach the top of the tower.
Write a function that returns the distance the snail must travel to the top of the tower given the height and length of each step and the height of the tower.
Examples
total_distance(0.2, 0.4, 100.0) ➞ 300.0
# Total distance is 300.

total_distance(0.3, 0.2, 25.0) ➞ 41.7

total_distance(0.1, 0.1, 6.0) ➞ 12.0
Notes
All given values are greater than 0.
Round answers to the nearest tenth 0.1.
Number of steps determined by tower height divided by stair height.
For the purposes of this exercise, the last step's length must be counted to complete the journey.:def total_distance(height, length, tower):
  return round(((tower/height)*(height+length)),1)<|endoftext|>"
1045,"<|endoftext|>Create a function that returns True if an asterisk * is inside a box.
Examples
in_box([
  ""###"",
  ""#*#"",
  ""###""
]) ➞ True


in_box([
  ""####"",
  ""#* #"",
  ""#  #"",
  ""####""
]) ➞ True


in_box([
  ""*####"",
  ""# #"",
  ""#  #*"",
  ""####""
]) ➞ false


in_box([
  ""#####"",
  ""#   #"",
  ""#   #"",
  ""#   #"",
  ""#####""
]) ➞ False
Notes
The asterisk may be in the array, however, it must be inside the box, if it exists.:def in_box(lst):
  return ""#*#"" in [x.replace(' ', '') for x in lst]<|endoftext|>"
1046,"<|endoftext|>In the previous article, we have discussed Python Program to Find Sum of Series (1+(1+2)+(1+2+3)+…till N)
 Given a number N and the task is to find the sum of the given series (1+(1*2)+(1*2*3)+…till N) for the given number in Python.
 Examples:
 Example1:
 Input:
 Given Number = 13
 Output:
 The total sum of the series till the given number { 13 } = 6749977113
 Example2:
 Input:
 Given Number = 7
 Output:
 The total sum of the series till the given number { 7 } = 5913:# Give the number N as static input.
 
 # store it in a variable.
 
 gvn_numb = 13
 
 # Take a variable say resltsum which gives the sum of the given series till N and
 
 # initialize its value to 0.
 
 resltsum = 0
 
 # Take another variable say k and initialize its value with 1.
 
 k = 1
 
 # Loop until the value of k is less than or equal to the given number using the while loop.
 
 while(k &lt;= gvn_numb):
 
  # Inside the loop take a variable say gvn_multiplr and initialize its value with 1.
 
  gvn_multiplr = 1
 
  # Iterate from 1 to the value of k using the for loop.
 
  for itr in range(1, k+1):
 
  # Multiply the iterator value to the above-initialized gvn_multiplr and store it in the same
 
  # variable gvn_multiplr.
 
  gvn_multiplr *= itr
 
  # Add the above-obtained value of gvn_multiplr to the resltsum outside the for loop.
 
 # Store it in the same variable resltsum.
 
  resltsum += gvn_multiplr
 
  # Increment the value of k by 1 outside the for loop.
 
  k += 1
 
 # Print the resltsum value which is the result of the series till the given Number N.
 
 print(
 
  ""The total sum of the series till the given number {"", gvn_numb, ""} = "", resltsum)
 
 </pre><|endoftext|>"
1047,"<|endoftext|>The readable() method returns True if the file is readable, False if not.

:f = open(""demofile.txt"", ""r"")
print(f.readable())<|endoftext|>"
1048,"<|endoftext|>Instructions
Given a number determine whether or not it is valid per the Luhn formula.

The Luhn algorithm is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers and Canadian Social Insurance Numbers.

The task is to check if a given string is valid.

Validating a Number
Strings of length 1 or less are not valid. Spaces are allowed in the input, but they should be stripped before checking. All other non-digit characters are disallowed.

Example 1: valid credit card number
4539 3195 0343 6467
The first step of the Luhn algorithm is to double every second digit, starting from the right. We will be doubling

4_3_ 3_9_ 0_4_ 6_6_
If doubling the number results in a number greater than 9 then subtract 9 from the product. The results of our doubling:

8569 6195 0383 3437
Then sum all of the digits:

8+5+6+9+6+1+9+5+0+3+8+3+3+4+3+7 = 80
If the sum is evenly divisible by 10, then the number is valid. This number is valid!

Example 2: invalid credit card number
8273 1232 7352 0569
Double the second digits, starting from the right

7253 2262 5312 0539
Sum the digits

7+2+5+3+2+2+6+2+5+3+1+2+0+5+3+9 = 57
57 is not evenly divisible by 10, so this number is not valid.:class Luhn(object):
    def __init__(self, number):
        self._number = number.replace(' ', '')
    def is_valid(self):
        if any([not char.isnumeric() for char in self._number]) or len(self._number) < 2:
            return False
        digits = [int(digit) for digit in self._number]
        return sum([self.get_checking_digit(index, digit)
                    for index, digit
                    in enumerate(digits[::-1])]) % 10 == 0
    def get_checking_digit(self, index, digit):
        if (index + 1) % 2 == 0:
            double_digit = digit * 2
            return double_digit if double_digit < 9 else double_digit - 9
        else:
            return digit<|endoftext|>"
1049,"<|endoftext|>Body Mass Index (BMI) :

The “Quetelet Index ” is another name for the BMI. It is a value calculated using a person’s weight (in kg) and height (in meters), whether male or female. The body mass index (BMI) is calculated by multiplying the body mass by the square of the body height. BMI is measured in kilograms per square meter.

The BMI is used to determine if a person is underweight, normal weight, overweight, or obese. A table with data from the four categories listed above is provided below.

BMI Weight Status
Below 18.5 Underweight
18.5 – 24.9 Normal or Healthy Weight
25.0 – 29.9 Overweight
30.0 and Above Obese

Formula to calculate BMI :

BMI = [mass/(height*height)]

where mass is the body’s mass in kilograms and

height is the body’s height in meters

Given Height, Weight and the task is to calculate BMI for given input values.

Examples:

Example1:

Input:

Given Height = 2.5
Given Weight = 50
Output:

The BMI for the above given values =  8.0
Health status of a person for the above obtained BMI = The person is Underweight
Example2:

Input:

Given Height =  1.5
Given Weight =  70
Output:

The BMI for the above given values =  31.11111111111111
Health status of a person for the above obtained BMI = The person is Suffering from Obesity:# Give the first number as static input and store it in a variable.
 gvn_heigt = 2.5
 # Give the second number as static input and store it in another variable.
 gvn_weigt = 50
 # Calculate the BMI Value using the above given mathematical formula and
 # store it in another variable.
 Bmi_vlue = gvn_weigt/(gvn_heigt**2)
 print(""The BMI for the above given values = "", format(Bmi_vlue))
 print(""Health status of a person for the above obtained BMI = "", end="""")
 # Check If the obtained BMI value is less than 18.5 using if conditional statement .
 # If it is True, Print ""The person is Underweight"".
 if (Bmi_vlue < 18.5):
  print(""The person is Underweight"")
 # Check If the obtained BMI is greater than or equal to 18.5 and less than 24.9 using 
 # elif conditional statement .
 # If it is True, Print ""The person is Healthy"".
 elif (Bmi_vlue >= 18.5 and Bmi_vlue < 24.9):
  print(""The person is Healthy"")
 # Check If the obtained BMI is greater than or equal to 24.9 and less than 30 using 
 # elif conditional statement .
 # If it is True, Print ""The person is Overweight"".
 elif (Bmi_vlue >= 24.9 and Bmi_vlue < 30):
  print(""The person is Overweight"")
 # Check If the obtained BMI is greater than or equal to 30 using 
 # elif conditional statement .
 # If it is True, Print ""The person is Suffering from Obesity""
 elif (Bmi_vlue >= 30):
  print(""The person is Suffering from Obesity"")<|endoftext|>"
1050,"<|endoftext|>Dictionaries in Python:

In Python, a dictionary dict is a one-to-one mapping; it includes a set of (key, value) pairs, with each key mapped to a value. It exemplifies a hash map or hash table (from Computer Science).

Each key denotes a value and is separated by a colon (:).



Curly brackets are used to define a dictionary. The value to the left of the colon is known as the key, while the value to the right of the colon is known as the value. A comma separates each (key, value) pair.

Examples:

Example1:

Input:

given number = 17
Output:

Enter some random number = 17
printing the resultant dictionary :
key = 1 value = 1
key = 2 value = 4
key = 3 value = 9
key = 4 value = 16
key = 5 value = 25
key = 6 value = 36
key = 7 value = 49
key = 8 value = 64
key = 9 value = 81
key = 10 value = 100
key = 11 value = 121
key = 12 value = 144
key = 13 value = 169
key = 14 value = 196
key = 15 value = 225
key = 16 value = 256
key = 17 value = 289
Example2:

Input:

given number=11
Output:

printing the resultant dictionary :
key = 1 value = 1
key = 2 value = 4
key = 3 value = 9
key = 4 value = 16
key = 5 value = 25
key = 6 value = 36
key = 7 value = 49
key = 8 value = 64
key = 9 value = 81
key = 10 value = 100
key = 11 value = 121:# given number
numb = int(input(""Enter some random number = ""))
# using dictionary comprehension
resultdict = {k: k*k for k in range(1, numb+1)}
# printing the resultant dictionary
print('printing the resultant dictionary :')
for key,value in resultdict.items():
  print(""key ="",key,""value ="",value)<|endoftext|>"
1051,"<|endoftext|>Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.
 
Example 1:

Input: arr = [2,6,4,1]
Output: false
Explanation: There are no three consecutive odds.

Example 2:

Input: arr = [1,2,34,3,4,5,7,23,12]
Output: true
Explanation: [5,7,23] are three consecutive odds.

 
Constraints:

1 <= arr.length <= 1000
1 <= arr[i] <= 1000:class Solution:
  def threeConsecutiveOdds(self, arr: List[int]) -> bool:
  count = 0
  
  for i in range(0, len(arr)):
  if arr[i] %2 != 0:
  count += 1
  if count == 3:
  return True
  else:
  count = 0
  return False<|endoftext|>"
1052,"<|endoftext|>Dynamic connectivity is a data structure that dynamically maintains the information about the connected components of graph. In simple words suppose there is a graph G(V, E) in which no. of vertices V is constant but no. of edges E is variable. There are three ways in which we can change the number of edges

In this article only Incremental connectivity is discussed. There are mainly two operations that need to be handled. 
 

An edge is added to the graph.
Information about two nodes x and y whether they are in the same connected components or not.
Example: 
 

Input : V = 7
        Number of operations = 11
        1 0 1
        2 0 1
        2 1 2
        1 0 2
        2 0 2
        2 2 3
        2 3 4
        1 0 5
        2 4 5
        2 5 6
        1 2 6
Note: 7 represents number of nodes, 
      11 represents number of queries. 
      There are two types of queries 
      Type 1: 1 x y in  this if the node 
               x and y are connected print 
               Yes else No
      Type 2: 2 x y in this add an edge 
               between node x and y
Output: No
         Yes
         No
         Yes
Explanation :
Initially there are no edges so node 0 and 1
will be disconnected so answer will be No
Node 0 and 2 will be connected through node 
1 so answer will be Yes similarly for other
queries we can find whether two nodes are 
connected or not
To solve the problems of incremental connectivity disjoint data structure is used. Here each connected component represents a set and if the two nodes belong to the same set it means that they are connected.:# Python3 implementation of
# incremental connectivity
 
# Finding the root of node i
def root(arr, i):
    while (arr[i] != i):
        arr[i] = arr[arr[i]]
        i = arr[i]
    return i
 
# union of two nodes a and b
def weighted_union(arr, rank, a, b):
    root_a = root (arr, a)
    root_b = root (arr, b)
 
    # union based on rank
    if (rank[root_a] < rank[root_b]):
        arr[root_a] = arr[root_b]
        rank[root_b] += rank[root_a]
    else:
        arr[root_b] = arr[root_a]
        rank[root_a] += rank[root_b]
 
# Returns true if two nodes have
# same root
def areSame(arr, a, b):
    return (root(arr, a) == root(arr, b))
 
# Performing an operation according
# to query type
def query(type, x, y, arr, rank):
     
    # type 1 query means checking if
    # node x and y are connected or not
    if (type == 1):
         
        # If roots of x and y is same
        # then yes is the answer
        if (areSame(arr, x, y) == True):
            print(""Yes"")
        else:
            print(""No"")
 
    # type 2 query refers union of
    # x and y
    elif (type == 2):
         
        # If x and y have different
        # roots then union them
        if (areSame(arr, x, y) == False):
            weighted_union(arr, rank, x, y)
 
# Driver Code
if __name__ == '__main__':
 
    # No.of nodes
    n = 7
 
    # The following two arrays are used to
    # implement disjoint set data structure.
    # arr[] holds the parent nodes while rank
    # array holds the rank of subset
    arr = [None] * n
    rank = [None] * n
 
    # initializing both array
    # and rank
    for i in range(n):
        arr[i] = i
        rank[i] = 1
 
    # number of queries
    q = 11
    query(1, 0, 1, arr, rank)
    query(2, 0, 1, arr, rank)
    query(2, 1, 2, arr, rank)
    query(1, 0, 2, arr, rank)
    query(2, 0, 2, arr, rank)
    query(2, 2, 3, arr, rank)
    query(2, 3, 4, arr, rank)
    query(1, 0, 5, arr, rank)
    query(2, 4, 5, arr, rank)
    query(2, 5, 6, arr, rank)
    query(1, 2, 6, arr, rank)
 
# This code is contributed by PranchalK
<|endoftext|>"
1053,"<|endoftext|>In the previous article, we have discussed Python Program for Sign Change
 Recursion:
 Recursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.
 Binary Code:
 As previously stated, Binary Code is a Base-2 representation of a number. In Binary, all numbers are represented by simply two symbols: 0 and 1. Binary (also known as base-2) is a numerical system with only two digits: 0 and 1.
 Given a binary string, the task is to convert the given binary string to a decimal number using recursion in Python.
 Examples:
 Example1:
 Input:
 Given binary number = 1011
 Output:
 The decimal Equivalent of the given binary number { 1011 } is : 11
 Example2:
 Input:
 Given binary number = 10010101
 Output:
 The decimal Equivalent of the given binary number { 10010101 } is : 149:# Create a recursive function to say binaryToDeci()
 
 # which accepts the binary number as an argument
 
 # and returns the decimal equivalent of the given binary string.
 
 
 
 
 
 def binaryToDeci(binanumb):
 
  # Inside the binaryToDeci() function,
 
  # Check if the binary number is equal to 0 using the if conditional statement.
 
  if(binanumb == 0):
 
  # If it is true then return 0.
 
  return 0
 
  # Else return (n% 10 + 2* binaryToDeci(n // 10))
 
  # {Recursive logic where n%10 gives rightmostbit and n//10 divides the number by 10}.
 
  return (binanumb % 10 + 2 * binaryToDeci(binanumb // 10))
 
 
 
 
 
 # Give the binary number as static input and store it in a variable.
 
 gvnbinarynumb = 1011
 
 # Inside the main function pass the given binary number as an argument
 
 # to binaryToDeci() which returns the decimal equivalent of the given binary number.
 
 resdecimalnumbr = binaryToDeci(gvnbinarynumb)
 
 # Print the decimal equivalent of the given binary number.
 
 print(
 
  'The decimal Equivalent of the given binary number {', gvnbinarynumb, '} is :', resdecimalnumbr)<|endoftext|>"
1054,"<|endoftext|>Linear Discriminant Analysis or Normal Discriminant Analysis or Discriminant Function Analysis is a dimensionality reduction technique that is commonly used for supervised classification problems. It is used for modelling differences in groups i.e. separating two or more classes. It is used to project the features in higher dimension space into a lower dimension space. :
# necessary import
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import sklearn
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix
  
# read dataset from URL
url = ""https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data""
cls = ['sepal-length', 'sepal-width', 'petal-length', 'petal-width', 'Class']
dataset = pd.read_csv(url, names=cls)
  
# divide the dataset into class and target variable
X = dataset.iloc[:, 0:4].values
y = dataset.iloc[:, 4].values
  
# Preprocess the dataset and divide into train and test
sc = StandardScaler()
X = sc.fit_transform(X)
le = LabelEncoder()
y = le.fit_transform(y)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
  
# apply Linear Discriminant Analysis
lda = LinearDiscriminantAnalysis(n_components=2)
X_train = lda.fit_transform(X_train, y_train)
X_test = lda.transform(X_test)
  
# plot the scatterplot
plt.scatter(
    X_train[:,0],X_train[:,1],c=y_train,cmap='rainbow',
  alpha=0.7,edgecolors='b'
)
  
# classify using random forest classifier
classifier = RandomForestClassifier(max_depth=2, random_state=0)
classifier.fit(X_train, y_train)
y_pred = classifier.predict(X_test)
  
# print the accuracy and confusion matrix
print('Accuracy : ' + str(accuracy_score(y_test, y_pred)))
conf_m = confusion_matrix(y_test, y_pred)
print(conf_m)<|endoftext|>"
1055,"<|endoftext|>Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.

An integer m is a divisor of n if there exists an integer k such that n = k * m.:class Solution:
    def isThree(self, n: int) -> bool:
        #number of divisors
        #start at 1  all numbers are divisible by 1 
        count = 1
        #look  for divisors in the range inclusive 2 to inclusive n = [2,n]
        for i in range (2, n+1):
            if n % i == 0 :
                #add one if divisible
                count += 1 
                #if it goes out of bounce terminate
                if count > 3:
                    return False 
        #base cases
        if count < 3:
            return False 
        return True <|endoftext|>"
1056,"<|endoftext|>The continue keyword is used to end the current iteration in a for loop (or a while loop), and continues to the next iteration.

:for i in range(9):
  if i == 3:
    continue
  print(i)<|endoftext|>"
1057,"<|endoftext|>Given a list and a number N the task is to split and move the first N elements of the list to the end in Python:# Give the list as static input and store it in a variable.
gvnlstt = [9, 3, 1, 11, 13, 18, 5, 0, 11, 35, 67, 24]
# Give the Number N as static input and store it in another variable
Numb = 4
# Calculate the length of the given list and store it in a variable.
lengthlst = len(gvnlstt)
# Slice from N to the length of the list using slicing
# and store it in a variable say firstpart.
frstpart = gvnlstt[Numb:lengthlst]
# Slice from 0 to N using slicing and
# store it in another variable say secondpart.
secndpart = gvnlstt[0:Numb]
# Add the firstpart and secondpart using the + operator
# and store the result in another variable say resultpart.
resltpart = frstpart+secndpart
# Print the resultpart.
print('The result part after moving first [',
      Numb, '] numbers to the end is', resltpart)<|endoftext|>"
1058,"<|endoftext|>Remove Item from Set
To remove an item in a set, use the remove(), or the discard() method.

Example:thisset = {""apple"", ""banana"", ""cherry""}

thisset.remove(""banana"")

print(thisset)<|endoftext|>"
1059,"<|endoftext|>Check a Binary Number is Divisible by a Number N (User input):# Give the binary number as user input using int(input()) and store it in a variable.
binry = int(input(""Enter some random number = ""))
# Given the number as user input using int(input()) and store it in another variable.
num = int(input(""Enter some random number = ""))
# Convert the given binary number into a decimal number using int(str(binary number),2)
# function and store it in another variable say ""deci"".
deci = int(str(binry), 2)
# Check if the above-obtained decimal number modulus given number is equal to 0 using the if
# conditional statement.
if deci % num == 0:
    # If the statement is true, then print ""The binary number is divisible by the given
    # input number"".
    print(""The given binary number is divisible by{"", num, ""}"")
else:
 # Else print """"The binary number is not divisible by the given input number"".
    print(""The given binary number is not divisible by{"", num, ""}"")<|endoftext|>"
1060,"<|endoftext|>Create a function that takes two inputs: indexes (a list of integers) and string (a string). The function should return another string with the letters of string at each index in indexes in order.
Examples
index_filter([2, 3, 8, 11], ""Autumn in New York"") ➞ ""tune""

index_filter([0, 1, 5, 7, 4, 2], ""Cry me a river"") ➞ ""creamy""

index_filter([9, -9, 2, 27, 36, 6, 5, 13, -1, 2, 0, 30, 2], 
  ""That's life, I've got you under my skin"") ➞ ""frank sinatra""
Notes
Indexes may not be in order / may be negative (see example #2 and #3).
The output string must always be lowercase, but the input string may not be (see examples).
Bonus points for submitting a lambda function.:index_filter=lambda i,s:''.join(s[x].lower()for x in i)<|endoftext|>"
1061,"<|endoftext|>There is a survey that consists of n questions where each question's answer is either 0 (no) or 1 (yes).

The survey was given to m students numbered from 0 to m - 1 and m mentors numbered from 0 to m - 1. The answers of the students are represented by a 2D integer array students where students[i] is an integer array that contains the answers of the ith student (0-indexed). The answers of the mentors are represented by a 2D integer array mentors where mentors[j] is an integer array that contains the answers of the jth mentor (0-indexed).

Each student will be assigned to one mentor, and each mentor will have one student assigned to them. The compatibility score of a student-mentor pair is the number of answers that are the same for both the student and the mentor.

For example, if the student's answers were [1, 0, 1] and the mentor's answers were [0, 0, 1], then their compatibility score is 2 because only the second and the third answers are the same.
You are tasked with finding the optimal student-mentor pairings to maximize the sum of the compatibility scores.

Given students and mentors, return the maximum compatibility score sum that can be achieved.

 :class Solution:
    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:
        scoreDict = dict()
        M = len(students)
        N = len(students[0])
        for i, j in itertools.product(range(M), range(M)):
            res = 0
            for k in range(N):
                res += (students[i][k] == mentors[j][k])
            scoreDict[(i, j)] = res
        
        self.res = 0
        self.students = students
        self.mentors = mentors
        self.scoreDict = scoreDict
        self.M = M
        self.helper(0, set(), 0)
        return self.res
    
    def helper(self, idx, chosen, curr):
        if len(chosen) == self.M:
            self.res = max(self.res, curr)         
            return
        
        for i in range(0, self.M):
            if i not in chosen:
                chosen.add(i)
                self.helper(idx + 1, chosen, curr + self.scoreDict[(idx, i)])
                chosen.remove(i)<|endoftext|>"
1062,"<|endoftext|>A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.
You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released.
The tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration of releaseTimes[0].
Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration.
Return the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.
 
Example 1:

Input: releaseTimes = [9,29,49,50], keysPressed = ""cbcd""
Output: ""c""
Explanation: The keypresses were as follows:
Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).
Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).
Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).
Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).
The longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.
'c' is lexicographically larger than 'b', so the answer is 'c'.

Example 2:

Input: releaseTimes = [12,23,36,46,62], keysPressed = ""spuda""
Output: ""a""
Explanation: The keypresses were as follows:
Keypress for 's' had a duration of 12.
Keypress for 'p' had a duration of 23 - 12 = 11.
Keypress for 'u' had a duration of 36 - 23 = 13.
Keypress for 'd' had a duration of 46 - 36 = 10.
Keypress for 'a' had a duration of 62 - 46 = 16.
The longest of these was the keypress for 'a' with duration 16.
 
Constraints:

releaseTimes.length == n
keysPressed.length == n
2 <= n <= 1000
1 <= releaseTimes[i] <= 109
releaseTimes[i] < releaseTimes[i+1]
keysPressed contains only lowercase English letters.:class Solution:
  def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
  k, t = keysPressed[0], releaseTimes[0]
  
  for i in range(1, len(keysPressed)):
  time = releaseTimes[i] - releaseTimes[i-1] 
  if time > t or (time == t and keysPressed[i] > k):
  t = time
  k = keysPressed[i]
  
  return k<|endoftext|>"
1063,"<|endoftext|>What is a Module?
Consider a module to be the same as a code library.

A file containing a set of functions you want to include in your application.

Create a Module
To create a module just save the code you want in a file with the file extension .py::#Save this code in a file named mymodule.py

def greeting(name):
  print(""Hello, "" + name)
import mymodule
mymodule.greeting(""Jonathan"")<|endoftext|>"
1064,"<|endoftext|>Given a matrix of size N*M, and a number K. We have to rotate the matrix K times to the right side. 

Examples: 
Input :  N = 3, M = 3, K = 2
         12 23 34
         45 56 67
         78 89 91 

Output : 23 34 12
         56 67 45
         89 91 78 


Input :  N = 2, M = 2, K = 2
         1 2
         3 4
         
Output : 1 2
         3 4:# Python program to rotate
# a matrix right by k times
 
# size of matrix
M = 3
N = 3
matrix = [[12, 23, 34],
          [45, 56, 67],
          [78, 89, 91]]
 
# function to rotate
# matrix by k times
def rotateMatrix(k) :
 
    global M, N, matrix
     
    # temporary array
    # of size M
    temp = [0] * M
     
    # within the size
    # of matrix
    k = k % M
     
    for i in range(0, N) :
     
        # copy first M-k elements
        # to temporary array
        for t in range(0, M - k) :
            temp[t] = matrix[i][t]
     
        # copy the elements from
        # k to end to starting
        for j in range(M - k, M) :
            matrix[i][j - M + k] = matrix[i][j]
     
        # copy elements from
        # temporary array to end
        for j in range(k, M) :
            matrix[i][j] = temp[j - k]
     
# function to display
# the matrix
def displayMatrix() :
 
    global M, N, matrix
    for i in range(0, N) :
     
        for j in range(0, M) :
            print (""{} "" .
                   format(matrix[i][j]), end = """")
        print ()
 
# Driver code
k = 2
 
# rotate matrix by k
rotateMatrix(k)
 
# display rotated matrix
displayMatrix()
 
# This code is contributed by
# Manish Shaw(manishshaw1)
<|endoftext|>"
1065,"<|endoftext|>Create a function that takes a string's characters as ASCII and returns each character's hexadecimal value as a string.
Examples
convert_to_hex(""hello world"") ➞ ""68 65 6c 6c 6f 20 77 6f 72 6c 64""

convert_to_hex(""Big Boi"") ➞ ""42 69 67 20 42 6f 69""

convert_to_hex(""Marty Poppinson"") ➞ ""4d 61 72 74 79 20 50 6f 70 70 69 6e 73 6f 6e""
Notes
Each byte must be seperated by a space.
All alpha hex characters must be lowercase.:def convert_to_hex(txt):
  return ' '.join(hex(ord(i))[2:] for i in txt)<|endoftext|>"
1066,"<|endoftext|>Leader:

If an element is greater than all of the elements on its right side, it is the leader. And the last element is always a leader. Python Program to Find Leaders in an Array/List:# Give the list as static input and store it in a variable.
gvnlstt = [23, 11, 1, 7, 8, 6, 3]
# Calculate the length of the list and store it in another variable.
lstleng = len(gvnlstt)
print('The leaders of the given list', gvnlstt, 'are :')
# Loop from 0 to the length of the list using the For loop.
for m in range(lstleng):
    # Loop from parent loop iterator value to the length of the list
    # using another Nested for loop(Inner For loop)
    for n in range(m+1, lstleng):
            # Check if the element at the index of the parent loop iterator value
        # is less than or equal to the element at the index of the inner loop iterator value.
        # (gvnlist[m] <= gvnlist[n]) using the if conditional statement.
        if (gvnlstt[m] <= gvnlstt[n]):
            # If it is true then break the inner loop using the break keyword.
            break

            # After the end of the inner For loop check if the inner loop iterator value
        # is equal to the length of the given list - 1 using the if conditional statement.
    if(n == lstleng-1):
        # If it is true then it is the leader so print it.
        print(gvnlstt[m])<|endoftext|>"
1067,"<|endoftext|>In a special ranking system, each voter gives a rank from highest to lowest to all teams participated in the competition.

The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.

Given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.

Return a string of all teams sorted by the ranking system.

 

Example 1:

Input: votes = [""ABC"",""ACB"",""ABC"",""ACB"",""ACB""]
Output: ""ACB""
Explanation: Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team.
Team B was ranked second by 2 voters and was ranked third by 3 voters.
Team C was ranked second by 3 voters and was ranked third by 2 voters.
As most of the voters ranked C second, team C is the second team and team B is the third.
Example 2:

Input: votes = [""WXYZ"",""XYZW""]
Output: ""XWYZ""
Explanation: X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position while W doesn't have any votes as second position. 
Example 3:

Input: votes = [""ZMNAGUEDSJYLBOPHRQICWFXTVK""]
Output: ""ZMNAGUEDSJYLBOPHRQICWFXTVK""
Explanation: Only one voter so his votes are used for the ranking.
 

Constraints:

1 <= votes.length <= 1000
1 <= votes[i].length <= 26
votes[i].length == votes[j].length for 0 <= i, j < votes.length.
votes[i][j] is an English uppercase letter.
All characters of votes[i] are unique.
All the characters that occur in votes[0] also occur in votes[j] where 1 <= j < votes.length.:def rankTeams(self, votes):
  count = {v: [0] * len(votes[0]) + [v] for v in votes[0]}
  for vote in votes:
  for i, v in enumerate(vote):
  count[v][i] -= 1
  return ''.join(sorted(votes[0], key=count.get))<|endoftext|>"
1068,"<|endoftext|>Find Smallest Prime Divisor of a Number (Static Input):# Give the number as static input and store it in a variable.
numb = 91
# Take an empty list and initialize it's with an empty list using list() and [].
nwlist = []
# Loop from 2 to the given number using the For loop.
for m in range(2, numb+1):
        # Check if the iterator value divides the given number
    # using the % operator and the If statement.
    if(numb % m == 0):
        # If It is true then append it to the list.
        nwlist.append(m)
smalldivisor = nwlist[0]
# Print the first element of the list using the index 0.
print(
    'The smallest prime divisor the number [', numb, '] is [', smalldivisor, ']')<|endoftext|>"
1069,"<|endoftext|>Given a Binary Tree and a key ‘k’, find distance of the closest leaf from ‘k’.

Examples: 

              A
            /    \    
           B       C
                 /   \  
                E     F   
               /       \
              G         H
             / \       /
            I   J     K

Closest leaf to 'H' is 'K', so distance is 1 for 'H'
Closest leaf to 'C' is 'B', so distance is 2 for 'C'
Closest leaf to 'E' is either 'I' or 'J', so distance is 2 for 'E' 
Closest leaf to 'B' is 'B' itself, so distance is 0 for 'B' 
:# Python program to find closest leaf of a
# given key in binary tree

INT_MAX = 2**32

# A binary tree node
class Node:
	# Constructor to create a binary tree
	def __init__(self ,key):
		self.key = key
		self.left = None
		self.right = None

def closestDown(root):
	#Base Case
	if root is None:
		return INT_MAX
	if root.left is None and root.right is None:
		return 0
	
	# Return minimum of left and right plus one
	return 1 + min(closestDown(root.left),
				closestDown(root.right))

# Returns distance of the closes leaf to a given key k
# The array ancestors us used to keep track of ancestors
# of current node and 'index' is used to keep track of
# current index in 'ancestors[i]'
def findClosestUtil(root, k, ancestors, index):
	# Base Case
	if root is None:
		return INT_MAX
	
	# if key found
	if root.key == k:
		# Find closest leaf under the subtree rooted
		# with given key
		res = closestDown(root)
		
		# Traverse ll ancestors and update result if any
		# parent node gives smaller distance
		for i in reversed(range(0,index)):
			res = min(res, index-i+closestDown(ancestors[i]))
		return res

	# if key node found, store current node and recur for left
	# and right childrens
	ancestors[index] = root
	return min(
		findClosestUtil(root.left, k,ancestors, index+1),
		findClosestUtil(root.right, k, ancestors, index+1))

# The main function that return distance of the clses key to
# 'key'. It mainly uses recursive function findClosestUtil()
# to find the closes distance
def findClosest(root, k):
	# Create an array to store ancestors
	# Assumption: Maximum height of tree is 100
	ancestors = [None for i in range(100)]

	return findClosestUtil(root, k, ancestors, 0)


# Driver program to test above function
root = Node('A')
root.left = Node('B')
root.right = Node('C');
root.right.left = Node('E');
root.right.right = Node('F');
root.right.left.left = Node('G');
root.right.left.left.left = Node('I');
root.right.left.left.right = Node('J');
root.right.right.right = Node('H');
root.right.right.right.left = Node('K');

k = 'H';
print (""Distance of the closest key from ""+ k + "" is"",findClosest(root, k))

k = 'C'
print (""Distance of the closest key from "" + k + "" is"",findClosest(root, k))

k = 'E'
print (""Distance of the closest key from "" + k + "" is"",findClosest(root, k))

k = 'B'
print (""Distance of the closest key from "" + k + "" is"",findClosest(root, k))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)<|endoftext|>"
1070,"<|endoftext|>iven a stream of numbers, generate a random number from the stream. You are allowed to use only O(1) space and the input is in the form of a stream, so can’t store the previously seen numbers. 
So how do we generate a random number from the whole stream such that the probability of picking any number is 1/n. with O(1) extra space? This problem is a variation of Reservoir Sampling. Here the value of k is 1.
1) Initialize ‘count’ as 0, ‘count’ is used to store count of numbers seen so far in stream. 
2) For each number ‘x’ from stream, do following 
…..a) Increment ‘count’ by 1. 
…..b) If count is 1, set result as x, and return result. 
…..c) Generate a random number from 0 to ‘count-1’. Let the generated random number be i. 
…..d) If i is equal to ‘count – 1’, update the result as x. :# An efficient python3 program
# to randomly select a number
# from stream of numbers.
import random

# A function to randomly select a item
# from stream[0], stream[1], .. stream[i-1]
# The resultant random number
res=0
# Count of numbers visited
# so far in stream
count=0
def selectRandom(x):
	
	global res
	global count

	# increment count of numbers
	# seen so far
	count += 1;

	# If this is the first element
	# from stream, return it
	if (count == 1):
		res = x;
	else:
		
		# Generate a random number
		# from 0 to count - 1
		i = random.randrange(count);

		# Replace the prev random number
		# with new number with 1/count
		# probability
		if (i == count - 1):
			res = x;
	return res;

# Driver Code
stream = [1, 2, 3, 4];
n = len(stream);

# Use a different seed value
# for every run.
for i in range (n):
	print(""Random number from first"",
		(i + 1), ""numbers is"",
		selectRandom(stream[i]));

# This code is contributed by mits<|endoftext|>"
1071,"<|endoftext|>The geometric mean of numbers a and b is the square root of their product (i.e. √(ab)). For example, the geometric mean of 2 and 8 is √(2*8)=4.
Two integers (a and b) are randomly (and independently) chosen between 1 and n (inclusive) where n is an integer greater than one. Create a function that takes a number n as an argument and returns the probability that the geometric mean of a and b is an integer.
Examples
f(2) ➞ 0.5
# There are four possible pairs: (1, 1), (2, 1), (1, 2) and (2, 2).
# The pairs (1, 1) and (2, 2) are wanted (√(1*1)=1 and √(2*2)=2)
# but the pairs (2, 1) and (1, 2) are not (√(2*1)=√2 and √(1*2)=√2).
# Thus, the probability is 2/4 = 0.5.

f(10) ➞ 0.18

f(100) ➞ 0.031
Notes
Do not round your answer.:from math import sqrt
def f(n):
  count = 0
  for x in range(1,n+1):
    for y in range(1,n+1):
      gmean = sqrt(x*y)
      if int(gmean) == gmean:
        count = count+1
  return count/(n**2)<|endoftext|>"
1072,"<|endoftext|>Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.

A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.

 

Example 1:


Input: root = [1,null,2,null,3,null,4,null,null]
Output: [2,1,3,null,null,null,4]
Explanation: This is not the only correct answer, [3,1,4,null,2] is also correct.
Example 2:


Input: root = [2,1,3]
Output: [2,1,3]
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
1 <= Node.val <= 105:class Solution:
def balanceBST(self, root: TreeNode) -> TreeNode:
v = []
def dfs(node):
if node:
dfs(node.left)
v.append(node.val)
dfs(node.right)
dfs(root)

def bst(v):
if not v:
return None
mid = len(v) // 2
root = TreeNode(v[mid])
root.left = bst(v[:mid])
root.right = bst(v[mid + 1:])
return root

return bst(v)<|endoftext|>"
1073,"<|endoftext|>You are given an array of unique integers salary where salary[i] is the salary of the ith employee.
Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.
 
Example 1:

Input: salary = [4000,3000,1000,2000]
Output: 2500.00000
Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.
Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500

Example 2:

Input: salary = [1000,2000,3000]
Output: 2000.00000
Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.
Average salary excluding minimum and maximum salary is (2000) / 1 = 2000

 
Constraints:

3 <= salary.length <= 100
1000 <= salary[i] <= 106
All the integers of salary are unique.:def average(self, salary: List[int]) -> float:
  m, M, total = math.inf, -math.inf, 0.0
  for s in salary:
  m, M = min(m, s), max(M, s)
  total += s
  return (total - m - M) / (len(salary) - 2)<|endoftext|>"
1074,"<|endoftext|>In this tutorial, we will learn how to swap two variables in a Python program. Suppose we have two variables, P and Q; We have to write a Python program for swapping their values. We will also discuss the different methods in Python for doing this task.:P = int( input(""Please enter value for P: ""))  
Q = int( input(""Please enter value for Q: ""))  
   
# To swap the value of two variables  
# we will user third variable which is a temporary variable  
temp_1 = P  
P = Q  
Q = temp_1  
   
print (""The Value of P after swapping: "", P)  
print (""The Value of Q after swapping: "", Q)  <|endoftext|>"
1075,"<|endoftext|>Change Tuple Values
Once a tuple is created, you cannot change its values. Tuples are unchangeable, or immutable as it also is called.

But there is a workaround. You can convert the tuple into a list, change the list, and convert the list back into a tuple.:x = (""apple"", ""banana"", ""cherry"")
y = list(x)
y[1] = ""kiwi""
x = tuple(y)

print(x)<|endoftext|>"
1076,"<|endoftext|>Steps to follow for deletion. 
To make sure that the given tree remains AVL after every deletion, we must augment the standard BST delete operation to perform some re-balancing. Following are two basic operations that can be performed to re-balance a BST without violating the BST property (keys(left) < key(root) < keys(right)). :# Python code to delete a node in AVL tree
# Generic tree node class
class TreeNode(object):
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1
 
# AVL tree class which supports insertion,
# deletion operations
class AVL_Tree(object):
 
    def insert(self, root, key):
         
        # Step 1 - Perform normal BST
        if not root:
            return TreeNode(key)
        elif key < root.val:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)
 
        # Step 2 - Update the height of the
        # ancestor node
        root.height = 1 + max(self.getHeight(root.left),
                          self.getHeight(root.right))
 
        # Step 3 - Get the balance factor
        balance = self.getBalance(root)
 
        # Step 4 - If the node is unbalanced,
        # then try out the 4 cases
        # Case 1 - Left Left
        if balance > 1 and key < root.left.val:
            return self.rightRotate(root)
 
        # Case 2 - Right Right
        if balance < -1 and key > root.right.val:
            return self.leftRotate(root)
 
        # Case 3 - Left Right
        if balance > 1 and key > root.left.val:
            root.left = self.leftRotate(root.left)
            return self.rightRotate(root)
 
        # Case 4 - Right Left
        if balance < -1 and key < root.right.val:
            root.right = self.rightRotate(root.right)
            return self.leftRotate(root)
 
        return root
 
    # Recursive function to delete a node with
    # given key from subtree with given root.
    # It returns root of the modified subtree.
    def delete(self, root, key):
 
        # Step 1 - Perform standard BST delete
        if not root:
            return root
 
        elif key < root.val:
            root.left = self.delete(root.left, key)
 
        elif key > root.val:
            root.right = self.delete(root.right, key)
 
        else:
            if root.left is None:
                temp = root.right
                root = None
                return temp
 
            elif root.right is None:
                temp = root.left
                root = None
                return temp
 
            temp = self.getMinValueNode(root.right)
            root.val = temp.val
            root.right = self.delete(root.right,
                                      temp.val)
 
        # If the tree has only one node,
        # simply return it
        if root is None:
            return root
 
        # Step 2 - Update the height of the
        # ancestor node
        root.height = 1 + max(self.getHeight(root.left),
                            self.getHeight(root.right))
 
        # Step 3 - Get the balance factor
        balance = self.getBalance(root)
 
        # Step 4 - If the node is unbalanced,
        # then try out the 4 cases
        # Case 1 - Left Left
        if balance > 1 and self.getBalance(root.left) >= 0:
            return self.rightRotate(root)
 
        # Case 2 - Right Right
        if balance < -1 and self.getBalance(root.right) <= 0:
            return self.leftRotate(root)
 
        # Case 3 - Left Right
        if balance > 1 and self.getBalance(root.left) < 0:
            root.left = self.leftRotate(root.left)
            return self.rightRotate(root)
 
        # Case 4 - Right Left
        if balance < -1 and self.getBalance(root.right) > 0:
            root.right = self.rightRotate(root.right)
            return self.leftRotate(root)
 
        return root
 
    def leftRotate(self, z):
 
        y = z.right
        T2 = y.left
 
        # Perform rotation
        y.left = z
        z.right = T2
 
        # Update heights
        z.height = 1 + max(self.getHeight(z.left),
                         self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left),
                         self.getHeight(y.right))
 
        # Return the new root
        return y
 
    def rightRotate(self, z):
 
        y = z.left
        T3 = y.right
 
        # Perform rotation
        y.right = z
        z.left = T3
 
        # Update heights
        z.height = 1 + max(self.getHeight(z.left),
                          self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left),
                          self.getHeight(y.right))
 
        # Return the new root
        return y
 
    def getHeight(self, root):
        if not root:
            return 0
 
        return root.height
 
    def getBalance(self, root):
        if not root:
            return 0
 
        return self.getHeight(root.left) - self.getHeight(root.right)
 
    def getMinValueNode(self, root):
        if root is None or root.left is None:
            return root
 
        return self.getMinValueNode(root.left)
 
    def preOrder(self, root):
 
        if not root:
            return
 
        print(""{0} "".format(root.val), end="""")
        self.preOrder(root.left)
        self.preOrder(root.right)
 
 
myTree = AVL_Tree()
root = None
nums = [9, 5, 10, 0, 6, 11, -1, 1, 2]
 
for num in nums:
    root = myTree.insert(root, num)
 
# Preorder Traversal
print(""Preorder Traversal after insertion -"")
myTree.preOrder(root)
print()
 
# Delete
key = 10
root = myTree.delete(root, key)
 
# Preorder Traversal
print(""Preorder Traversal after deletion -"")
myTree.preOrder(root)
print()
 
# This code is contributed by Ajitesh Pathak<|endoftext|>"
1077,"<|endoftext|>Format String
As we learned in the Python Variables chapter, we CANNOT combine strings and numbers like this:

Example
age = 36
txt = ""My name is John, I am "" + age
print(txt):age = 36
txt = ""My name is John, and I am {}""
print(txt.format(age))<|endoftext|>"
1078,"<|endoftext|>Files in Python:

Python File handling is a method that allows you to save the program’s output to a file or read data from a file. In the programming world, file handling is a critical notion. File management is employed in practically every type of project. For example, suppose you’re developing an inventory management system. You have data connected to sales and purchases in the inventory management system, thus you must save that data somewhere. You can save that data to a file using Python file management. If you want to undertake data analysis, you must be given data in the form of a comma-separated file or a Microsoft Excel file. You can read data from a file and also store output back into it using file handling.

Given the file, the task is to count the number of blank spaces in a Text File.:# Take a variable say blankCount that stores the calculate the
# total number of blank spaces in a given file and initialize it to 0.
blankCount = 0
# Enter the file name of the file using the input() function and store it in a variable.
filename = input(""Enter the file name = "")
# In read mode, open the file with the entered file name.
with open(filename, 'r') as givenfile:
  # Using for loop, go over the lines in the first file.
    for fileline in givenfile:
        # Split the line into words using the split() function.
        wordslist = fileline.split()
        # To traverse the words in the list, use a for loop, then another
        # for loop to traverse the letters in the word.
        for words in wordslist:
            for char in words:
                # Check to see if the letter is a space using isspace,
                # and if so, increase the blank count by 1.
                if(char.isspace):
                    blankCount = blankCount+1
print('The total count of the blank spaces in the given file = ', blankCount)<|endoftext|>"
1079,"<|endoftext|>Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

a binary tree in which the left and right subtrees of every node differ in height by no more than 1.

 

Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: true
Example 2:


Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
Example 3:

Input: root = []
Output: true:class Solution:
    # Compute the tree's height via recursion
    def height(self, root: TreeNode) -> int:
        # An empty tree has height -1
        if not root:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))
    
    def isBalanced(self, root: TreeNode) -> bool:
        # An empty tree satisfies the definition of a balanced tree
        if not root:
            return True

        # Check if subtrees have height within 1. If they do, check if the
        # subtrees are balanced
        return abs(self.height(root.left) - self.height(root.right)) < 2 \
            and self.isBalanced(root.left) \
            and self.isBalanced(root.right)
        <|endoftext|>"
1080,"<|endoftext|>Check whether kth Bit of a Number is Set Using Right Shift Operator (Static Input):# Give the number and the value of k as static input # and store it in a variable.
numb = 19
k = 2
# First, compute number>>(k-1) and store it in a variable called temp, resulting in temp=number>>(k-1).
# If the kth bit is set, the last bit of temp will be 1, otherwise, it will be 0.
temp = numb >> (k-1)
# You must execute a bitwise AND of 1 and temp in this step.
# If this gives a non-zero integer,
# the kth bit of the number is set, otherwise, it is not.
if (1 & temp):
        # If it is true then print the kth bit is set bit.
    print('The', k, 'nd bit in the number ', numb,
          '(binary representation =', bin(numb)[2:], ') is set bit')
# Else print it is not set bit.
else:
    print('The', k, 'nd bit in the number', numb,
          '(binary representation =', bin(numb)[2:], ')is not a set bit')<|endoftext|>"
1081,"<|endoftext|>The minimum absolute difference of an array a is defined as the minimum value of |a[i] - a[j]|, where 0 <= i < j < a.length and a[i] != a[j]. If all elements of a are the same, the minimum absolute difference is -1.

For example, the minimum absolute difference of the array [5,2,3,7,2] is |2 - 3| = 1. Note that it is not 0 because a[i] and a[j] must be different.
You are given an integer array nums and the array queries where queries[i] = [li, ri]. For each query i, compute the minimum absolute difference of the subarray nums[li...ri] containing the elements of nums between the 0-based indices li and ri (inclusive).

Return an array ans where ans[i] is the answer to the ith query.

A subarray is a contiguous sequence of elements in an array.

The value of |x| is defined as:

x if x >= 0.
-x if x < 0.:class Solution:
    def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        N = len(nums)
        counts = [[] for _ in range(N + 1)]
        counts[0] = [0] * 101
        for i in range(N):
            counts[i + 1] = counts[i][:]
            counts[i + 1][nums[i]] += 1
        
        def findMin(l, r):
            cl, cr = counts[l], counts[r + 1]
            trueIdx = 1
            while cr[trueIdx] - cl[trueIdx] == 0:
                trueIdx += 1
            minDist = 100
            idx = trueIdx + 1
            while idx <= 100:
                if cr[idx] - cl[idx] > 0:
                    minDist = min(minDist, idx - trueIdx)
                    trueIdx = idx
                idx += 1
            return -1 if minDist == 100 else minDist
        results = []
        for l, r in queries:
            results.append(findMin(l, r))
        return results<|endoftext|>"
1082,"<|endoftext|>The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.

For example, ""ACGAATTCCG"" is a DNA sequence.
When studying DNA, it is useful to identify repeated sequences within the DNA.

Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.

 

Example 1:

Input: s = ""AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT""
Output: [""AAAAACCCCC"",""CCCCCAAAAA""]
Example 2:

Input: s = ""AAAAAAAAAAAAA""
Output: [""AAAAAAAAAA""]:class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        L, n = 10, len(s)     
        seen, output = set(), set()

        # iterate over all sequences of length L
        for start in range(n - L + 1):
            tmp = s[start:start + L]
            if tmp in seen:
                output.add(tmp[:])
            seen.add(tmp)
        return output<|endoftext|>"
1083,"<|endoftext|>In the previous article, we have discussed Python Program to Find Sum of Odd Numbers Using Recursion in a List/Array
 Given a number and the task is to count the number of digits present in a given number using recursion in python.
 Recursion:
 Recursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.
 Examples:
 Example1:
 Input:
 Given Number = 567812
 Output:
 The Number of digits present in the above given Number { 567812 } = 6
 Example2:
 Input:
 Given Number = 602
 Output:
 The Number of digits present in the above given Number { 602 } = 3:# Create a recursive function to say countnumbr_digits which takes the given number as
 
 # an argument and returns the count of the number of digits present in a given number.
 
 
 
 
 
 def countnumbr_digits(gvn_numb):
 
  # Make the cnt_digits a global declaration.
 
  global cnt_digits
 
  # Check if the given number is not equal to 0 using the if conditional statement.
 
  if (gvn_numb != 0):
 
  # If the statement is true, then increment the value of cnt_digits by 1 and store it
 
  # inthe same variable.
 
  cnt_digits += 1
 
  # Pass the given number divided by 10 as an argument to the countnumbr_digits function
 
  # (which removes the last digit of the number) {Recursive Logic}.
 
  countnumbr_digits(gvn_numb // 10)
 
  # Return cnt_digits.
 
  return cnt_digits
 
 
 
 
 
 # Give the number as static input and store it in a variable.
 
 gvn_numb = 567812
 
 # Take a variable say cnt_digits and initialize its value to 0.
 
 # Pass the given number as an argument to the countnumbr_digits function.
 
 cnt_digits = 0
 
 # Print the count of the number of digits present in the above-given number.
 
 print(""The Number of digits present in the above given Number {"", gvn_numb, ""} = "", countnumbr_digits(
 
  gvn_numb))<|endoftext|>"
1084,"<|endoftext|>If you want to build something using a Raspberry Pi, you'll probably use resistors. For this exercise, you need to know two things about them:

Each resistor has a resistance value.
Resistors are small - so small in fact that if you printed the resistance value on them, it would be hard to read.
To get around this problem, manufacturers print color-coded bands onto the resistors to denote their resistance values. Each band has a position and a numeric value.

The first 2 bands of a resistor have a simple encoding scheme: each color maps to a single number.

In this exercise you are going to create a helpful program so that you don't have to remember the values of the bands.

These colors are encoded as follows:

Black: 0
Brown: 1
Red: 2
Orange: 3
Yellow: 4
Green: 5
Blue: 6
Violet: 7
Grey: 8
White: 9
The goal of this exercise is to create a way:

to look up the numerical value associated with a particular color band
to list the different band colors
Mnemonics map the colors to the numbers, that, when stored as an array, happen to map to their index in the array: Better Be Right Or Your Great Big Values Go Wrong.:def color_code(color):
    return colors().index(color)
def colors():
    return [
        'black',
        'brown',
        'red',
        'orange',
        'yellow',
        'green',
        'blue',
        'violet',
        'grey',
        'white'
    ]<|endoftext|>"
1085,"<|endoftext|>OOP Exercise 3:Create a Bus object that will inherit all of the variables and methods of the parent Vehicle class and display it.:class Vehicle:

    def __init__(self, name, max_speed, mileage):
        self.name = name
        self.max_speed = max_speed
        self.mileage = mileage

class Bus(Vehicle):
    pass

School_bus = Bus(""School Volvo"", 180, 12)
print(""Vehicle Name:"", School_bus.name, ""Speed:"", School_bus.max_speed, ""Mileage:"", School_bus.mileage)<|endoftext|>"
1086,"<|endoftext|>In Mathematics, Handsome numbers are those number in which the sum of all the left side digit is equal to the last digit.

Handsome number examples: 123, 224, 235 etc.

Here 123 is Handsome number because last digit = 3 & remaining left part is 12 and sum of 1+2 is 3 i.e. 123 --> 1+2 = 3 which is last digit.

Similarly, 347 is Handsome because 3+4 = 7 which is last digit.

This Python program checks whether a given number by user is Handsome number or not.:# Handsome number

number = int(input('Enter number: '))

last_digit = number % 10

left_part = number // 10

left_part_sum = 0
while left_part:
    left_part_sum += left_part % 10
    left_part = left_part // 10

if left_part_sum == last_digit:
    print('%d is Handsome Number.' %(number))
else:
    print('%d is Not Handsome Number.' %(number))<|endoftext|>"
1087,"<|endoftext|>You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k.
The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed).
Find the kth largest value (1-indexed) of all the coordinates of matrix.
 
Example 1:

Input: matrix = [[5,2],[1,6]], k = 1
Output: 7
Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.

Example 2:

Input: matrix = [[5,2],[1,6]], k = 2
Output: 5
Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.

Example 3:

Input: matrix = [[5,2],[1,6]], k = 3
Output: 4
Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.
 
Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 1000
0 <= matrix[i][j] <= 106
1 <= k <= m * n:def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:
  R, C = map(len, (matrix, matrix[0]))
  ans = [[0] * (C + 1) for _ in range(R + 1)]
  heap = []
  for r, row in enumerate(matrix):
  for c, cell in enumerate(row):
  ans[r + 1][c + 1] = cell ^ ans[r + 1][c] ^ ans[r][c + 1] ^ ans[r][c]
  heapq.heappush(heap, ans[r + 1][c + 1])
  if len(heap) > k:
 heapq.heappop(heap)
  return heap[0]<|endoftext|>"
1088,"<|endoftext|>JSON in Python
JSON is a syntax for storing and exchanging data.

JSON is text, written with JavaScript object notation.

Python has a built-in package called json, which can be used to work with JSON data.:import json<|endoftext|>"
1089,"<|endoftext|>Interested in programming and want to excel in it by choosing the short ways. Then, practicing with the available Java Program list is mandatory.
 
 Recursion in Python:
 
 When a function calls itself and loops until it reaches the intended end state, this is referred to as recursion. It is based on the mathematics idea of recursive definitions, which define elements in a set in terms of other members in the set.
 
 Each recursive implementation contains a base case in which the desired state is reached, and a recursive case in which the desired state is not reached and the function enters another recursive phase.
 
 
 
 On each step, the behavior in the recursive situation prior to the recursive function call, the internal self-call, is repeated. Recursive structures are beneficial when a larger problem (the base case) can be solved by solving repeated subproblems (the recursive case) that incrementally advance the program to the base case.
 It behaves similarly to for and while loops, with the exception that recursion moves closer to the desired condition, whereas for loops run a defined number of times and while loops run until the condition is no longer met.
 
 
 
 In other words, recursion is declarative because you specify the desired state, whereas for/while loops are iterative because you provide the number of repeats.
 
 Examples:
 
 Example1:
 
 Input:
 
 given number = 97
 Output:
 
 The given number 97 is prime number.
 Example2:
 
 Input:
 
 given number = 139
 Output:
 
 The given number 139 is a prime number.:def checkPrimeRecursion(numb, divisors=None):
  if divisors is None:
  divisors = numb - 1
  while divisors >= 2:
  if numb % divisors == 0:
  # if we find the divisor then return false because it is not prime
  return False
  else:
  return checkPrimeRecursion(numb, divisors-1)
  else:
  # if we reach here return true because we did not find any
  # divisors of the given number
  return True
 # Give the number as static input and store it in a variable.
 given_numb = 97
 # passing the given number as argument to the recursive function checkPrimeRecursion.
 # If the function returns true then it is a prime number.
 if(checkPrimeRecursion(given_numb)):
  print('The given number', given_numb, 'is a prime number.')
 # Else it is not a prime number.
 else:
  print('The given number', given_numb, 'is not a prime number.')<|endoftext|>"
1090,"<|endoftext|>In the previous article, we have discussed Python Program for Sum of Middle Row and Column in Matrix
 
 Markov Matrix:
 
 The matrix where the sum of each row equals one.
 
 Given a matrix, the task is to check if the given matrix is a Markov matrix or not.
 
 What is a matrix:
 
 A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.
 
 Example:
 
 
 
 Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.
 
 In this order, the dimensions of a matrix indicate the number of rows and columns.
 
 Here as there are 5 rows and 4 columns it is called a 5*4 matrix.
 
 Examples:
 
 Example1:
 
 Input:
 
 Given Matrix : 
 0.5 0.5 0
 0 0 1
 1 0 0
 Output:
 
 Yes, the given matrix is a Markov Matrix
 Example2:
 
 Input:
 
 Given Matrix : 
 1 2 0
 0 0.5 0.5
 1 0 0
 Output:
 
 No, the given matrix is not a Markov Matrix:# Create a function to say chek_Markovmatrix which takes the given matrix as an argument
 # and returns True or false.
 def chek_Markovmatrix(mtrx):
  # Loop till the given number of rows using the For loop.
  for p in range(mtrxrows):
  # Take a variable to say row_summ and initialize its value to 0.
  row_summ = 0
  # Inside the For loop, Iterate till the given number of rows using another Nested
  # For loop (Inner For loop).
  for q in range(mtrxrows):
  # Add mtrx[p][q] to the above row_summ (where p is the iterator value of the
  # parent for loop and q is the iterator value of the inner forloop).
  # Store it in the same variable row_summ
  row_summ = row_summ + mtrx[p][q]
  # Check if the value of row_summ is not equal to 1 using the if conditional
  # statement.
  if (row_summ != 1):
  # If it is true then return false.
  return False
  # Return True.
  return True
 # Give the matrix as static input and store it in a variable.
 mtrx = [[0.5, 0.5, 0], [0, 0, 1], [1, 0, 0]]
 # Calculate the number of rows of the given matrix by
 # calculating the length of the nested list using the len() function
 # and store it in a variable mtrxrows.
 mtrxrows = len(mtrx)
 # Calculate the number of columns of the given matrix by
 # calculating the length of the first list in the nested list
 # using the len() function and store it in a variable mtrxcols.
 mtrxcols = len(mtrx[0])
 # Pass the given matrix as an argument to the chek_Markovmatrix function and check if
 # the function returns true or false using the if conditional statement.
 if (chek_Markovmatrix(mtrx)):
  # If it is true then print ""Yes, the given matrix is a Markov Matrix"".
  print(""Yes, the given matrix is a Markov Matrix"")
 else:
  # Else print ""No, the given matrix is not a Markov Matrix"".
  print(""No, the given matrix is not a Markov Matrix"")<|endoftext|>"
1091,"<|endoftext|>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:

[4,5,6,7,0,1,4] if it was rotated 4 times.
[0,1,4,4,5,6,7] if it was rotated 7 times.
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.

You must decrease the overall operation steps as much as possible.:class Solution:
    def findMin(self, nums: List[int]) -> int:    
        low = 0
        high = len(nums)-1
        while high > low:
            pivot = low + (high - low) // 2
            # risk of overflow: pivot = (low + high) // 2
            # Case 1):
            if nums[pivot] < nums[high]:
                high = pivot 
                # alternative: high = pivot - 1
                # too aggressive to move the `high` index,
                # it won't work for the test case of [3, 1, 3]
            # Case 2):
            elif nums[pivot] > nums[high]:
                low = pivot + 1
            # Case 3):
            else:
                high -= 1
        # the 'low' and 'high' index converge to the inflection point.
        return nums[low]<|endoftext|>"
1092,"<|endoftext|>You must all be aware of what PDFs are. They are, in fact, one of the most essential and extensively utilized forms of digital media. PDF is an abbreviation for Portable Document Format. It has the.pdf extension. It is used to reliably exhibit and share documents, regardless of software, hardware, or operating system.

Text Extraction from a PDF File
The Python module PyPDF can be used to achieve what we want (text extraction), but it can also do more. This software can also produce, decrypt, and merge PDF files.:import PyPDF2

# The opening procedure for a file object variable will be rb
pdffile = open(r'C:\Users\Vikram\Desktop\samplepdf.pdf', 'rb')

# create a variable called reader that will read the pdf file
pdfReader = PyPDF2.PdfFileReader(pdffile)

# The number of pages in this pdf file will be saved.
num = pdfReader.numPages

# create a variable that will select the selected number of pages
pageobj = pdfReader.getPage(num+1)

resulttext = pageobj.extractText()

newfile = open(
    r""C:\Users\Vikram\Desktop\Calender\\sample.txt"", ""a"")
newfile.writelines(resulttext)<|endoftext|>"
1093,"<|endoftext|>Given an array of n integers. The task is to print the duplicates in the given array. If there are no duplicates then print -1. 

Examples: 

Input: {2, 10,10, 100, 2, 10, 11,2,11,2}
Output: 2 10 11

Input: {5, 40, 1, 40, 100000, 1, 5, 1}
Output: 5 40 1:# Python3 implementation of the
# above approach

# Function to find the Duplicates,
# if duplicate occurs 2 times or
# more than 2 times in array so,
# it will print duplicate value
# only once at output
def findDuplicates(arr, Len):
	
	# Initialize ifPresent as false
	ifPresent = False

	# ArrayList to store the output
	a1 = []
	for i in range(Len - 1):
		for j in range(i + 1, Len):

			# Checking if element is
			# present in the ArrayList
			# or not if present then break
			if (arr[i] == arr[j]):
				if arr[i] in a1:
					break
				
				# If element is not present in the
				# ArrayList then add it to ArrayList
				# and make ifPresent at true
				else:
					a1.append(arr[i])
					ifPresent = True

	# If duplicates is present
	# then print ArrayList
	if (ifPresent):
		print(a1, end = "" "")
	else:
		print(""No duplicates present in arrays"")

# Driver Code
arr = [ 12, 11, 40, 12, 5, 6, 5, 12, 11 ]
n = len(arr)

findDuplicates(arr, n)

# This code is contributed by rag2127<|endoftext|>"
1094,"<|endoftext|>Natural numbers:

As the name specifies, a natural number is the number that occurs commonly and obviously in the nature. It is a whole, non-negative number.:num = int(input(""Enter a number: ""))  
  
if num < 0:  
   print(""Enter a positive number"")  
else:  
   sum = 0  
   # use while loop to iterate un till zero  
   while(num > 0):  
       sum += num  
       num -= 1  
   print(""The sum is"",sum)  <|endoftext|>"
1095,"<|endoftext|>Every month, Microny™️ (a big entertainment corporation) publishes a few free videogames on their web store. You are working on a script that will notify you whenever the new games are available for download. There is not a fixed date for the new releases, but you know that it happens every first Tuesday of every month.
Write a function that, given a year and a month, returns a string with the date of when the new games will be available.
Examples
first_tuesday_of_the_month(1997, 1) ➞ ""1997-01-07""

first_tuesday_of_the_month(2021, 2) ➞ ""2021-02-02""

first_tuesday_of_the_month(2020, 3) ➞ ""2020-03-03""
Notes
Months are given as numbers starting at 1 = January.:from datetime import date
def first_tuesday_of_the_month(year, month):
  for day in range(1, 8):
    if date(year, month, day).weekday() == 1:
      return date(year, month, day).isoformat()<|endoftext|>"
1096,"<|endoftext|>You will learn to find resolution of a jpeg image in this example without using external libraries:def jpeg_res(filename):
   """"""""This function prints the resolution of the jpeg image file passed into it""""""

   # open image for reading in binary mode
   with open(filename,'rb') as img_file:

       # height of image (in 2 bytes) is at 164th position
       img_file.seek(163)

       # read the 2 bytes
       a = img_file.read(2)

       # calculate height
       height = (a[0] << 8) + a[1]

       # next 2 bytes is width
       a = img_file.read(2)

       # calculate width
       width = (a[0] << 8) + a[1]

   print(""The resolution of the image is"",width,""x"",height)

jpeg_res(""img1.jpg"")<|endoftext|>"
1097,"<|endoftext|>Fibonacci numbers are defined by the sequence f(0) = 0, f(1) = 1 and f(n) = f(n – 1) + f(n – 2) for n >= 2. The program prompts the user to enter n and it prints the nth Fibonacci number.:def fibonacci(n):
    """"""Return the nth Fibonacci number.""""""
    # r[i] will contain the ith Fibonacci number
    r = [-1]*(n + 1)
    return fibonacci_helper(n, r)
 
 
def fibonacci_helper(n, r):
    """"""Return the nth Fibonacci number and store the ith Fibonacci number in
    r[i] for 0 <= i <= n.""""""
    if r[n] >= 0:
        return r[n]
 
    if (n == 0 or n == 1):
        q = n
    else:
        q = fibonacci_helper(n - 1, r) + fibonacci_helper(n - 2, r)
    r[n] = q
 
    return q
 
 
n = int(input('Enter n: '))
 
ans = fibonacci(n)
print('The nth Fibonacci number:', ans)<|endoftext|>"
1098,"<|endoftext|>The program creates a tree and finds the sum of all nodes in the tree.:class Tree:
    def __init__(self, data=None):
        self.key = data
        self.children = []
 
    def set_root(self, data):
        self.key = data
 
    def add(self, node):
        self.children.append(node)
 
    def search(self, key):
        if self.key == key:
            return self
        for child in self.children:
            temp = child.search(key)
            if temp is not None:
                return temp
        return None
 
    def sum_nodes(self):
        summation = self.key
        for child in self.children:
            summation = summation + child.sum_nodes()
        return summation
 
 
tree = None
 
print('Menu (this assumes no duplicate keys)')
print('add <data> at root')
print('add <data> below <data>')
print('sum')
print('quit')
 
while True:
    do = input('What would you like to do? ').split()
 
    operation = do[0].strip().lower()
    if operation == 'add':
        data = int(do[1])
        new_node = Tree(data)
        suboperation = do[2].strip().lower() 
        if suboperation == 'at':
            tree = new_node
        elif suboperation == 'below':
            position = do[3].strip().lower()
            key = int(position)
            ref_node = None
            if tree is not None:
                ref_node = tree.search(key)
            if ref_node is None:
                print('No such key.')
                continue
            ref_node.add(new_node)
 
    elif operation == 'sum':
        if tree is None:
            print('Tree is empty.')
        else:
            summation = tree.sum_nodes()
            print('Sum of all nodes: {}'.format(summation))
 
    elif operation == 'quit':
        break<|endoftext|>"
1099,"<|endoftext|>We are given a row-wise sorted matrix of size r*c, we need to find the median of the matrix given. It is assumed that r*c is always odd.

Examples: 

Input : 1 3 5
        2 6 9
        3 6 9
Output : Median is 5
If we put all the values in a sorted 
array A[] = 1 2 3 3 5 6 6 9 9)

Input: 1 3 4
       2 5 6
       7 8 9
Output: Median is 5:# Python program to find median of matrix
# sorted row wise
 
from bisect import bisect_right as upper_bound
 
MAX = 100;
 
# Function to find median in the matrix
def binaryMedian(m, r, d):
    mi = m[0][0]
    mx = 0
    for i in range(r):
        if m[i][0] < mi:
            mi = m[i][0]
        if m[i][d-1] > mx :
            mx =  m[i][d-1]
     
    desired = (r * d + 1) // 2
     
    while (mi < mx):
        mid = mi + (mx - mi) // 2
        place = [0];
         
        # Find count of elements smaller than mid
        for i in range(r):
             j = upper_bound(m[i], mid)
             place[0] = place[0] + j
        if place[0] < desired:
            mi = mid + 1
        else:
            mx = mid
    print (""Median is"", mi)
    return   
     
# Driver code
r, d = 3, 3
 
m = [ [1, 3, 5], [2, 6, 9], [3, 6, 9]]
binaryMedian(m, r, d)
 
# This code is contributed by Sachin BIsht
<|endoftext|>"
1100,"<|endoftext|>lPaeesh le pemu mnxit ehess rtnisg! Oh, sorry, that was supposed to say: Please help me unmix these strings!
Somehow my strings have all become mixed up; every pair of characters has been swapped. Help me undo this so I can understand my strings again.
Examples
unmix(""123456"") ➞ ""214365""

unmix(""hTsii  s aimex dpus rtni.g"") ➞ ""This is a mixed up string.""

unmix(""badce"") ➞ ""abcde""
Notes
The length of a string can be odd — in this case the last character is not altered (as there's nothing to swap it with).:def unmix(txt):
  return ''.join(txt[i:i+2][::-1] for i in range(0,len(txt),2))<|endoftext|>"
1101,"<|endoftext|>You can use the pop() method to remove an element from the array.

:cars.pop(1)<|endoftext|>"
1102,"<|endoftext|>Dictionaries in Python:

Dictionary is a mutable built-in Python Data Structure. It is conceptually related to List, Set, and Tuples. It is, however, indexed by keys rather than a sequence of numbers and can be thought of as associative arrays. On a high level, it consists of a key and its associated value. The Dictionary class in Python represents a hash-table implementation.

Examples:

Example1:

Input:

given string =""hello this is hello BTechGeeks BTechGeeks BTechGeeks this python programming python language""
Output:

{'hello': 2, 'this': 2, 'is': 1, 'BTechGeeks': 3, 'python': 2, 'programming': 1, 'language': 1}:# given string
given_string = ""hello this is hello BTechGeeks BTechGeeks BTechGeeks this python programming python language""
# Split the given string into words using split() function
# Convert this into list using list() function.
listString = given_string.split()
# Count the frequency of each term using count() function and
# save the results in a separate list using list Comprehension.
freqWords = [listString.count(k) for k in listString]
# Merge the lists containing the terms and the word counts
# into a dictionary using the zip() function.
resultdict = dict(zip(listString, freqWords))
# Print the resultant dictionary
print(resultdict)<|endoftext|>"
1103,"<|endoftext|>Given a Directed Acyclic Graph of n nodes (numbered from 1 to n) and m edges. The task is to find the number of sink nodes. A sink node is a node such that no edge emerges out of it.

Examples: 

Input : n = 4, m = 2
        Edges[] = {{2, 3}, {4, 3}} 
Output : 2:# Python3 program to count number if sink nodes
  
# Return the number of Sink NOdes. 
def countSink(n, m, edgeFrom, edgeTo):
      
    # Array for marking the non-sink node. 
    mark = [0] * (n + 1)
  
    # Marking the non-sink node.
    for i in range(m):
        mark[edgeFrom[i]] = 1
  
    # Counting the sink nodes. 
    count = 0
    for i in range(1, n + 1):
        if (not mark[i]): 
            count += 1
  
    return count
  
# Driver Code
if __name__ == '__main__': 
      
    n = 4
    m = 2
    edgeFrom = [2, 4] 
    edgeTo = [3, 3]
  
    print(countSink(n, m, edgeFrom, edgeTo))
  
# This code is contributed by PranchalK
<|endoftext|>"
1104,"<|endoftext|>In the previous article, we have discussed Python Program to Sort digits of a Number in Ascending Order
 Highest Common Factor (HCF) / Greatest Common Divisor (GCD) :
 When at least one of the integers is not zero, the greatest positive integer that evenly divides the numbers without a remainder is called the Highest Common Factor or Greatest Common Divisor.
 The GCD of 12 and 16 is, for example, 4.
 Given two numbers, n, and m, and the task is to solve the equation, Find the largest integer a(gcd) that is divisible by all integers n, n + 1, n + 2,…, m.
 We only need to look at two cases here:
 If a = b, the segment is made up of a single number, so the answer is a.
 If a = b, then gcd(n, n + 1, n?+ 2,…, m) = gcd(n, n + 1), n + 2,…, m) = gcd(1, n + 2,…, n) = 1.
 Examples:
 Example1:
 Input:
 Given First Number =  125
 
 Given Second Number = 125
 Output:
 The greatest number that divides both 125 and 125 = 125
 Example2:
 Input:
 Given First Number = 5
 
 Given Second Number = 8
 Output:
 The greatest number that divides both 5 and 8 = 1:# Give the first number as static input and store it in a variable.
 
 fst_numb = 125
 
 # Give the second number as static input and store it in another variable.
 
 secnd_numb = 125
 
 # Check if the first number is equal to the second number using the if conditional statement.
 
 if(fst_numb == secnd_numb):
 
  # If the statement is true, then print the first number.
 
  print(""The greatest number that divides both"",
 
  fst_numb, ""and"", secnd_numb, ""="", fst_numb)
 
 else:
 
  # If the statement is false, then print 1.
 
  print(""The greatest number that divides both"",
 
  fst_numb, ""and"", secnd_numb, ""="", 1)
 
 </pre><|endoftext|>"
1105,"<|endoftext|>We are given n requests numbered 0 to n – 1. Each request i has a time that it takes to complete t(i) and a deadline d(i). If a request i starts at time s(i), then its finish time is f(i) = s(i) + t(i). The lateness of request i is L(i) = f(i) – d(i) if f(i) > d(i). The maximum value of L(i) over all i is called the maximum lateness. That is, maximum lateness = max(L(0), L(1), …, L(n – 1)). The problem is to schedule all the requests such that the value of maximum lateness is minimized.:def minimize_lateness(ttimes, dtimes):
    """"""Return minimum max lateness and the schedule to obtain it.
 
    (min_lateness, schedule) is returned.
 
    Lateness of a request i is L(i) = finish time of i - deadline of if
    request i finishes after its deadline.
    The maximum lateness is the maximum value of L(i) over all i.
    min_lateness is the minimum value of the maximum lateness that can be
    achieved by optimally scheduling the requests.
 
    schedule is a list that contains the indexes of the requests ordered such
    that minimum maximum lateness is achieved.
 
    ttime[i] is the time taken to complete request i.
    dtime[i] is the deadline of request i.
    """"""
    # index = [0, 1, 2, ..., n - 1] for n requests
    index = list(range(len(dtimes)))
    # sort according to deadlines
    index.sort(key=lambda i: dtimes[i])
 
    min_lateness = 0
    start_time = 0
    for i in index:
        min_lateness = max(min_lateness,
                           (ttimes[i] + start_time) - dtimes[i])
        start_time += ttimes[i]
 
    return min_lateness, index
 
 
n = int(input('Enter number of requests: '))
ttimes = input('Enter the time taken to complete the {} request(s) in order: '
              .format(n)).split()
ttimes = [int(tt) for tt in ttimes]
dtimes = input('Enter the deadlines of the {} request(s) in order: '
               .format(n)).split()
dtimes = [int(dt) for dt in dtimes]
 
min_lateness, schedule = minimize_lateness(ttimes, dtimes)
print('The minimum maximum lateness:', min_lateness)
print('The order in which the requests should be scheduled:', schedule)<|endoftext|>"
1106,"<|endoftext|>Given an array of integers arr, return the number of subarrays with an odd sum.
Since the answer can be very large, return it modulo 109 + 7.
 
Example 1:

Input: arr = [1,3,5]
Output: 4
Explanation: All subarrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]
All sub-arrays sum are [1,4,9,3,8,5].
Odd sums are [1,9,3,5] so the answer is 4.

Example 2:

Input: arr = [2,4,6]
Output: 0
Explanation: All subarrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]
All sub-arrays sum are [2,6,12,4,10,6].
All sub-arrays have even sum and the answer is 0.

Example 3:

Input: arr = [1,2,3,4,5,6,7]
Output: 16

 
Constraints:

1 <= arr.length <= 105
1 <= arr[i] <= 100:class Solution:
  def numOfSubarrays(self, arr: List[int]) -> int:
  res = odd = even = 0
  for x in arr:
  even += 1
  if x % 2:
  odd, even = even, odd
  res = (res + odd) % 1000000007  
  return res<|endoftext|>"
1107,"<|endoftext|>Definition and Usage
The setdefault() method returns the value of the item with the specified key.

If the key does not exist, insert the key, with the specified value, see example below:car = {
  ""brand"": ""Ford"",
  ""model"": ""Mustang"",
  ""year"": 1964
}

x = car.setdefault(""model"", ""Bronco"")

print(x)<|endoftext|>"
1108,"<|endoftext|>Clear nth Bit of a Number Using Bitwise &(and) Operator (User Input):# Give the number as user input using the int(input()) function and 
# store it in a variable.
gvn_numb = int(input(""Enter some random number = ""))
# Give the bit position as user input using the int(input()) function 
# and store it in another variable.
bitpositin = int(input(""Enter some random number = ""))
# Apply the left shift operator to 1 and the above-given bit position and
# store it in another variable.
numbr_bit = (1 << bitpositin)
# Apply the complement operator (which converts 0 to 1 and vice-versa) to the above result
# and store it in another variable.
complemt = (~numbr_bit)
# Apply bitwise & operation for the given number and the above result and store it in
# another variable say rslt_numb.
rslt_numb = gvn_numb & complemt
# Print the number after clearing the bit at the given position for a given number.
print(""The Number after clearing the bit at the given position{"",
      bitpositin, ""} for a given number{"", gvn_numb, ""} ="", rslt_numb)<|endoftext|>"
1109,"<|endoftext|>You are given an integer array nums and an integer k. Append k unique positive integers that do not appear in nums to nums such that the resulting total sum is minimum.

Return the sum of the k integers appended to nums.:class Solution:
    def minimalKSum(self, nums: List[int], k: int) -> int:
        
        # Append 0 and +inf to avoid extra checks in the for loop
        nums.append(0)
        nums.append(float(""+inf""))
        nums.sort()
        
        total = 0
        for i in range(1, len(nums)):
            if k == 0:
                break
            # check that the numbers are different
            elif nums[i] == nums[i-1]:
                continue
            else:
                # calculate the sum between n1 and n2 in O(1)
                n1, n2 = nums[i-1]+1, nums[i]-1
                # Special check in case that there more numbers than k
                if n2 - n1 + 1 > k:
                    n2 = n1 + k - 1
                    remaining = k
                    k = 0
                else:
                    remaining = n2 - n1 + 1
                    k -= n2 - n1 + 1
                
                total += remaining * (n2 + n1) // 2
            
        return total<|endoftext|>"
1110,"<|endoftext|>Write a function that returns the number of ways a person can climb n stairs, where the person may only climb 1 or 2 steps at a time.
To illustrate, if n = 4 there are 5 ways to climb:
[1, 1, 1, 1]
[2, 1, 1]
[1, 2, 1]
[1, 1, 2]
[2, 2]
Examples
ways_to_climb(1) ➞ 1

ways_to_climb(2) ➞ 2

ways_to_climb(5) ➞ 8
Notes
A staircase of height 0 should return 1.:def ways_to_climb(n):
  a, b = 0, 1
  for _ in range(n):
    a, b = b, a + b
  return b<|endoftext|>"
1111,"<|endoftext|>The program sorts a list by counting sort.:def counting_sort(alist, largest):
    c = [0]*(largest + 1)
    for i in range(len(alist)):
        c[alist[i]] = c[alist[i]] + 1
 
    # Find the last index for each element
    c[0] = c[0] - 1 # to decrement each element for zero-based indexing
    for i in range(1, largest + 1):
        c[i] = c[i] + c[i - 1]
 
    result = [None]*len(alist)
 
    # Though it is not required here,
    # it becomes necessary to reverse the list
    # when this function needs to be a stable sort
    for x in reversed(alist):
        result[c[x]] = x
        c[x] = c[x] - 1
 
    return result
 
 
alist = input('Enter the list of (nonnegative) numbers: ').split()
alist = [int(x) for x in alist]
k = max(alist)
sorted_list = counting_sort(alist, k)
print('Sorted list: ', end='')
print(sorted_list)<|endoftext|>"
1112,"<|endoftext|>Given an undirected tree consisting of n vertices numbered from 0 to n-1, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at vertex 0 and coming back to this vertex.
The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. Additionally, there is a boolean array hasApple, where hasApple[i] = true means that vertex i has an apple; otherwise, it does not have any apple.
 
Example 1:


Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]
Output: 8 
Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  

Example 2:


Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]
Output: 6
Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  

Example 3:

Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]
Output: 0

 
Constraints:

1 <= n <= 105
edges.length == n - 1
edges[i].length == 2
0 <= ai < bi <= n - 1
fromi < toi
hasApple.length == n:def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:
  adj = [[] for _ in range(n)]
  for u, v in edges:
  adj[u].append(v)
  adj[v].append(u)

  visited = set()
  def dfs(node):
  if node in visited:
  return 0
  visited.add(node)
  secs = 0
  for child in adj[node]:
  secs += dfs(child)
  if secs > 0:
  return secs + 2
  return 2 if hasApple[node] else 0

  return max(dfs(0) - 2, 0)<|endoftext|>"
1113,"<|endoftext|>The program creates a dequeue and allows the user to perform append and pop operations on it from both sides.:class Dequeue:
    def __init__(self):
        self.items = []
 
    def is_empty(self):
        return self.items == []
 
    def append(self, data):
        self.items.append(data)
 
    def append_left(self, data):
        self.items.insert(0, data)
 
    def pop(self):
        return self.items.pop()
 
    def pop_left(self):
        return self.items.pop(0)
 
 
q = Dequeue()
print('Menu')
print('append <value>')
print('appendleft <value>')
print('pop')
print('popleft')
print('quit')
 
while True:
    do = input('What would you like to do? ').split()
 
    operation = do[0].strip().lower()
    if operation == 'append':
        q.append(int(do[1]))
    elif operation == 'appendleft':
        q.append_left(int(do[1]))
    elif operation == 'pop':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from right: ', q.pop())
    elif operation == 'popleft':
        if q.is_empty():
            print('Dequeue is empty.')
        else:
            print('Popped value from left: ', q.pop_left())
    elif operation == 'quit':
        break<|endoftext|>"
1114,"<|endoftext|>Create a function that calculates the chance of being an imposter. The formula for the chances of being an imposter is 100 × (i / p) where i is the imposter count and p is the player count. Make sure to round the value to the nearest integer and return the value as a percentage.

Examples
imposter_formula(1, 10) ➞ ""10%""

imposter_formula(2, 5) ➞ ""40%""

imposter_formula(1, 8) ➞ ""13%""
Notes
The player limit is 10 and the imposter count can only go up to 3.:def imposter_formula(i, p):
		return '{:.0%}'.format(i/p)<|endoftext|>"
1115,"<|endoftext|>Surface Area of a Cube :

If we know the length of an edge in a Cube, we can use the following formula to calculate the surface area of a Cube:

Cube Surface Area = 6S²

In which  S= length of any side of a Cube

A square’s area = S². Surface Area of a Cube = 6S²  because the Cube is made up of 6 equal squares.

The volume of a Cube :

Volume refers to the amount of space inside the Cube. If we know the length of any edge of a Cube, we can use the following

Formula to calculate the Volume of the Cube:  S*S*S*

A Cube’s Lateral Surface Area = 4 * (S * S)



Given the side of a cube and the task is to find the surface area, volume, and lateral surface for a given side of a cube.

Examples:
Example 1:
Input:
Given side length of a cube = 12
Output:
The given surface Area of a Cube with side length [ 12 ]= 864.000
The given volume of a Cube with side length [ 12 ]= 1728.000
The given lateral surface area of a Cube with side lngth [ 12 ]= 576.000

Example 2:
Input:
Given side length of a cube = 4
Output:
The given surface Area of a Cube with side length [ 4 ]= 96.000
The given volume of a Cube with side length [ 4 ]= 64.000
The given lateral surface area of a Cube with side lngth [ 4 ]= 64.000:# Give the length of the side of a cube as static input and store it in a variable.
 cube_side = 7
 # Calculate the surface area of a given cube using the above given mathematical formula
 # and store it in another variable.
 surf_area = 6 * (cube_side * cube_side)
 # Calculate the volume of a given cube using the above given mathematical formula and
 # store it in another variable.
 Volum = cube_side * cube_side * cube_side
 # Calculate the lateral surface area of a given cube using the above given mathematical
 # formula and store it in another variable.
 Laterl_surfcarea = 4 * (cube_side * cube_side)
 # Print the surface area of a given cube.
 print(
  ""The given surface Area of a Cube with side length ["", cube_side, ""]= %.3f"" % surf_area)
 # Print the volume of a given cube.
 print(
  ""The given volume of a Cube with side length ["", cube_side, ""]= %.3f"" % Volum)
 # Print the lateral surface area of a given cube.
 print(
  ""The given lateral surface area of a Cube with side lngth ["", cube_side, ""]= %.3f"" % Laterl_surfcarea)<|endoftext|>"
1116,"<|endoftext|>Instructions
Your task is to convert a number into a string that contains raindrop sounds corresponding to certain potential factors. A factor is a number that evenly divides into another number, leaving no remainder. The simplest way to test if one number is a factor of another is to use the modulo operation.

The rules of raindrops are that if a given number:

has 3 as a factor, add 'Pling' to the result.
has 5 as a factor, add 'Plang' to the result.
has 7 as a factor, add 'Plong' to the result.
does not have any of 3, 5, or 7 as a factor, the result should be the digits of the number.
Examples
28 has 7 as a factor, but not 3 or 5, so the result would be ""Plong"".
30 has both 3 and 5 as factors, but not 7, so the result would be ""PlingPlang"".
34 is not factored by 3, 5, or 7, so the result would be ""34"".:def convert(number):
    return ''.join(drop for divisor, drop in
                   {3: ""Pling"", 5: ""Plang"", 7: ""Plong""}.items()
                   if number % divisor == 0) or str(number)
# using list of tuples for pre-3.7
# def convert(number):
#     return ''.join(drop for divisor, drop in
#                    [(3, ""Pling""), (5, ""Plang""), (7, ""Plong"")]
#                    if number % divisor == 0) or str(number)
# the above use or on the falsiness of an empty string
# the below use a ternary expression
# def convert(number):
#     msg = ''.join(drop for divisor, drop in {3: ""Pling"", 5: ""Plang"",
#                   7: ""Plong""}.items() if number % divisor == 0)
#     return msg if msg != '' else str(number)
# using list of tuples for pre-3.7
# def convert(number):
#     msg = ''.join(drop for divisor, drop in [(3, ""Pling""), (5, ""Plang""),
#                   (7, ""Plong"")] if number % divisor == 0)
#     return msg if msg != '' else str(number)<|endoftext|>"
1117,"<|endoftext|>Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.

Return the sum of the three integers.

You may assume that each input would have exactly one solution.

 

Example 1:

Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
Example 2:

Input: nums = [0,0,0], target = 1
Output: 0
 

Constraints:

3 <= nums.length <= 1000
-1000 <= nums[i] <= 1000
-104 <= target <= 104:class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        diff = float('inf')
        nums.sort()
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                complement = target - nums[i] - nums[j]
                hi = bisect_right(nums, complement, j + 1)
                lo = hi - 1
                if hi < len(nums) and abs(complement - nums[hi]) < abs(diff):
                    diff = complement - nums[hi]
                if lo > j and abs(complement - nums[lo]) < abs(diff):
                    diff = complement - nums[lo]
            if diff == 0:
                break
        return target - diff<|endoftext|>"
1118,"<|endoftext|>In microwave ovens, when buttons are pressed from 0-9, it will add that number to the microwave oven timer (starting from the left). All microwave ovens have the functionality where you can hit a ""+30"" button and it will add 30 seconds to the timer to cook your food. If you want to heat something for 5 mins, you can hit the ""+30"" button 10 times instead of thinking if there are fewer button presses that can give you the same result.
Create a function that takes an argument time and returns the shortest amount of button presses to set the given time on the microwave oven. The microwave oven timer always starts at 00:00.
Buttons
Buttons from ""0-9""

# It will add that number to the microwave oven timer (starting from the left).
# If the number ""5"" is pressed followed by ""0"" twice, it will put 05:00 on the timer.
# If the number ""3"" is pressed followed by ""0"", it will put 00:30 on the timer.

Button ""+30"", which adds 30 seconds to the current timer.

# If the number ""+30"" is pressed twice, it will put 00:60 on the timer.

A ""Start"" button which you have to finally press to start the microwave oven.

# Remember to press this!
Examples
microwave_buttons(""00:30"") ➞ 2
# ""+30"" to put 30 seconds on the timer.
# ""Start"" button to start the oven.

microwave_buttons(""00:70"") ➞ 3
# ""7"" followed by ""0"" to put 70 seconds on the timer.
# ""Start"" button to start the oven.

microwave_buttons(""00:00"") ➞ 1
# ""Start"" button to start the oven.
Notes
Input may not always be what you expect (e.g. you can put in 00:70, which is valid).
No exception handling is required for this challenge.:def microwave_buttons(time):
  try:
    return ('00:00', '00:30', '01:00').index(time) + 1
  except:
    return len(time.lstrip('0'))<|endoftext|>"
1119,"<|endoftext|>In the previous article, we have discussed Python Program to Find Isosceles Triangle Area
 The general mathematical formula to calculate the sum of cubes of a series = ( n (n+1) / 6)²
 where n= nth term of a series.
 Given the nth term of a series and the task is to calculate the sum of the cubes of a series.
 Math Module :
 Python’s math module is a built-in module. By importing this module, we can perform mathematical computations.
 Numerous mathematical operations like ceil( ),floor( ),factorial( ),mod( ),value of pi ,…..etc .can be computed with the help of math module.
 math.pow() :
 The math. pow() method returns the value of x to the power of y.
 It throws a ValueError if x is negative and y is not an integer.
 Both arguments are converted to floats by this method.
 Note: Using math.pow(1.0,x) or math.pow(x,0.0) always returns 1.0.
 Examples:
 Example1:
 Input:
 Given n value = 13
 Output:
 The sum of cubes of a series with the given n value[ 13 ] = 8281.0
 Example2:
 Input:
 Given n value = 6
 Output:
 The sum of cubes of a series with the given n value[ 6 ] = 441.0:# Import math module using the import keyword.
 
 import math
 
 # Give the nth term of a series as static input and store it in a variable.
 
 num = 10
 
 # Calculate the sum of cubes of a series with a given nth term using the above
 
 # mathematical formula and math.pow() function. 
 
 # Store it in another variable.
 
 cube_sum = math.pow((num * (num + 1)) / 2, 2)
 
 # Print the sum of cubes of a given series with the given n value.
 
 print(
 
  ""The sum of cubes of a series with the given n value["", num, ""] ="", cube_sum)
 
 </pre><|endoftext|>"
1120,"<|endoftext|>Given a pair-sum array and size of the original array (n), construct the original array.
A pair-sum array for an array is the array that contains sum of all pairs in ordered form. For example pair-sum array for arr[] = {6, 8, 3, 4} is {14, 9, 10, 11, 12, 7}.
In general, pair-sum array for arr[0..n-1] is {arr[0]+arr[1], arr[0]+arr[2], ……., arr[1]+arr[2], arr[1]+arr[3], ……., arr[2]+arr[3], arr[2]+arr[4], …., arr[n-2]+arr[n-1}.:# Fills element in arr[] from its
# pair sum array pair[].
# n is size of arr[]

def constructArr(arr,pair,n):
	arr [0] = (pair[0]+pair[1]-pair[n-1])//2
	for i in range(1,n):
		arr[i] = pair[i-1]-arr[0]

# Driver code
if __name__=='__main__':
	pair = [15, 13, 11, 10, 12, 10, 9, 8, 7, 5]
	n =5
	arr = [0]*n
	constructArr(arr,pair,n)
	for i in range(n):
		print(arr[i],end ="" "")

# This code is contributed by
# Shrikant13<|endoftext|>"
1121,"<|endoftext|>Given a square matrix, find out count of numbers that are same in same row and same in both primary and secondary diagonals.

Examples : 
Input : 1 2 1
        4 5 2
        0 5 1
Output : 2
Primary diagonal is 1 5 1
Secondary diagonal is 1 5 0
Two elements (1 and 5) match 
in two diagonals and same.

Input : 1 0 0
        0 1 0
        0 0 1
Output : 1
Primary diagonal is 1 1 1
Secondary diagonal is 0 1 0
Only one element is same.

 :# Python3 program to find common
# elements in two diagonals.
 
Max = 100
 
# Returns count of row wise same
# elements in two diagonals of
# mat[n][n]
def countCommon(mat, n):
    res = 0
     
    for i in range(n):
         
        if mat[i][i] == mat[i][n-i-1] :
            res = res + 1
    return res    
 
# Driver Code
mat = [[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]]
 
print(countCommon(mat, 3))
 
# This code is contributed by Anant Agarwal.
<|endoftext|>"
1122,"<|endoftext|>Given a 2D matrix, the task is to find the maximum sum of an hourglass.

An hour glass is made of 7 cells
in following form.
    A B C
      D
    E F G

Examples: 

Input : 1 1 1 0 0 
        0 1 0 0 0 
        1 1 1 0 0 
        0 0 0 0 0 
        0 0 0 0 0 
Output : 7
Below is the hour glass with
maximum sum:
1 1 1 
  1
1 1 1
                                                      
Input : 0 3 0 0 0
        0 1 0 0 0
        1 1 1 0 0
        0 0 2 4 4
        0 0 0 2 4
Output : 11
Below is the hour glass with
maximum sum
1 0 0
  4
0 2 4:# Python 3 program to find the maximum
# sum of hour glass in a Matrix
 
# Fixing the size of the Matrix.
# Here it is of order 6 x 6
R = 5
C = 5
 
# Function to find the maximum sum of hour glass
def MaxSum(arr):
 
    # Considering the matrix also contains
    max_sum = -50000 
     
    # Negative values , so initialized with
    # -50000. It can be any value but very
    # smaller.
    # max_sum=0 -> Initialize with 0 only if your
    # matrix elements are positive
 
    if(R < 3 or C < 3):
        return -1
 
    # Here loop runs (R-2)*(C-2) times considering
    # different top left cells of hour glasses.
    for i in range(0, R-2):
        for j in range(0, C-2):
                     
            # Considering arr[i][j] as top
            # left cell of hour glass.
            SUM = (arr[i][j] + arr[i][j + 1] + arr[i][j + 2]) + (arr[i + 1][j + 1]) +       (arr[i + 2][j] +
                    arr[i + 2][j + 1] + arr[i + 2][j + 2])
 
            # If previous sum is less
            # then current sum then
            # update new sum in max_sum
            if(SUM > max_sum):
                max_sum = SUM
            else:
                continue
 
    return max_sum
 
 
# Driver Code
arr = [[1, 2, 3, 0, 0],
       [0, 0, 0, 0, 0],
       [2, 1, 4, 0, 0],
       [0, 0, 0, 0, 0],
       [1, 1, 0, 1, 0]]
res = MaxSum(arr)
 
if(res == -1):
    print(""Not possible"")
else:
    print(f""Maximum sum of hour glass = {res}"")
 
# This code is written by Akshay Prakash
<|endoftext|>"
1123,"<|endoftext|>Write a function that takes a number n and a string s as arguments and returns the nth term of the Red/Yellow sequence. s will ask the function what to return, all, red or yellow.
Examples
ry_seq(2, ""all"") ➞ 5

ry_seq(3, ""yellow"") ➞ 8

ry_seq(28, ""red"") ➞ 55

ry_seq(1, ""blue"") ➞ False
Notes
If s is not ""all"", ""yellow"" or ""red"", return False.
If n is 0, return 0.
n is always a positive integer.:def ry_seq(n, s=''):
    if n == 0:
        return 0
    return {'all': n**2 + (n-1)**2, 'red': n*2 - 1, 
            'yellow': (n**2 + (n-1)**2) - (n*2 - 1)}.get(s, False)<|endoftext|>"
1124,"<|endoftext|>Here, we will develop a Python program to string remove the first character. If the string was “Knowprogram” then the new string will be “nowprogram”. We will discuss how to remove the first character from the given string using native methods, slice operator, and Regular Expression.:# Python program to remove first character from string # take input string = input(""Enter any string: "") # remove first character from string out_string = """" for i in range(1, len(string)): out_string = out_string + string[i] # print string after removal print (""New string:"", out_string)<|endoftext|>"
1125,"<|endoftext|>We’ll look at how to determine the indices of non-zero entries in a Python list. There may be times when we simply need to access the list’s non-zero elements. In such instances, we can apply the following techniques.

Lists:

A list is an ordered grouping of values. It can hold a variety of values. A list is a container that may be changed. This means that we can add new values, delete old ones, or change current ones.

A Python list is a mathematical concept that describes a finite sequence. Items or elements in a list are the values in a list. A list can have multiple instances of the same value. Each occurrence is treated as a separate item.

Given a list, the task is to find the indices of non-zero elements in the given list.:# Give the list as static input and store it in a variable.
gvnlst = [11, 19, 0, 8, 45, 0, 29, 0, 19, 0, 26, 0, 33]
# Take an empty list and initialize it’s with an empty list using list() and [].
nwlist = []
# Calculate the length of the given list using the len() function.
gvnlstlen = len(gvnlst)
# Loop till the length of the given list using the For loop.
for m in range(gvnlstlen):
    # Check if the element in the given list is equal to 0 or not
    # using the If conditional statement.
    if(gvnlst[m] != 0):
        # If it is non-zero element then append the index to the new list
        # using the append() function.
        nwlist.append(m)
# Print the index list.
print('The non zero elements indices in the given list are = ', nwlist)<|endoftext|>"
1126,"<|endoftext|>Given an integer n, return true if it is possible to represent n as the sum of distinct powers of three. Otherwise, return false.
An integer y is a power of three if there exists an integer x such that y == 3x.
 
Example 1:

Input: n = 12
Output: true
Explanation: 12 = 31 + 32

Example 2:

Input: n = 91
Output: true
Explanation: 91 = 30 + 32 + 34

Example 3:

Input: n = 21
Output: false

 
Constraints:

1 <= n <= 107:powersOf3 = [3 ** i for i in reversed(range(15))]
  def checkPowersOfThree(self, n: int) -> bool:
  for p in self.powersOf3:
  if n >= 2 * p:
  return False
  elif n >= p:
  n -= p
  return True<|endoftext|>"
1127,"<|endoftext|>Given a two-dimensional list of maze and a list of directions. Your task is to follow the given directions.
If you can reach the endpoint before all your moves have gone, return ""Finish"".
If you hit any walls or go outside the maze border, return ""Dead"".
If you find yourself still in the maze after using all the moves, return ""Lost"".
The maze list will look like this:
maze = [
  [1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
  [1, 3, 1, 0, 1, 0, 0, 0, 0, 1],
  [1, 0, 1, 0, 0, 0, 1, 1, 0, 1],
  [1, 0, 1, 1, 1, 1, 1, 0, 0, 1],
  [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],
  [1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
  [1, 0, 1, 0, 1, 0, 0, 0, 0, 0],
  [1, 0, 1, 0, 1, 0, 1, 1, 0, 1],
  [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
  [1, 1, 1, 0, 1, 1, 1, 1, 2, 1]
]

# 0 = Safe place to walk
# 1 = Wall
# 2 = Start Point
# 3 = Finish Point
# N = North, E = East, W = West and S = South
See the below examples for a better understanding:
Examples
exit_maze(maze, [""N"", ""E"", ""E""]) ➞ ""Dead""
# Hitting the wall should return ""Dead"".

exit_maze(maze, [""N"", ""N"", ""N"", ""E""]) ➞ ""Lost""
# Couldn't reach the finish point.

exit_maze(maze, [""N"", ""W"", ""W"", ""W"", ""N"", ""N"", ""N"", ""N"", ""W"", ""W"", ""S"", ""S"", ""S"", ""S"", ""W"", ""W"", ""N"", ""N"", ""N"", ""N"", ""N"", ""N"", ""N""]) ➞ ""Finish""
Notes
N/A:def exit_maze(maze, directions):
  i = 9
  j = 8
  for direction in directions:
    if direction == ""N"":
      i -= 1
    elif direction == ""S"":
      i += 1
    elif direction == ""E"":
      j += 1
    else:
      j -= 1
    if i < 0 or i > 9 or j < 0 or j > 9:
      return ""Dead""
    elif maze[i][j] == 1:
      return ""Dead""
    elif maze[i][j] == 3:
      return ""Finish""
  return ""Lost""<|endoftext|>"
1128,"<|endoftext|>Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.

Since the result may be very large, so you need to return a string instead of an integer.

 

Example 1:

Input: nums = [10,2]
Output: ""210""
Example 2:

Input: nums = [3,30,34,5,9]
Output: ""9534330"":class LargerNumKey(str):
    def __lt__(x, y):
        return x+y > y+x
        
class Solution:
    def largestNumber(self, nums):
        largest_num = ''.join(sorted(map(str, nums), key=LargerNumKey))
        return '0' if largest_num[0] == '0' else largest_num<|endoftext|>"
1129,"<|endoftext|>In this exercise you will have to:
Take a list of names.
Add ""Hello"" to every name.
Make one big string with all greetings.
The solution should be one string with a comma in between every ""Hello (Name)"".
Examples
greet_people([""Joe""]) ➞ ""Hello Joe""

greet_people([""Angela"", ""Joe""]) ➞ ""Hello Angela, Hello Joe""

greet_people([""Frank"", ""Angela"", ""Joe""]) ➞ ""Hello Frank, Hello Angela, Hello Joe""
Notes
Each greeting has to be separated with a comma and a space.
If you're given an empty list [], return an empty string """".:def greet_people(names):
  return "", "".join([""Hello "" + n for n in names])<|endoftext|>"
1130,"<|endoftext|>Given Inorder Traversal of a Special Binary Tree in which key of every node is greater than keys in left and right children, construct the Binary Tree and return root.:# Python3 program to construct tree from
# inorder traversal

# Helper class that allocates a new node
# with the given data and None left and
# right pointers.
class newNode:
	def __init__(self, data):
		self.data = data
		self.left = None
		self.right = None

# Prototypes of a utility function to get
# the maximum value in inorder[start..end]

# Recursive function to construct binary of
# size len from Inorder traversal inorder[].
# Initial values of start and end should be
# 0 and len -1.
def buildTree (inorder, start, end):
	if start > end:
		return None

	# Find index of the maximum element
	# from Binary Tree
	i = Max (inorder, start, end)

	# Pick the maximum value and make it root
	root = newNode(inorder[i])

	# If this is the only element in
	# inorder[start..end], then return it
	if start == end:
		return root

	# Using index in Inorder traversal,
	# construct left and right subtress
	root.left = buildTree (inorder, start, i - 1)
	root.right = buildTree (inorder, i + 1, end)

	return root

# UTILITY FUNCTIONS

# Function to find index of the maximum
# value in arr[start...end]
def Max(arr, strt, end):
	i, Max = 0, arr[strt]
	maxind = strt
	for i in range(strt + 1, end + 1):
		if arr[i] > Max:
			Max = arr[i]
			maxind = i
	return maxind

# This function is here just to test buildTree()
def printInorder (node):
	if node == None:
		return

	# first recur on left child
	printInorder (node.left)

	# then print the data of node
	print(node.data, end = "" "")

	# now recur on right child
	printInorder (node.right)

# Driver Code
if __name__ == '__main__':
	
	# Assume that inorder traversal of
	# following tree is given
	#	 40
	# / \
	# 10	 30
	# /		 \
	#5		 28

	inorder = [5, 10, 40, 30, 28]
	Len = len(inorder)
	root = buildTree(inorder, 0, Len - 1)

	# Let us test the built tree by
	# printing Inorder traversal
	print(""Inorder traversal of the"",
			""constructed tree is "")
	printInorder(root)
	
# This code is contributed by PranchalK<|endoftext|>"
1131,"<|endoftext|>Python has a built-in function, calendar to work with date related tasks. You will learn to display the calendar of a given date in this example.  :# Program to display calendar of the given month and year

# importing calendar module
import calendar

yy = 2014  # year
mm = 11    # month

# To take month and year input from the user
# yy = int(input(""Enter year: ""))
# mm = int(input(""Enter month: ""))

# display the calendar
print(calendar.month(yy, mm))<|endoftext|>"
1132,"<|endoftext|>Create a function that will return an integer number corresponding to the amount of digits in the given integer num.
Examples
num_of_digits(1000) ➞ 4

num_of_digits(12) ➞ 2

num_of_digits(1305981031) ➞ 10

num_of_digits(0) ➞ 1
Notes
Try to solve this challenge without using strings!:def num_of_digits(n):
  return next(i for i in range(1, 100) if abs(n) < 10**i)<|endoftext|>"
1133,"<|endoftext|>In mathematics and digital electronics, a binary number is a number expressed in the base-2 numeral system or binary numeral system. Given a list of ones and zeroes of a binary number, return the equivalent decimal value.
Examples
binary_to_decimal([0, 0, 0, 1]) ➞ 1

binary_to_decimal([0, 0, 1, 0]) ➞ 2

binary_to_decimal([1, 1, 1, 1, 1, 0, 1, 1, 0, 1]) ➞ 1005
Notes
N/A:def binary_to_decimal(lst):
  return int(''.join(map(str,lst)),2)<|endoftext|>"
1134,"<|endoftext|>Given an array of integers, find length of the longest subarray which contains numbers that can be arranged in a continuous sequence. 
Examples: 

Input:  arr[] = {10, 12, 11};
Output: Length of the longest contiguous subarray is 3:# python program to find length of the largest
# subarray which has all contiguous elements */

# This function prints all distinct elements
def findLenght(arr, n):
        max_len = 1
        for i in range(0,n - 1):

                # Create an empty hash set and
                # add i'th element to it
                myset = set()
                myset.add(arr[i])

                # Initialize max and min in
                # current subarray
                mn = arr[i]
                mx = arr[i]
                for j in range(i + 1,n):

                        # If current element is already
                        # in hash set, then this subarray
                        # cannot contain contiguous elements
                        if arr[j] in myset:
                                break


                        # Else add current element to hash
                        # set and update min, max if required.
                        myset.add(arr[j])
                        mn = min(mn, arr[j])
                        mx = max(mx, arr[j])

                        # We have already checked for
                        # duplicates, now check for other
                        #property and update max_len
                        # if needed
                        if mx - mn == j - i:
                                max_len = max(max_len, mx - mn + 1)

        return max_len # Return result


# Driver code

arr = [10, 12, 12, 10, 10, 11, 10]
n = len(arr)
print(""Length of the longest contiguous subarray is"",
                                                                findLenght(arr,n))

# This code is contributed by Shrikant13
<|endoftext|>"
1135,"<|endoftext|>Tuple Length
To determine how many items a tuple has, use the len() method::thistuple = (""apple"", ""banana"", ""cherry"")
print(len(thistuple))<|endoftext|>"
1136,"<|endoftext|>We are given queue data structure, the task is to implement stack using only given queue data structure.

This solution assumes that we can find size of queue at any point. The idea is to keep newly inserted element always at front of queue, keeping order of previous elements same. Below are complete steps.


 :# Python3 program to implement stack using a
# single queue
  
q = []
 
# append operation
def append(val):
 
    # get previous size of queue
    size = len(q)
 
    # Add current element
    q.append(val);
 
    # Pop (or Dequeue) all previous
    # elements and put them after current
    # element
    for i in range(size):
 
        # this will add front element into
        # rear of queue
        x = q.pop(0);
        q.append(x);
            
# Removes the top element
def pop():
 
    if (len(q) == 0):
 
        print(""No elements"");
        return -1;
     
    x = q.pop(0);
    return x;
 
# Returns top of stack
def top():
 
    if(len(q) == 0):
        return -1;
    return q[-1]
 
# Returns true if Stack is empty else false
def isEmpty():
 
    return len(q)==0;
 
# Driver program to test above methods
if __name__=='__main__':
 
    s = []
 
    s.append(10);
    s.append(20);
    print(""Top element :"" + str(s[-1]));
    s.pop();
    s.append(30);
    s.pop();
    print(""Top element :"" + str(s[-1]));
     
    # This code is contributed by rutvik_56.
<|endoftext|>"
1137,"<|endoftext|>Instructions
Azara and Rui are teammates competing in a pirate-themed treasure hunt. One has a list of treasures with map coordinates, the other a list of location names with map coordinates. They've also been given blank maps with a starting place marked YOU ARE HERE.


Azara's List                Rui's List
Treasure        Coordinates
Amethyst Octopus        1F
Angry Monkey Figurine        5B
Antique Glass Fishnet Float        3D
Brass Spyglass        4B
Carved Wooden Elephant        8C
Crystal Crab        6A
Glass Starfish        6D
Model Ship in Large Bottle        8A
Pirate Flag        7F
Robot Parrot        1C
Scrimshaw Whale's Tooth        2A
Silver Seahorse        4E
Vintage Pirate Hat        7E                
Location Name        Coordinates        Quadrant
Seaside Cottages        (""1"", ""C"")        Blue
Aqua Lagoon (Island of Mystery)        (""1"", ""F"")        Yellow
Deserted Docks        (""2"", ""A"")        Blue
Spiky Rocks        (""3"", ""D"")        Yellow
Abandoned Lighthouse        (""4"", ""B"")        Blue
Hidden Spring (Island of Mystery)        (""4"", ""E"")        Yellow
Stormy Breakwater        (""5"", ""B"")        Purple
Old Schooner        (""6"", ""A"")        Purple
Tangled Seaweed Patch        (""6"", ""D"")        Orange
Quiet Inlet (Island of Mystery)        (""7"", ""E"")        Orange
Windswept Hilltop (Island of Mystery)        (""7"", ""F"")        Orange
Harbor Managers Office        (""8"", ""A"")        Purple
Foggy Seacave        (""8"", ""C"")        Purple

But things are a bit disorganized: Azara's coordinates appear to be formatted and sorted differently from Rui's, and they have to keep looking from one list to the other to figure out which treasures go with which locations. Being budding pythonistas, they have come to you for help in writing a small program (a set of functions, really) to better organize their hunt information.

1. Extract coordinates
Implement the get_coordinate() function that takes a (treasure, coordinate) pair from Azara's list and returns only the extracted map coordinate.

>>> get_coordinate((""Scrimshaw Whale's Tooth"", ""2A""))
""2A""
2. Format coordinates
Implement the convert_coordinate() function that takes a coordinate in the format ""2A"" and returns a tuple in the format (""2"", ""A"").

>>> convert_coordinate(""2A"")
(""2"", ""A"")
3. Match coordinates
Implement the compare_records() function that takes a (treasure, coordinate) pair and a (location, coordinate, quadrant) record and compares coordinates from each. Return True if the coordinates ""match"", and return False if they do not. Re-format coordinates as needed for accurate comparison.

>>> compare_records(('Brass Spyglass', '4B'), ('Seaside Cottages', ('1', 'C'), 'blue'))
False

>>> compare_records(('Model Ship in Large Bottle', '8A'), ('Harbor Managers Office', ('8', 'A'), 'purple'))
True
4. Combine matched records
Implement the create_record() function that takes a (treasure, coordinate) pair from Azara's list and a (location, coordinate, quadrant) record from Rui's list and returns (treasure, coordinate, location, coordinate, quadrant) if the coordinates match. If the coordinates do not match, return the string ""not a match"". Re-format the coordinate as needed for accurate comparison.

>>> create_record(('Brass Spyglass', '4B'), ('Abandoned Lighthouse', ('4', 'B'), 'Blue'))
('Brass Spyglass', '4B', 'Abandoned Lighthouse', ('4', 'B'), 'Blue')

>>> create_record(('Brass Spyglass', '4B'), (('1', 'C'), 'Seaside Cottages', 'blue'))
""not a match""
5. ""Clean up"" & make a report of all records
Clean up the combined records from Azara and Rui so that there's only one set of coordinates per record. Make a report so they can see one list of everything they need to put on their maps. Implement the clean_up() function that takes a tuple of tuples (everything from both lists), looping through the outer tuple, dropping the unwanted coordinates from each inner tuple and adding each to a 'report'. Format and return the 'report' so that there is one cleaned record on each line.

>>> clean_up((('Brass Spyglass', '4B', 'Abandoned Lighthouse', ('4', 'B'), 'Blue'), ('Vintage Pirate Hat', '7E', 'Quiet Inlet (Island of Mystery)', ('7', 'E'), 'Orange'), ('Crystal Crab', '6A', 'Old Schooner', ('6', 'A'), 'Purple')))

""""""
('Brass Spyglass', 'Abandoned Lighthouse', ('4', 'B'), 'Blue')\n
('Vintage Pirate Hat', 'Quiet Inlet (Island of Mystery)', ('7', 'E'), 'Orange')\n
('Crystal Crab', 'Old Schooner', ('6', 'A'), 'Purple')\n
"""""":def get_coordinate(record):
    """"""
 
    :param record: tuple - a (treasure, coordinate) pair.
    :return: str - the extracted map coordinate.
    """"""
    return record[1]
def convert_coordinate(coordinate):
    """"""
 
    :param coordinate: str - a string map coordinate
    :return:  tuple - the string coordinate seperated into its individual components.
    """"""
    return tuple(coordinate)
def compare_records(azara_record, rui_record):
    """"""
 
    :param azara_record: tuple - a (treasure, coordinate) pair.
    :param rui_record: tuple - a (location, coordinate, quadrant) trio.
    :return: bool - True if coordinates match, False otherwise.
    """"""
    return tuple(azara_record[1]) == rui_record[1]
def create_record(azara_record, rui_record):
    """"""
 
    :param azara_record: tuple - a (treasure, coordinate) pair.
    :param rui_record: tuple - a (location, coordinate, quadrant) trio.
    :return:  tuple - combined record, or ""not a match"" if the records are incompatible.
    """"""
    return azara_record + rui_record if compare_records(azara_record, rui_record) else 'not a match'
def clean_up(combined_record_group):
    """"""
 
    :param combined_record_group: tuple of tuples - everything from both participants.
    :return: string of tuples separated by newlines - everything ""cleaned"". Excess coordinates and information removed.
    """"""
    combined_records = tuple(tuple([i[0]])+i[2:] for i in combined_record_group)
    report = ""\n"".join(str(record) for record in combined_records) + ""\n""
    return report<|endoftext|>"
1138,"<|endoftext|>Heap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the minimum element and place the minimum element at the beginning. We repeat the same process for the remaining elements.

What is Binary Heap? 
Let us first define a Complete Binary Tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible (Source Wikipedia)
A Binary Heap is a Complete Binary Tree where items are stored in a special order such that the value in a parent node is greater(or smaller) than the values in its two children nodes. The former is called max heap and the latter is called min-heap. The heap can be represented by a binary tree or array.:# Python program for implementation of heap Sort

# To heapify subtree rooted at index i.
# n is size of heap


def heapify(arr, n, i):
	largest = i # Initialize largest as root
	l = 2 * i + 1	 # left = 2*i + 1
	r = 2 * i + 2	 # right = 2*i + 2

	# See if left child of root exists and is
	# greater than root
	if l < n and arr[largest] < arr[l]:
		largest = l

	# See if right child of root exists and is
	# greater than root
	if r < n and arr[largest] < arr[r]:
		largest = r

	# Change root, if needed
	if largest != i:
		arr[i], arr[largest] = arr[largest], arr[i] # swap

		# Heapify the root.
		heapify(arr, n, largest)

# The main function to sort an array of given size


def heapSort(arr):
	n = len(arr)

	# Build a maxheap.
	for i in range(n//2 - 1, -1, -1):
		heapify(arr, n, i)

	# One by one extract elements
	for i in range(n-1, 0, -1):
		arr[i], arr[0] = arr[0], arr[i] # swap
		heapify(arr, i, 0)


# Driver code
arr = [12, 11, 13, 5, 6, 7]
heapSort(arr)
n = len(arr)
print(""Sorted array is"")
for i in range(n):
	print(""%d"" % arr[i],end="" "")
# This code is contributed by Mohit Kumra<|endoftext|>"
1139,"<|endoftext|>Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
 

Example 1:

Input: s = ""()""
Output: true
Example 2:

Input: s = ""()[]{}""
Output: true
Example 3:

Input: s = ""(]""
Output: false
 

Constraints:

1 <= s.length <= 104
s consists of parentheses only '()[]{}'.:class Solution(object):
    def isValid(self, s):
        """"""
        :type s: str
        :rtype: bool
        """"""

        # The stack to keep track of opening brackets.
        stack = []

        # Hash map for keeping track of mappings. This keeps the code very clean.
        # Also makes adding more types of parenthesis easier
        mapping = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}

        # For every bracket in the expression.
        for char in s:

            # If the character is an closing bracket
            if char in mapping:

                # Pop the topmost element from the stack, if it is non empty
                # Otherwise assign a dummy value of '#' to the top_element variable
                top_element = stack.pop() if stack else '#'

                # The mapping for the opening bracket in our hash and the top
                # element of the stack don't match, return False
                if mapping[char] != top_element:
                    return False
            else:
                # We have an opening bracket, simply push it onto the stack.
                stack.append(char)

        # In the end, if the stack is empty, then we have a valid expression.
        # The stack won't be empty for cases like ((()
        return not stack<|endoftext|>"
1140,"<|endoftext|>Create a function that takes a list of factorial expressions and returns the sum.

Examples
eval_factorial([""2!"", ""3!""]) ➞ 8

eval_factorial([""5!"", ""4!"", ""2!""]) ➞ 146

eval_factorial([""0!"", ""1!""]) ➞ 2:def eval_factorial(lst):
	return sum(fac(int(k[:-1])) for k in lst)

def fac(n):
	return n*fac(n-1) if n else 1<|endoftext|>"
1141,"<|endoftext|>Create a function that takes a string (will be a person's first and last name) and returns a string with the first and last name swapped.
Examples
name_shuffle(""Donald Trump"") ➞ ""Trump Donald""

name_shuffle(""Rosie O'Donnell"") ➞ ""O'Donnell Rosie""

name_shuffle(""Seymour Butts"") ➞ ""Butts Seymour""
Notes
There will be exactly one space between the first and last name.
If you get stuck on a challenge, find help in the Resources tab.
If you're really stuck, unlock solutions in the Solutions tab.:def nameShuffle(str):
  return ' '.join(reversed(str.split(' ')))<|endoftext|>"
1142,"<|endoftext|>Files In Python:

A file is a piece of data or information stored on a computer’s hard drive. You’re already familiar with a variety of file kinds, including music, video, and text files. Manipulation of these files is trivial with Python. Text files and binary files are the two types of files that are commonly used. Binary files contain binary data that can only be read by a computer, whereas text files include plain text.

For programmers and automation testers, Python file handling (also known as File I/O) is a crucial topic. Working with files is required in order to write to or read data from them.



In addition, if you didn’t know, I/O activities are the most expensive techniques via which software might fail. As a result, when implementing file processing for reporting or any other reason, you should proceed with caution. The construction of a high-performance application or a robust solution for automated software testing can benefit from optimizing a single file activity.

File readable() Method in Python:

The readable() method is a built-in function that produces a result True if the file is readable, False otherwise.

Syntax:

file.readable()
Parameters: This method doesn’t accept any arguments.

Return Value:

This method’s return type is <class ‘bool’>; it returns True if the file stream is readable and False if the file stream is not readable.:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in write mode. In this case, we're writing the contents into the file.
gvn_file = open(givenFilename, 'w') 
# Apply readable() function to the given file to check if the file is readable or not
# and print the result.
print(""In write-mode:"", gvn_file.readable())
# Close the given file using the close() function
gvn_file.close()
# Open the file in read-only mode. In this case, we're simply reading the contents of the file.
gvn_file = open(givenFilename, 'r') 
# Apply readable() function to the given file to check if the file is readable or not
# and print the result.
print(""In read-mode:"", gvn_file.readable())
# Close the given file using the close() function
gvn_file.close()<|endoftext|>"
1143,"<|endoftext|>Given a Binary Tree, find vertical sum of the nodes that are in same vertical line. Print all sums through different vertical lines.

Examples: 

      1
    /   \
  2      3
 / \    / \
4   5  6   7
The tree has 5 vertical lines
Vertical-Line-1 has only one node 4 => vertical sum is 4 
Vertical-Line-2: has only one node 2=> vertical sum is 2 
Vertical-Line-3: has three nodes: 1,5,6 => vertical sum is 1+5+6 = 12 
Vertical-Line-4: has only one node 3 => vertical sum is 3 
Vertical-Line-5: has only one node 7 => vertical sum is 7
So expected output is 4, 2, 12, 3 and 7:# Python3 program of space optimized
# solution to find vertical sum of
# binary tree.

# Tree node structure
class TNode:
	
	def __init__(self, key):
		
		self.key = key
		self.left = None
		self.right = None

# Doubly linked list structure
class LLNode:
	
	def __init__(self, key):
		
		self.key = key
		self.prev = None
		self.next = None

# Function that creates Linked list and store
# vertical sum in it.
def verticalSumDLLUtil(root: TNode,
					sumNode: LLNode) -> None:

	# Update sum of current line by adding
	# value of current tree node.
	sumNode.key = sumNode.key + root.key

	# Recursive call to left subtree.
	if (root.left):
		if (sumNode.prev == None):
			sumNode.prev = LLNode(0)
			sumNode.prev.next = sumNode

		verticalSumDLLUtil(root.left,
						sumNode.prev)

	# Recursive call to right subtree.
	if (root.right):
		if (sumNode.next == None):
			sumNode.next = LLNode(0)
			sumNode.next.prev = sumNode

		verticalSumDLLUtil(root.right,
						sumNode.next)

# Function to print vertical sum of Tree.
# It uses verticalSumDLLUtil() to calculate sum.
def verticalSumDLL(root: TNode) -> None:

	# Create Linked list node for
	# line passing through root.
	sumNode = LLNode(0)

	# Compute vertical sum of different lines.
	verticalSumDLLUtil(root, sumNode)

	# Make doubly linked list pointer point
	# to first node in list.
	while (sumNode.prev != None):
		sumNode = sumNode.prev

	# Print vertical sum of different lines
	# of binary tree.
	while (sumNode != None):
		print(sumNode.key, end = "" "")
		sumNode = sumNode.next

# Driver code
if __name__ == ""__main__"":
	
	'''
				1
				/ \
			/ \
			2	 3
			/ \ / \
			/ \ / \
		4 5 6 7
	'''
	root = TNode(1)
	root.left = TNode(2)
	root.right = TNode(3)
	root.left.left = TNode(4)
	root.left.right = TNode(5)
	root.right.left = TNode(6)
	root.right.right = TNode(7)
	
	print(""Vertical Sums are"")
	
	verticalSumDLL(root)

# This code is contributed by sanjeev2552
<|endoftext|>"
1144,"<|endoftext|>Given an array, print all subarrays in the array which has sum 0.
Examples: 
 

Input:  arr = [6, 3, -1, -3, 4, -2, 2,
             4, 6, -12, -7]
Output:  
Subarray found from Index 2 to 4
Subarray found from Index 2 to 6          
Subarray found from Index 5 to 6
Subarray found from Index 6 to 9
Subarray found from Index 0 to 10:# Python3 program to print all subarrays
# in the array which has sum 0

# Function to get all subarrays
# in the array which has sum 0
def findSubArrays(arr,n):

        # create a python dict
        hashMap = {}
        
        # create a python list
        # equivalent to ArrayList
        out = []
        
        # tracker for sum of elements
        sum1 = 0
        for i in range(n):
                
                # increment sum by element of array
                sum1 += arr[i]
                
                # if sum is 0, we found a subarray starting
                # from index 0 and ending at index i
                if sum1 == 0:
                        out.append((0, i))
                al = []
                
                # If sum already exists in the map
                # there exists at-least one subarray
                # ending at index i with 0 sum
                if sum1 in hashMap:
                        
                        # map[sum] stores starting index
                        # of all subarrays
                        al = hashMap.get(sum1)
                        for it in range(len(al)):
                                out.append((al[it] + 1, i))
                al.append(i)
                hashMap[sum1] = al
        return out

# Utility function to print
# all subarrays with sum 0
def printOutput(output):
        for i in output:
                print (""Subarray found from Index "" +
                                str(i[0]) + "" to "" + str(i[1]))

# Driver Code
if __name__ == '__main__':
        arr = [6, 3, -1, -3, 4, -2,
                        2, 4, 6, -12, -7]
        n = len(arr)
        out = findSubArrays(arr, n)
        
        # if we did not find any subarray with 0 sum,
        # then subarray does not exists
        if (len(out) == 0):
                print (""No subarray exists"")
        else:
                printOutput (out)

# This code is contributed by Vikas Chitturi
<|endoftext|>"
1145,"<|endoftext|>This python program checks whether a given number by user is Automorphic (Cyclic) Number or not.
A number is called Automorphic or Cyclic number if and only if its square ends in the same digits as the number itself.

Automorphic or Cyclic Number Examples: 52 = 25, 62 = 36, 762 = 5776, 3762 = 141376

List of Automorphic Numbers: 0, 1, 5, 6, 25, 76, 376, 625, 9376, 90625, 109376, 890625, 2890625, 7109376, 12890625, 87109376:# Python program to check Automorphic or Cyclic Number

# Function to Check Automorphic
def is_automorphic(n):
    square = n * n

    while n:
        square_remainder = square%10
        number_remainder = n%10

        if square_remainder != number_remainder:
            return False

        n //= 10
        square //= 10

    return True


# Reading number
number = int(input('Enter number: '))

if is_automorphic(number):
    print('%d is AUTOMORPHIC' %(number))
else:
    print('%d is NOT AUTOMORPHIC' %(number))<|endoftext|>"
1146,"<|endoftext|>Create a function that takes in a two-dimensional list and returns the number of sub-lists with only identical elements.
Examples
count_identical([
  [1],
  [2],
  [3],
  [4]
]) ➞ 4

# Single-item lists still count as having identical elements.


count_identical([
  [1, 2],
  [2, 3],
  [3, 4],
  [4, 4]
]) ➞ 1


count_identical([
  [33, 33],
  [5],
  [""a"", ""a""],
  [2, 2, 2],
  [1, 2, 2],
  [3, 1]
]) ➞ 4

# 4 lists with identical elements: [33, 33], [5], [""a"", ""a""], and [2, 2, 2]


count_identical([
  [""@"", ""@"", ""@"", ""@""],
  [2, 3], [3, 4], [4, 4]
]) ➞ 2
Notes
Single-element lists count as (trivially) having identical elements.:def count_identical(lst):
  return len([c for c in lst if len(set(c))==1])<|endoftext|>"
1147,"<|endoftext|>Create a function that takes the memory size (MS is a string type) as an argument and returns the actual memory size.
Examples
actual_memory_size(32GB) ➞ 29.76GB

actual_memory_size(2GB) ➞ 1.86GB

actual_memory_size(512MB) ➞ 476MB
Notes
The actual storage loss on a USB device is 7% of the overall memory size!
If the actual memory size was greater than 1 GB, round your result to two decimal places.
If the memory size after adjustment is smaller then 1 GB, return the result in MB.
For the purposes of this challenge, there are 1000 MB in a Gigabyte.:def actual_memory_size(MS):
  if 'G' in MS and 'M' in MS:
    MS = MS.replace('G','000')
  size = int(MS[:-2])
  if MS[-2]=='M':
    return str(round(size*0.93))+MS[-2:]
  return str(round(size*0.93,2))+MS[-2:]<|endoftext|>"
1148,"<|endoftext|>Create a function that takes a list containing nested lists as an argument. Each sublist has 2 elements. The first element is the numerator and the second element is the denominator. Return the sum of the fractions rounded to the nearest whole number.:def sum_fractions(lst):
        return round(sum(n/d for n, d in lst))<|endoftext|>"
1149,"<|endoftext|>Exercise 4: Update the first set with items that don’t exist in the second set:set1 = {10, 20, 30}
set2 = {20, 40, 50}

set1.difference_update(set2)
print(set1)<|endoftext|>"
1150,"<|endoftext|>In this post, we will develop a Python program to convert the string to ASCII values. Based on this program we will also develop a program to find the sum of ASCII values of string in Python.:# Python program to find ASCII value of each character in string # take input string = input(""Enter any string: "") # printing ascii value of each character for i in range(len(string)): print(""The ASCII value of character %c = %d"" %(string[i], ord(string[i])))<|endoftext|>"
1151,"<|endoftext|>Write a function to count the number of nodes in a given singly linked list.:
# A complete working Python program to find length of a
# Linked List iteratively
 
# Node class
class Node:
    # Function to initialise the node object
    def __init__(self, data):
        self.data = data # Assign data
        self.next = None # Initialize next as null
 
 
# Linked List class contains a Node object
class LinkedList:
 
    # Function to initialize head
    def __init__(self):
        self.head = None
 
 
    # This function is in LinkedList class. It inserts
    # a new node at the beginning of Linked List.
    def push(self, new_data):
 
        # 1 & 2: Allocate the Node &
        #     Put in the data
        new_node = Node(new_data)
 
        # 3. Make next of new Node as head
        new_node.next = self.head
 
        # 4. Move the head to point to new Node
        self.head = new_node
 
 
    # This function counts number of nodes in Linked List
    # iteratively, given 'node' as starting node.
    def getCount(self):
        temp = self.head # Initialise temp
        count = 0 # Initialise count
 
        # Loop while end of linked list is not reached
        while (temp):
            count += 1
            temp = temp.next
        return count
 <|endoftext|>"
1152,"<|endoftext|>Create a function that takes a list of numbers and returns the number that's unique.
Examples
unique([3, 3, 3, 7, 3, 3]) ➞ 7

unique([0, 0, 0.77, 0, 0]) ➞ 0.77

unique([0, 1, 1, 1, 1, 1, 1, 1]) ➞ 0
Notes
Test cases will always have exactly one unique number while all others are the same.:def unique(lst):
  return min(set(lst), key=lst.count)<|endoftext|>"
1153,"<|endoftext|>Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).

A middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].

If middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.

Return the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.

 

:class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            if sum(nums[:i]) == sum(nums[i+1:]):
                return i
        return -1<|endoftext|>"
1154,"<|endoftext|>Enhancing programming skills is very important no matter what language you have chosen. So, practice frequently with these simple java programs examples and excel in coding the complex logic.
 
 The task is to discover the missing and recurring numbers in the given n-dimensional array or list. The array’s values are in the inclusive range from 1 to n.
 
 Examples:
 
 Example1:
 
 Input:
 
 Given list = [2, 6, 4, 5, 4, 3]
 Output:
 
 The element which is repeating in the given list [2, 6, 4, 5, 4, 3] is [ 4 ]
 The missing element in the given list [2, 6, 4, 5, 4, 3] is [ 1 ]
 Example2:
 
 Input:
 
 Given list =[7, 1, 3, 7, 2, 5, 8, 6]
 Output:
 
 The element which is repeating in the given list [7, 1, 3, 7, 2, 5, 8, 6] is [ 7 ]
 The missing element in the given list [7, 1, 3, 7, 2, 5, 8, 6] is [ 4 ]:# Import the Counter() function from collections using the import keyword.
 from collections import Counter
 # Give the list as static input and store it in a variable.
 gvnlst = [2, 6, 4, 5, 4, 3]
 # Calculate the frequency of all the given list
 # elements using the Counter() function which returns
 # the element and its frequency as key-value pair and
 # store this dictionary in a variable(say freqncyValues)
 freqncyValues = Counter(gvnlst)
 # Traverse in the freqncyValues using For loop.
 for key in freqncyValues:
  # Check if the value(frequency) is greater
  # than 1 or not using the If statement.
  if(freqncyValues[key] > 1):
  # If it is true then print it which is the
  # only repeating element in the given list.
  print('The element which is repeating in the given list',
  gvnlst, 'is [', key, ']')
 # Calculate the sum of all keys in freqncyValues 
 # using the sum() and keys() function and store it in a variable sumele.
 sumele = sum(freqncyValues.keys())
 # Calculate the total number of unique elements
 # in the given list by calculating the length of the freqncyValues say unqelemts.
 unqelemts = len(freqncyValues)
 # Increase the value of unqelemts by 1.
 unqelemts = unqelemts+1
 # Apply the sum of n elements formula using (n*(n+1))/2 where n is unqelemts.
 result = ((unqelemts*(unqelemts+1))//2)
 # Subtract the value of sumele from the above sum and store it in another variable.
 result = result-sumele
 # This is the missing element in the given list and prints it.
 print('The missing element in the given list', gvnlst, 'is [', result, ']')<|endoftext|>"
1155,"<|endoftext|>In this post, we will look at various Python techniques for converting seconds to hours and minutes.

Date and Time

Python, as a multipurpose language, can be used for a variety of reasons. Python includes a number of packages that help us with data manipulation tasks.

To achieve the same result in timestamp conversion, i.e. conversion of seconds to hours or minutes, numerous strategies might be considered.

Examples:

Input:

timeSeconds=30000
Output:

converting given time in seconds 30000 = 8 hrs 20 minutes:timeseconds = timeseconds % (24*3600)<|endoftext|>"
1156,"<|endoftext|>Given a matrix of n X n. The task is to calculate the absolute difference between the sums of its diagonal.: 


 :# Python3 program to find the difference
# between the sum of diagonal.
def difference(arr, n):
 
    # Initialize sums of diagonals
    d1 = 0
    d2 = 0
 
    for i in range(0, n):
     
        for j in range(0, n):
         
            # finding sum of primary diagonal
            if (i == j):
                d1 += arr[i][j]
 
            # finding sum of secondary diagonal
            if (i == n - j - 1):
                d2 += arr[i][j]
         
    # Absolute difference of the sums
    # across the diagonals
    return abs(d1 - d2);
 
# Driver Code
n = 3
 
arr = [[11, 2, 4],
       [4 , 5, 6],
       [10, 8, -12]]
 
print(difference(arr, n))
     
# This code is contributed
# by ihritik
<|endoftext|>"
1157,"<|endoftext|>The tricky thing here is that a leap year in the Gregorian calendar occurs:

on every year that is evenly divisible by 4
  except every year that is evenly divisible by 100
    unless the year is also evenly divisible by 400
For example, 1997 is not a leap year, but 1996 is. 1900 is not a leap year, but 2000 is.:def leap_year(year):
    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)<|endoftext|>"
1158,"<|endoftext|>Given a string and the task is to remove all the even occurring characters from the given string.

Examples:

Example1:

Input:

Given String = ""zzzkkooopppzytuh""
Output:

The given string { zzzkkooopppzytuh } after removing even frequency elements is : ooopppytuh:# Take a dictionary and initialize it to empty
# using the {} or dict() say freqncyDictionary.
freqncyDictionary = {}
# Give the string as static input and store it in a variable
gvnstrng = ""zzzkkooopppzytuh""
# Loop in the given string using the For loop.
for i in gvnstrng:
        # Inside the For loop,
    # Check if the string character is present in the dictionary
    # or not using the if conditional statement and 'in' keyword.
    if i in freqncyDictionary.keys():
                # If it is true then increment the count of the string character
        # in the dictionary by 1.
        freqncyDictionary[i] = freqncyDictionary[i]+1
    # Else initialize the dictionary with the string character as key and value as 1.
    else:
        freqncyDictionary[i] = 1
# Take a string which stores all the characters which are not occuring even number
# of times and initialize it to null string using """" or str()
modifd_string = """"
# loop in the given string using the for loop
for charac in gvnstrng:

        # check if the character has odd frequency by checking value of that character in frequency dictionary
        # we check using the if conditional statement
    if(freqncyDictionary[charac] % 2 != 0):
        # if it is true then concatenate this character to modifd_string using string concatenation
        modifd_string = modifd_string+charac


# print the modifd_string string
print('The given string {', gvnstrng,
      '} after removing even frequency elements is :', modifd_string)<|endoftext|>"
1159,"<|endoftext|>Your music player contains n different songs. You want to listen to goal songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:

Every song is played at least once.
A song can only be played again only if k other songs have been played.
Given n, goal, and k, return the number of possible playlists that you can create. Since the answer can be very large, return it modulo 109 + 7.:from functools import lru_cache

class Solution:
    def numMusicPlaylists(self, N, L, K):
        @lru_cache(None)
        def dp(i, j):
            if i == 0:
                return +(j == 0)
            ans = dp(i-1, j-1) * (N-j+1)
            ans += dp(i-1, j) * max(j-K, 0)
            return ans % (10**9+7)

        return dp(L, N)<|endoftext|>"
1160,"<|endoftext|>Suppose there is a circle. There are n petrol pumps on that circle. You are given two sets of data.
The amount of petrol that every petrol pump has.
Distance from that petrol pump to the next petrol pump.
Calculate the first point from where a truck will be able to complete the circle (The truck will stop at each petrol pump and it has infinite capacity). Expected time complexity is O(n). Assume for 1-litre petrol, the truck can go 1 unit of distance.
For example, let there be 4 petrol pumps with amount of petrol and distance to next petrol pump value pairs as {4, 6}, {6, 5}, {7, 3} and {4, 5}. The first point from where the truck can make a circular tour is 2nd petrol pump. Output should be “start = 1” (index of 2nd petrol pump).:# Python program to find circular tour for a truck
# In this approach we will start the tour from the first petrol pump
# then while moving to the next pumps in the loop we will store the cumulative
# information that whether we have a deficit of petrol at the current pump or not
# If there is a deficit then we will add it to the deficit value calculated
# till the previous petrol pump and then update the starting point to the next pump
# and reset the petrol available in the truck as 0
 
# This function return starting point if there is a possible
# solution otherwise returns -1
def printTour(arr,n):
     
    # Consider first petrol pump as starting point
    start = 0
    # These two variable will keep tracking if there is
    # surplus(s) or deficit(d) of petrol in the truck
    s = 0          # petrol available the truck till now
    d = 0        # deficit of petrol till visiting this petrol pump
     
    # Start from the first petrol pump and complete one loop
    # of visiting all the petrol pumps and keep updating s and d at each pump
    for i in range(n):
      s += arr[i][0] - arr[i][1]
      if s < 0:            # the truck has a deficit of petrol
        start = i+1        # change the starting point
        d += s            # storing the deficit of petrol till current petrol pump
        s = 0            # starting again from new station
     
    # when we reach first petrol pump again and sum of the petrol available at the truck
    # and the petrol deficit till now is 0 or more petrol then return the starting point
    # else return -1
    return start if (s+d)>=0 else -1
   
   
# Driver program to test above function
arr = [[6,4], [3,6], [7,3]]
start = printTour(arr,3)
if start == -1:
  print(""No Solution Possible !!!"")
else:
  print(""start = {}"".format(start))
 
# This code is contributed by Antara Das(anny)


<|endoftext|>"
1161,"<|endoftext|>In the previous article, we have discussed Python Program to Toggle Bits of a Number Except First and Last bits
 Given a number and the task is to print all the bitwise AND set of a given number.
 For some number I the bitwise AND set of a number N is all feasible numbers x smaller than or equal to N such that N & I equals x.
 Examples:
 Example1:
 Input:
 Given Number = 6
 Output:
 The all bitwise AND set of a given number{ 6 } : 
 
 0 2 4 6
 Explanation:
 Iterating from 0 to 6 so
 
 0 & 6 = 0
 
 1 & 6 = 0 
 
 2 & 6 = 2
 
 3 & 6 = 2
 
 4 & 6 = 4
 
 5 & 6 = 4
 
 6 & 6 = 6
 
 Hence the all bitwise AND set of a given number = 0 2 4 6 (removing duplicates)
 Example2:
 Input:
 Given Number = 3
 Output:
 The all bitwise AND set of a given number{ 3 } : 
 
 0 1 2 3:# Give the number as static input and store it in a variable.
 
 gvn_numb = 6
 
 # Loop till the given number using the for loop.
 
 print(""The all bitwise AND set of a given number{"", gvn_numb, ""} : "")
 
 for itr in range(gvn_numb + 1):
 
  # Apply AND operation for the given number and the iterator value and store it in
 
  # another variable.
 
  p = gvn_numb &amp; itr
 
  # Check if the above result is equal to the iterator value using the if conditional
 
  # statement.
 
  if (p == itr):
 
  # If the statement is true, then print the iterator value separated by spaces.
 
  print(itr, "" "", end="""")
 
 </pre><|endoftext|>"
1162,"<|endoftext|>You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.

Each train can only depart at an integer hour, so you may need to wait in between each train ride.

For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.
Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.

Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.
:class Solution:
    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:

        if len(dist) - 1 > hour:
            return -1
        def canFinis(dist, hour, speed):
            if speed == 0: return False
            ans = 0
            for i in dist[:-1]:
                cur = i / speed
                ans += int(cur)
                if int(cur) != cur:
                    ans += 1
                if ans > hour:
                    return False
            ans += dist[-1] / speed
            return ans<=hour
        inf = float(""inf"")
        left,right = 0, 10**7 + 2
        res = inf
        while left<right:
            mid = (left + right) // 2
            tmp = canFinis(dist, hour, mid)
            if tmp:
                right = mid
                res = min(res, mid)
            else:
                left  = mid + 1
        return res if res != inf else -1<|endoftext|>"
1163,"<|endoftext|>Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.
Return the number of good nodes in the binary tree.
 
Example 1:



Input: root = [3,1,4,3,null,1,5]

Output: 4

Explanation: Nodes in blue are good.

Root Node (3) is always a good node.

Node 4 -> (3,4) is the maximum value in the path starting from the root.

Node 5 -> (3,4,5) is the maximum value in the path

Node 3 -> (3,1,3) is the maximum value in the path.
Example 2:



Input: root = [3,3,null,4,2]

Output: 3

Explanation: Node 2 -> (3, 3, 2) is not good, because ""3"" is higher than it.
Example 3:


Input: root = [1]

Output: 1

Explanation: Root is considered as good.
 
Constraints:

The number of nodes in the binary tree is in the range [1, 10^5].
Each node's value is between [-10^4, 10^4].:def goodNodes(self, r, ma=-10000):
  return self.goodNodes(r.left, max(ma, r.val)) + self.goodNodes(r.right, max(ma, r.val)) + (r.val >= ma) if r else 0<|endoftext|>"
1164,"<|endoftext|>The function is given a list of numbers where each number appears three times except for one which appears only one time. Find the single number and return it.
Examples
single_number([2, 2, 3, 2]) ➞ 3

single_number([0, 1, 0, 1, 0, 1, 99]) ➞ 99

single_number([-1, 2, -4, 20, -1, 2, -4, -4, 2, -1]) ➞ 20
Notes
To run under 12 seconds the function needs to be efficient.:from collections import Counter
def single_number(nums):
    for k, v in Counter(nums).items():
        if v == 1:
            return k<|endoftext|>"
1165,"<|endoftext|>The below program adds two square matrices of size 4*4, we can change N for different dimensions. :# Python3 program for addition
# of two matrices
 
N = 4
  
# This function adds A[][]
# and B[][], and stores
# the result in C[][]
def add(A,B,C):
 
    for i in range(N):
        for j in range(N):
            C[i][j] = A[i][j] + B[i][j]
 
# driver code
A = [ [1, 1, 1, 1],
    [2, 2, 2, 2],
    [3, 3, 3, 3],
    [4, 4, 4, 4]]
  
B= [ [1, 1, 1, 1],
    [2, 2, 2, 2],
    [3, 3, 3, 3],
    [4, 4, 4, 4]]
  
C=A[:][:] # To store result
 
add(A, B, C)
  
print(""Result matrix is"")
for i in range(N):
    for j in range(N):
        print(C[i][j], "" "", end='')
    print()
     
# This code is contributed
# by Anant Agarwal.
<|endoftext|>"
1166,"<|endoftext|>We are given a matrix that contains different values in each cell. Our aim is to find the minimal set of positions in the matrix such that the entire matrix can be traversed starting from the positions in the set. 
We can traverse the matrix under the below conditions: 
We can move only to those neighbors that contain values less than or equal to the current cell’s value. A neighbor of the cell is defined as the cell that shares a side with the given cell.
Examples: 

Input : 1 2 3
        2 3 1
        1 1 1
Output : 1 1
         0 2
If we start from 1, 1 we can cover 6 
vertices in the order (1, 1) -> (1, 0) -> (2, 0) 
-> (2, 1) -> (2, 2) -> (1, 2). We cannot cover
the entire matrix with this vertex. Remaining 
vertices can be covered (0, 2) -> (0, 1) -> (0, 0). 

Input : 3 3
        1 1
Output : 0 1
If we start from 0, 1, we can traverse 
the entire matrix from this single vertex 
in this order (0, 0) -> (0, 1) -> (1, 1) -> (1, 0). 
Traversing the matrix in this order 
satisfies all the conditions stated above.
From the above examples, we can easily identify that in order to use a minimum number of positions, we have to start from the positions having the highest cell value. Therefore, we pick the positions that contain the highest value in the matrix. We take the vertices having the highest value in a separate array. We perform DFS at every vertex starting from the
highest value. If we encounter any unvisited vertex during dfs then we have to include this vertex in our set. When all the cells have been processed, then the set contains the required vertices.

How does this work? 
We need to visit all vertices and to reach the largest values we must start with them. If the two largest values are not adjacent, then both of them must be picked. If the two largest values are adjacent, then any of them can be picked as moving to equal value neighbors is allowed.:# Python3 program to find minimum initial
# vertices to reach whole matrix
MAX = 100
  
# (n, m) is current source cell from which
# we need to do DFS. N and M are total no.
# of rows and columns.
def dfs(n, m, visit, adj, N, M):
     
    # Marking the vertex as visited
    visit[n][m] = 1
  
    # If below neighbor is valid and has
    # value less than or equal to current
    # cell's value
    if (n + 1 < N and
        adj[n][m] >= adj[n + 1][m] and
        not visit[n + 1][m]):
        dfs(n + 1, m, visit, adj, N, M)
  
    # If right neighbor is valid and has
    # value less than or equal to current
    # cell's value
    if (m + 1 < M and
        adj[n][m] >= adj[n][m + 1] and
        not visit[n][m + 1]):
        dfs(n, m + 1, visit, adj, N, M)
  
    # If above neighbor is valid and has
    # value less than or equal to current
    # cell's value
    if (n - 1 >= 0 and
        adj[n][m] >= adj[n - 1][m] and
        not visit[n - 1][m]):
        dfs(n - 1, m, visit, adj, N, M)
  
    # If left neighbor is valid and has
    # value less than or equal to current
    # cell's value
    if (m - 1 >= 0 and
        adj[n][m] >= adj[n][m - 1] and
        not visit[n][m - 1]):
        dfs(n, m - 1, visit, adj, N, M)
 
def printMinSources(adj, N, M):
 
    # Storing the cell value and cell
    # indices in a vector.
    x = []
     
    for i in range(N):
        for j in range(M):
            x.append([adj[i][j], [i, j]])
  
    # Sorting the newly created array according
    # to cell values
    x.sort()
  
    # Create a visited array for DFS and
    # initialize it as false.
    visit = [[False for i in range(MAX)]
                    for i in range(N)]
     
    # Applying dfs for each vertex with
    # highest value
    for i in range(len(x) - 1, -1, -1):
         
        # If the given vertex is not visited
        # then include it in the set
        if (not visit[x[i][1][0]][x[i][1][1]]):
            print('{} {}'.format(x[i][1][0],
                                 x[i][1][1]))
             
            dfs(x[i][1][0],
                x[i][1][1],
                visit, adj, N, M)
         
# Driver code
if __name__=='__main__':
 
    N = 2
    M = 2
  
    adj = [ [ 3, 3 ], [ 1, 1 ] ]
     
    printMinSources(adj, N, M)
 
# This code is contributed by rutvik_56
<|endoftext|>"
1167,"<|endoftext|>Given an array arr[0..n-1]. The following operations need to be performed.:# Python3 program to demonstrate Range 
# Update and PoQueries Without using BIT 
  
# Updates such that getElement() gets an 
# increased value when queried from l to r. 
def update(arr, l, r, val):
    arr[l] += val
    if r + 1 < len(arr):
        arr[r + 1] -= val
  
# Get the element indexed at i 
def getElement(arr, i):
      
    # To get ith element sum of all the elements 
    # from 0 to i need to be computed 
    res = 0
    for j in range(i + 1):
        res += arr[j] 
  
    return res
  
# Driver Code
if __name__ == '__main__': 
    arr = [0, 0, 0, 0, 0] 
    n = len(arr) 
  
    l = 2
    r = 4
    val = 2
    update(arr, l, r, val) 
  
    # Find the element at Index 4 
    index = 4
    print(""Element at index"", index, 
          ""is"", getElement(arr, index)) 
  
    l = 0
    r = 3
    val = 4
    update(arr, l, r, val) 
  
    # Find the element at Index 3 
    index = 3
    print(""Element at index"", index,
          ""is"", getElement(arr, index))
  
# This code is contributed by PranchalK
<|endoftext|>"
1168,"<|endoftext|>In data mining and statistics, hierarchical clustering analysis is a method of cluster analysis that seeks to build a hierarchy of clusters i.e. tree-type structure based on the hierarchy. :from sklearn.cluster import AgglomerativeClustering
import numpy as np
 
# randomly chosen dataset
X = np.array([[1, 2], [1, 4], [1, 0],
              [4, 2], [4, 4], [4, 0]])
 
# here we need to mention the number of clusters
# otherwise the result will be a single cluster
# containing all the data
clustering = AgglomerativeClustering(n_clusters = 2).fit(X)
 
# print the class labels
print(clustering.labels_)<|endoftext|>"
1169,"<|endoftext|>You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.

A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei.

Return the number of weak characters.:class Solution:
    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:
        properties.sort(key=lambda p: p[0])

        n = len(properties)
        maxpos_x = defaultdict(lambda: -inf)
        maxval_y = [-inf] * n
        maxval_y[n-1] = properties[n-1][1]
        for i in reversed(range(n-1)):
            x, y = properties[i]
            maxpos_x[x] = max(i, maxpos_x[x])
            maxval_y[i] = max(y, maxval_y[i+1])
        x, _ = properties[-1]
        maxpos_x[x] = max(n-1, maxpos_x[x])

        ans = 0
        for i, (x, y) in enumerate(properties[:-1]):
            j = maxpos_x[x]
            if j+1 < n and y < maxval_y[j+1]:
                ans += 1
        return ans<|endoftext|>"
1170,"<|endoftext|>Given a MxN matrix where each element can either be 0 or 1. We need to find the shortest path between a given source cell to a destination cell. The path can only be created out of a cell if its value is 1.

Expected time complexity is O(MN).:# Python program to find the shortest
# path between a given source cell
# to a destination cell.
 
from collections import deque
ROW = 9
COL = 10
 
# To store matrix cell coordinates
class Point:
    def __init__(self,x: int, y: int):
        self.x = x
        self.y = y
 
# A data structure for queue used in BFS
class queueNode:
    def __init__(self,pt: Point, dist: int):
        self.pt = pt  # The coordinates of the cell
        self.dist = dist  # Cell's distance from the source
 
# Check whether given cell(row,col)
# is a valid cell or not
def isValid(row: int, col: int):
    return (row >= 0) and (row < ROW) and
                   (col >= 0) and (col < COL)
 
# These arrays are used to get row and column
# numbers of 4 neighbours of a given cell
rowNum = [-1, 0, 0, 1]
colNum = [0, -1, 1, 0]
 
# Function to find the shortest path between
# a given source cell to a destination cell.
def BFS(mat, src: Point, dest: Point):
     
    # check source and destination cell
    # of the matrix have value 1
    if mat[src.x][src.y]!=1 or mat[dest.x][dest.y]!=1:
        return -1
     
    visited = [[False for i in range(COL)]
                       for j in range(ROW)]
     
    # Mark the source cell as visited
    visited[src.x][src.y] = True
     
    # Create a queue for BFS
    q = deque()
     
    # Distance of source cell is 0
    s = queueNode(src,0)
    q.append(s) #  Enqueue source cell
     
    # Do a BFS starting from source cell
    while q:
 
        curr = q.popleft() # Dequeue the front cell
         
        # If we have reached the destination cell,
        # we are done
        pt = curr.pt
        if pt.x == dest.x and pt.y == dest.y:
            return curr.dist
         
        # Otherwise enqueue its adjacent cells
        for i in range(4):
            row = pt.x + rowNum[i]
            col = pt.y + colNum[i]
             
            # if adjacent cell is valid, has path 
            # and not visited yet, enqueue it.
            if (isValid(row,col) and
               mat[row][col] == 1 and
                not visited[row][col]):
                visited[row][col] = True
                Adjcell = queueNode(Point(row,col),
                                    curr.dist+1)
                q.append(Adjcell)
     
    # Return -1 if destination cannot be reached
    return -1
 
# Driver code
def main():
    mat = [[ 1, 0, 1, 1, 1, 1, 0, 1, 1, 1 ],
           [ 1, 0, 1, 0, 1, 1, 1, 0, 1, 1 ],
           [ 1, 1, 1, 0, 1, 1, 0, 1, 0, 1 ],
           [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ],
           [ 1, 1, 1, 0, 1, 1, 1, 0, 1, 0 ],
           [ 1, 0, 1, 1, 1, 1, 0, 1, 0, 0 ],
           [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 ],
           [ 1, 0, 1, 1, 1, 1, 0, 1, 1, 1 ],
           [ 1, 1, 0, 0, 0, 0, 1, 0, 0, 1 ]]
    source = Point(0,0)
    dest = Point(3,4)
     
    dist = BFS(mat,source,dest)
     
    if dist!=-1:
        print(""Shortest Path is"",dist)
    else:
        print(""Shortest Path doesn't exist"")
main()
 
# This code is contributed by stutipathak31jan
<|endoftext|>"
1171,"<|endoftext|>Create an Iterator
To create an object/class as an iterator you have to implement the methods __iter__() and __next__() to your object.

As you have learned in the Python Classes/Objects chapter, all classes have a function called __init__(), which allows you do some initializing when the object is being created.

The __iter__() method acts similar, you can do operations (initializing etc.), but must always return the iterator object itself.

The __next__() method also allows you to do operations, and must return the next item in the sequence.:class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    x = self.a
    self.a += 1
    return x

myclass = MyNumbers()
myiter = iter(myclass)

print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))<|endoftext|>"
1172,"<|endoftext|>Find the number of negative numbers in a column-wise / row-wise sorted matrix M[][]. Suppose M has n rows and m columns.:# Python implementation of Naive method to count of
# negative numbers in M[n][m]
 
def countNegative(M, n, m):
    count = 0
 
    # Follow the path shown using arrows above
    for i in range(n):
        for j in range(m):
 
            if M[i][j] < 0:
                count += 1
 
            else:
                # no more negative numbers in this row
                break
    return count
 
 
# Driver code
M = [
      [-3, -2, -1,  1],
      [-2,  2,  3,  4],
      [ 4,  5,  7,  8]
    ]
print(countNegative(M, 3, 4))
<|endoftext|>"
1173,"<|endoftext|>There is a hidden integer array arr that consists of n non-negative integers.
It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3].
You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0].
Return the original array arr. It can be proved that the answer exists and is unique.
 
Example 1:

Input: encoded = [1,2,3], first = 1
Output: [1,0,2,1]
Explanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]

Example 2:

Input: encoded = [6,2,7,3], first = 4
Output: [4,2,0,7,4]

 
Constraints:

2 <= n <= 104
encoded.length == n - 1
0 <= encoded[i] <= 105
0 <= first <= 105:def decode(self, A, first):
  res = [first]
  for a in A:
  res.append(res[-1] ^ a)
  return res<|endoftext|>"
1174,"<|endoftext|>In this challenge, you will learn about classes in Python.
Python classes are easy to understand. They are almost the same as JavaScript classes, with a different syntax and different constructor function names. Constructors define some variables in your class; in Python that is def __init__(self). Other functions are defined the same as normal.
I want you to create a class called programmer. It should have a salary value, work_hours value, and a __del__(self) function. __del__(self) should return ""oof, "" + str(salary) + "", "" + str(work_hours) when the object is destroyed. salary and work_hours will be in the constructor. Variables in a class are defined with self.name = value.
Also, define a function that will compare two programmers (their salary and work_hours) and return the programmer with the lower salary. If their salary is equal, then compare their work_hours, which will always be different.
This is not really a challenge, just an introduction to Python classes.
Examples
prog = programmer(25000, 5)

prog.salary ➞ 25000

prog.work_hours ➞ 5

del prog ➞ ""oof, 25000, 5""
# By the __del__ function.
Notes
Only base functions are pre-written in the code tab. You need to complete them and possibly add a few arguments.
Class variables are defined inside the __init__ function.
In most cases __del__ isn't used to return values (but it's not possible to check print output in an Edabit test).:class programmer:
  def __init__ (self,s,w):
    self.salary= s
    self.work_hours=w
  def __del__ (self):
    return ""oof, {}, {}"".format(self.salary, self.work_hours)
  def compare (self,other):
    return sorted([self,other], key=lambda x:x.salary)[0]<|endoftext|>"
1175,"<|endoftext|>Alice is a caretaker of n gardens and she wants to plant flowers to maximize the total beauty of all her gardens.

You are given a 0-indexed integer array flowers of size n, where flowers[i] is the number of flowers already planted in the ith garden. Flowers that are already planted cannot be removed. You are then given another integer newFlowers, which is the maximum number of flowers that Alice can additionally plant. You are also given the integers target, full, and partial.

A garden is considered complete if it has at least target flowers. The total beauty of the gardens is then determined as the sum of the following:

The number of complete gardens multiplied by full.
The minimum number of flowers in any of the incomplete gardens multiplied by partial. If there are no incomplete gardens, then this value will be 0.
Return the maximum total beauty that Alice can obtain after planting at most newFlowers flowers.:from bisect import bisect_right
class Solution:
    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
        flowers = [min(target, e) for e in flowers]
        flowers.sort()
        n = len(flowers)
        if min(flowers) == target: return n*full
        if newFlowers >= target*n - sum(flowers):
            return max(full*n, (n-1)*full + (target-1)*partial)
        cost = [0]*n
        for i in range(1,n):
            cost[i] = cost[i-1] + i*(flowers[i]-flowers[i-1])
        j = n - 1
        while flowers[j] == target:
            j -= 1
        res = 0
        l = j
        while newFlowers >= 0:
            while cost[l] > newFlowers:
                l -= 1
            idx = min(j, l)
            cur_min = flowers[idx] + (newFlowers-cost[idx])//(idx+1)
            res = max(res, cur_min*partial+full*(n-j-1))
            newFlowers -= (target-flowers[j])
            j -= 1
        return res<|endoftext|>"
1176,"<|endoftext|>Given a string of letters in the English alphabet, return the letter that's missing from the string. The missing letter will make the string be in alphabetical order (from A to Z).
If there are no missing letters in the string, return ""No Missing Letter"".
Examples
missing_letter(""abdefg"") ➞ ""c""

missing_letter(""mnopqs"") ➞ ""r""

missing_letter(""tuvxyz"") ➞ ""w""

missing_letter(""ghijklmno"") ➞ ""No Missing Letter""
Notes
The given string will never have more than one missing letter.:def missing_letter(txt):
  res = {chr(i) for i in range(ord(txt[0]),ord(txt[-1])+1)} - set(txt)
  return res.pop() if res else 'No Missing Letter'<|endoftext|>"
1177,"<|endoftext|>You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries.

Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.

Note that the batteries cannot be recharged.

Return the maximum number of minutes you can run all the n computers simultaneously.:def maxRunTime(self, n, A):
        A.sort()
        su = sum(A)
        while A[-1] > su / n:
            n -= 1
            su -= A.pop()
        return su / n<|endoftext|>"
1178,"<|endoftext|>This program generates 1-121-12321-1234321 numeric triangle (pyramid) pattern up to n number of lines in Python programming language.
In this program we first read number of rows from user and set outer loop i for number of lines. Generating 1-121-12321 pattern requires setup for space pattern, increasing number pattern & decreasing number pattern which are set by inner loop j.:# Pattern 1-121-12321 pyramid pattern

# Reading number of rows
row = int(input('Enter how many lines? '))

# Generating pattern
for i in range(1,row+1):
    
    # for space
    for j in range(1, row+1-i):
        print(' ', end='')
    
    # for increasing pattern
    for j in range(1,i+1):
        print(j, end='')
    
    # for decreasing pattern 
    for j in range(i-1,0,-1):
        print(j, end='')
    
    # Moving to next line
    print()<|endoftext|>"
1179,"<|endoftext|>Given a binary number and the task is to get the respective decimal number using the while loop.:# Give the binary number as user input using the int(input()) function and
# store it in a variable.
gvn_binry_num = int(input(""Enter some Random Number = ""))
# Take a variable say 'a 'and initialize its value with 0.
a = 0
# Take another variable say deciml_num and initialize its value with 0.
deciml_num = 0
print(
    ""The Decimal value of the given binary number {"", gvn_binry_num, ""} is: "")
# Loop till the given number is not equal to zero using the while loop.
while (gvn_binry_num != 0):
    # Inside the loop, calculate the value of the given binary number modulus 10
    # (to get the last digit) and store it in a variable say rem.
    rem = gvn_binry_num % 10
    # Calculate the value of the given binary number divided by 10.
# Store it in the same variable gvn_binry_num.
    gvn_binry_num = gvn_binry_num // 10
    # Multiply rem with the 2 power a using the pow() function and store it in
# another variable say  'b'.
    b = rem*pow(2, a)
    # Add b with the above deciml_num and store it in the same variable deciml_num.
    deciml_num = deciml_num + b
   # Increment the value a by 1 and store it in the same variable 'a'.
    a = a+1
# Print the deciml_num to get the decimal value of the given binary number.
print(deciml_num)<|endoftext|>"
1180,"<|endoftext|>Solve the zebra puzzle.

There are five houses.
The Englishman lives in the red house.
The Spaniard owns the dog.
Coffee is drunk in the green house.
The Ukrainian drinks tea.
The green house is immediately to the right of the ivory house.
The Old Gold smoker owns snails.
Kools are smoked in the yellow house.
Milk is drunk in the middle house.
The Norwegian lives in the first house.
The man who smokes Chesterfields lives in the house next to the man with the fox.
Kools are smoked in the house next to the house where the horse is kept.
The Lucky Strike smoker drinks orange juice.
The Japanese smokes Parliaments.
The Norwegian lives next to the blue house.
Each of the five houses is painted a different color, and their inhabitants are of different national extractions, own different pets, drink different beverages and smoke different brands of cigarettes.

Which of the residents drinks water? Who owns the zebra?:import itertools
ppl = 'Norwegian Englishman Ukrainian Spaniard Japanese'.split()
def drinks_water():
    x,_ = solve()
    return ppl[x]
def owns_zebra():
    _,x = solve()
    return ppl[x]
def solve():
    g = ((water, zebra)
        for (red, green, ivory, yellow, blue) in itertools.permutations(range(5))
        if green - ivory == 1
        for (norway, english, ukraine, spain, japan) in itertools.permutations(range(5))
        if norway == 0
        if english == red
        for (dog, fox, snails, horse, zebra) in itertools.permutations(range(5))
        if spain == dog
        for (coffee, tea, milk, orange, water) in itertools.permutations(range(5))
        if coffee == green
        if ukraine == tea
        if milk == 2
        for (oldgold, kools, chesterfields, luckystrike, parliaments) in itertools.permutations(range(5))
        if oldgold == snails
        if kools == yellow
        if abs(chesterfields - fox) == 1
        if abs(kools - horse) == 1
        if luckystrike == orange
        if parliaments == japan
        if abs(norway - blue) == 1
        )
    return next(g)<|endoftext|>"
1181,"<|endoftext|>Write a function that returns True if the binary string can be rearranged to form a string of alternating 0s and 1s.
Examples
can_alternate(""0001111"") ➞ True
# Can make: ""1010101""

can_alternate(""01001"") ➞ True
# Can make: ""01010""

can_alternate(""010001"") ➞ False

can_alternate(""1111"") ➞ False
Notes
No substring of the output may contain more than one consecutive repeating character (e.g. 00 or 11 are not allowed).
Return False if a string only contains 0s or only contains 1s.:def can_alternate(s):
    return abs(s.count('0') - s.count('1')) in (0, 1)<|endoftext|>"
1182,"<|endoftext|>The Fibonacci sequence is a classic use case for recursive functions since the value of the sequence at a given index is dependent on the last two values. More precisely, it's dependent on the sum of the previous two values.
Write a function named fib that takes an integer n as its input. It should return the Fibonacci sequence's value at index n.
Examples
fib(6) ➞ 8
# 0 + 1 = 1, 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8

fib(1) ➞ 1

fib(2) ➞ 1
Notes
You should throw a ValueError if n is less than 0.
Assume the Fibonacci sequence's first two values (at indices 0 and 1) are 0 and 1.
You must make fib a recursive function.
Tips
You can call a function within itself to get the value a different iteration returns. This is called a ""recursive function"".
If you're getting stuck, try looking up the math behind the Fibonacci sequence to see if that inspires you.
Check the Resources tab for relevant information!:def fib(n, a=0, b=1):
    if n < 0:
        raise ValueError
    return a if n == 0 else fib(n - 1, b, a + b)<|endoftext|>"
1183,"<|endoftext|>The try block lets you test a block of code for errors.

The except block lets you handle the error.

The finally block lets you execute code, regardless of the result of the try- and except blocks.:try:
  print(x)
except NameError:
  print(""Variable x is not defined"")
except:
  print(""Something else went wrong"")<|endoftext|>"
1184,"<|endoftext|>In mathematics, the Fibonacci numbers, commonly denoted Fn, form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1:
and
for n > 1
The beginning of the sequence is thus:
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...
The function fib_fast(num) returns the fibonacci number Fn, of the given num as an argument.
Examples
fib_fast(5) ➞ 5

fib_fast(10) ➞ 55

fib_fast(20) ➞ 6765

fib_fast(50) ➞ 12586269025
Notes
The input number is always positive.
Edabit would fail your code if it's not Fast enough.:def fibFast(num):
    a, b = 0, 1
    for _ in range(num - 1):
        a, b = b, a + b
    return b<|endoftext|>"
1185,"<|endoftext|>Write a function that creates a dictionary with each (key, value) pair being the (lower case, upper case) versions of a letter, respectively.
Examples
mapping([""p"", ""s""]) ➞ { ""p"": ""P"", ""s"": ""S"" }

mapping([""a"", ""b"", ""c""]) ➞ { ""a"": ""A"", ""b"": ""B"", ""c"": ""C"" }

mapping([""a"", ""v"", ""y"", ""z""]) ➞ { ""a"": ""A"", ""v"": ""V"", ""y"": ""Y"", ""z"": ""Z"" }
Notes
All of the letters in the input list will always be lowercase.:def mapping(letters):
  return {i:i.upper() for i in letters}<|endoftext|>"
1186,"<|endoftext|>Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.

 :def numOfPairs(self, nums: List[str], target: str) -> int:        
        d1, d2 = {}, {}
        counts = Counter()
        
        out = 0
        
        for n in nums:            
            if n in d1:
                out += counts[d1[n]]
            if n in d2:
                out += counts[d2[n]]
            
            counts[n] += 1
            
            l = len(n)
            
            if n == target[:l]:
                d2[target[l:]] = n
                
            if n == target[-l:]:
                d1[target[:-l]] = n
        
        return out<|endoftext|>"
1187,"<|endoftext|>Simple Linear Regression is a statistical method that allows us to summarize and study relationships between two continuous (quantitative) variables. One variable denoted x is regarded as an independent variable and other one denoted y is regarded as a dependent variable. It is assumed that the two variables are linearly related. Hence, we try to find a linear function that predicts the response value (y) as accurately as possible as a function of the feature or independent variable (x).

The simplest form of the regression equation with one dependent and one independent variable is defined by the formula:
:# Simple Linear Regression

# Importing the libraries
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the dataset
dataset = pd.read_csv('Salary_Data.csv')
X = dataset.iloc[:, :-1].values
y = dataset.iloc[:, 1].values

# Splitting the dataset into the Training set and Test set
from sklearn.cross_validation import train_test_split
X_train, X_test, y_train, y_test = train_test_split(
			X, y, test_size = 1/3, random_state = 0)

# Fitting Simple Linear Regression to the Training set
from sklearn.linear_model import LinearRegression
regressor = LinearRegression()
regressor.fit(X_train, y_train)

# Predicting the Test set results
y_pred = regressor.predict(X_test)

# Visualising the Training set results
plt.scatter(X_train, y_train, color = 'red')
plt.plot(X_train, regressor.predict(X_train), color = 'blue')
plt.title('Salary vs Experience (Training set)')
plt.xlabel('Years of Experience')
plt.ylabel('Salary')
plt.show()

# Visualising the Test set results
plt.scatter(X_test, y_test, color = 'red')
plt.plot(X_train, regressor.predict(X_train), color = 'blue')
plt.title('Salary vs Experience (Test set)')
plt.xlabel('Years of Experience')
plt.ylabel('Salary')
plt.show()<|endoftext|>"
1188,"<|endoftext|>Create a function that takes a list of numbers lst as an argument. Square each number in the list if the number is even and square root √ the number if it is odd. Return the sum of the new list rounded to two decimal places.
Example:
[2, 4, 9]  ➞ 23
2 ^ 2 + 4 ^ 2 + √9 = 4 + 16 + 3 = 23
Examples
list_sum([1, 3, 3, 1, 10]) ➞ 105.46

list_sum([2, 3, 4, 5]) ➞ 23.97

list_sum([1, 31, 3, 11, 0]) ➞ 11.62
Notes
No empty list in Tests.
Each list element ≥ 0.:def list_sum(lst):
  return round(sum(i ** .5 if i % 2 else i ** 2 for i in lst), 2)<|endoftext|>"
1189,"<|endoftext|>Although binary numbers are the most common way to store numbers, they can be challenging to use in many situations, necessitating the usage of a binary number variant. This is where Gray codes come in handy.

Gray code has the property that two consecutive numbers differ in just one bit. Because of this quality, grey code cycles through multiple states with low effort and is used in K-maps, error correction, communication, and so on.



Gray Code is a type of minimum-change coding in which the two subsequent values differ by only one bit. More specifically, it is a binary number system in which only a single bit varies while travelling from one step to the next.

We will learn how to convert gray to binary code in Python in this tutorial. A binary number is a number written in the base-2 numeral system. As a result, a binary number is made up of only 0s and 1s. So, today, we’ll learn how to represent binary and gray code numbers, how to convert a gray number to binary code, and how to use a Python program to convert a gray number to binary code.

Examples:

Example1:

Input:

given gray code =1001000010
Output:

The Binary string of the given gray code= 1001000010 is 1110000011
Example2:

Input:

given gray code =1000111100110
Output:

The Binary string of the given gray code= 1000111100110 is 1111010111011:# function which accepts the gray code and returns the binary code of the gray code
 def grayToBin(grayCde):
  # Converting the given gray code to integer
  graynum = int(grayCde, 2)
  # Taking a temporary variable which stores the the gray code integer number
  tempnum = graynum
  # using while loop
  while tempnum != 0:
  tempnum >>= 1
  graynum ^= tempnum
  # bin(n) returns n's binary representation with the prefix '0b' removed
  # the slice operation removes the prefix.
  return bin(graynum)[2:]
 # given gray code as static
 graycode = ""1001000010""
 # passing this graycode to grayToBin function
 resultbin = grayToBin(graycode)
 print('The Binary string of the given gray code=', graycode, 'is', resultbin)<|endoftext|>"
1190,"<|endoftext|>We have discussed Circular Linked List Introduction and Applications, in the previous post on Circular Linked List. In this post, traversal operation is discussed. :# Python program to demonstrate
# circular linked list traversal

# Structure for a Node
class Node:
	
	# Constructor to create a new node
	def __init__(self, data):
		self.data = data
		self.next = None

class CircularLinkedList:
	
	# Constructor to create a empty circular linked list
	def __init__(self):
		self.head = None

	# Function to insert a node at the beginning of a
	# circular linked list
	def push(self, data):
		ptr1 = Node(data)
		temp = self.head
		
		ptr1.next = self.head

		# If linked list is not None then set the next of
		# last node
		if self.head is not None:
			while(temp.next != self.head):
				temp = temp.next
			temp.next = ptr1

		else:
			ptr1.next = ptr1 # For the first node

		self.head = ptr1

	# Function to print nodes in a given circular linked list
	def printList(self):
		temp = self.head
		if self.head is not None:
			while(True):
				print (temp.data, end="" "")
				temp = temp.next
				if (temp == self.head):
					break


# Driver program to test above function

# Initialize list as empty
cllist = CircularLinkedList()

# Created linked list will be 11->2->56->12
cllist.push(12)
cllist.push(56)
cllist.push(2)
cllist.push(11)

print (""Contents of circular Linked List"")
cllist.printList()
		
# This code is contributed by
# Nikhil Kumar Singh(nickzuck_007)<|endoftext|>"
1191,"<|endoftext|>Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).

The algorithm for myAtoi(string s) is as follows:

Read in and ignore any leading whitespace.
Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.
Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.
Convert these digits into an integer (i.e. ""123"" -> 123, ""0032"" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).
If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.
Return the integer as the final result.
Note:

Only the space character ' ' is considered a whitespace character.
Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.
 

Example 1:

Input: s = ""42""
Output: 42
Explanation: The underlined characters are what is read in, the caret is the current reader position.
Step 1: ""42"" (no characters read because there is no leading whitespace)
         ^
Step 2: ""42"" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: ""42"" (""42"" is read in)
           ^
The parsed integer is 42.
Since 42 is in the range [-231, 231 - 1], the final result is 42.
Example 2:

Input: s = ""   -42""
Output: -42
Explanation:
Step 1: ""   -42"" (leading whitespace is read and ignored)
            ^
Step 2: ""   -42"" ('-' is read, so the result should be negative)
             ^
Step 3: ""   -42"" (""42"" is read in)
               ^
The parsed integer is -42.
Since -42 is in the range [-231, 231 - 1], the final result is -42.
Example 3:

Input: s = ""4193 with words""
Output: 4193
Explanation:
Step 1: ""4193 with words"" (no characters read because there is no leading whitespace)
         ^
Step 2: ""4193 with words"" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: ""4193 with words"" (""4193"" is read in; reading stops because the next character is a non-digit)
             ^
The parsed integer is 4193.
Since 4193 is in the range [-231, 231 - 1], the final result is 4193.
 

Constraints:

0 <= s.length <= 200
s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.:class StateMachine:
    def __init__(self):
        self.State = { ""q0"": 1, ""q1"": 2, ""q2"": 3, ""qd"": 4 }
        self.INT_MAX, self.INT_MIN = pow(2, 31) - 1, -pow(2, 31)
        
        # Store current state value.
        self.__current_state = self.State[""q0""]
        # Store result formed and its sign.
        self.__result = 0
        self.__sign = 1

    def to_state_q1(self, ch: chr) -> None:
        """"""Transition to state q1.""""""
        self.__sign = -1 if (ch == '-') else 1
        self.__current_state = self.State[""q1""]
    
    def to_state_q2(self, digit: int) -> None:
        """"""Transition to state q2.""""""
        self.__current_state = self.State[""q2""]
        self.append_digit(digit)
    
    def to_state_qd(self) -> None:
        """"""Transition to dead state qd.""""""
        self.__current_state = self.State[""qd""]
    
    def append_digit(self, digit: int) -> None:
        """"""Append digit to result, if out of range return clamped value.""""""
        if ((self.__result > self.INT_MAX // 10) or 
            (self.__result == self.INT_MAX // 10 and digit > self.INT_MAX % 10)):
            if self.__sign == 1:
                # If sign is 1, clamp result to INT_MAX.
                self.__result = self.INT_MAX
            else:
                # If sign is -1, clamp result to INT_MIN.
                self.__result = self.INT_MIN
                self.__sign = 1
            
            # When the 32-bit int range is exceeded, a dead state is reached.
            self.to_state_qd()
        else:
            # Append current digit to the result. 
            self.__result = (self.__result * 10) + digit

    def transition(self, ch: chr) -> None:
        """"""Change state based on current input character.""""""
        if self.__current_state == self.State[""q0""]:
            # Beginning state of the string (or some whitespaces are skipped).
            if ch == ' ':
                # Current character is a whitespaces.
                # We stay in same state. 
                return
            elif ch == '-' or ch == '+':
                # Current character is a sign.
                self.to_state_q1(ch)
            elif ch.isdigit():
                # Current character is a digit.
                self.to_state_q2(int(ch))
            else:
                # Current character is not a space/sign/digit.
                # Reached a dead state.
                self.to_state_qd()
        
        elif self.__current_state == self.State[""q1""] or self.__current_state == self.State[""q2""]:
            # Previous character was a sign or digit.
            if ch.isdigit():
                # Current character is a digit.
                self.to_state_q2(int(ch))
            else:
                # Current character is not a digit.
                # Reached a dead state.
                self.to_state_qd()
    
    def get_integer(self) -> None:
        """"""Return the final result formed with it's sign.""""""
        return self.__sign * self.__result
    
    def get_state(self) -> None:
        """"""Get current state.""""""
        return self.__current_state

class Solution:
    def myAtoi(self, input: str) -> int:
        q = StateMachine()
        
        for ch in input:
            q.transition(ch)
            if q.get_state() == q.State[""qd""]:
                break

        return q.get_integer()<|endoftext|>"
1192,"<|endoftext|>Given an unsorted array of numbers, write a function that returns true if the array consists of consecutive numbers. :# Helper functions to get minimum and
# maximum in an array

# The function checks if the array
# elements are consecutive. If elements
# are consecutive, then returns true,
# else returns false
def areConsecutive(arr, n):

        if ( n < 1 ):
                return False

        # 1) Get the minimum element in array
        min = getMin(arr, n)

        # 2) Get the maximum element in array
        max = getMax(arr, n)

        # 3) max - min + 1 is equal to n
        # then only check all elements
        if (max - min + 1 == n):

                for i in range(n):

                        if (arr[i] < 0):
                                j = -arr[i] - min
                        else:
                                j = arr[i] - min

                        # if the value at index j is negative
                        # then there is repetition
                        if (arr[j] > 0):
                                arr[j] = -arr[j]
                        else:
                                return False

                # If we do not see a negative value
                # then all elements are distinct
                return True

        return False         # if (max - min + 1 != n)

# UTILITY FUNCTIONS
def getMin(arr, n):
        
        min = arr[0]
        for i in range(1, n):
                if (arr[i] < min):
                        min = arr[i]
        return min

def getMax(arr, n):
        max = arr[0]
        for i in range(1, n):
                if (arr[i] > max):
                        max = arr[i]
        return max

# Driver Code
if __name__ == ""__main__"":
        
        arr = [1, 4, 5, 3, 2, 6]
        n = len(arr)
        if(areConsecutive(arr, n) == True):
                print("" Array elements are consecutive "")
        else:
                print("" Array elements are not consecutive "")

# This code is contributed by ita_c<|endoftext|>"
1193,"<|endoftext|>TensorFlow is a very popular open-source library for high performance numerical computation developed by the Google Brain team in Google. As the name suggests, Tensorflow is a framework that involves defining and running computations involving tensors. It can train and run deep neural networks that can be used to develop several AI applications. TensorFlow is widely used in the field of deep learning research and application. :#  Python program using TensorFlow
#  for multiplying two arrays
 
# import `tensorflow`
import tensorflow as tf
 
# Initialize two constants
x1 = tf.constant([1, 2, 3, 4])
x2 = tf.constant([5, 6, 7, 8])
 
# Multiply
result = tf.multiply(x1, x2)
 
# Initialize the Session
sess = tf.Session()
 
# Print the result
print(sess.run(result))
 
# Close the session
sess.close()<|endoftext|>"
1194,"<|endoftext|>A number num, that elevated to the power of another number k ""ends"" with the same num, it's automorphic.
5² = 25
# It's automorphic because ""25"" ends with ""5""

5³  = 125
# It's automorphic because ""125"" ends with ""5""

76⁴ = 33362176
# It's automorphic because ""33362176"" ends with ""76""
A number can have various powers that make it automorphic (i.e. look at number 5 in the above example). In this challenge, you have to verify if the given number is automorphic for each power from 2 up to 10.
Given a non-negative integer num, implement a function that returns the string:
""Polymorphic"" if num is automorphic for every power from 2 up to 10.
""Quadrimorphic"" if num is automorphic for only four powers (any from 2 up to 10).
""Dimorphic"" if num is automorphic for only two powers (any from 2 up to 10).
""Enamorphic"" if num is automorphic for only one power (any from 2 up to 10).
""Amorphic"" if num is not automorphic for for any powers from 2 up to 10.
Examples
power_morphic(5) ➞ ""Polymorphic""
# From 2 up to 10, every power of 5 ends with 5

power_morphic(21) ➞ ""Enamorphic""
# 21⁶ = 85766121

power_morphic(7) ➞ ""Dimorphic""
# 7⁵ = 716807
# 7⁹ = 40353607

power_morphic(4) ➞ ""Quadrimorphic""
# 4³ = 64
# 4⁵ = 1024
# 4⁷ = 16384
# 4⁹ = 262144

power_morphic(10) ➞ ""Amorphic""
# There are no powers that make it automorphic
Notes
You can do a complete loop cycle to check if num is automorphic for each power, or you can try to spot the discriminants that permit you to shorten the logic of your code.
Despite being inspired by the OEIS sequence A003226, the assertions of this challenge are to be considered properly valid only in the specific context.:def power_morphic(num):
  morphic = {9:""Polymorphic"", 4:""Quadrimorphic"", 2:""Dimorphic"", 1:""Enamorphic""}
  n = sum(str(num**i).endswith(str(num)) for i in range(2,11))
  return morphic.get(n, ""Amorphic"")<|endoftext|>"
1195,"<|endoftext|>This Python program calculates surface area of cone given radius and height.
Surface area of cone calculated by using following formula:

A = πr ( r + √(r2 + h2) ):# Objective: Python program to calculate surface area of cone
# Author: Codesansar

# importing math to use sqrt() function
import math

# Reading radius
radius = float(input(""Enter radius of cone: ""))

# Reading height
height = float(input(""Enter height of cone: ""))

# Calculating surface area of cone
area = 3.141592 * radius * (radius + math.sqrt(radius*radius + height*height))

# Displaying area
print(""Surface area = "", area)<|endoftext|>"
1196,"<|endoftext|>Given a ternary tree, create a doubly linked list out of it. A ternary tree is just like binary tree but instead of having two nodes, it has three nodes i.e. left, middle, right.

The doubly linked list should holds following properties –  

Left pointer of ternary tree should act as prev pointer of doubly linked list.
Middle pointer of ternary tree should not point to anything.
Right pointer of ternary tree should act as next pointer of doubly linked list.
Each node of ternary tree is inserted into doubly linked list before its subtrees and for any node, its left child will be inserted first, followed by mid and right child (if any).
For the above example, the linked list formed for below tree should be NULL <- 30 <-> 5 <-> 1 <-> 4 <-> 8 <-> 11 <-> 6 <-> 7 <-> 15 <-> 63 <-> 31 <-> 55 <-> 65 -> NULL :# Python3 program to create a doubly linked
# list out of given a ternary tree.

# Custom node class.
class newNode:
	
	def __init__(self, data):
		
		self.data = data
		self.left = None
		self.right = None
		self.middle = None

class GFG:
	
	def __init__(self):
		
		# Tail of the linked list.
		self.tail = None

	# Function to push the node to the tail.
	def push(self, node):

		# To put the node at the end of
		# the already existing tail.
		self.tail.right = node

		# To point to the previous node.
		node.left = self.tail

		# Middle pointer should point to
		# nothing so null. initiate right
		# pointer to null.
		node.middle = node.right = None

		# Update the tail position.
		self.tail = node

	# Create a doubly linked list out of given
	# a ternary tree By traversing the tree in
	# preorder fashion.
	def ternaryTree(self, node, head):
		
		if node == None:
			return

		left = node.left
		middle = node.middle
		right = node.right
		
		if self.tail != node:
			
			# Already root is in the tail so dont push
			# the node when it was root.In the first
			# case both node and tail have root in them.
			self.push(node)

		# First the left child is to be taken.
		# Then middle and then right child.
		self.ternaryTree(left, head)
		self.ternaryTree(middle, head)
		self.ternaryTree(right, head)

	def startTree(self, root):
		
		# Initiate the head and tail with root.
		head = root
		self.tail = root
		self.ternaryTree(root, head)

		# Since the head,root are passed
		# with reference the changes in
		# root will be reflected in head.
		return head

	# Utility function for printing double linked list.
	def printList(self, head):
		
		print(""Created Double Linked list is:"")
		
		while head:
			print(head.data, end = "" "")
			head = head.right

# Driver code
if __name__ == '__main__':
	
	# Constructing ternary tree as shown
	# in above figure
	root = newNode(30)
	root.left = newNode(5)
	root.middle = newNode(11)
	root.right = newNode(63)
	root.left.left = newNode(1)
	root.left.middle = newNode(4)
	root.left.right = newNode(8)
	root.middle.left = newNode(6)
	root.middle.middle = newNode(7)
	root.middle.right = newNode(15)
	root.right.left = newNode(31)
	root.right.middle = newNode(55)
	root.right.right = newNode(65)

	# The function which initiates the list
	# process returns the head.
	head = None
	gfg = GFG()
	head = gfg.startTree(root)
	
	gfg.printList(head)

# This code is contributed by Winston Sebastian Pais<|endoftext|>"
1197,"<|endoftext|>Dictionaries in Python:

Dictionary is a mutable built-in Python Data Structure. It is conceptually related to List, Set, and Tuples. It is, however, indexed by keys rather than a sequence of numbers and can be thought of as associative arrays. On a high level, it consists of a key and its associated value. The Dictionary class in Python represents a hash-table implementation.

Given a string , the task is to create a Python program for creating a dictionary with the Key as the first character and the Value as words beginning with that character.

Examples:

Example1:

Input:

given string = ""hello this is btechgeeks online programming platform to read the coding articles specially python language""
Output:

h ::: ['hello']
t ::: ['this', 'to', 'the']
i ::: ['is']
b ::: ['btechgeeks']
o ::: ['online']
p ::: ['programming', 'platform', 'python']
r ::: ['read']
c ::: ['coding']
a ::: ['articles']
s ::: ['specially']
l ::: ['language']
Example2:

Input:

given string = ""this is btechgeeks today is monday and tomorrow is sunday sun sets in the east ""
Output:

t ::: ['this', 'today', 'tomorrow', 'the']
i ::: ['is', 'in']
b ::: ['btechgeeks']
m ::: ['monday']
a ::: ['and']
s ::: ['sunday', 'sun', 'sets']
e ::: ['east']:# given string
given_string = ""hello this is btechgeeks online programming platform to read the coding articles specially python language""
# Split the given string into words using split() function
# Convert this into list using list() function.
listString = given_string.split()
# Declare a dictionary which is empty using {} or dict()
resultdict = {}
# Traverse the list String
for stringword in listString:
  # checking if the first character of the word exists in dictionary resultdict keys or not
  if(stringword[0] not in resultdict.keys()):
  resultdict[stringword[0]] = []
  # adding this character to the resultdict
  resultdict[stringword[0]].append(stringword)
  else:
  # If it is present, add the word to the associated sublist as the value.
  if(stringword not in resultdict[stringword[0]]):
  resultdict[stringword[0]].append(stringword)
for key, value in resultdict.items():
  print(key, "":::"", value)<|endoftext|>"
1198,"<|endoftext|>Access the Elements of an Array
You refer to an array element by referring to the index number.:x = cars[0]<|endoftext|>"
1199,"<|endoftext|>Fibonacci numbers are defined by the sequence f(0) = 0, f(1) = 1 and f(n) = f(n – 1) + f(n – 2) for n >= 2. The program prompts the user to enter n and it prints the nth Fibonacci number.:def fibonacci(n):
    """"""Return the nth Fibonacci number.""""""
    if n == 0:
        return 0
 
    # r[i] will contain the ith Fibonacci number
    r = [-1]*(n + 1)
    r[0] = 0
    r[1] = 1
 
    for i in range(2, n + 1):
        r[i] = r[i - 1] + r[i - 2]
 
    return r[n]
 
 
n = int(input('Enter n: '))
 
ans = fibonacci(n)
print('The nth Fibonacci number:', ans)<|endoftext|>"
1200,"<|endoftext|>User Input: Shuffle Elements of a Tuple:# Import the random module using import method.
import random
# Give the tuple as user input using tuple(),map(),input(),and split() functions
#and Store it in a variable.
gvn_tup = tuple(map(int, input(
   'Enter some random tuple Elements separated by spaces = ').split()))
# Convert the given tuple into list using the list() function and
# store it in another variable.
lst = list(gvn_tup)
# Apply random.shuffle() method on the above obtained list .
random.shuffle(lst)
# Convert the above shuffled list into tuple again using the tuple() function
# and store it in another variable.
shuffld_tupl = tuple(lst)
# Print the above given tuple after shuffling the elements of a given tuple.
print(""The given tuple after Shuffling the elements = "", shuffld_tupl)<|endoftext|>"
1201,"<|endoftext|>In the previous article, we have discussed Python Program to Count Divisors of Factorial
 Given two lists, the task is to find the product of maximum in the given first list and minimum in the given second list.
 Examples:
 Example 1:
 Input:
 Given the First List = [1, 2, 3, 4, 5]
 
 Given the Second List = [2, 6, 7, 8, 9, 1]
 Output:
 The maximum element in given first list [1, 2, 3, 4, 5] = 5
 
 The minimum element in given second list [2, 6, 7, 8, 9, 1] = 1
 
 The product of max_in_fstlst and min_in_seclst [ 5 * 1 ] = 5
 Example 2:
 Input:
 Given the First List = [10, 20, 30, 40, 50] 
 
 Given the Second List = [1, 2, 3, 4, 5]
 Output:
 The maximum element in given first list [10, 20, 30, 40, 50] = 50
 
 The minimum element in given second list [1, 2, 3, 4, 5] = 1
 
 The product of max_in_fstlst and min_in_seclst [ 50 * 1 ] = 50:# Give the first list as static input and store it in a variable.
 fst_lst = [1, 2, 3, 4, 5]
 # Give the second list as static input and store it in another variable.
 secnd_lst = [2, 6, 7, 8, 9, 1]
 # Find out the maximum element in the given first list using the built-in max() method
 # and store it in another variable.
 max_in_fstlst = max(fst_lst)
 # Find out the minimum element in the given second list using the built-in min() method
 # and store it in another variable.
 min_in_seclst = min(secnd_lst)
 # Multiply both the above obtained maximum element in the first list and minimum element
 # in the given second list and store it in another variable.
 prodct = max_in_fstlst*min_in_seclst
 # Print the maximum element in the given first .
 print(""The maximum element in given first list"", fst_lst, ""="", max_in_fstlst)
 # Print the minimum element in the given second list.
 print(""The minimum element in given second list"", secnd_lst, ""="", min_in_seclst)
 # Print the Product of maximum element in the given first and minimum element in
 # the given second list.
 print(""The product of max_in_fstlst and min_in_seclst ["",
  max_in_fstlst, ""*"", min_in_seclst, ""] ="", prodct)<|endoftext|>"
1202,"<|endoftext|>Given an array of n numbers and a number of queries are also given. Each query will be represented by two integers l, r. The task is to find out the GCD of all the numbers of the array excluding the numbers given in the range l, r (both inclusive) for each query.
Examples: 
 

Input : arr[] = {2, 6, 9}
        Ranges [0 0], [1 1], [1 2]
Output : 3
         1
         2 
GCD of numbers excluding [0 0] or 
first element is GCD(6, 9) = 3
GCD of numbers excluding the [1 1] or
second element is GCD(2, 9) = 1
GCD of numbers excluding [1 2] is 
equal to first element = 2:# Python program for
# queries of GCD excluding
# given range of elements.

# Calculating GCD
# using euclid algorithm
def GCD(a,b):
	if (b==0):
		return a
	return GCD (b, a%b)


# Filling the prefix
# and suffix array
def FillPrefixSuffix(prefix,arr,suffix,n):

	# Filling the prefix array
	# following relation
	# prefix(i) = GCD(prefix(i-1), arr(i))
	prefix[0] = arr[0]
	for i in range(1,n):
		prefix[i] = GCD (prefix[i-1], arr[i])

	# Filling the suffix
	# array following the
	# relation suffix(i) = GCD(suffix(i+1), arr(i))
	suffix[n-1] = arr[n-1]

	for i in range(n-2,-1,-1):
		suffix[i] = GCD (suffix[i+1], arr[i])


# To calculate gcd of
# the numbers outside range
def GCDoutsideRange(l,r,prefix,suffix,n):
	
	# If l=0, we need to tell GCD of numbers
	# from r+1 to n
	if (l==0):
		return suffix[r+1]

	# If r=n-1 we need to return the gcd of
	# numbers from 1 to l
	if (r==n-1):
		return prefix[l-1]
	return GCD(prefix[l-1], suffix[r+1])

# Driver code

arr = [2, 6, 9]
n = len(arr)
prefix=[]
suffix=[]
for i in range(n+1):
	prefix.append(0)
	suffix.append(0)
	
FillPrefixSuffix(prefix, arr, suffix, n)
l = 0
r = 0
print(GCDoutsideRange(l, r, prefix, suffix, n))

l = 1
r = 1
print(GCDoutsideRange(l, r, prefix, suffix, n))

l = 1
r = 2
print(GCDoutsideRange(l, r, prefix, suffix, n))

# This code is contributed
# by Anant Agarwal.<|endoftext|>"
1203,"<|endoftext|>Instructions
Given a diagram, determine which plants each child in the kindergarten class is responsible for.

The kindergarten class is learning about growing plants. The teacher thought it would be a good idea to give them actual seeds, plant them in actual dirt, and grow actual plants.

They've chosen to grow grass, clover, radishes, and violets.

To this end, the children have put little cups along the window sills, and planted one type of plant in each cup, choosing randomly from the available types of seeds.

[window][window][window]
........................ # each dot represents a cup
........................
There are 12 children in the class:

Alice, Bob, Charlie, David,
Eve, Fred, Ginny, Harriet,
Ileana, Joseph, Kincaid, and Larry.
Each child gets 4 cups, two on each row. Their teacher assigns cups to the children alphabetically by their names.

The following diagram represents Alice's plants:

[window][window][window]
VR......................
RG......................
In the first row, nearest the windows, she has a violet and a radish. In the second row she has a radish and some grass.

Your program will be given the plants from left-to-right starting with the row nearest the windows. From this, it should be able to determine which plants belong to each student.

For example, if it's told that the garden looks like so:

[window][window][window]
VRCGVVRVCGGCCGVRGCVCGCGV
VRCCCGCRRGVCGCRVVCVGCGCV
Then if asked for Alice's plants, it should provide:

Violets, radishes, violets, radishes
While asking for Bob's plants would yield:

Clover, grass, clover, clover
Python Implementation
The tests for this exercise expect your program to be implemented as a Garden class in Python. If you are unfamiliar with classes in Python, classes from the Python docs is a good place to start.

Your class should implement a method called plants, which takes a student's name as an argument and returns the list of plant names belonging to that student.

Constructors
Creating the example garden

[window][window][window]
VRCGVVRVCGGCCGVRGCVCGCGV
VRCCCGCRRGVCGCRVVCVGCGCV
would, in the tests, be represented as Garden(""VRCGVVRVCGGCCGVRGCVCGCGV\nVRCCCGCRRGVCGCRVVCVGCGCV"").

To make this representation work, your class will need to implement an __init__() method. If you're not familiar with __init__() or constructors, class and instance objects from the Python docs gives a more detailed explanation.

Default Parameters
In some tests, a list of students is passed as an argument to __init__(). This should override the twelve student roster provided in the problem statement. Both of these statements need to work with your __init__() method:

# Make a garden based on the default 12-student roster.
Garden(""VRCGVVRVCGGCCGVRGCVCGCGV\nVRCCCGCRRGVCGCRVVCVGCGCV"") 

# Make a garden based on a 2-student roster.
Garden(""VRCC\nVCGG"", students=[""Valorie"", ""Raven""]) 
One approach is to make the student list a default argument; the Python docs describe default parameters in depth while explaining function definitions.
:DEFAULT_STUDENTS = (
    'Alice', 'Bob', 'Charlie', 'David', 'Eve', 'Fred',
    'Ginny', 'Harriet', 'Ileana', 'Joseph', 'Kincaid', 'Larry',
)
PLANTS = {
    'C': 'Clover',
    'G': 'Grass',
    'R': 'Radishes',
    'V': 'Violets',
}
class Garden(object):
    def __init__(self, diagram, students=DEFAULT_STUDENTS):
        self.lines = diagram.splitlines()
        self.students = sorted(students)
    def plants(self, student):
        index = self.students.index(student)*2
        return [PLANTS[p[i]] for p in self.lines for i in (index, index + 1)]<|endoftext|>"
1204,"<|endoftext|>Create Object
Now we can use the class named myClass to create objects::p1 = MyClass()
print(p1.x)<|endoftext|>"
1205,"<|endoftext|>Create a function that determines if there is an upward trend.
Examples
upward_trend([1, 2, 3, 4]) ➞ True

upward_trend([1, 2, 6, 5, 7, 8]) ➞ False

upward_trend([1, 2, 3, ""4""]) ➞ ""Strings not permitted!""

upward_trend([1, 2, 3, 6, 7]) ➞ True
Notes
If there is a string element in the list, return ""Strings not permitted!"".
The numbers don't have to be consecutive (e.g. [1, 3, 5] should still return True).:def upward_trend(lst):
  try:
    return sorted(lst) == lst
  except:
    return ""Strings not permitted!""<|endoftext|>"
1206,"<|endoftext|>You are given a character array keys containing unique characters and a string array values containing strings of length 2. You are also given another string array dictionary that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a 0-indexed string.

A string is encrypted with the following process:

For each character c in the string, we find the index i satisfying keys[i] == c in keys.
Replace c with values[i] in the string.
Note that in case a character of the string is not present in keys, the encryption process cannot be carried out, and an empty string """" is returned.

A string is decrypted with the following process:

For each substring s of length 2 occurring at an even index in the string, we find an i such that values[i] == s. If there are multiple valid i, we choose any one of them. This means a string could have multiple possible strings it can decrypt to.
Replace s with keys[i] in the string.
Implement the Encrypter class:

Encrypter(char[] keys, String[] values, String[] dictionary) Initializes the Encrypter class with keys, values, and dictionary.
String encrypt(String word1) Encrypts word1 with the encryption process described above and returns the encrypted string.
int decrypt(String word2) Returns the number of possible strings word2 could decrypt to that also appear in dictionary.:class Encrypter:

    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):
        
        self.mapping = defaultdict(str)
        
                #mapping each key to its respective value
        for x, y in zip(keys, values): 
            self.mapping[x] = y            
            
        self.frequency = defaultdict(int)
        
                #encrpting every worder by function calling and updating 
                #how many times the encrypted sequene occurs
        for word in dictionary:
            self.frequency[self.encrypt(word)] += 1  
        
  
    def encrypt(self, word1: str) -> str:
            #Using list. So that it would be efficient to concatenate it at the end using join.
        res = [] 
        
        for c in word1:
            if c in self.mapping:
                res.append(self.mapping[c])
            else:
                return '' 
                                # #it's important that even if one charecter is missing, we should
                                #return an empty string or else it would give wrong output
                                
        return """".join(res)  
        
                
    def decrypt(self, word2: str) -> int:
        
            #return the frequency of the encrypted sequence
        return self.frequency[word2]<|endoftext|>"
1207,"<|endoftext|>You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.

You start on square 1 of the board. In each move, starting from square curr, do the following:

Choose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)].
This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.
If next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next.
The game ends when you reach the square n2.
A board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 do not have a snake or ladder.

Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.

For example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.
Return the least number of moves required to reach the square n2. If it is not possible to reach the square, return -1.:def snakesAndLadders(self, board: List[List[int]]) -> int:
        n = len(board)
        def label_to_position(label):
            r, c = divmod(label-1, n)
            if r % 2 == 0:
                return n-1-r, c
            else:
                return n-1-r, n-1-c
            
        seen = set()
        queue = collections.deque()
        queue.append((1, 0))
        while queue:
            label, step = queue.popleft()
            r, c = label_to_position(label)
            if board[r][c] != -1:
                label = board[r][c]
            if label == n*n:
                return step
            for x in range(1, 7):
                new_label = label + x
                if new_label <= n*n and new_label not in seen:
                    seen.add(new_label)
                    queue.append((new_label, step+1))
        return -1<|endoftext|>"
1208,"<|endoftext|>In the previous article, we have discussed about Program for addition of two matrices in Python & C++ Programming. Let us learn Program for Transpose a Matrix in C++ Program and Python.
 
 What is a matrix:
 
 A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.
 
 Example:
 
 
 
 Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.
 
 In this order, the dimensions of a matrix indicate the number of rows and columns.
 
 
 
 Here as there are 5 rows and 4 columns it is called as 5*4 matrix.
 
 What is Matrix Transpose:
 
 The interchanging of rows and columns is known as a matrix transpose. It’s abbreviated as A’. The element in A’s ith row and jth column will be moved to A’s jth row and ith column.
 
 
 
 Examples for matrix Transpose:
 
 Input:
 
 Matrix 1 = 2 3 1 
  1 2 3
 Output:
 
 Printing the transpose of matrices : 
 2 1
 3 2
 1 3:# given matrix A
 A = [[2, 3, 1],
  [1, 2, 3]]
 rows = len(A)
 columns = len(A[0])
 # Initialize the transpose of matrices elements to 0
 # with rows as columns and columns as rows as dimensions
 matrixTrans = [[0, 0],
  [0, 0],
  [0, 0]]
 # iterate through rows
 for i in range(rows):
  # iterate through columns
  for j in range(columns):
  matrixTrans[j][i] = A[i][j]
 # printing the transpose of matrices
 print(""Printing the transpose of matrices : "")
 for rows in matrixTrans:
  print(*rows)<|endoftext|>"
1209,"<|endoftext|>In the previous article, we have discussed Python Program to Find Sum of Series 1/2!+2/3!+3/5!+…..N/(N+1)!
 Given a number N and the task is to find the sum of series (1^1/1+2^2/2+3^3/3…+N^N/N) till the given number N in Python.
 Examples:
 Example1:
 Input:
 Given Number (Limit) = 4
 Output:
 The above series sum till the given number N{ 4 } = 76.0
 Example2:
 Input:
 Given Number (Limit) = 9
 Output:
 The above series sum till the given number N{ 9 } = 45269999.0:# Import math module using the import keyword.
 
 import math
 
 # Give the number N(limit) as static input and store it in a variable.
 
 gvn_numb = 4
 
 # Take a variable to say rsltseries_summ and initialize its value to 0.0
 
 # (Floating point number)
 
 rsltseries_summ = 0.0
 
 # Loop from 1 to the given number using the for loop.
 
 for itr in range(1, gvn_numb+1):
 
  # Inside the loop, calculate the value of the iterator raised to the power itself and
 
  # divided by the iterator value using the pow() function.
 
  # Store it in another variable.
 
  a = pow(itr, itr) / itr
 
  # Add the above result to the rsltseries_summ and store it in the same variable.
 
  rsltseries_summ += a
 
 # Print the sum of series till the given number N.
 
 print(
 
  ""The above series sum till the given number N{"", gvn_numb, ""} = "", rsltseries_summ)
 
 </pre><|endoftext|>"
1210,"<|endoftext|>Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.
Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.
Note that you can return the indices of the edges in any order.
 
Example 1:


Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
Output: [[0,1],[2,3,4,5]]
Explanation: The figure above describes the graph.
The following figure shows all the possible MSTs:

Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.
The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.

Example 2:


Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
Output: [[],[0,1,2,3]]
Explanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.

 
Constraints:

2 <= n <= 100
1 <= edges.length <= min(200, n * (n - 1) / 2)
edges[i].length == 3
0 <= ai < bi < n
1 <= weighti <= 1000
All pairs (ai, bi) are distinct.:class Solution:
  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:
  
  # reference: LC 1192
  def dfs(curr, level, parent):
  levels[curr] = level
  for child, i in graph[curr]:
  if child == parent:
  continue
  elif levels[child] == -1:
  levels[curr] = min(levels[curr], dfs(child, level + 1, curr))
  else:
  levels[curr] = min(levels[curr], levels[child])
  if levels[child] >= level + 1 and i not in p_cri:
  cri.add(i)
  return levels[curr]
  
  # init critical and pseudo-critical edge set
  cri, p_cri = set(), set()
  
  # use dic to store all edges associated with a given weight
  dic = collections.defaultdict(list)
  for i, (u, v, w) in enumerate(edges):
  dic[w].append([u, v, i])
  
  # define union find et
  union_set = UnionFindSet(n)
  
  # iterate through all weights in ascending order
  for w in sorted(dic):
  
  # seen[(pu, pv)] contains all edges connecting pu and pv,
  # where pu and pv are the parent nodes of their corresponding groups
  seen = collections.defaultdict(set)
  # populate seen
  for u, v, i in dic[w]:
  pu, pv = union_set.find(u), union_set.find(v)
  # skip the edge that creates cycle
  if pu == pv:
  continue
  seen[min(pu, pv), max(pu, pv)].add(i) # edge i connects pu and pv
  
  # w_edges contains all weight-w edges we may add to MST
  w_edges, graph = [], collections.defaultdict(list)
  for pu, pv in seen:
  # more than 1 edge can connect pu and pv
  # these edges are pseudo-critical
  if len(seen[pu, pv]) > 1:
  p_cri |= seen[pu, pv]
  # construct graph for weight w 
  edge_idx = seen[pu, pv].pop()
  graph[pu].append((pv, edge_idx))
  graph[pv].append((pu, edge_idx))
  w_edges.append((pu, pv, edge_idx))
  # union pu and pv groups
  union_set.union(pu, pv)
  
  # run dfs to mark all critical w_edges
  levels = [-1] * n
  for u, v, i in w_edges:
  if levels[u] == -1:
  dfs(u, 0, -1)
  # the edges in w_edges cycles are pseudo-critical
  for u, v, i in w_edges:
  if i not in cri:
  p_cri.add(i)
  
  return [cri, p_cri]<|endoftext|>"
1211,"<|endoftext|>Exercise 1: Reverse the tuple:tuple1 = (10, 20, 30, 40, 50)
tuple1 = tuple1[::-1]
print(tuple1)<|endoftext|>"
1212,"<|endoftext|>Given a boolean 2D matrix, find the number of islands.
A group of connected 1s forms an island. For example, the below matrix contains 5 islands 

{1, 1, 0, 0, 0},
{0, 1, 0, 0, 1},
{1, 0, 0, 1, 1},
{0, 0, 0, 0, 0},
{1, 0, 1, 0, 1} 
A cell in the 2D matrix can be connected to 8 neighbours. 
This is a variation of the standard problem: “Counting the number of connected components in an undirected graph”. We have discussed a DFS based solution in below set 1.
Find the number of islands
We can also solve the question using disjoint set data structure explained here. The idea is to consider all 1 values as individual sets. Traverse the matrix and do a union of all adjacent 1 vertices. Below are detailed steps.
Approach: 
1) Initialize result (count of islands) as 0 
2) Traverse each index of the 2D matrix. 
3) If the value at that index is 1, check all its 8 neighbours. If a neighbour is also equal to 1, take the union of the index and its neighbour. 
4) Now define an array of size row*column to store frequencies of all sets. 
5) Now traverse the matrix again. 
6) If the value at index is 1, find its set. 
7) If the frequency of the set in the above array is 0, increment the result be 1.
Following is Java implementation of the above steps.:# Python3 program to find
# the number of islands using
# Disjoint Set data structure.
 
# Class to represent
# Disjoint Set Data structure
class DisjointUnionSets:
    def __init__(self, n):
        self.rank = [0] * n
        self.parent = [0] * n
        self.n = n
        self.makeSet()
 
    def makeSet(self):
         
        # Initially, all elements are in their
        # own set.
        for i in range(self.n):
            self.parent[i] = i
 
    # Finds the representative of the set that x
    # is an element of
    def find(self, x):
        if (self.parent[x] != x):
 
            # if x is not the parent of itself,
            # then x is not the representative of
            # its set.
            # so we recursively call Find on its parent
            # and move i's node directly under the
            # representative of this set
            self.parent[x]=self.find(self.parent[x])
             
        return self.parent[x]
 
    # Unites the set that includes x and
    # the set that includes y
    def Union(self, x, y):
         
        # Find the representatives(or the root nodes)
        # for x an y
        xRoot = self.find(x)
        yRoot = self.find(y)
 
        # Elements are in the same set,
        # no need to unite anything.
        if xRoot == yRoot:
            return
 
        # If x's rank is less than y's rank
        # Then move x under y so that depth of tree
        # remains less
        if self.rank[xRoot] < self.rank[yRoot]:
            parent[xRoot] = yRoot
 
        # Else if y's rank is less than x's rank
        # Then move y under x so that depth of tree
        # remains less
        elif self.rank[yRoot] < self.rank[xRoot]:
            self.parent[yRoot] = xRoot
 
        else:
             
            # Else if their ranks are the same
            # Then move y under x (doesn't matter
            # which one goes where)
            self.parent[yRoot] = xRoot
 
            # And increment the result tree's
            # rank by 1
            self.rank[xRoot] = self.rank[xRoot] + 1
 
# Returns number of islands in a[][]
def countIslands(a):
    n = len(a)
    m = len(a[0])
 
    dus = DisjointUnionSets(n * m)
 
    # The following loop checks for its neighbours
    # and unites the indexes if both are 1.
    for j in range(0, n):
        for k in range(0, m):
 
            # If cell is 0, nothing to do
            if a[j][k] == 0:
                continue
 
            # Check all 8 neighbours and do a Union
            # with neighbour's set if neighbour is
            # also 1
            if j + 1 < n and a[j + 1][k] == 1:
                dus.Union(j * (m) + k, 
                         (j + 1) * (m) + k)
            if j - 1 >= 0 and a[j - 1][k] == 1:
                dus.Union(j * (m) + k,
                         (j - 1) * (m) + k)
            if k + 1 < m and a[j][k + 1] == 1:
                dus.Union(j * (m) + k,
                        (j) * (m) + k + 1)
            if k - 1 >= 0 and a[j][k - 1] == 1:
                dus.Union(j * (m) + k,
                        (j) * (m) + k - 1)
            if (j + 1 < n and k + 1 < m and
                     a[j + 1][k + 1] == 1):
                dus.Union(j * (m) + k, (j + 1) *
                              (m) + k + 1)
            if (j + 1 < n and k - 1 >= 0 and
                     a[j + 1][k - 1] == 1):
                dus.Union(j * m + k, (j + 1) *
                             (m) + k - 1)
            if (j - 1 >= 0 and k + 1 < m and
                      a[j - 1][k + 1] == 1):
                dus.Union(j * m + k, (j - 1) *
                              m + k + 1)
            if (j - 1 >= 0 and k - 1 >= 0 and
                      a[j - 1][k - 1] == 1):
                dus.Union(j * m + k, (j - 1) *
                              m + k - 1)
 
    # Array to note down frequency of each set
    c = [0] * (n * m)
    numberOfIslands = 0
    for j in range(n):
        for k in range(n):
            if a[j][k] == 1:
                x = dus.find(j * m + k)
                 
                # If frequency of set is 0,
                # increment numberOfIslands
                if c[x] == 0:
                    numberOfIslands += 1
                    c[x] += 1
                else:
                    c[x] += 1
    return numberOfIslands
 
# Driver Code
a = [[1, 1, 0, 0, 0],
     [0, 1, 0, 0, 1],
     [1, 0, 0, 1, 1],
     [0, 0, 0, 0, 0],
     [1, 0, 1, 0, 1]]
print(""Number of Islands is:"", countIslands(a))
 
# This code is contributed by ankush_953
<|endoftext|>"
1213,"<|endoftext|>We are given a directed graph. We need compute whether the graph has negative cycle or not. A negative cycle is one in which the overall sum of the cycle comes negative.:# Python Program to check
# if there is a
# negative weight
# cycle using Floyd
# Warshall Algorithm
  
   
# Number of vertices
# in the graph
V = 4
       
# Define Infinite as a
# large enough value. This 
# value will be used 
#for vertices not connected 
# to each other 
INF = 99999
       
# Returns true if graph has
# negative weight cycle
# else false.
def negCyclefloydWarshall(graph):
           
    # dist[][] will be the
    # output matrix that will 
    # finally have the shortest 
    # distances between every
    # pair of vertices 
    dist=[[0 for i in range(V+1)]for j in range(V+1)]
       
    # Initialize the solution
    # matrix same as input
    # graph matrix. Or we can
    # say the initial values 
    # of shortest distances
    # are based on shortest 
    # paths considering no
    # intermediate vertex. 
    for i in range(V):
        for j in range(V):
            dist[i][j] = graph[i][j]
       
    ''' Add all vertices one
        by one to the set of 
        intermediate vertices.
    ---> Before start of a iteration,
         we have shortest
        distances between all pairs
        of vertices such 
        that the shortest distances
        consider only the
        vertices in set {0, 1, 2, .. k-1}
        as intermediate vertices.
    ----> After the end of a iteration,
          vertex no. k is 
        added to the set of
        intermediate vertices and 
        the set becomes {0, 1, 2, .. k} '''
    for k in range(V):
      
        # Pick all vertices 
        # as source one by one
        for i in range(V):
                   
            # Pick all vertices as
            # destination for the
            # above picked source
            for j in range(V):
          
                # If vertex k is on
                # the shortest path from
                # i to j, then update
                # the value of dist[i][j]
                if (dist[i][k] + dist[k][j] < dist[i][j]):
                        dist[i][j] = dist[i][k] + dist[k][j]
   
    # If distance of any
    # vertex from itself
    # becomes negative, then
    # there is a negative
    # weight cycle.
    for i in range(V):
        if (dist[i][i] < 0):
            return True
   
    return False 
  
           
# Driver code
  
       
''' Let us create the
    following weighted graph
            1
    (0)----------->(1)
    /|\               |
     |               |
  -1 |               | -1
     |                \|/
    (3)<-----------(2)
        -1     '''
           
graph = [ [0, 1, INF, INF],
          [INF, 0, -1, INF],
          [INF, INF, 0, -1],
          [-1, INF, INF, 0]]
           
if (negCyclefloydWarshall(graph)):
    print(""Yes"")
else:
    print(""No"") 
  
# This code is contributed
# by Anant Agarwal.
<|endoftext|>"
1214,"<|endoftext|>Given an array of positive numbers, find the maximum sum of a subsequence with the constraint that no 2 numbers in the sequence should be adjacent in the array. So 3 2 7 10 should return 13 (sum of 3 and 10) or 3 2 5 10 7 should return 15 (sum of 3, 5 and 7).Answer the question in most efficient way.

Examples : 

Amazon Test Series

Input : arr[] = {5, 5, 10, 100, 10, 5}
Output : 110

Input : arr[] = {1, 2, 3}
Output : 4

Input : arr[] = {1, 20, 3}
Output : 20:# Function to return max sum such that
# no two elements are adjacent
def find_max_sum(arr):
	incl = 0
	excl = 0
	
	for i in arr:
		
		# Current max excluding i (No ternary in
		# Python)
		new_excl = excl if excl>incl else incl
		
		# Current max including i
		incl = excl + i
		excl = new_excl
	
	# return max of incl and excl
	return (excl if excl>incl else incl)

# Driver program to test above function
arr = [5, 5, 10, 100, 10, 5]
print (find_max_sum(arr))

# This code is contributed by Kalai Selvan<|endoftext|>"
1215,"<|endoftext|>The challenge is to try and fix this buggy code, given the inputs True and False. See the examples below for the expected output.

Examples
has_bugs(True) ➞ ""sad days""

has_bugs(False) ➞ ""it's a good day""
Notes
Don't overthink this challenge (look at the syntax and correct it).:def has_bugs(buggy_code):
  if buggy_code:
    return 'sad days'
  else:
    return 'it\'s a good day'<|endoftext|>"
1216,"<|endoftext|>Given an array of integers cost and an integer target, return the maximum integer you can paint under the following rules:

The cost of painting a digit (i + 1) is given by cost[i] (0-indexed).
The total cost used must be equal to target.
The integer does not have 0 digits.

Since the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return ""0"".
 
Example 1:

Input: cost = [4,3,2,5,6,7,2,5,5], target = 9
Output: ""7772""
Explanation: The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost(""7772"") = 2*3+ 3*1 = 9. You could also paint ""977"", but ""7772"" is the largest number.
Digit  cost
  1  ->  4
  2  ->  3
  3  ->  2
  4  ->  5
  5  ->  6
  6  ->  7
  7  ->  2
  8  ->  5
  9  ->  5

Example 2:

Input: cost = [7,6,5,5,5,6,8,7,8], target = 12
Output: ""85""
Explanation: The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost(""85"") = 7 + 5 = 12.

Example 3:

Input: cost = [2,4,6,2,4,6,4,4,4], target = 5
Output: ""0""
Explanation: It is impossible to paint any integer with total cost equal to target.

 
Constraints:

cost.length == 9
1 <= cost[i], target <= 5000:def largestNumber(self, cost, target):
  dp = [0] + [-1] * (target + 5000)
  for t in xrange(1, target + 1):
  dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))
  return str(max(dp[t], 0))<|endoftext|>"
1217,"<|endoftext|>Given the upper limit and the task is to print the odd numbers in a given range (from 1 to given limit).

Recursion:

Recursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.

Examples:

Example1:

Input:

 Given Upper Limit = 45
Output:

The Odd Numbers in a given range 1 and 45 are :
1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45:# Create a recursive function to say odd_range which takes the given lower and upper
# limits as arguments and returns the odd numbers in a given range using recursion.


def odd_range(gvnlowr_lmt, gvnuppr_lmt):
    # Check if the given lower limit value is greater than the upper limit using the if
    # conditional statement.
    if gvnlowr_lmt > gvnuppr_lmt:
        # If the statement is true, then return.
        return
    # After the return statement, print the given lower limit separated by spaces.
    print(gvnlowr_lmt, end="" "")
    # Return odd_range(gvnlowr_lmt+2, gvnuppr_lmt) {Recursive Logic}.
    return odd_range(gvnlowr_lmt+2, gvnuppr_lmt)


# Give the lower limit as 1 and store it in a variable.
gvnlowr_lmt = 1
# Give the upper limit as static input and store it in another variable.
gvnuppr_lmt = 45
# Pass the given lower and upper limits as the arguments to odd_range function.
# Print the Odd Numbers in a given range.
print(""The Odd Numbers in a given range"",
      gvnlowr_lmt, ""and"", gvnuppr_lmt, ""are :"")
odd_range(gvnlowr_lmt, gvnuppr_lmt)<|endoftext|>"
1218,"<|endoftext|>Write a regular expression that will help us count how many bad cookies are produced every day. You must use RegEx negative lookbehind.
Example
lst = [""bad cookie"", ""good cookie"", ""bad cookie"", ""good cookie"", ""good cookie""]
pattern = ""yourregularexpressionhere""

len(re.findall(pattern, "", "".join(lst))) ➞ 2
Notes
You don't need to write a function, just the pattern.
Do not remove import re from the code.
Find more info on RegEx and negative lookbehind in Resources.
You can find all the challenges of this series in my Basic RegEx collection.:import re
pattern = ""(?<!good )(cookie)""<|endoftext|>"
1219,"<|endoftext|>Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Return true if there is a cycle in the linked list. Otherwise, return false.

 

Example 1:


Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
Example 2:


Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.:class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if head is None:
            return False
        slow = head
        fast = head.next
        while slow != fast:
            if fast is None or fast.next is None:
                return False
            slow = slow.next
            fast = fast.next.next
        return True<|endoftext|>"
1220,"<|endoftext|>Generate all binary permutations such that there are more or equal 1’s than 0’s before every point in all permutations:# Python 3 program to generate all permutations of 1's and 0's such that
# every permutation has more 1's than 0's at all indexes.
 
# ones & zeroes --> counts of 1's and 0's in current string 'str'
# len ---> desired length of every permutation
def generate(ones, zeroes, str, len1):
    # If length of current string becomes same as desired length
    if (len1 == len(str)):
        print(str,end ="" "")
        return
     
    # Append a 1 and recur
    generate(ones+1, zeroes, str+""1"", len1)
 
    # If there are more 1's, append a 0 as well, and recur
    if (ones > zeroes):
        generate(ones, zeroes+1, str+""0"", len1)
 
# Driver program to test above function
if __name__ == '__main__':
    str = """"
    generate(0, 0, str, 4)
 
# This code is contributed by
# Surendra_Gangwar<|endoftext|>"
1221,"<|endoftext|>You have been given an array and you have to make a program to convert that array such that positive elements occur at even numbered places in the array and negative elements occur at odd numbered places in the array. We have to do it in place.
There can be unequal number of positive and negative values and the extra values have to left as it is.

Examples:  



Input : arr[] = {1, -3, 5, 6, -3, 6, 7, -4, 9, 10}
Output : arr[] = {1, -3, 5, -3, 6, 6, 7, -4, 9, 10}

Input : arr[] = {-1, 3, -5, 6, 3, 6, -7, -4, -9, 10}
Output : arr[] = {3, -1, 6, -5, 3, -7, 6, -4, 10, -9}:# Python 3 program to rearrange
# positive and negative numbers

def rearrange(a, size) :
	
	positive = 0
	negative = 1

	while (True) :
		
		# Move forward the positive
		# pointer till negative number
		# number not encountered
		while (positive < size and a[positive] >= 0) :
			positive = positive + 2

		# Move forward the negative
		# pointer till positive number
		# number not encountered
		while (negative < size and a[negative] <= 0) :
			negative = negative + 2

		# Swap array elements to fix
		# their position.
		if (positive < size and negative < size) :
			temp = a[positive]
			a[positive] = a[negative]
			a[negative] = temp

		# Break from the while loop when
		# any index exceeds the size of
		# the array
		else :
			break
		
# Driver code
arr =[ 1, -3, 5, 6, -3, 6, 7, -4, 9, 10 ]
n = len(arr)

rearrange(arr, n)
for i in range(0, n) :
	print(arr[i], end = "" "")

# This code is contributed by Nikita Tiwari.<|endoftext|>"
1222,"<|endoftext|>Loop Through a Tuple
You can loop through the tuple items by using a for loop.:thistuple = (""apple"", ""banana"", ""cherry"")
for x in thistuple:
  print(x)<|endoftext|>"
1223,"<|endoftext|>Pascal’s triangle is a triangular array of the binomial coefficients. Write a function that takes an integer value n as input and prints first n lines of the Pascal’s triangle. Following are the first 6 rows of Pascal’s Triangle.
 

1  
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 :# Python 3 code for Pascal's Triangle
# A simple O(n^3)
# program for
# Pascal's Triangle

# Function to print
# first n lines of
# Pascal's Triangle
def printPascal(n) :
	
	# Iterate through every line
	# and print entries in it
	for line in range(0, n) :
		
		# Every line has number of
		# integers equal to line
		# number
		for i in range(0, line + 1) :
			print(binomialCoeff(line, i),
				"" "", end = """")
		print()
	

# See https://www.geeksforgeeks.org/space-and-time-efficient-binomial-coefficient/
# for details of this function
def binomialCoeff(n, k) :
	res = 1
	if (k > n - k) :
		k = n - k
	for i in range(0 , k) :
		res = res * (n - i)
		res = res // (i + 1)
	
	return res

# Driver program
n = 7
printPascal(n)


# This code is contributed by Nikita Tiwari.<|endoftext|>"
1224,"<|endoftext|>Given a Linked List of integers, write a function to modify the linked list such that all even numbers appear before all the odd numbers in the modified linked list. Also, keep the order of even and odd numbers same.
Examples: 
 

Input: 17->15->8->12->10->5->4->1->7->6->NULL
Output: 8->12->10->4->6->17->15->5->1->7->NULL

Input: 8->12->10->5->4->1->6->NULL
Output: 8->12->10->4->6->5->1->NULL

// If all numbers are even then do not change the list
Input: 8->12->10->NULL
Output: 8->12->10->NULL

// If all numbers are odd then do not change the list
Input: 1->3->5->7->NULL
Output: 1->3->5->7->NULL
:# Python program to segregate even and odd nodes in a
# Linked List
head = None # head of list

# Node class
class Node:
	
	# Function to initialise the node object
	def __init__(self, data):
		self.data = data # Assign data
		self.next =None

def segregateEvenOdd():

	global head
	end = head
	prev = None
	curr = head

	# Get pointer to last Node
	while (end.next != None):
		end = end.next

	new_end = end

	# Consider all odd nodes before getting first even node
	while (curr.data % 2 !=0 and curr != end):
		
		new_end.next = curr
		curr = curr.next
		new_end.next.next = None
		new_end = new_end.next
		
	# do following steps only if there is an even node
	if (curr.data % 2 == 0):
		
		head = curr

		# now curr points to first even node
		while (curr != end):
			
			if (curr.data % 2 == 0):
				
				prev = curr
				curr = curr.next
				
			else:
				
				# Break the link between prev and curr
				prev.next = curr.next

				# Make next of curr as None
				curr.next = None

				# Move curr to end
				new_end.next = curr

				# Make curr as new end of list
				new_end = curr

				# Update curr pointer
				curr = prev.next
			
	# We have to set prev before executing rest of this code
	else:
		prev = curr

	if (new_end != end and end.data % 2 != 0):
		
		prev.next = end.next
		end.next = None
		new_end.next = end
		
# Given a reference (pointer to pointer) to the head
# of a list and an int, push a new node on the front
# of the list.
def push(new_data):
	global head

	# 1 & 2: Allocate the Node &
	#		 Put in the data
	new_node = Node(new_data)

	# 3. Make next of new Node as head
	new_node.next = head

	# 4. Move the head to point to new Node
	head = new_node

# Utility function to print a linked list
def printList():
	global head
	temp = head
	while(temp != None):
		
		print(temp.data, end = "" "")
		temp = temp.next
		
	print("" "")

# Driver program to test above functions

push(11)
push(10)
push(8)
push(6)
push(4)
push(2)
push(0)
print(""Original Linked List"")
printList()

segregateEvenOdd()

print(""Modified Linked List"")
printList()

# This code is contributed by Arnab Kundu
<|endoftext|>"
1225,"<|endoftext|>Given a number N and the task is to print the series (6, 9, 14, 21, 30, 41, 54 … N) till the given number N in Python.:# Give the number N (Limit) as static input and store it in a variable.
gvn_numb = 7
# Take a variable to say itr and initialize its value to 1.
itr = 1
# Take another variable say k and initialize its value to 3.
k = 3
# Take another variable say valu and initialize its value to 6.
valu = 6
print(""The above series till the given number{"", gvn_numb, ""} is :"")
# Loop until the above-declared variable itr value is less than or equal to the given
# number using the while loop.
while(itr <= gvn_numb):
    # Inside the loop, print the value of the above variable valu separated by spaces.
    print(valu, end="" "")
    # Add k value to the above valu and store it in the same variable valu.
    valu += k
    # Increment the above k value by 2.
    k += 2
    # Increment the above itr value by 1.
    itr += 1<|endoftext|>"
1226,"<|endoftext|>Given a singly linked list, we have to convert it into circular linked list. For example, we have been given a singly linked list with four nodes and we want to convert this singly linked list into circular linked list.:# Python3 program for converting
# singly linked list into
# circular linked list.
import sys

# Linked list node
class Node:
	def __init__(self,data):
		self.data = data
		self.next = None

def push(head, data):
	if not head:
		return Node(data)

	# Allocate dynamic memory
	# for newNode.
	# Assign the data into newNode.
	newNode = Node(data)

	# newNode.next assign the
	# address of head node.
	newNode.next = head

	# newNode become the headNode.
	head = newNode
	return head

# Function that convert
# singly linked list into
# circular linked list.
def circular(head):

	# declare a node variable
	# start and assign head
	# node into start node.
	start = head

	# check that while head.next
	# not equal to null then head
	# points to next node.
	while(head.next is not None):
		head = head.next

	# if head.next points to null
	# then start assign to the
	# head.next node.	
	head.next = start
	return start

# Function that display the elements
# of circular linked list.
def displayList(node):
	start = node
	while(node.next is not start):
		print(""{} "".format(node.data),end="""")
		node=node.next

	# Display the last node of
	# circular linked list.
	print(""{} "".format(node.data),end="""")

# Driver Code
if __name__=='__main__':
	
	# Start with empty list
	head=None

	# Using push() function to
	# convert singly linked list
	# 17.22.13.14.15
	head=push(head,15)
	head=push(head,14)
	head=push(head,13)
	head=push(head,22)
	head=push(head,17)

	# Call the circular_list function
	# that convert singly linked
	# list to circular linked list.
	circular(head)
	print(""Display List:"")
	displayList(head)

# This Code is Contributed By Vikash Kumar 37<|endoftext|>"
1227,"<|endoftext|>Files in Python:

Python file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python’s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.

File encoding Property in Python:

In Python, the encoding Property is a built-in property of the File object (IO object), and it is used to retrieve the file’s encoding format from the file object. “utf-8,” which stands for “Unicode Transformation Standard 8 bits,” is the default encoding format.

Syntax:

fileobject.encoding
Parameters: This property has no arguments

Return Value: This method’s return type is <class’str’>, and it returns the file’s encoding format.:# Make a single variable to store the path of the file. This is a constant value.
# This value must be replaced with the file path from your own system in the example below.
givenFilename = ""samplefile.txt""
# Open the file in write mode. In this case, we're writing the contents into the file.
gvn_file = open(givenFilename, 'w') 
# Apply encoding function to the given file and print it
print(""In write-mode:"", gvn_file.encoding)
# Close the given file using the close function
gvn_file.close()
# Open the file in append mode. In this case, we're appending the contents into the file.
gvn_file = open(givenFilename, 'a') 
# Apply encoding function to the given file and print it
print(""In append-mode:"", gvn_file.encoding)
# Close the given file using the close function
gvn_file.close()
# Open the file in write mode and pass encoding ='utf-16' as the 
# arguments to the open() function
gvn_file = open(givenFilename, 'w', encoding='utf-16') 
# Apply encoding function to the given file and print it
print(""In write-mode with encoding='utf-16':"", gvn_file.encoding)
# Close the given file using the close function
gvn_file.close()<|endoftext|>"
1228,"<|endoftext|>Create a function that returns an Earned Run Average (ERA). An ERA is calculated by multiplying 9 by the quotient of Earned Runs Allowed er divided by ip Innings Pitched.
In baseball statistics, innings are represented with a fractional part of .1 (1/3) or .2 (2/3) to represent the number of outs in an inning. A whole number or a number with a fractional part of .0 represents a full inning with three outs. Check the Resources tab for a deeper explanation.
Examples
era(22, 99) ➞ 2.00

era(23, 99.1) ➞ 2.08

era(24, 99.2) ➞ 2.17
Notes
ERA is represented with a scale of 2: 2.08
For 1/3 and 2/3, use a scale of 2.:def era(er, ip):
  return (str(9 * er / ip) + '00')[:4]<|endoftext|>"
1229,"<|endoftext|>In this post, we will discuss how to find consonants in a string in python using the for loop. The alphabets ‘A’, ‘E’, ‘I’, ‘O’, ‘U’ (in uppercase) and ‘a’, ‘e’, ‘i’, ‘o’, ‘u’ are vowels, and remaining alphabets are called consonants.:# Python program to find consonants in a string # take input string = input('Enter any string: ') # to find the consonants consonant = [each for each in string if each not in ""aeiouAEIOU ""] # print number of consonants in string print('Number of consonants in string:', len(consonant)) # print all consonants in string print(consonant)<|endoftext|>"
1230,"<|endoftext|>In this challenge, you must build a program that generates the last character of an Italian Codice Fiscale, an alphanumeric identifying ID code.
The last character, also called check letter or CIN (Control Internal Number), is calculated after converting every other character into a numeric value, in relation to the parity of their natural position into the string (treating so the string as a 1-indexed sequence).
CONVERSION TABLE
Char Odd Even Char Odd Even
0 1 0 I 19 8
1 0 1 J 21 9
2 5 2 K 2 10
3 7 3 L 4 11
4 9 4 M 18 12
5 13 5 N 20 13
6 15 6 O 11 14
7 17 7 P 3 15
8 19 8 Q 6 16
9 21 9 R 8 17
A 1 0 S 12 18
B 0 1 T 14 19
C 5 2 U 16 20
D 7 3 V 10 21
E 9 4 W 22 22
F 13 5 X 25 23
G 15 6 Y 24 24
H 17 7 Z 23 25
When all characters will be converted accordingly to the conversion table, you have to sum these values and divide the result by 26: the remainder will give you the index of a letter, from A = 0 up to Z = 25.
Given a string code being a partial Fiscal Code, implement a function that returns the CIN as a capitalized single letter.
Example
fiscal_code(""MRTMTT25D09F205"") ➞ ""Z""

Convert the characters in odd positions:

Pos   Char   Value
1st  -> M -> 18
3rd  -> T -> 14
5th  -> T -> 14
7th  -> 2 -> 5
9th  -> D -> 7
11th -> 9 -> 21
13th -> 2 -> 5
15th -> 5 -> 13

Convert the characters in even positions:

Pos   Char   Value
2nd  -> R -> 17
4th  -> M -> 12
6th  -> T -> 19
8th  -> 5 -> 5
10th -> 0 -> 0
12th -> F -> 5
14th -> 0 -> 0

Sum of the values:

18 + 14 + 14 + 5 + 7 + 21 + 5 + 13 +
17 + 12 + 19 + 5 + 0 + 5 + 0 = 155

The remainder (modulo) of 155 % 26 is 25

Starting from A = 0, Z is the 25th letter
The following dict can be used for coding:
conversion_table = {
  ""0"": (1, 0), ""I"": (19, 8),
  ""1"": (0, 1), ""J"": (21, 9),
  ""2"": (5, 2), ""K"": (2, 10),
  ""3"": (7, 3), ""L"": (4, 11),
  ""4"": (9, 4), ""M"": (18, 12),
  ""5"": (13, 5), ""N"": (20, 13),
  ""6"": (15, 6), ""O"": (11, 14),
  ""7"": (17, 7), ""P"": (3, 15),
  ""8"": (19, 8), ""Q"": (6, 16),
  ""9"": (21, 9), ""R"": (8, 17),
  ""A"": (1, 0), ""S"": (12, 18),
  ""B"": (0, 1), ""T"": (14, 19),
  ""C"": (5, 2), ""U"": (16, 20),
  ""D"": (7, 3), ""V"": (10, 21),
  ""E"": (9, 4), ""W"": (22, 22),
  ""F"": (13, 5), ""X"": (25, 23),
  ""G"": (15, 6), ""Y"": (24, 24),
  ""H"": (17, 7), ""Z"": (23, 25)
}
Notes
Remember that the positions of characters into the string are 1-indexed. On the other hand, when returning the check letter, the positions of the letters into the alphabet are 0-indexed.
You can expect only valid data: uppercase alpha-numeric strings made of 15 valid characters.
Check the Resources tab for more info on Codice Fiscale.:def fiscal_code(code):
  d = {
    '0': [1, 0], '1': [0, 1], '2': [5, 2], '3': [7, 3], 
    '4': [9, 4], '5': [13, 5], '6': [15, 6], '7': [17, 7],
    '8': [19, 8], '9': [21, 9], 'A': [1, 0], 'B': [0, 1], 
    'C': [5, 2], 'D': [7, 3], 'E': [9, 4], 'F': [13, 5], 
    'G': [15, 6], 'H': [17, 7], 'I': [19, 8], 'J': [21, 9], 
    'K': [2, 10], 'L': [4, 11], 'M': [18, 12], 'N': [20, 13],
    'O': [11, 14], 'P': [3, 15], 'Q': [6, 16], 'R': [8, 17],
    'S': [12, 18], 'T': [14, 19], 'U': [16, 20], 'V': [10, 21],
    'W': [22, 22], 'X': [25, 23], 'Y': [24, 24], 'Z': [23, 25]
  }
  return chr(sum(d[ch][idx%2] for idx, ch in enumerate(code)) % 26 + 65)<|endoftext|>"
1231,"<|endoftext|>Edabit allows for markdown formatting, meaning that it's possible to format words by surrounding text with special characters. For example, to get bold text, you surround the text with double asterisks, like this **bold**.
Here is a list of the possible formatting options in Edabit and how to apply them:
**bold**
_italics_
`inline code`
~~strikethrough~~
Challenge
Given a string and a style character, return the newly formatted string. Style characters are single letters that represent the different types of formatting.
For the purposes of this challenge, the style characters are as follows:
""b"" is for bold
""i"" is for italics
""c"" is for inline code
""s"" is for strikethrough
Examples
md_format(""Bold"", ""b"") ➞ ""**Bold**""

md_format(""leaning text"", ""i"") ➞ ""_leaning text_""

md_format(""Edabit"", ""c"") ➞ ""`Edabit`""

md_format(""That's a strike!"", ""s"") ➞ ""~~That's a strike!~~""
Notes
Remember to format your comments!:def md_format(word, style):
  markdown = {'b':'**', 'i':'_', 'c':'`', 's':'~~'}
  return '{0}{1}{0}'.format(markdown[style], word)<|endoftext|>"
1232,"<|endoftext|>In the previous article, we have discussed Python Program to Sort a List in Wave Form
 Consider a List of distinct numbers that are sorted in ascending order. The list has been rotated k times (clockwise). The task is to determine the value of k.
 In simple terms, print the minimum index value to get the rotation count.
 Examples:
 Example1:
 Input:
 Given List = [7, 9, 11, 12, 5, 6, 1, 8]
 Output:
 The number of rotations of a gvn_lst [7, 9, 11, 12, 5, 6, 1, 8] = 6
 Example2:
 Input:
 Given List = [6, 3, 1, 4, 7]
 Output:
 The number of rotations of a gvn_lst [6, 3, 1, 4, 7] = 1:# Give the list as static input and store it in a variable.
 gvn_lst = [1, 3, 5, 7, 9]
 # Calculate the length of the given list using the len() function and
 # store it in another variable.
 len_lst = len(gvn_lst)
 # Take a variable say ""minim_index"" and initialize it with the first element of
 # the given list.
 minim_index = gvn_lst[0]
 # Loop from 0 to the length of the given list using the for loop.
 for itr in range(0, len_lst):
  # Check if the value of the variable ""minim_index"" is greater than the given list of
  # iterator value.
  if (minim_index &gt; gvn_lst[itr]):
  # If the statement is true then assign the given list of iterator value to the ""minim_index"".
  minim_index = gvn_lst[itr]
 # Store the iterator value in a variable ""minim_index"".
  minim_index = itr
 # Print ""minim_index"" to get the number of rotations of a given list.
 print(""The number of rotations of a gvn_lst"", gvn_lst, ""="", minim_index)<|endoftext|>"
1233,"<|endoftext|>Why Circular? In a singly linked list, for accessing any node of the linked list, we start traversing from the first node. If we are at any node in the middle of the list, then it is not possible to access nodes that precede the given node. This problem can be solved by slightly altering the structure of a singly linked list. In a singly linked list, the next part (pointer to next node) is NULL. If we utilize this link to point to the first node, then we can reach the preceding nodes. Refer to this for more advantages of circular linked lists.
The structure thus formed is a circular singly linked list and looks like this: 





In this post, the implementation and insertion of a node in a Circular Linked List using a singly linked list are explained.

Implementation 
To implement a circular singly linked list, we take an external pointer that points to the last node of the list. If we have a pointer last pointing to the last node, then last -> next will point to the first node. 



The pointer last points to node Z and last -> next points to node P.

Why have we taken a pointer that points to the last node instead of the first node? 
For the insertion of a node at the beginning, we need to traverse the whole list. Also, for insertion at the end, the whole list has to be traversed. If instead of start pointer, we take a pointer to the last node, then in both cases there won’t be any need to traverse the whole list. So insertion at the beginning or at the end takes constant time, irrespective of the length of the list.:prev = current<|endoftext|>"
1234,"<|endoftext|>Given two numbers N and K, the task is to find the sum of Modulo K of the first N natural numbers in Python.:# Create a function to say Sum_mod_k which takes the given number and k value as the
# arguments and returns the sum of modulo K of the given first N natural numbers.


def Sum_mod_k(gvn_numb, gvn_Kval):
    # Take a variable to say rslt and initialize its value to 0.
    rslt = 0
    # Loop from 1 to the given number using the for loop.
    for itr in range(1, gvn_numb + 1):
      # Calculate the value of the iterator modulus given k value and store it in a variable.
        mod_rslt = (itr % gvn_Kval)
      # Add the above result to the rslt and store it in the same variable rslt.
        rslt += mod_rslt
   # Return the value of rslt.
    return rslt


# Give the number as user input using the int(input()) function and store it in a variable.
gvn_numb = int(input(""Enter some random number = ""))
# Give the k value as user input using the int(input()) function and store it in another variable.
gvn_Kval = int(input(""Enter some random number = ""))
# Pass the given number and k value as the arguments to the Sum_mod_k function.
# Print the sum of modulo K of the given first N natural numbers.
print(""The sum of modulo k of the given n natural numbers = "",
      Sum_mod_k(gvn_numb, gvn_Kval))<|endoftext|>"
1235,"<|endoftext|>In this example, you will learn to convert string to datetime.:from datetime import datetime

my_date_string = ""Mar 11 2011 11:31AM""

datetime_object = datetime.strptime(my_date_string, '%b %d %Y %I:%M%p')

print(type(datetime_object))
print(datetime_object)
from dateutil import parser

date_time = parser.parse(""Mar 11 2011 11:31AM"")

print(date_time)
print(type(date_time))<|endoftext|>"
1236,"<|endoftext|>Write a function that takes a string as an argument and returns the left most integer in the string.
Examples
left_digit(""TrAdE2W1n95!"") ➞ 2

left_digit(""V3r1ta$"") ➞ 3

left_digit(""U//DertHe1nflu3nC3"") ➞ 1

left_digit(""J@v@5cR1PT"") ➞ 5
Notes
Each string will have at least two numbers.
Return the result as an integer.:def left_digit(num):
  return [int(d) for d in num if d.isdigit()][0]<|endoftext|>"
1237,"<|endoftext|>There is a m*n rectangular matrix whose top-left(start) location is (1, 1) and bottom-right(end) location is (m*n). There are k circles each with radius r. Find if there is any path from start to end without touching any circle.

The input contains values of m, n, k, r and two array of integers X and Y, each of length k. (X[i], Y[i]) is the center of ith circle.:# Python3 program to find out path in
# a rectangle containing circles.
import math
import queue
 
# Function to find out if there is
# any possible path or not.
 
 
def isPossible(m, n, k, r, X, Y):
 
    # Take an array of m*n size and
    # initialize each element to 0.
    rect = [[0] * n for i in range(m)]
 
    # Now using Pythagorean theorem find if a
    # cell touches or within any circle or not.
    for i in range(m):
        for j in range(n):
            for p in range(k):
                if (math.sqrt((pow((X[p] - 1 - i), 2) +
                               pow((Y[p] - 1 - j), 2))) <= r):
                    rect[i][j] = -1
 
    # If the starting cell comes within
    # any circle return false.
    if (rect[0][0] == -1):
        return False
 
    # Now use BFS to find if there
    # is any possible path or not.
 
    # Initialize the queue which holds
    # the discovered cells whose neighbors
    # are not discovered yet.
    qu = queue.Queue()
 
    rect[0][0] = 1
    qu.put([0, 0])
 
    # Discover cells until queue is not empty
    while (not qu.empty()):
        arr = qu.get()
        elex = arr[0]
        eley = arr[1]
 
        # Discover the eight adjacent nodes.
        # check top-left cell
        if ((elex > 0) and (eley > 0) and
                (rect[elex - 1][eley - 1] == 0)):
            rect[elex - 1][eley - 1] = 1
            v = [elex - 1, eley - 1]
            qu.put(v)
 
        # check top cell
        if ((elex > 0) and
                (rect[elex - 1][eley] == 0)):
            rect[elex - 1][eley] = 1
            v = [elex - 1, eley]
            qu.put(v)
 
        # check top-right cell
        if ((elex > 0) and (eley < n - 1) and
                (rect[elex - 1][eley + 1] == 0)):
            rect[elex - 1][eley + 1] = 1
            v = [elex - 1, eley + 1]
            qu.put(v)
 
        # check left cell
        if ((eley > 0) and
                (rect[elex][eley - 1] == 0)):
            rect[elex][eley - 1] = 1
            v = [elex, eley - 1]
            qu.put(v)
 
        # check right cell
        if ((eley < n - 1) and
                (rect[elex][eley + 1] == 0)):
            rect[elex][eley + 1] = 1
            v = [elex, eley + 1]
            qu.put(v)
 
        # check bottom-left cell
        if ((elex < m - 1) and (eley > 0) and
                (rect[elex + 1][eley - 1] == 0)):
            rect[elex + 1][eley - 1] = 1
            v = [elex + 1, eley - 1]
            qu.put(v)
 
        # check bottom cell
        if ((elex < m - 1) and
                (rect[elex + 1][eley] == 0)):
            rect[elex + 1][eley] = 1
            v = [elex + 1, eley]
            qu.put(v)
 
        # check bottom-right cell
        if ((elex < m - 1) and (eley < n - 1) and
                (rect[elex + 1][eley + 1] == 0)):
            rect[elex + 1][eley + 1] = 1
            v = [elex + 1, eley + 1]
            qu.put(v)
 
    # Now if the end cell (i.e. bottom right cell)
    # is 1(reachable) then we will send true.
    return (rect[m - 1][n - 1] == 1)
 
 
# Driver Code
if __name__ == '__main__':
 
    # Test case 1
    m1 = 5
    n1 = 5
    k1 = 2
    r1 = 1
    X1 = [1, 3]
    Y1 = [3, 3]
     
    # Function call
    if (isPossible(m1, n1, k1, r1, X1, Y1)):
        print(""Possible"")
    else:
        print(""Not Possible"")
 
    # Test case 2
    m2 = 5
    n2 = 5
    k2 = 2
    r2 = 1
    X2 = [1, 1]
    Y2 = [2, 3]
     
    # Function call
    if (isPossible(m2, n2, k2, r2, X2, Y2)):
        print(""Possible"")
    else:
        print(""Not Possible"")
 
# This code is contributed by PranchalK
<|endoftext|>"
1238,"<|endoftext|>This python program generates hollow pyramid pattern made up of stars up to n lines.
In this python example, we first read number of row in the hollow pyramid pattern from user using built-in function input(). And then we use using python's for loop to print hollow pyramid pattern.:# Generating Hollow Pyramid Pattern Using Stars

row = int(input('Enter number of rows required: '))

for i in range(row):
    for j in range(row-i):
        print(' ', end='') # printing space required and staying in same line
    
    for j in range(2*i+1):
        if j==0 or j==2*i or i==row-1:
            print('*',end='')
        else:
            print(' ', end='')
    print() # printing new line<|endoftext|>"
1239,"<|endoftext|>Given two arrays of integers nums1 and nums2, return the number of triplets formed (type 1 and type 2) under the following rules:

Type 1: Triplet (i, j, k) if nums1[i]2 == nums2[j] * nums2[k] where 0 <= i < nums1.length and 0 <= j < k < nums2.length.
Type 2: Triplet (i, j, k) if nums2[i]2 == nums1[j] * nums1[k] where 0 <= i < nums2.length and 0 <= j < k < nums1.length.

 
Example 1:

Input: nums1 = [7,4], nums2 = [5,2,8,9]
Output: 1
Explanation: Type 1: (1, 1, 2), nums1[1]2 = nums2[1] * nums2[2]. (42 = 2 * 8). 

Example 2:

Input: nums1 = [1,1], nums2 = [1,1,1]
Output: 9
Explanation: All Triplets are valid, because 12 = 1 * 1.
Type 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2).  nums1[i]2 = nums2[j] * nums2[k].
Type 2: (0,0,1), (1,0,1), (2,0,1). nums2[i]2 = nums1[j] * nums1[k].

Example 3:

Input: nums1 = [7,7,8,3], nums2 = [1,2,9,7]
Output: 2
Explanation: There are 2 valid triplets.
Type 1: (3,0,2).  nums1[3]2 = nums2[0] * nums2[2].
Type 2: (3,0,1).  nums2[3]2 = nums1[0] * nums1[1].

 
Constraints:

1 <= nums1.length, nums2.length <= 1000
1 <= nums1[i], nums2[i] <= 105:class Solution:
def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
d1 = collections.defaultdict(int)
d2 = collections.defaultdict(int)
for i in nums1:
d1[i * i] += 1
for i in nums2:
d2[i * i] += 1
res = 0
for i in range(len(nums1) - 1):
for j in range(i + 1, len(nums1)):
p = nums1[i] * nums1[j]
if p in d2:
res += d2[p]
for i in range(len(nums2) - 1):
for j in range(i + 1, len(nums2)):
p = nums2[i] * nums2[j]
if p in d1:
res += d1[p]
return res<|endoftext|>"
1240,"<|endoftext|>You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:

A stone '#'
A stationary obstacle '*'
Empty '.'
The box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.

It is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.

Return an n x m matrix representing the box after the rotation described above.:class Solution:
    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:
        grid=box
        for i in range(len(box)):
            right=len(box[0])-1
            for left in range(right,-1,-1):
                if grid[i][left]=='*': right=left-1
                if grid[i][left]=='#': 
                    grid[i][left],grid[i][right]=grid[i][right],grid[i][left]
                    right-=1
        return list(zip(*grid[::-1]))  <|endoftext|>"
1241,"<|endoftext|>Create a function that returns the next element in an arithmetic sequence. In an arithmetic sequence, each element is formed by adding the same constant to the previous element.
Examples
next_element([3, 5, 7, 9]) ➞ 11

next_element([-5, -6, -7]) ➞ -8

next_element([2, 2, 2, 2, 2]) ➞ 2
Notes
All input arrays will contain integers only.:def next_element(lst):
  return lst[-1] + (lst[1] - lst[0])<|endoftext|>"
1242,"<|endoftext|>Given a binary search tree and a key, your task to reverse path of the binary tree.

Prerequisite : Reverse path of Binary tree:# Python3 code to demonstrate insert
# operation in binary search tree
class Node:
 
    # Constructor to create a new node
    def __init__(self, data):
        self.key = data
        self.left = None
        self.right = None
 
# A utility function to
# do inorder traversal of BST
def inorder(root):
    if root != None:
        inorder(root.left)
        print(root.key, end = "" "")
        inorder(root.right)
         
# reverse tree path using queue
def reversePath(node, key, q1):
     
    # If the tree is empty,
    # return a new node */
    if node == None:
        return
 
    # If the node key equal
    # to key then
    if node.key == key:
         
        # push current node key
        q1.insert(0, node.key)
 
        # replace first node
        # with last element
        node.key = q1[-1]
 
        # remove first element
        q1.pop()
 
        # return
        return
     
    # if key smaller than node key then
    elif key < node.key:
         
        # push node key into queue
        q1.insert(0, node.key)
 
        # recursive call itself
        reversePath(node.left, key, q1)
 
        # replace queue front to node key
        node.key = q1[-1]
 
        # performe pop in queue
        q1.pop()
     
    # if key greater than node key then
    elif (key > node.key):
         
        # push node key into queue
        q1.insert(0, node.key)
 
        # recursive call itself
        reversePath(node.right, key, q1)
 
        # replace queue front to node key
        node.key = q1[-1]
 
        # performe pop in queue
        q1.pop()
 
    # return
    return
     
# A utility function to insert
#a new node with given key in BST */
def insert(node, key):
     
    # If the tree is empty,
    # return a new node */
    if node == None:
        return Node(key)
 
    # Otherwise, recur down the tree */
    if key < node.key:
        node.left = insert(node.left, key)
    elif key > node.key:
        node.right = insert(node.right, key)
 
    # return the (unchanged) node pointer */
    return node
     
# Driver Code
if __name__ == '__main__':
     
    # Let us create following BST
    #             50
    #         /     \
    #         30     70
    #         / \ / \
    #     20 40 60 80 */
    root = None
    q1 = []
 
    # reverse path till k
    k = 80;
    root = insert(root, 50)
    insert(root, 30)
    insert(root, 20)
    insert(root, 40)
    insert(root, 70)
    insert(root, 60)
    insert(root, 80)
 
    print(""Before Reverse :"")
     
    # print inorder traversal of the BST
    inorder(root)
 
    # reverse path till k
    reversePath(root, k, q1)
    print()
    print(""After Reverse :"")
 
    # print inorder of reverse path tree
    inorder(root)    
     
# This code is contributed by PranchalK
<|endoftext|>"
1243,"<|endoftext|>Given a rooted tree, and two nodes which are in the tree, find the Lowest common ancestor of both the nodes. The LCA for two nodes u and v is defined as the farthest node from the root that is the ancestor to both u and v. 


 :# Python code to find LCA of given
# two nodes in a tree
 
maxn = 100005
 
# the graph
g = [[] for i in range(maxn)]
 
# level of each node
level = [0] * maxn
 
e = []
l = []
h = [0] * maxn
 
# the segment tree
st = [0] * (5 * maxn)
 
# adding edges to the graph(tree)
def add_edge(u: int, v: int):
    g[u].append(v)
    g[v].append(u)
 
# assigning level to nodes
def levelling(src: int):
    for i in range(len(g[src])):
        des = g[src][i]
        if not level[des]:
            level[des] = level[src] + 1
            leveling(des)
 
visited = [False] * maxn
 
# storing the dfs traversal
# in the array e
def dfs(src: int):
    e.append(src)
    visited[src] = True
    for i in range(len(g[src])):
        des = g[src][i]
        if not visited[des]:
            dfs(des)
            e.append(src)
 
# making the array l
def setting_l(n: int):
    for i in range(len(e)):
        l.append(level[e[i]])
 
# making the array h
def setting_h(n: int):
    for i in range(n + 1):
        h[i] = -1
    for i in range(len(e)):
 
        # if is already stored
        if h[e[i]] == -1:
            h[e[i]] = i
 
# Range minimum query to return the index
# of minimum in the subarray L[qs:qe]
def RMQ(ss: int, se: int, qs: int, qe: int, i: int) -> int:
    global st
    if ss > se:
        return -1
 
    # out of range
    if se < qs or qe < ss:
        return -1
 
    # in the range
    if qs <= ss and se <= qe:
        return st[i]
 
    mid = (se + ss) >> 1
    stt = RMQ(ss, mid, qs, qe, 2 * i + 1)
    en = RMQ(mid + 1, se, qs, qe, 2 * i + 2)
 
    if stt != -1 and en != -1:
        if l[stt] < l[en]:
            return stt
        return en
    elif stt != -1:
        return stt
    elif en != -1:
        return en
 
# constructs the segment tree
def segmentTreeConstruction(ss: int, se: int, i: int):
    if ss > se:
        return
    if ss == se: # leaf
        st[i] = ss
        return
 
    mid = (ss + se) >> 1
    segmentTreeConstruction(ss, mid, 2 * i + 1)
    segmentTreeConstruction(mid + 1, se, 2 * i + 2)
 
    if l[st[2 * i + 1]] < l[st[2 * i + 2]]:
        st[i] = st[2 * i + 1]
    else:
        st[i] = st[2 * i + 2]
 
# Function to get LCA
def LCA(x: int, y: int) -> int:
    if h[x] > h[y]:
        x, y = y, x
    return e[RMQ(0, len(l) - 1, h[x], h[y], 0)]
 
# Driver Code
if __name__ == ""__main__"":
 
    # n=number of nodes in the tree
    # q=number of queries to answer
    n = 15
    q = 5
 
    # making the tree
    # /*
    #         1
    #     / | \
    #     2 3 4
    #         | \
    #         5 6
    #     / | \
    #     8 7 9 (right of 5)
    #     / | \ | \
    #     10 11 12 13 14
    #             |
    #             15
    # */
    add_edge(1, 2)
    add_edge(1, 3)
    add_edge(1, 4)
    add_edge(3, 5)
    add_edge(4, 6)
    add_edge(5, 7)
    add_edge(5, 8)
    add_edge(5, 9)
    add_edge(7, 10)
    add_edge(7, 11)
    add_edge(7, 12)
    add_edge(9, 13)
    add_edge(9, 14)
    add_edge(12, 15)
 
    level[1] = 1
    leveling(1)
    dfs(1)
    setting_l(n)
    setting_h(n)
 
    segmentTreeConstruction(0, len(l) - 1, 0)
 
    print(LCA(10, 15))
    print(LCA(11, 14))
 
# This code is contributed by
# sanjeev2552
<|endoftext|>"
1244,"<|endoftext|>Given a number x in degrees and number of terms, the task is to print the sum of sine series in  python:# importing math module
import math
# function which returns sum of sine series


def sumsine(degrees, terms):
  # taking a variable which stores sum of sine series
    sumSeries = 0
    for i in range(terms):
      # getting sign
        signofNum = (-1)**i
        # pie value
        pievalue = 22/7
        # degree value of given number
        degval = degrees*(pievalue/180)
        sumSeries = sumSeries + ((degval**(2.0*i+1)) /
                                 math.factorial(2*i+1))*signofNum
     # returning the sum of sine series
    return sumSeries


degrees = int(input(""enter the number of degrees = ""))
terms = int(input(""enter number of terms = ""))
print(""The sum of sine series of "", degrees, ""degrees"", ""of"",
      terms, ""terms ="", round(sumsine(degrees, terms), 2))<|endoftext|>"
1245,"<|endoftext|>You will be given a collection of five cards (representing a player's hand in poker). If your hand contains at least one pair, return a list of two elements: True and the card number of the highest pair (trivial if there only exists a single pair). Else, return False.

Examples
highest_pair([""A"", ""A"", ""Q"", ""Q"", ""6"" ]) ➞ [True, ""A""]

highest_pair([""J"", ""6"", ""3"", ""10"", ""8""]) ➞ False

highest_pair([""K"", ""7"", ""3"", ""9"", ""3""]) ➞ [True, 3]

highest_pair([""K"", ""9"", ""10"", ""J"", ""Q""]) ➞ False

highest_pair([""3"", ""5"", ""5"", ""5"", ""5""]) ➞ [True, 5]
Notes
Hands with three or more of the same card still count as containing a pair (see the last example).:def highest_pair(cards):
  pairs = [c for c in set(cards) if cards.count(c) >= 2]
  return [True, max(pairs, key='23456789JQKA'.index)] if pairs else False<|endoftext|>"
1246,"<|endoftext|>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.

Each number in candidates may only be used once in the combination.

Note: The solution set must not contain duplicate combinations.

 

Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
Example 2:

Input: candidates = [2,5,2,1,2], target = 5
Output: 
[
[1,2,2],
[5]
]
 

Constraints:

1 <= candidates.length <= 100
1 <= candidates[i] <= 50
1 <= target <= 30:class Solution:
    def combinationSum2(self, nums: List[int], target: int) -> List[List[int]]:
        
        res=[]
        nums.sort()
        
        def dfs(nums,target,path):
            if target==0:
                res.append(path)
                return
            if target<0:
                return
            
            for i in range(len(nums)):
                if i>0 and nums[i]==nums[i-1]:
                    continue
                dfs(nums[i+1:],target-nums[i],path+[nums[i]])
                
        dfs(nums,target,[])
        return res<|endoftext|>"
1247,"<|endoftext|>If you take an integer and form the product of its individual digits, you get a smaller number. Keep doing this and eventually you end up with a single digit.
The number of steps it takes to reach this point is known as the integer's multiplicative persistence. For example, 347 has a persistence of 3: 3*4*7 = 84, 8*4 = 32, 3*2 = 6.
Devise a function that returns the persistence of an integer.
Examples
persistence(9) ➞ 0

persistence(12) ➞ 1

persistence(6788) ➞ 6

persistence(678852) ➞ 2
Notes
The smallest number with persistence 11 is 277777788888899.
A number has never been found, no matter how large, that has a persistence greater than 11.:def persistence(num):
  i = 0
  while len(str(num)) > 1 and i < 50:
    num = eval('*'.join(str(num)))
    i += 1
  return i<|endoftext|>"
1248,"<|endoftext|>Given a matrix where every cell has some number of coins. Count number of ways to reach bottom right from top left with exactly k coins. We can move to (i+1, j) and (i, j+1) from a cell (i, j).:# A Naive Recursive Python program to
# count paths with exactly 'k' coins
 
R = 3
C = 3
 
# Recursive function to count paths
# with sum k from (0, 0) to (m, n)
def pathCountRec(mat, m, n, k):
 
    # Base cases
    if m < 0 or n < 0 or k < 0:
        return 0
    elif m == 0 and n == 0:
        return k == mat[m][n]
 
    # #(m, n) can be reached either
    # through (m-1, n) or through
    # (m, n-1)
    return (pathCountRec(mat, m-1, n, k-mat[m][n])
         + pathCountRec(mat, m, n-1, k-mat[m][n]))
 
# A wrapper over pathCountRec()
def pathCount(mat, k):
    return pathCountRec(mat, R-1, C-1, k)
 
# Driver Program
k = 12
mat = [[1, 2, 3],
       [4, 6, 5],
       [3, 2, 1]]
 
print(pathCount(mat, k))
 
# This code is contributed by Shrikant13.
<|endoftext|>"
1249,"<|endoftext|>Whenever we have textual data, we need to apply several pre-processing steps to the data to transform words into numerical features that work with machine learning algorithms. The pre-processing steps for a problem depend mainly on the domain and the problem itself, hence, we don’t need to apply all steps to every problem. 
In this article, we are going to see text preprocessing in Python. We will be using the NLTK (Natural Language Toolkit) library here. :# import the necessary libraries
import nltk
import string
import re
from nltk.tokenize import word_tokenize
from nltk import pos_tag
  
# convert text into word_tokens with their tags
def pos_tagging(text):
    word_tokens = word_tokenize(text)
    return pos_tag(word_tokens)
  
pos_tagging('You just gave me a scare')
# download the tagset 
nltk.download('tagsets')
  
# extract information about the tag
nltk.help.upenn_tagset('NN')
from nltk.tokenize import word_tokenize 
from nltk import pos_tag
  
# define chunking function with text and regular
# expression representing grammar as parameter
def chunking(text, grammar):
    word_tokens = word_tokenize(text)
  
    # label words with part of speech
    word_pos = pos_tag(word_tokens)
  
    # create a chunk parser using grammar
    chunkParser = nltk.RegexpParser(grammar)
  
    # test it on the list of word tokens with tagged pos
    tree = chunkParser.parse(word_pos)
      
    for subtree in tree.subtrees():
        print(subtree)
    tree.draw()
      
sentence = 'the little yellow bird is flying in the sky'
grammar = ""NP: {<DT>?<JJ>*<NN>}""
chunking(sentence, grammar)
from nltk.tokenize import word_tokenize
from nltk import pos_tag, ne_chunk
  
def named_entity_recognition(text):
    # tokenize the text
    word_tokens = word_tokenize(text)
  
    # part of speech tagging of words
    word_pos = pos_tag(word_tokens)
  
    # tree of word entities
    print(ne_chunk(word_pos))
  
text = 'Bill works for GeeksforGeeks so he went to Delhi for a meetup.'
named_entity_recognition(text)<|endoftext|>"
1250,"<|endoftext|>Given an array of strings strs, group the anagrams together. You can return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

 

Example 1:

Input: strs = [""eat"",""tea"",""tan"",""ate"",""nat"",""bat""]
Output: [[""bat""],[""nat"",""tan""],[""ate"",""eat"",""tea""]]
Example 2:

Input: strs = [""""]
Output: [[""""]]
Example 3:

Input: strs = [""a""]
Output: [[""a""]]
 

Constraints:

1 <= strs.length <= 104
0 <= strs[i].length <= 100
strs[i] consists of lowercase English letters.:class Solution:
    def groupAnagrams(strs):
        ans = collections.defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            ans[tuple(count)].append(s)
        return ans.values()<|endoftext|>"
1251,"<|endoftext|>The program creates a graph object and allows the user to determine whether the graph is bipartite.:class Graph:
    def __init__(self):
        # dictionary containing keys that map to the corresponding vertex object
        self.vertices = {}
 
    def add_vertex(self, key):
        """"""Add a vertex with the given key to the graph.""""""
        vertex = Vertex(key)
        self.vertices[key] = vertex
 
    def get_vertex(self, key):
        """"""Return vertex object with the corresponding key.""""""
        return self.vertices[key]
 
    def __contains__(self, key):
        return key in self.vertices
 
    def add_edge(self, src_key, dest_key, weight=1):
        """"""Add edge from src_key to dest_key with given weight.""""""
        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)
 
    def add_undirected_edge(self, v1_key, v2_key, weight=1):
        """"""Add undirected edge (2 directed edges) between v1_key and v2_key with
        given weight.""""""
        self.add_edge(v1_key, v2_key, weight)
        self.add_edge(v2_key, v1_key, weight)
 
    def does_undirected_edge_exist(self, v1_key, v2_key):
        """"""Return True if there is an undirected edge between v1_key and v2_key.""""""
        return (self.does_edge_exist(v1_key, v2_key)
                and self.does_edge_exist(v1_key, v2_key))
 
    def does_edge_exist(self, src_key, dest_key):
        """"""Return True if there is an edge from src_key to dest_key.""""""
        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])
 
    def __iter__(self):
        return iter(self.vertices.values())
 
 
class Vertex:
    def __init__(self, key):
        self.key = key
        self.points_to = {}
 
    def get_key(self):
        """"""Return key corresponding to this vertex object.""""""
        return self.key
 
    def add_neighbour(self, dest, weight):
        """"""Make this vertex point to dest with given edge weight.""""""
        self.points_to[dest] = weight
 
    def get_neighbours(self):
        """"""Return all vertices pointed to by this vertex.""""""
        return self.points_to.keys()
 
    def get_weight(self, dest):
        """"""Get weight of edge from this vertex to dest.""""""
        return self.points_to[dest]
 
    def does_it_point_to(self, dest):
        """"""Return True if this vertex points to dest.""""""
        return dest in self.points_to
 
 
class Queue:
    def __init__(self):
        self.items = []
 
    def is_empty(self):
        return self.items == []
 
    def enqueue(self, data):
        self.items.append(data)
 
    def dequeue(self):
        return self.items.pop(0)
 
 
def is_bipartite(vertex, visited):
    """"""Return True if component containing vertex is bipartite and put all
    vertices in its component in set visited.""""""
    colour = {vertex: 0}
    visited.add(vertex)
    q = Queue()
    q.enqueue(vertex)
    while not q.is_empty():
        current = q.dequeue()
 
        next_colour = 1 - colour[current] # switch colour
        for dest in current.get_neighbours():
            if dest not in visited:
                visited.add(dest)
                colour[dest] = next_colour
                q.enqueue(dest)
            else:
                if colour[dest] != next_colour:
                    return False
    return True
 
 
g = Graph()
print('Undirected Graph')
print('Menu')
print('add vertex <key>')
print('add edge <vertex1> <vertex2>')
print('bipartite')
print('display')
print('quit')
 
while True:
    do = input('What would you like to do? ').split()
 
    operation = do[0]
    if operation == 'add':
        suboperation = do[1]
        if suboperation == 'vertex':
            key = int(do[2])
            if key not in g:
                g.add_vertex(key)
            else:
                print('Vertex already exists.')
        elif suboperation == 'edge':
            v1 = int(do[2])
            v2 = int(do[3])
            if v1 not in g:
                print('Vertex {} does not exist.'.format(v1))
            elif v2 not in g:
                print('Vertex {} does not exist.'.format(v2))
            else:
                if not g.does_undirected_edge_exist(v1, v2):
                    g.add_undirected_edge(v1, v2)
                else:
                    print('Edge already exists.')
 
    elif operation == 'bipartite':
        bipartite = True
        visited = set()
        for v in g:
            if v not in visited:
                if not is_bipartite(v, visited):
                    bipartite = False
                    break
 
        if bipartite:
            print('Graph is bipartite.')
        else:
            print('Graph is not bipartite.')
 
    elif operation == 'display':
        print('Vertices: ', end='')
        for v in g:
            print(v.get_key(), end=' ')
        print()
 
        print('Edges: ')
        for v in g:
            for dest in v.get_neighbours():
                w = v.get_weight(dest)
                print('(src={}, dest={}, weight={}) '.format(v.get_key(),
                                                             dest.get_key(), w))
        print()
 
    elif operation == 'quit':
        break<|endoftext|>"
1252,"<|endoftext|>Give the string the task is to print the least frequent character in a string in Python.

Examples:

Example1:

Input:

Given string =zzzyyddddeeeee
Output:

The least frequency character in the given string zzzyyddddeeeee is [ y ]:# Import the Counter() function from collections using the import keyword.
from collections import Counter
# Give the string a static input and store it in a variable.
gvnstrng = 'zzzyyddddeeeee'
# Calculate the frequency of all the given string elements
# using the Counter() function which returns the element
# and its frequency as key-value pair and store this
# dictionary in a variable(say elementsfrequency)
elementsfrequency = Counter(gvnstrng)
# Calculate the minimum frequency character in the given string
# using the min() and ""get"" function and store it in a variable.
minfreqchar = str(min(elementsfrequency, key=elementsfrequency.get))
# Print the least frequency character in the given string
# by printing the above variable.
print('The least frequency character in the given string',
      gvnstrng, 'is [', minfreqchar, ']')<|endoftext|>"
1253,"<|endoftext|>iven an array, the task is to find if the input array contains a majority element or not.:# Hashing based Python
# program to find if
# there is a majority
# element in input array.

# Returns true if there
# is a majority element
# in a[]
def isMajority(a):
	
	# Insert all elements
	# in a hash table
	mp = {}
	
	for i in a:
		if i in mp: mp[i] += 1
		else: mp[i] = 1
	
	# Check if frequency
	# of any element is
	# n/2 or more.
	for x in mp:
		if mp[x] >= len(a)//2:
			return True
	return False

# Driver code
a = [ 2, 3, 9, 2, 2 ]

print(""Yes"" if isMajority(a) else ""No"")

#This code is contributed by Ansu Kumari<|endoftext|>"
1254,"<|endoftext|>The Collatz sequence is as follows:
Start with some given integer n.
If it is even, the next number will be n divided by 2.
If it is odd, multiply it by 3 and add 1 to make the next number.
The sequence stops when it reaches 1.
According to the Collatz conjecture, it will always reach 1. If that's true, you can construct a finite sequence following the aforementioned method for any given integer.
Write a function that takes in an integer n and returns the highest integer in the corresponding Collatz sequence.
Examples
max_collatz(10) ➞ 16
# Collatz sequence: 10, 5, 16, 8, 4, 2, 1

max_collatz(32) ➞ 32
# Collatz sequence: 32, 16, 8, 4, 2, 1

max_collatz(85) ➞ 256
# Collatz sequence: 85, 256, 128, 64, 32, 16, 8, 4, 2, 1
Notes
N/A:def max_collatz(num):
    res = num
    while num > 1:
        num = num * 3 + 1 if num % 2 else num // 2
        if num > res:
            res = num
    return res<|endoftext|>"
1255,"<|endoftext|>You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

 

Example 1:

Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6
Example 2:

Input: lists = []
Output: []
Example 3:

Input: lists = [[]]
Output: []
 

Constraints:

k == lists.length
0 <= k <= 104
0 <= lists[i].length <= 500
-104 <= lists[i][j] <= 104
lists[i] is sorted in ascending order.
The sum of lists[i].length will not exceed 104.:class Solution(object):
    def mergeKLists(self, lists):
        """"""
        :type lists: List[ListNode]
        :rtype: ListNode
        """"""
        amount = len(lists)
        interval = 1
        while interval < amount:
            for i in range(0, amount - interval, interval * 2):
                lists[i] = self.merge2Lists(lists[i], lists[i + interval])
            interval *= 2
        return lists[0] if amount > 0 else None

    def merge2Lists(self, l1, l2):
        head = point = ListNode(0)
        while l1 and l2:
            if l1.val <= l2.val:
                point.next = l1
                l1 = l1.next
            else:
                point.next = l2
                l2 = l1
                l1 = point.next.next
            point = point.next
        if not l1:
            point.next=l2
        else:
            point.next=l1
        return head.next<|endoftext|>"
1256,"<|endoftext|>You are given an integer array digits, where each element is a digit. The array may contain duplicates.

You need to find all the unique integers that follow the given requirements:

The integer consists of the concatenation of three elements from digits in any arbitrary order.
The integer does not have leading zeros.
The integer is even.
For example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements.

Return a sorted array of the unique integers.

 :class Solution:
    def findEvenNumbers(self, digits):
        c, numbers = Counter(digits), []
        
        for i in range(100,1000,2):
            ci = Counter([int(x) for x in str(i)])
            if all(k in c and c[k]>=v for k,v in ci.items()):
                numbers.append(i)
        
        return numbers<|endoftext|>"
1257,"<|endoftext|>Given an array arr[] of n integers, find the maximum that maximizes the sum of the value of i*arr[i] where i varies from 0 to n-1.

Examples:  

Input: arr[] = {8, 3, 1, 2}
Output: 29
Explanation: Lets look at all the rotations,
{8, 3, 1, 2} = 8*0 + 3*1 + 1*2 + 2*3 = 11
{3, 1, 2, 8} = 3*0 + 1*1 + 2*2 + 8*3 = 29
{1, 2, 8, 3} = 1*0 + 2*1 + 8*2 + 3*3 = 27
{2, 8, 3, 1} = 2*0 + 8*1 + 3*2 + 1*3 = 17

Input: arr[] = {3, 2, 1}
Output: 7
Explanation: Lets look at all the rotations,
{3, 2, 1} = 3*0 + 2*1 + 1*2 = 4
{2, 1, 3} = 2*0 + 1*1 + 3*2 = 7
{1, 3, 2} = 1*0 + 3*1 + 2*2 = 7:# A Naive Python3 program to find
# maximum sum rotation
import sys

# Returns maximum value of i * arr[i]
def maxSum(arr, n):

	# Initialize result
	res = -sys.maxsize

	# Consider rotation beginning with i
	# for all possible values of i.
	for i in range(0, n):


		# Initialize sum of current rotation
		curr_sum = 0
	
		# Compute sum of all values. We don't
		# actually rotation the array, but
		# compute sum by finding ndexes when
		# arr[i] is first element
		for j in range(0, n):
		
			index = int((i + j)% n)
			curr_sum += j * arr[index]
	

		# Update result if required
		res = max(res, curr_sum)
	return res

# Driver code
arr = [8, 3, 1, 2]
n = len(arr)

print(maxSum(arr, n))

# This code is contributed by
# Smitha Dinesh Semwal<|endoftext|>"
1258,"<|endoftext|>Multiclass classification is a popular problem in supervised machine learning.

Problem – Given a dataset of m training examples, each of which contains information in the form of various features and a label. Each label corresponds to a class, to which the training example belongs. In multiclass classification, we have a finite set of classes. Each training example also has n features. 

Naive Bayes classifier – Naive Bayes classification method is based on Bayes’ theorem. It is termed as ‘Naive’ because it assumes independence between every pair of features in the data. Let (x1, x2, …, xn) be a feature vector and y be the class label corresponding to this feature vector.:
# importing necessary libraries
from sklearn import datasets
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import train_test_split
 
# loading the iris dataset
iris = datasets.load_iris()
 
# X -> features, y -> label
X = iris.data
y = iris.target
 
# dividing X, y into train and test data
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state = 0)
 
# training a Naive Bayes classifier
from sklearn.naive_bayes import GaussianNB
gnb = GaussianNB().fit(X_train, y_train)
gnb_predictions = gnb.predict(X_test)
 
# accuracy on X_test
accuracy = gnb.score(X_test, y_test)
print accuracy
 
# creating a confusion matrix
cm = confusion_matrix(y_test, gnb_predictions)<|endoftext|>"
1259,"<|endoftext|>Given an array of elements, our task is to construct a complete binary tree from this array in level order fashion. That is, elements from left in the array will be filled in the tree level wise starting from level 0.:# Python3 program to construct binary
# tree from given array in level
# order fashion Tree Node

# Helper function that allocates a
#new node
class newNode:
	def __init__(self, data):
		self.data = data
		self.left = self.right = None

# Function to insert nodes in level order
def insertLevelOrder(arr, root, i, n):
	
	# Base case for recursion
	if i < n:
		temp = newNode(arr[i])
		root = temp

		# insert left child
		root.left = insertLevelOrder(arr, root.left,
									2 * i + 1, n)

		# insert right child
		root.right = insertLevelOrder(arr, root.right,
									2 * i + 2, n)
	return root

# Function to print tree nodes in
# InOrder fashion
def inOrder(root):
	if root != None:
		inOrder(root.left)
		print(root.data,end="" "")
		inOrder(root.right)

# Driver Code
if __name__ == '__main__':
	arr = [1, 2, 3, 4, 5, 6, 6, 6, 6]
	n = len(arr)
	root = None
	root = insertLevelOrder(arr, root, 0, n)
	inOrder(root)
	
# This code is contributed by PranchalK<|endoftext|>"
1260,"<|endoftext|>Python Program for Dictionary get() Function. The get() method of the Python dictionary returns a value for the given key. If the key is not available, the default value None is returned.:# Give the dictionary by initializing it with some random values and store it
# in a variable.
gvn_dictinry = {100: 'hello', 200: 'this', 300: 'is', 400: 'btechgeeks'}
# Print the above-given dictionary.
print(""The above given dictionary is :"")
print(gvn_dictinry)
# Apply get() method to the given dictionary to get the respective value
# for the given key.
# Store it in another variable.
rslt = gvn_dictinry.get(200)
# Similarly, do the same for the other keys to get the respective value for the given key.
print(""The respective value at the given key 200 :  "", rslt)
rslt_1 = gvn_dictinry.get(400)
print(""The respective value at the given key 400 :  "", rslt_1)
rslt_2 = gvn_dictinry.get(500)
print(""The respective value at the given key 500:  "", rslt_2)<|endoftext|>"
